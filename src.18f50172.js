: function () {
    return e;
  };
  return __webpackgi_require__.d(t, {
    a: t
  }), t;
}, __webpackgi_require__.d = function (e, t) {
  for (var n in t) __webpackgi_require__.o(t, n) && !__webpackgi_require__.o(e, n) && Object.defineProperty(e, n, {
    enumerable: !0,
    get: t[n]
  });
}, __webpackgi_require__.o = function (e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}, __webpackgi_require__.r = function (e) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
    value: "Module"
  }), Object.defineProperty(e, "__esModule", {
    value: !0
  });
};
var __webpackgi_exports__ = {};
!function () {
  __webpackgi_require__.d(__webpackgi_exports__, {
    LY2: function () {
      return i.LY2;
    },
    HRj: function () {
      return Zt;
    },
    li4: function () {
      return XM;
    },
    FO5: function () {
      return qM;
    },
    Nlh: function () {
      return VM;
    },
    QvI: function () {
      return Gs;
    },
    JHp: function () {
      return so;
    },
    bGH: function () {
      return i.bGH;
    },
    NDo: function () {
      return i.NDo;
    },
    gSk: function () {
      return i.gSk;
    },
    WMw: function () {
      return i.WMw;
    },
    OTo: function () {
      return i.OTo;
    },
    Se2: function () {
      return i.Se2;
    },
    cum: function () {
      return i.cum;
    },
    Mig: function () {
      return i.Mig;
    },
    B$7: function () {
      return Ns;
    },
    i_9: function () {
      return i.i_9;
    },
    m7l: function () {
      return i.m7l;
    },
    sYA: function () {
      return i.sYA;
    },
    Xcj: function () {
      return i.Xcj;
    },
    mzJ: function () {
      return i.mzJ;
    },
    ZZA: function () {
      return i.ZZA;
    },
    $Ph: function () {
      return kc;
    },
    T__: function () {
      return i.T__;
    },
    HkE: function () {
      return i.HkE;
    },
    tGC: function () {
      return i.tGC;
    },
    g1S: function () {
      return Dx;
    },
    I$C: function () {
      return jx;
    },
    _HT: function () {
      return Dm;
    },
    QIH: function () {
      return Us;
    },
    ksm: function () {
      return Vs;
    },
    jl_: function () {
      return ji;
    },
    b7R: function () {
      return ns;
    },
    BDV: function () {
      return Di;
    },
    Ea_: function () {
      return Hi;
    },
    qff: function () {
      return ji;
    },
    tmC: function () {
      return Fi;
    },
    BON: function () {
      return Rs;
    },
    P40: function () {
      return $i;
    },
    wLL: function () {
      return Ss;
    },
    iHO: function () {
      return qi;
    },
    BbS: function () {
      return i.BbS;
    },
    kqm: function () {
      return i.kqm;
    },
    Hmr: function () {
      return i.Hmr;
    },
    SJI: function () {
      return i.SJI;
    },
    mTL: function () {
      return i.mTL;
    },
    y8_: function () {
      return i.y8_;
    },
    _Li: function () {
      return i._Li;
    },
    g56: function () {
      return q_;
    },
    bj3: function () {
      return Y;
    },
    z81: function () {
      return i.z81;
    },
    _MY: function () {
      return i._MY;
    },
    yEv: function () {
      return sx;
    },
    dFZ: function () {
      return Cc;
    },
    N$j: function () {
      return i.N$j;
    },
    _YM: function () {
      return i._YM;
    },
    TUj: function () {
      return i.TUj;
    },
    ZzF: function () {
      return i.ZzF;
    },
    qzb: function () {
      return P;
    },
    GQ: function () {
      return i.GQ;
    },
    nvb: function () {
      return i.nvb;
    },
    DvJ: function () {
      return i.DvJ;
    },
    fQA: function () {
      return i.fQA;
    },
    cPz: function () {
      return Ta;
    },
    TlE: function () {
      return i.TlE;
    },
    u9r: function () {
      return i.u9r;
    },
    s4_: function () {
      return i.s4_;
    },
    T95: function () {
      return i.T95;
    },
    CtF: function () {
      return i.CtF;
    },
    V1s: function () {
      return i.V1s;
    },
    jOv: function () {
      return nt;
    },
    Rki: function () {
      return i.Rki;
    },
    itZ: function () {
      return jc;
    },
    qKx: function () {
      return zc;
    },
    vlJ: function () {
      return $M;
    },
    nPO: function () {
      return eT;
    },
    zcQ: function () {
      return Ic;
    },
    GH1: function () {
      return Nc;
    },
    ROQ: function () {
      return i.ROQ;
    },
    YN5: function () {
      return i.YN5;
    },
    BVQ: function () {
      return i.BVQ;
    },
    YT8: function () {
      return i.YT8;
    },
    YGz: function () {
      return i.YGz;
    },
    trn: function () {
      return i.trn;
    },
    zf8: function () {
      return i.zf8;
    },
    uWy: function () {
      return i.uWy;
    },
    SUY: function () {
      return i.SUY;
    },
    Ilk: function () {
      return i.Ilk;
    },
    R2R: function () {
      return i.R2R;
    },
    epp: function () {
      return i.epp;
    },
    GD$: function () {
      return Bi;
    },
    EB7: function () {
      return i.EB7;
    },
    DqL: function () {
      return i.DqL;
    },
    _3: function () {
      return i._3;
    },
    b_z: function () {
      return i.b_z;
    },
    OCn: function () {
      return iT;
    },
    _am: function () {
      return i._am;
    },
    kB7: function () {
      return Po;
    },
    fY$: function () {
      return i.fY$;
    },
    vxC: function () {
      return i.vxC;
    },
    BtG: function () {
      return i.BtG;
    },
    cBK: function () {
      return i.cBK;
    },
    g8_: function () {
      return i.g8_;
    },
    AXT: function () {
      return i.AXT;
    },
    yj7: function () {
      return i.yj7;
    },
    dYG: function () {
      return i.dYG;
    },
    tm_: function () {
      return i.tm_;
    },
    S2y: function () {
      return i.S2y;
    },
    B02: function () {
      return i.B02;
    },
    PeU: function () {
      return i.PeU;
    },
    Hyl: function () {
      return i.Hyl;
    },
    Wqd: function () {
      return i.Wqd;
    },
    Xaj: function () {
      return i.Xaj;
    },
    DUb: function () {
      return dm;
    },
    dZ3: function () {
      return i.dZ3;
    },
    m_w: function () {
      return i.m_w;
    },
    fHI: function () {
      return i.fHI;
    },
    LBq: function () {
      return i.LBq;
    },
    dHf: function () {
      return BM;
    },
    Qww: function () {
      return hr.Q;
    },
    CGV: function () {
      return jM;
    },
    JUT: function () {
      return i.JUT;
    },
    p3g: function () {
      return i.p3g;
    },
    IEO: function () {
      return i.IEO;
    },
    CN8: function () {
      return i.CN8;
    },
    zob: function () {
      return i.zob;
    },
    yxD: function () {
      return i.yxD;
    },
    CUS: function () {
      return ox;
    },
    A5E: function () {
      return i.A5E;
    },
    zqG: function () {
      return j_;
    },
    PfX: function () {
      return us;
    },
    Q1o: function () {
      return ts;
    },
    jfJ: function () {
      return i.jfJ;
    },
    T_J: function () {
      return i.T_J;
    },
    tEQ: function () {
      return i.tEQ;
    },
    gb4: function () {
      return Pi;
    },
    qkB: function () {
      return i.qkB;
    },
    cvk: function () {
      return mu;
    },
    HWo: function () {
      return vu;
    },
    brP: function () {
      return i.brP;
    },
    $YQ: function () {
      return i.$YQ;
    },
    yNB: function () {
      return Fo;
    },
    h7x: function () {
      return Pa;
    },
    Ox3: function () {
      return i.Ox3;
    },
    qtn: function () {
      return Is;
    },
    cBI: function () {
      return i.cBI;
    },
    cU9: function () {
      return i.cU9;
    },
    DT1: function () {
      return i.DT1;
    },
    Kgo: function () {
      return i.Kgo;
    },
    ehD: function () {
      return i.ehD;
    },
    fhJ: function () {
      return cm;
    },
    y1s: function () {
      return um;
    },
    fSK: function () {
      return i.fSK;
    },
    Vdb: function () {
      return i.Vdb;
    },
    l8J: function () {
      return i.l8J;
    },
    dj0: function () {
      return i.dj0;
    },
    QM0: function () {
      return i.QM0;
    },
    OIS: function () {
      return ab;
    },
    q8b: function () {
      return fc;
    },
    TOt: function () {
      return i.TOt;
    },
    xaN: function () {
      return f;
    },
    Ny0: function () {
      return i.Ny0;
    },
    Zof: function () {
      return ps;
    },
    eD: function () {
      return i.eD;
    },
    jwo: function () {
      return i.jwo;
    },
    dSO: function () {
      return i.dSO;
    },
    Bf4: function () {
      return i.Bf4;
    },
    USm: function () {
      return i.USm;
    },
    pBf: function () {
      return i.pBf;
    },
    $Vf: function () {
      return i.$Vf;
    },
    O7d: function () {
      return i.O7d;
    },
    ksq: function () {
      return Ob;
    },
    gXf: function () {
      return z_;
    },
    hH6: function () {
      return i.hH6;
    },
    esl: function () {
      return i.esl;
    },
    e62: function () {
      return i.e62;
    },
    a$l: function () {
      return i.a$l;
    },
    OM3: function () {
      return i.OM3;
    },
    VzW: function () {
      return i.VzW;
    },
    ybr: function () {
      return i.ybr;
    },
    yo9: function () {
      return i.yo9;
    },
    Zxw: function () {
      return i.Zxw;
    },
    JfN: function () {
      return i.JfN;
    },
    $Bt: function () {
      return Ea;
    },
    Wzm: function () {
      return i.Wzm;
    },
    Wl3: function () {
      return i.Wl3;
    },
    iWj: function () {
      return i.iWj;
    },
    DNz: function () {
      return $_;
    },
    m1M: function () {
      return Ys;
    },
    ylh: function () {
      return i.ylh;
    },
    v9Y: function () {
      return i.v9Y;
    },
    LSk: function () {
      return i.LSk;
    },
    LHE: function () {
      return wc;
    },
    KE0: function () {
      return bM;
    },
    KCF: function () {
      return vM;
    },
    a4n: function () {
      return Px;
    },
    zIH: function () {
      return qn;
    },
    Hfk: function () {
      return ar;
    },
    png: function () {
      return or;
    },
    Eb_: function () {
      return lr;
    },
    BT2: function () {
      return Bb;
    },
    _8p: function () {
      return kx;
    },
    hkn: function () {
      return Ut;
    },
    GFY: function () {
      return Ws;
    },
    w$m: function () {
      return i.w$m;
    },
    ksN: function () {
      return i.ksN;
    },
    j4z: function () {
      return i.j4z;
    },
    OAl: function () {
      return i.OAl;
    },
    VLJ: function () {
      return i.VLJ;
    },
    C73: function () {
      return Z_;
    },
    ZAu: function () {
      return i.ZAu;
    },
    ibP: function () {
      return Gi;
    },
    _fI: function () {
      return Bi;
    },
    hUN: function () {
      return tu;
    },
    cLu: function () {
      return i.cLu;
    },
    vmT: function () {
      return i.vmT;
    },
    Qpg: function () {
      return i.Qpg;
    },
    So8: function () {
      return i.So8;
    },
    eOv: function () {
      return DC;
    },
    Wjw: function () {
      return i.Wjw;
    },
    cJO: function () {
      return i.cJO;
    },
    QRU: function () {
      return i.QRU;
    },
    S3k: function () {
      return i.S3k;
    },
    PpQ: function () {
      return i.PpQ;
    },
    AHu: function () {
      return i.AHu;
    },
    q_9: function () {
      return $t;
    },
    ZRs: function () {
      return i.ZRs;
    },
    oqc: function () {
      return i.oqc;
    },
    T_x: function () {
      return Ii;
    },
    lb7: function () {
      return i.lb7;
    },
    L5s: function () {
      return i.L5s;
    },
    $TI: function () {
      return i.$TI;
    },
    SPe: function () {
      return i.SPe;
    },
    aVm: function () {
      return i.aVm;
    },
    j87: function () {
      return i.j87;
    },
    RNb: function () {
      return i.RNb;
    },
    Kz5: function () {
      return i.Kz5;
    },
    vpT: function () {
      return i.vpT;
    },
    kB5: function () {
      return i.kB5;
    },
    _C8: function () {
      return i._C8;
    },
    Syv: function () {
      return i.Syv;
    },
    NMF: function () {
      return i.NMF;
    },
    pIN: function () {
      return i.pIN;
    },
    eMJ: function () {
      return i.eMJ;
    },
    rN7: function () {
      return O_;
    },
    iUp: function () {
      return L_;
    },
    GFd: function () {
      return ix;
    },
    x5V: function () {
      return i.x5V;
    },
    tUh: function () {
      return i.tUh;
    },
    z8B: function () {
      return i.z8B;
    },
    GZb: function () {
      return i.GZb;
    },
    p7y: function () {
      return i.p7y;
    },
    S9g: function () {
      return i.S9g;
    },
    Zr5: function () {
      return i.Zr5;
    },
    vCF: function () {
      return i.vCF;
    },
    yt0: function () {
      return i.yt0;
    },
    uXU: function () {
      return i.uXU;
    },
    _kC: function () {
      return i._kC;
    },
    lk7: function () {
      return i.lk7;
    },
    x12: function () {
      return i.x12;
    },
    Zzh: function () {
      return i.Zzh;
    },
    nls: function () {
      return i.nls;
    },
    g_z: function () {
      return i.g_z;
    },
    U7: function () {
      return i.U7;
    },
    FT0: function () {
      return i.FT0;
    },
    blk: function () {
      return i.blk;
    },
    ejS: function () {
      return i.ejS;
    },
    rnI: function () {
      return i.rnI;
    },
    wem: function () {
      return i.wem;
    },
    lfu: function () {
      return i.lfu;
    },
    FDw: function () {
      return i.FDw;
    },
    lRj: function () {
      return i.lRj;
    },
    D1R: function () {
      return i.D1R;
    },
    qyh: function () {
      return i.qyh;
    },
    GUF: function () {
      return i.GUF;
    },
    EoG: function () {
      return i.EoG;
    },
    aNw: function () {
      return i.aNw;
    },
    Zp0: function () {
      return i.Zp0;
    },
    lLk: function () {
      return i.lLk;
    },
    jAl: function () {
      return i.jAl;
    },
    uEv: function () {
      return i.uEv;
    },
    YKA: function () {
      return i.YKA;
    },
    cRx: function () {
      return i.cRx;
    },
    Y8D: function () {
      return i.Y8D;
    },
    RsA: function () {
      return i.RsA;
    },
    Y0m: function () {
      return Vb;
    },
    F5T: function () {
      return i.F5T;
    },
    EDU: function () {
      return lT;
    },
    z$Q: function () {
      return RA;
    },
    KA8: function () {
      return Vt;
    },
    XUj: function () {
      return kA;
    },
    Me$: function () {
      return PA;
    },
    u7G: function () {
      return i.u7G;
    },
    PEk: function () {
      return Jt;
    },
    BG4: function () {
      return aT;
    },
    M8C: function () {
      return i.M8C;
    },
    Vkp: function () {
      return i.Vkp;
    },
    yGw: function () {
      return i.yGw;
    },
    Sm8: function () {
      return i.Sm8;
    },
    Kj0: function () {
      return i.Kj0;
    },
    vBJ: function () {
      return i.vBJ;
    },
    lRF: function () {
      return i.lRF;
    },
    Lun: function () {
      return i.Lun;
    },
    YBo: function () {
      return i.YBo;
    },
    kaV: function () {
      return i.kaV;
    },
    RSm: function () {
      return i.RSm;
    },
    xoR: function () {
      return i.xoR;
    },
    EJi: function () {
      return i.EJi;
    },
    Wid: function () {
      return i.Wid;
    },
    iuj: function () {
      return Kt;
    },
    IKL: function () {
      return i.IKL;
    },
    r_: function () {
      return i.r_;
    },
    OoA: function () {
      return i.OoA;
    },
    qhX: function () {
      return i.qhX;
    },
    qPT: function () {
      return oo;
    },
    M5h: function () {
      return i.M5h;
    },
    Ns1: function () {
      return i.Ns1;
    },
    TyD: function () {
      return i.TyD;
    },
    vZf: function () {
      return i.vZf;
    },
    HTd: function () {
      return i.HTd;
    },
    aH4: function () {
      return i.aH4;
    },
    YLQ: function () {
      return i.YLQ;
    },
    BVF: function () {
      return i.BVF;
    },
    MyG: function () {
      return i.MyG;
    },
    jFi: function () {
      return i.jFi;
    },
    aCh: function () {
      return i.aCh;
    },
    uL9: function () {
      return i.uL9;
    },
    TNj: function () {
      return xu;
    },
    IFH: function () {
      return i.IFH;
    },
    bdR: function () {
      return i.bdR;
    },
    kM_: function () {
      return Do;
    },
    M6v: function () {
      return i.M6v;
    },
    RvT: function () {
      return i.RvT;
    },
    dUE: function () {
      return i.dUE;
    },
    oe_: function () {
      return ex;
    },
    BuN: function () {
      return tx;
    },
    Tme: function () {
      return i.Tme;
    },
    N9P: function () {
      return it;
    },
    Gql: function () {
      return i.Gql;
    },
    $XY: function () {
      return Zn;
    },
    O9d: function () {
      return No;
    },
    zEO: function () {
      return rt;
    },
    qfx: function () {
      return FA;
    },
    PA7: function () {
      return i.PA7;
    },
    REq: function () {
      return i.REq;
    },
    pQR: function () {
      return i.pQR;
    },
    ghN: function () {
      return i.ghN;
    },
    Hy8: function () {
      return i.Hy8;
    },
    Wpd: function () {
      return i.Wpd;
    },
    LgZ: function () {
      return i.LgZ;
    },
    iWC: function () {
      return i.iWC;
    },
    mqn: function () {
      return WC;
    },
    iKG: function () {
      return i.iKG;
    },
    _iA: function () {
      return i._iA;
    },
    ntZ: function () {
      return i.ntZ;
    },
    anP: function () {
      return i.anP;
    },
    X2e: function () {
      return NM;
    },
    FCo: function () {
      return BA;
    },
    jjw: function () {
      return i.jjw;
    },
    y$t: function () {
      return i.y$t;
    },
    cPb: function () {
      return i.cPb;
    },
    lmx: function () {
      return Ca;
    },
    JOQ: function () {
      return i.JOQ;
    },
    BKK: function () {
      return i.BKK;
    },
    _12: function () {
      return i._12;
    },
    tJx: function () {
      return i.tJx;
    },
    cek: function () {
      return i.cek;
    },
    xG9: function () {
      return i.xG9;
    },
    woe: function () {
      return i.woe;
    },
    UY4: function () {
      return i.UY4;
    },
    aq0: function () {
      return i.aq0;
    },
    ujx: function () {
      return i.ujx;
    },
    Uol: function () {
      return i.Uol;
    },
    JiH: function () {
      return KA;
    },
    VYz: function () {
      return i.VYz;
    },
    EsW: function () {
      return co;
    },
    iUV: function () {
      return i.iUV;
    },
    tf: function () {
      return i.tf;
    },
    ZQ6: function () {
      return i.ZQ6;
    },
    mXe: function () {
      return i.mXe;
    },
    _fP: function () {
      return i._fP;
    },
    iLg: function () {
      return i.iLg;
    },
    zbs: function () {
      return i.zbs;
    },
    UZH: function () {
      return i.UZH;
    },
    mSO: function () {
      return i.mSO;
    },
    wk1: function () {
      return i.wk1;
    },
    E2K: function () {
      return i.E2K;
    },
    FUD: function () {
      return i.FUD;
    },
    pKu: function () {
      return i.pKu;
    },
    GG6: function () {
      return i.GG6;
    },
    Gih: function () {
      return i.Gih;
    },
    iiP: function () {
      return i.iiP;
    },
    SvJ: function () {
      return i.SvJ;
    },
    ptH: function () {
      return i.ptH;
    },
    jZA: function () {
      return i.jZA;
    },
    y2t: function () {
      return i.y2t;
    },
    gi4: function () {
      return i.gi4;
    },
    Djp: function () {
      return i.Djp;
    },
    BG$: function () {
      return i.BG$;
    },
    NYV: function () {
      return i.NYV;
    },
    xJs: function () {
      return i.xJs;
    },
    bsb: function () {
      return i.bsb;
    },
    ekQ: function () {
      return i.ekQ;
    },
    CaW: function () {
      return i.CaW;
    },
    eaV: function () {
      return i.eaV;
    },
    BFQ: function () {
      return i.BFQ;
    },
    v3W: function () {
      return i.v3W;
    },
    ILR: function () {
      return i.ILR;
    },
    UCm: function () {
      return i.UCm;
    },
    Inb: function () {
      return i.Inb;
    },
    LgE: function () {
      return i.LgE;
    },
    fto: function () {
      return i.fto;
    },
    l0P: function () {
      return i.l0P;
    },
    vCx: function () {
      return i.vCx;
    },
    _AM: function () {
      return i._AM;
    },
    wuA: function () {
      return i.wuA;
    },
    av9: function () {
      return i.av9;
    },
    CtA: function () {
      return i.CtA;
    },
    BvQ: function () {
      return Yc;
    },
    FZJ: function () {
      return $c;
    },
    FIo: function () {
      return i.FIo;
    },
    zHn: function () {
      return i.zHn;
    },
    iMs: function () {
      return i.iMs;
    },
    T_f: function () {
      return i.T_f;
    },
    hEm: function () {
      return i.hEm;
    },
    D9w: function () {
      return i.D9w;
    },
    sHH: function () {
      return K_;
    },
    CdI: function () {
      return i.CdI;
    },
    rpg: function () {
      return i.rpg;
    },
    ce8: function () {
      return i.ce8;
    },
    rOj: function () {
      return i.rOj;
    },
    P6m: function () {
      return Ub;
    },
    JA6: function () {
      return Nb;
    },
    V4E: function () {
      return i.V4E;
    },
    o8S: function () {
      return i.o8S;
    },
    flB: function () {
      return _t;
    },
    DUH: function () {
      return UM;
    },
    KI_: function () {
      return i.KI_;
    },
    iLN: function () {
      return ko;
    },
    jsw: function () {
      return tm;
    },
    i6Z: function () {
      return To;
    },
    vfv: function () {
      return zb;
    },
    xsS: function () {
      return i.xsS;
    },
    ov0: function () {
      return Ma;
    },
    cQH: function () {
      return tt;
    },
    WdD: function () {
      return i.WdD;
    },
    Vj0: function () {
      return i.Vj0;
    },
    jyz: function () {
      return i.jyz;
    },
    Mn1: function () {
      return Lt;
    },
    Hlq: function () {
      return Ft;
    },
    Fi7: function () {
      return H_;
    },
    Tn7: function () {
      return i.Tn7;
    },
    bnF: function () {
      return i.bnF;
    },
    HW6: function () {
      return i.HW6;
    },
    oa8: function () {
      return i.oa8;
    },
    T_1: function () {
      return i.T_1;
    },
    zHJ: function () {
      return HA;
    },
    iDF: function () {
      return i.iDF;
    },
    iAb: function () {
      return i.iAb;
    },
    d4E: function () {
      return Nm;
    },
    lBg: function () {
      return RC;
    },
    JeJ: function () {
      return Um;
    },
    FKY: function () {
      return r;
    },
    zlZ: function () {
      return ax;
    },
    vkg: function () {
      return tn;
    },
    brh: function () {
      return lx;
    },
    kZK: function () {
      return sC;
    },
    puG: function () {
      return kC;
    },
    OdW: function () {
      return i.OdW;
    },
    _YX: function () {
      return i._YX;
    },
    TUv: function () {
      return i.TUv;
    },
    wcA: function () {
      return i.wcA;
    },
    Hw6: function () {
      return i.Hw6;
    },
    aLr: function () {
      return i.aLr;
    },
    Aip: function () {
      return i.Aip;
    },
    xo$: function () {
      return i.xo$;
    },
    bIn: function () {
      return KC;
    },
    $V: function () {
      return i.$V;
    },
    lDi: function () {
      return i.lDi;
    },
    gti: function () {
      return i.gti;
    },
    PMe: function () {
      return i.PMe;
    },
    iwP: function () {
      return Fs;
    },
    FvO: function () {
      return i.FvO;
    },
    jyi: function () {
      return i.jyi;
    },
    xeV: function () {
      return i.xeV;
    },
    k74: function () {
      return i.k74;
    },
    RlZ: function () {
      return i.RlZ;
    },
    KhW: function () {
      return i.KhW;
    },
    HgB: function () {
      return i.HgB;
    },
    W2J: function () {
      return i.W2J;
    },
    JWc: function () {
      return i.JWc;
    },
    u37: function () {
      return i.u37;
    },
    Z6B: function () {
      return i.Z6B;
    },
    QZ1: function () {
      return i.QZ1;
    },
    Ir4: function () {
      return i.Ir4;
    },
    NwF: function () {
      return i.NwF;
    },
    Wbm: function () {
      return i.Wbm;
    },
    N4l: function () {
      return i.N4l;
    },
    ej9: function () {
      return jA;
    },
    QmN: function () {
      return i.QmN;
    },
    IOt: function () {
      return i.IOt;
    },
    NOD: function () {
      return Lc;
    },
    L5g: function () {
      return i.L5g;
    },
    H$k: function () {
      return i.H$k;
    },
    MP$: function () {
      return i.MP$;
    },
    cuP: function () {
      return nC;
    },
    xEZ: function () {
      return i.xEZ;
    },
    dpR: function () {
      return i.dpR;
    },
    wOD: function () {
      return ru;
    },
    KNb: function () {
      return zs;
    },
    Rk2: function () {
      return ho;
    },
    IiN: function () {
      return fo;
    },
    Cne: function () {
      return i.Cne;
    },
    XvJ: function () {
      return i.XvJ;
    },
    XZw: function () {
      return i.XZw;
    },
    FE5: function () {
      return i.FE5;
    },
    lVp: function () {
      return Ra;
    },
    CJI: function () {
      return i.CJI;
    },
    z$h: function () {
      return i.z$h;
    },
    UlW: function () {
      return i.UlW;
    },
    WwZ: function () {
      return i.WwZ;
    },
    Lcc: function () {
      return i.Lcc;
    },
    WXh: function () {
      return i.WXh;
    },
    Vjr: function () {
      return zA;
    },
    LuM: function () {
      return CC;
    },
    LP5: function () {
      return bC;
    },
    xfE: function () {
      return i.xfE;
    },
    qlB: function () {
      return i.qlB;
    },
    lCJ: function () {
      return i.lCJ;
    },
    WTc: function () {
      return i.WTc;
    },
    rAo: function () {
      return i.rAo;
    },
    LZj: function () {
      return po;
    },
    xWb: function () {
      return i.xWb;
    },
    gH0: function () {
      return i.gH0;
    },
    rBU: function () {
      return i.rBU;
    },
    rDY: function () {
      return i.rDY;
    },
    ywz: function () {
      return i.ywz;
    },
    wJv: function () {
      return i.wJv;
    },
    JQ4: function () {
      return i.JQ4;
    },
    k0A: function () {
      return i.k0A;
    },
    irR: function () {
      return i.irR;
    },
    LsT: function () {
      return i.LsT;
    },
    q5h: function () {
      return ks;
    },
    TKh: function () {
      return Cs;
    },
    tyg: function () {
      return As;
    },
    Ro5: function () {
      return Ji;
    },
    dwk: function () {
      return i.dwk;
    },
    FM8: function () {
      return i.FM8;
    },
    Pa4: function () {
      return i.Pa4;
    },
    Ltg: function () {
      return i.Ltg;
    },
    yC1: function () {
      return i.yC1;
    },
    lHq: function () {
      return B_;
    },
    fO1: function () {
      return i.fO1;
    },
    oMA: function () {
      return ro;
    },
    JzW: function () {
      return t;
    },
    b5g: function () {
      return i.b5g;
    },
    Ywn: function () {
      return i.Ywn;
    },
    GVz: function () {
      return i.GVz;
    },
    oAp: function () {
      return i.oAp;
    },
    kFz: function () {
      return i.kFz;
    },
    p7A: function () {
      return i.p7A;
    },
    dd2: function () {
      return i.dd2;
    },
    CP7: function () {
      return i.CP7;
    },
    fQK: function () {
      return i.fQK;
    },
    Wd$: function () {
      return Fm;
    },
    Uk6: function () {
      return i.Uk6;
    },
    _sL: function () {
      return i._sL;
    },
    Pnf: function () {
      return i.Pnf;
    },
    c8b: function () {
      return i.c8b;
    },
    _lf: function () {
      return i._lf;
    },
    ad5: function () {
      return i.ad5;
    },
    sZV: function () {
      return Ms;
    },
    TfA: function () {
      return ws;
    },
    sKX: function () {
      return Os;
    },
    UdM: function () {
      return ys;
    },
    P0y: function () {
      return Xi;
    },
    L_r: function () {
      return i.L_r;
    },
    Bve: function () {
      return Om;
    },
    UeO: function () {
      return dr;
    },
    $nx: function () {
      return Ox;
    },
    Bk6: function () {
      return $n;
    },
    y4l: function () {
      return rn;
    },
    pQ0: function () {
      return Ls;
    },
    wXW: function () {
      return nE;
    },
    r5x: function () {
      return QT;
    },
    MSI: function () {
      return sE;
    },
    jtH: function () {
      return dc;
    },
    T0T: function () {
      return bc;
    },
    gAb: function () {
      return YC;
    },
    iwT: function () {
      return Vc;
    },
    je_: function () {
      return ZC;
    },
    wBP: function () {
      return vc;
    },
    Zs7: function () {
      return SE;
    },
    x7s: function () {
      return UE;
    },
    d73: function () {
      return zT;
    },
    RG9: function () {
      return X;
    },
    mvg: function () {
      return VT;
    },
    XMc: function () {
      return eE;
    },
    N7M: function () {
      return JT;
    },
    iv: function () {
      return rE;
    },
    n55: function () {
      return bt;
    },
    IaC: function () {
      return UT;
    },
    $MY: function () {
      return eo;
    },
    wJl: function () {
      return $s;
    },
    zVI: function () {
      return WT;
    },
    DpF: function () {
      return fu;
    },
    nNb: function () {
      return zi;
    },
    cqZ: function () {
      return Vi;
    },
    KlC: function () {
      return Oo;
    },
    KVn: function () {
      return L;
    },
    oau: function () {
      return wE;
    },
    aw9: function () {
      return qt;
    },
    leS: function () {
      return pt;
    },
    Dxg: function () {
      return y;
    },
    O5A: function () {
      return mt;
    },
    wCn: function () {
      return wt;
    },
    Bi6: function () {
      return St;
    },
    fi_: function () {
      return VE;
    },
    TT: function () {
      return hE;
    },
    q2Z: function () {
      return OC;
    },
    NyK: function () {
      return Z;
    },
    bgu: function () {
      return Tt;
    },
    kcS: function () {
      return Mt;
    },
    ivY: function () {
      return T;
    },
    _HO: function () {
      return H;
    },
    tpL: function () {
      return W;
    },
    LjN: function () {
      return rs;
    },
    iFs: function () {
      return is;
    },
    qTg: function () {
      return v;
    },
    Wtl: function () {
      return Oi;
    },
    DmK: function () {
      return Li;
    },
    Hx7: function () {
      return Te;
    },
    imt: function () {
      return Se;
    },
    US6: function () {
      return LE;
    },
    vZs: function () {
      return Lo;
    },
    lmu: function () {
      return vt;
    },
    SvO: function () {
      return xt;
    },
    omp: function () {
      return qA;
    },
    utz: function () {
      return HT;
    },
    TFV: function () {
      return io;
    },
    hrz: function () {
      return w;
    },
    JKM: function () {
      return fE;
    },
    jZf: function () {
      return XC;
    },
    RjL: function () {
      return xC;
    },
    RRI: function () {
      return IE;
    },
    RUq: function () {
      return rC;
    },
    _t4: function () {
      return Je;
    },
    YHh: function () {
      return $e;
    },
    R8g: function () {
      return I;
    },
    Bbl: function () {
      return en;
    },
    V9r: function () {
      return b;
    },
    PZ2: function () {
      return x;
    },
    w7A: function () {
      return _;
    },
    N6S: function () {
      return U;
    },
    Uxp: function () {
      return B;
    },
    tAz: function () {
      return N;
    },
    R$F: function () {
      return z;
    },
    N33: function () {
      return j;
    },
    gw2: function () {
      return Bs;
    },
    KlU: function () {
      return F;
    },
    wo6: function () {
      return kt;
    },
    H4P: function () {
      return M;
    },
    swA: function () {
      return Wi;
    },
    _Z3: function () {
      return Ki;
    },
    ivc: function () {
      return zi;
    },
    rZ1: function () {
      return Vi;
    },
    CpZ: function () {
      return zE;
    },
    dyc: function () {
      return E;
    },
    MxZ: function () {
      return ZA;
    },
    btp: function () {
      return JA;
    },
    mXy: function () {
      return YA;
    },
    Ej0: function () {
      return ct;
    },
    ep4: function () {
      return Xt;
    },
    DQP: function () {
      return ut;
    },
    V7q: function () {
      return Et;
    },
    zEk: function () {
      return Ot;
    },
    qfq: function () {
      return At;
    },
    piB: function () {
      return R;
    },
    rrF: function () {
      return Ni;
    },
    naq: function () {
      return Ui;
    },
    p5I: function () {
      return gc;
    },
    GpE: function () {
      return m;
    },
    t$v: function () {
      return jT;
    },
    tdn: function () {
      return Hc;
    },
    Y9t: function () {
      return Wc;
    },
    DH3: function () {
      return tE;
    },
    uxM: function () {
      return cT;
    },
    zH3: function () {
      return uT;
    },
    MLs: function () {
      return Hs;
    },
    le6: function () {
      return ot;
    },
    s6f: function () {
      return st;
    },
    YM4: function () {
      return mc;
    },
    B3r: function () {
      return qC;
    },
    iAx: function () {
      return pT;
    },
    lDn: function () {
      return G;
    },
    TIc: function () {
      return Rt;
    },
    xsC: function () {
      return oE;
    },
    zOc: function () {
      return Ct;
    },
    r46: function () {
      return ME;
    },
    z2C: function () {
      return C;
    },
    _X$: function () {
      return Qt;
    },
    _yn: function () {
      return It;
    },
    Dyg: function () {
      return gt;
    },
    cUc: function () {
      return Wt;
    },
    Ctq: function () {
      return ZT;
    },
    k5b: function () {
      return XT;
    },
    kZl: function () {
      return pE;
    },
    OCg: function () {
      return bE;
    },
    YjH: function () {
      return NE;
    },
    Ui8: function () {
      return cx;
    },
    ij3: function () {
      return $T;
    },
    YPW: function () {
      return qT;
    },
    Bg1: function () {
      return FC;
    },
    kon: function () {
      return S;
    },
    F2z: function () {
      return BT;
    },
    pJF: function () {
      return OA;
    },
    knz: function () {
      return i.knz;
    },
    Ejo: function () {
      return g;
    },
    BgY: function () {
      return Ae;
    },
    qCG: function () {
      return xe;
    },
    HD9: function () {
      return Me;
    },
    fEB: function () {
      return ye;
    },
    Udc: function () {
      return dt;
    },
    ZQg: function () {
      return ht;
    },
    ofC: function () {
      return K;
    },
    yRy: function () {
      return Pt;
    },
    _NL: function () {
      return Lm;
    },
    LCA: function () {
      return lt;
    },
    j1w: function () {
      return at;
    },
    i8J: function () {
      return nR;
    },
    p7C: function () {
      return V_;
    },
    ZAS: function () {
      return Xc;
    },
    VWG: function () {
      return oT;
    },
    pQ7: function () {
      return Gc;
    },
    jc8: function () {
      return Ht;
    },
    BL_: function () {
      return GT;
    },
    T8U: function () {
      return ds;
    },
    TD6: function () {
      return hs;
    },
    akS: function () {
      return hT;
    },
    QKE: function () {
      return dT;
    },
    dKx: function () {
      return A;
    },
    OvX: function () {
      return JC;
    },
    VsW: function () {
      return _c;
    },
    aPg: function () {
      return q;
    },
    LFn: function () {
      return Dt;
    },
    wey: function () {
      return NT;
    },
    MaE: function () {
      return Xe;
    },
    s4x: function () {
      return Ye;
    },
    FJA: function () {
      return ze;
    },
    vIA: function () {
      return Ke;
    },
    Spv: function () {
      return Qe;
    },
    w8l: function () {
      return Ze;
    },
    riG: function () {
      return qe;
    },
    Kbh: function () {
      return Ge;
    },
    t8K: function () {
      return He;
    },
    Q7n: function () {
      return Ve;
    },
    KGF: function () {
      return We;
    },
    e5: function () {
      return V;
    },
    Rik: function () {
      return Ps;
    },
    GZo: function () {
      return Ds;
    },
    Bds: function () {
      return Qi;
    },
    HTu: function () {
      return es;
    },
    cTq: function () {
      return yt;
    },
    X_Y: function () {
      return Qs;
    },
    dA8: function () {
      return Js;
    },
    bwS: function () {
      return YT;
    },
    P4F: function () {
      return JM;
    },
    Pd0: function () {
      return Jn;
    },
    Pjo: function () {
      return KT;
    },
    Tum: function () {
      return Qn;
    },
    dRH: function () {
      return tr;
    },
    RX0: function () {
      return er;
    },
    cWm: function () {
      return iE;
    },
    NC9: function () {
      return ZM;
    },
    $Re: function () {
      return Ts;
    },
    Xo9: function () {
      return Es;
    },
    LNO: function () {
      return Yi;
    },
    iZP: function () {
      return Zi;
    }
  });

  var e = {};
  __webpackgi_require__.r(e), __webpackgi_require__.d(e, {
    KHR_DF_CHANNEL_RGBSDA_ALPHA: function () {
      return wp;
    },
    KHR_DF_CHANNEL_RGBSDA_BLUE: function () {
      return bp;
    },
    KHR_DF_CHANNEL_RGBSDA_DEPTH: function () {
      return yp;
    },
    KHR_DF_CHANNEL_RGBSDA_GREEN: function () {
      return vp;
    },
    KHR_DF_CHANNEL_RGBSDA_RED: function () {
      return gp;
    },
    KHR_DF_CHANNEL_RGBSDA_STENCIL: function () {
      return xp;
    },
    KHR_DF_FLAG_ALPHA_PREMULTIPLIED: function () {
      return Bu;
    },
    KHR_DF_FLAG_ALPHA_STRAIGHT: function () {
      return Uu;
    },
    KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: function () {
      return Ru;
    },
    KHR_DF_MODEL_ASTC: function () {
      return Fu;
    },
    KHR_DF_MODEL_ETC1: function () {
      return Lu;
    },
    KHR_DF_MODEL_ETC1S: function () {
      return Nu;
    },
    KHR_DF_MODEL_ETC2: function () {
      return Iu;
    },
    KHR_DF_MODEL_RGBSDA: function () {
      return Ou;
    },
    KHR_DF_MODEL_UNSPECIFIED: function () {
      return Du;
    },
    KHR_DF_PRIMARIES_ACES: function () {
      return pp;
    },
    KHR_DF_PRIMARIES_ACESCC: function () {
      return hp;
    },
    KHR_DF_PRIMARIES_ADOBERGB: function () {
      return mp;
    },
    KHR_DF_PRIMARIES_BT2020: function () {
      return cp;
    },
    KHR_DF_PRIMARIES_BT601_EBU: function () {
      return ap;
    },
    KHR_DF_PRIMARIES_BT601_SMPTE: function () {
      return lp;
    },
    KHR_DF_PRIMARIES_BT709: function () {
      return op;
    },
    KHR_DF_PRIMARIES_CIEXYZ: function () {
      return up;
    },
    KHR_DF_PRIMARIES_DISPLAYP3: function () {
      return _p;
    },
    KHR_DF_PRIMARIES_NTSC1953: function () {
      return dp;
    },
    KHR_DF_PRIMARIES_PAL525: function () {
      return fp;
    },
    KHR_DF_PRIMARIES_UNSPECIFIED: function () {
      return sp;
    },
    KHR_DF_SAMPLE_DATATYPE_EXPONENT: function () {
      return Tp;
    },
    KHR_DF_SAMPLE_DATATYPE_FLOAT: function () {
      return Sp;
    },
    KHR_DF_SAMPLE_DATATYPE_LINEAR: function () {
      return Ep;
    },
    KHR_DF_SAMPLE_DATATYPE_SIGNED: function () {
      return Mp;
    },
    KHR_DF_TRANSFER_ACESCC: function () {
      return np;
    },
    KHR_DF_TRANSFER_ACESCCT: function () {
      return rp;
    },
    KHR_DF_TRANSFER_ADOBERGB: function () {
      return ip;
    },
    KHR_DF_TRANSFER_BT1886: function () {
      return Xu;
    },
    KHR_DF_TRANSFER_DCIP3: function () {
      return $u;
    },
    KHR_DF_TRANSFER_HLG_EOTF: function () {
      return Yu;
    },
    KHR_DF_TRANSFER_HLG_OETF: function () {
      return qu;
    },
    KHR_DF_TRANSFER_ITU: function () {
      return Gu;
    },
    KHR_DF_TRANSFER_LINEAR: function () {
      return zu;
    },
    KHR_DF_TRANSFER_NTSC: function () {
      return Hu;
    },
    KHR_DF_TRANSFER_PAL625_EOTF: function () {
      return ep;
    },
    KHR_DF_TRANSFER_PAL_OETF: function () {
      return Qu;
    },
    KHR_DF_TRANSFER_PQ_EOTF: function () {
      return Zu;
    },
    KHR_DF_TRANSFER_PQ_OETF: function () {
      return Ju;
    },
    KHR_DF_TRANSFER_SLOG: function () {
      return Wu;
    },
    KHR_DF_TRANSFER_SLOG2: function () {
      return Ku;
    },
    KHR_DF_TRANSFER_SRGB: function () {
      return Vu;
    },
    KHR_DF_TRANSFER_ST240: function () {
      return tp;
    },
    KHR_DF_TRANSFER_UNSPECIFIED: function () {
      return ju;
    },
    KHR_DF_VENDORID_KHRONOS: function () {
      return ku;
    },
    KHR_DF_VERSION: function () {
      return Pu;
    },
    KHR_SUPERCOMPRESSION_BASISLZ: function () {
      return Eu;
    },
    KHR_SUPERCOMPRESSION_NONE: function () {
      return Tu;
    },
    KHR_SUPERCOMPRESSION_ZLIB: function () {
      return Cu;
    },
    KHR_SUPERCOMPRESSION_ZSTD: function () {
      return Au;
    },
    KTX2Container: function () {
      return e_;
    },
    VK_FORMAT_A1R5G5B5_UNORM_PACK16: function () {
      return Ip;
    },
    VK_FORMAT_A2B10G10R10_SINT_PACK32: function () {
      return bh;
    },
    VK_FORMAT_A2B10G10R10_SNORM_PACK32: function () {
      return gh;
    },
    VK_FORMAT_A2B10G10R10_UINT_PACK32: function () {
      return vh;
    },
    VK_FORMAT_A2B10G10R10_UNORM_PACK32: function () {
      return mh;
    },
    VK_FORMAT_A2R10G10B10_SINT_PACK32: function () {
      return _h;
    },
    VK_FORMAT_A2R10G10B10_SNORM_PACK32: function () {
      return dh;
    },
    VK_FORMAT_A2R10G10B10_UINT_PACK32: function () {
      return fh;
    },
    VK_FORMAT_A2R10G10B10_UNORM_PACK32: function () {
      return hh;
    },
    VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: function () {
      return Qf;
    },
    VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: function () {
      return $f;
    },
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: function () {
      return Yf;
    },
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK: function () {
      return _f;
    },
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK: function () {
      return ff;
    },
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: function () {
      return Kf;
    },
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK: function () {
      return cf;
    },
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK: function () {
      return lf;
    },
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: function () {
      return Xf;
    },
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK: function () {
      return pf;
    },
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK: function () {
      return uf;
    },
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: function () {
      return qf;
    },
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK: function () {
      return df;
    },
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK: function () {
      return hf;
    },
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: function () {
      return Zf;
    },
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK: function () {
      return gf;
    },
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK: function () {
      return mf;
    },
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: function () {
      return Jf;
    },
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK: function () {
      return bf;
    },
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK: function () {
      return vf;
    },
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: function () {
      return Uf;
    },
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK: function () {
      return Kd;
    },
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK: function () {
      return Wd;
    },
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: function () {
      return Bf;
    },
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK: function () {
      return qd;
    },
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK: function () {
      return Xd;
    },
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: function () {
      return jf;
    },
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK: function () {
      return Zd;
    },
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK: function () {
      return Yd;
    },
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: function () {
      return zf;
    },
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK: function () {
      return $d;
    },
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK: function () {
      return Jd;
    },
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: function () {
      return Vf;
    },
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK: function () {
      return ef;
    },
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK: function () {
      return Qd;
    },
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: function () {
      return Gf;
    },
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK: function () {
      return nf;
    },
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK: function () {
      return tf;
    },
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: function () {
      return Hf;
    },
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK: function () {
      return sf;
    },
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK: function () {
      return rf;
    },
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: function () {
      return Wf;
    },
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK: function () {
      return af;
    },
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK: function () {
      return of;
    },
    VK_FORMAT_B10G11R11_UFLOAT_PACK32: function () {
      return ud;
    },
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: function () {
      return Mf;
    },
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: function () {
      return Rf;
    },
    VK_FORMAT_B4G4R4A4_UNORM_PACK16: function () {
      return kp;
    },
    VK_FORMAT_B5G5R5A1_UNORM_PACK16: function () {
      return Lp;
    },
    VK_FORMAT_B5G6R5_UNORM_PACK16: function () {
      return Dp;
    },
    VK_FORMAT_B8G8R8A8_SINT: function () {
      return uh;
    },
    VK_FORMAT_B8G8R8A8_SNORM: function () {
      return lh;
    },
    VK_FORMAT_B8G8R8A8_SRGB: function () {
      return ph;
    },
    VK_FORMAT_B8G8R8A8_UINT: function () {
      return ch;
    },
    VK_FORMAT_B8G8R8A8_UNORM: function () {
      return ah;
    },
    VK_FORMAT_B8G8R8_SINT: function () {
      return eh;
    },
    VK_FORMAT_B8G8R8_SNORM: function () {
      return $p;
    },
    VK_FORMAT_B8G8R8_SRGB: function () {
      return th;
    },
    VK_FORMAT_B8G8R8_UINT: function () {
      return Qp;
    },
    VK_FORMAT_B8G8R8_UNORM: function () {
      return Jp;
    },
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK: function () {
      return wd;
    },
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK: function () {
      return yd;
    },
    VK_FORMAT_BC1_RGB_SRGB_BLOCK: function () {
      return xd;
    },
    VK_FORMAT_BC1_RGB_UNORM_BLOCK: function () {
      return bd;
    },
    VK_FORMAT_BC2_SRGB_BLOCK: function () {
      return Md;
    },
    VK_FORMAT_BC2_UNORM_BLOCK: function () {
      return Sd;
    },
    VK_FORMAT_BC3_SRGB_BLOCK: function () {
      return Ed;
    },
    VK_FORMAT_BC3_UNORM_BLOCK: function () {
      return Td;
    },
    VK_FORMAT_BC4_SNORM_BLOCK: function () {
      return Cd;
    },
    VK_FORMAT_BC4_UNORM_BLOCK: function () {
      return Ad;
    },
    VK_FORMAT_BC5_SNORM_BLOCK: function () {
      return kd;
    },
    VK_FORMAT_BC5_UNORM_BLOCK: function () {
      return Rd;
    },
    VK_FORMAT_BC6H_SFLOAT_BLOCK: function () {
      return Dd;
    },
    VK_FORMAT_BC6H_UFLOAT_BLOCK: function () {
      return Pd;
    },
    VK_FORMAT_BC7_SRGB_BLOCK: function () {
      return Ld;
    },
    VK_FORMAT_BC7_UNORM_BLOCK: function () {
      return Od;
    },
    VK_FORMAT_D16_UNORM: function () {
      return hd;
    },
    VK_FORMAT_D16_UNORM_S8_UINT: function () {
      return md;
    },
    VK_FORMAT_D24_UNORM_S8_UINT: function () {
      return gd;
    },
    VK_FORMAT_D32_SFLOAT: function () {
      return fd;
    },
    VK_FORMAT_D32_SFLOAT_S8_UINT: function () {
      return vd;
    },
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: function () {
      return pd;
    },
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK: function () {
      return Hd;
    },
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK: function () {
      return Gd;
    },
    VK_FORMAT_EAC_R11_SNORM_BLOCK: function () {
      return Vd;
    },
    VK_FORMAT_EAC_R11_UNORM_BLOCK: function () {
      return zd;
    },
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: function () {
      return Ud;
    },
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: function () {
      return Nd;
    },
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: function () {
      return jd;
    },
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: function () {
      return Bd;
    },
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: function () {
      return Fd;
    },
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: function () {
      return Id;
    },
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: function () {
      return Sf;
    },
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: function () {
      return Cf;
    },
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: function () {
      return Lf;
    },
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: function () {
      return kf;
    },
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: function () {
      return If;
    },
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: function () {
      return Pf;
    },
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: function () {
      return Ff;
    },
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: function () {
      return Df;
    },
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: function () {
      return Nf;
    },
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: function () {
      return Of;
    },
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: function () {
      return wf;
    },
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16: function () {
      return yf;
    },
    VK_FORMAT_R10X6_UNORM_PACK16: function () {
      return xf;
    },
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: function () {
      return Af;
    },
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16: function () {
      return Ef;
    },
    VK_FORMAT_R12X4_UNORM_PACK16: function () {
      return Tf;
    },
    VK_FORMAT_R16G16B16A16_SFLOAT: function () {
      return Bh;
    },
    VK_FORMAT_R16G16B16A16_SINT: function () {
      return Uh;
    },
    VK_FORMAT_R16G16B16A16_SNORM: function () {
      return Fh;
    },
    VK_FORMAT_R16G16B16A16_UINT: function () {
      return Nh;
    },
    VK_FORMAT_R16G16B16A16_UNORM: function () {
      return Ih;
    },
    VK_FORMAT_R16G16B16_SFLOAT: function () {
      return Lh;
    },
    VK_FORMAT_R16G16B16_SINT: function () {
      return Oh;
    },
    VK_FORMAT_R16G16B16_SNORM: function () {
      return Ph;
    },
    VK_FORMAT_R16G16B16_UINT: function () {
      return Dh;
    },
    VK_FORMAT_R16G16B16_UNORM: function () {
      return kh;
    },
    VK_FORMAT_R16G16_SFLOAT: function () {
      return Rh;
    },
    VK_FORMAT_R16G16_SINT: function () {
      return Ch;
    },
    VK_FORMAT_R16G16_SNORM: function () {
      return Eh;
    },
    VK_FORMAT_R16G16_UINT: function () {
      return Ah;
    },
    VK_FORMAT_R16G16_UNORM: function () {
      return Th;
    },
    VK_FORMAT_R16_SFLOAT: function () {
      return Mh;
    },
    VK_FORMAT_R16_SINT: function () {
      return Sh;
    },
    VK_FORMAT_R16_SNORM: function () {
      return yh;
    },
    VK_FORMAT_R16_UINT: function () {
      return wh;
    },
    VK_FORMAT_R16_UNORM: function () {
      return xh;
    },
    VK_FORMAT_R32G32B32A32_SFLOAT: function () {
      return Jh;
    },
    VK_FORMAT_R32G32B32A32_SINT: function () {
      return Zh;
    },
    VK_FORMAT_R32G32B32A32_UINT: function () {
      return Yh;
    },
    VK_FORMAT_R32G32B32_SFLOAT: function () {
      return qh;
    },
    VK_FORMAT_R32G32B32_SINT: function () {
      return Xh;
    },
    VK_FORMAT_R32G32B32_UINT: function () {
      return Kh;
    },
    VK_FORMAT_R32G32_SFLOAT: function () {
      return Wh;
    },
    VK_FORMAT_R32G32_SINT: function () {
      return Hh;
    },
    VK_FORMAT_R32G32_UINT: function () {
      return Gh;
    },
    VK_FORMAT_R32_SFLOAT: function () {
      return Vh;
    },
    VK_FORMAT_R32_SINT: function () {
      return zh;
    },
    VK_FORMAT_R32_UINT: function () {
      return jh;
    },
    VK_FORMAT_R4G4B4A4_UNORM_PACK16: function () {
      return Rp;
    },
    VK_FORMAT_R4G4_UNORM_PACK8: function () {
      return Cp;
    },
    VK_FORMAT_R5G5B5A1_UNORM_PACK16: function () {
      return Op;
    },
    VK_FORMAT_R5G6B5_UNORM_PACK16: function () {
      return Pp;
    },
    VK_FORMAT_R64G64B64A64_SFLOAT: function () {
      return cd;
    },
    VK_FORMAT_R64G64B64A64_SINT: function () {
      return ld;
    },
    VK_FORMAT_R64G64B64A64_UINT: function () {
      return ad;
    },
    VK_FORMAT_R64G64B64_SFLOAT: function () {
      return od;
    },
    VK_FORMAT_R64G64B64_SINT: function () {
      return sd;
    },
    VK_FORMAT_R64G64B64_UINT: function () {
      return id;
    },
    VK_FORMAT_R64G64_SFLOAT: function () {
      return rd;
    },
    VK_FORMAT_R64G64_SINT: function () {
      return nd;
    },
    VK_FORMAT_R64G64_UINT: function () {
      return td;
    },
    VK_FORMAT_R64_SFLOAT: function () {
      return ed;
    },
    VK_FORMAT_R64_SINT: function () {
      return Qh;
    },
    VK_FORMAT_R64_UINT: function () {
      return $h;
    },
    VK_FORMAT_R8G8B8A8_SINT: function () {
      return sh;
    },
    VK_FORMAT_R8G8B8A8_SNORM: function () {
      return rh;
    },
    VK_FORMAT_R8G8B8A8_SRGB: function () {
      return oh;
    },
    VK_FORMAT_R8G8B8A8_UINT: function () {
      return ih;
    },
    VK_FORMAT_R8G8B8A8_UNORM: function () {
      return nh;
    },
    VK_FORMAT_R8G8B8_SINT: function () {
      return Yp;
    },
    VK_FORMAT_R8G8B8_SNORM: function () {
      return Xp;
    },
    VK_FORMAT_R8G8B8_SRGB: function () {
      return Zp;
    },
    VK_FORMAT_R8G8B8_UINT: function () {
      return qp;
    },
    VK_FORMAT_R8G8B8_UNORM: function () {
      return Kp;
    },
    VK_FORMAT_R8G8_SINT: function () {
      return Hp;
    },
    VK_FORMAT_R8G8_SNORM: function () {
      return Vp;
    },
    VK_FORMAT_R8G8_SRGB: function () {
      return Wp;
    },
    VK_FORMAT_R8G8_UINT: function () {
      return Gp;
    },
    VK_FORMAT_R8G8_UNORM: function () {
      return zp;
    },
    VK_FORMAT_R8_SINT: function () {
      return Bp;
    },
    VK_FORMAT_R8_SNORM: function () {
      return Np;
    },
    VK_FORMAT_R8_SRGB: function () {
      return jp;
    },
    VK_FORMAT_R8_UINT: function () {
      return Up;
    },
    VK_FORMAT_R8_UNORM: function () {
      return Fp;
    },
    VK_FORMAT_S8_UINT: function () {
      return _d;
    },
    VK_FORMAT_UNDEFINED: function () {
      return Ap;
    },
    VK_FORMAT_X8_D24_UNORM_PACK32: function () {
      return dd;
    },
    read: function () {
      return a_;
    },
    write: function () {
      return u_;
    }
  });
  var t,
      n = {};
  __webpackgi_require__.r(n), __webpackgi_require__.d(n, {
    AsyncCompress: function () {
      return dv;
    },
    AsyncDecompress: function () {
      return Rv;
    },
    AsyncDeflate: function () {
      return sv;
    },
    AsyncGunzip: function () {
      return gv;
    },
    AsyncGzip: function () {
      return dv;
    },
    AsyncInflate: function () {
      return cv;
    },
    AsyncUnzipInflate: function () {
      return nb;
    },
    AsyncUnzlib: function () {
      return Tv;
    },
    AsyncZipDeflate: function () {
      return Zv;
    },
    AsyncZlib: function () {
      return yv;
    },
    Compress: function () {
      return hv;
    },
    DecodeUTF8: function () {
      return Nv;
    },
    Decompress: function () {
      return Cv;
    },
    Deflate: function () {
      return iv;
    },
    EncodeUTF8: function () {
      return Uv;
    },
    Gunzip: function () {
      return mv;
    },
    Gzip: function () {
      return hv;
    },
    Inflate: function () {
      return lv;
    },
    Unzip: function () {
      return rb;
    },
    UnzipInflate: function () {
      return tb;
    },
    UnzipPassThrough: function () {
      return eb;
    },
    Unzlib: function () {
      return Mv;
    },
    Zip: function () {
      return Jv;
    },
    ZipDeflate: function () {
      return Yv;
    },
    ZipPassThrough: function () {
      return qv;
    },
    Zlib: function () {
      return xv;
    },
    compress: function () {
      return fv;
    },
    compressSync: function () {
      return _v;
    },
    decompress: function () {
      return kv;
    },
    decompressSync: function () {
      return Pv;
    },
    deflate: function () {
      return ov;
    },
    deflateSync: function () {
      return av;
    },
    gunzip: function () {
      return vv;
    },
    gunzipSync: function () {
      return bv;
    },
    gzip: function () {
      return fv;
    },
    gzipSync: function () {
      return _v;
    },
    inflate: function () {
      return uv;
    },
    inflateSync: function () {
      return pv;
    },
    strFromU8: function () {
      return jv;
    },
    strToU8: function () {
      return Bv;
    },
    unzip: function () {
      return ib;
    },
    unzipSync: function () {
      return sb;
    },
    unzlib: function () {
      return Ev;
    },
    unzlibSync: function () {
      return Av;
    },
    zip: function () {
      return $v;
    },
    zipSync: function () {
      return Qv;
    },
    zlib: function () {
      return wv;
    },
    zlibSync: function () {
      return Sv;
    }
  }), function (e) {
    e[e.Error = -2] = "Error", e[e.Destroyed = -1] = "Destroyed", e[e.None = 0] = "None", e[e.Running = 1] = "Running", e[e.Paused = 2] = "Paused";
  }(t || (t = {}));

  class r {
    constructor() {
      this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this);
    }

    addEventListener(e, t) {
      const n = this._eventListeners;
      void 0 === n[e] && (n[e] = []), n[e].includes(t) || n[e].push(t);
    }

    hasEventListener(e, t) {
      const n = this._eventListeners;
      return void 0 !== n[e] && n[e].includes(t);
    }

    removeEventListener(e, t) {
      const n = this._eventListeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }
    }

    dispatchEvent(e) {
      const t = this._eventListeners[e.type];

      if (void 0 !== t) {
        e.target = this;
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
      }
    }

  }

  var i = __webpackgi_require__(927);

  const s = {
    uniforms: {
      tDiffuse: {
        value: null
      },
      opacity: {
        value: 1
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
  };

  class o {
    constructor() {
      this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
    }

    setSize() {}

    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }

  }

  const a = new i.iKG(-1, 1, 1, -1, 0, 1),
        l = new i.u9r();
  l.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), l.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));

  class c {
    constructor(e) {
      this._mesh = new i.Kj0(l, e);
    }

    dispose() {
      this._mesh.geometry.dispose();
    }

    render(e) {
      e.render(this._mesh, a);
    }

    get material() {
      return this._mesh.material;
    }

    set material(e) {
      this._mesh.material = e;
    }

  }

  class u extends o {
    constructor(e, t) {
      super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof i.jyz ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = i.rDY.clone(e.uniforms), this.material = new i.jyz({
        defines: Object.assign({}, e.defines),
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader
      })), this.fsQuad = new c(this.material), this.useExistingRenderTarget = !1;
    }

    render(e, t, n) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (this.useExistingRenderTarget || e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
    }

  }

  class p extends o {
    constructor(e, t) {
      super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
    }

    render(e, t, n) {
      const r = e.getContext(),
            i = e.state;
      let s, o;
      i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), i.buffers.stencil.setFunc(r.ALWAYS, s, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), i.buffers.stencil.setLocked(!0);
    }

  }

  class h extends o {
    constructor() {
      super(), this.needsSwap = !1;
    }

    render(e) {
      e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
    }

  }

  new i.iKG(-1, 1, 1, -1, 0, 1);
  const d = new i.u9r();
  d.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), d.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));

  class f extends class {
    constructor(e, t) {
      if (this.renderer = e, void 0 === t) {
        const n = e.getSize(new i.FM8());
        this._pixelRatio = e.getPixelRatio(), this._width = n.width, this._height = n.height, (t = new i.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
      } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;

      this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === s && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === u && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new u(s), this.clock = new i.SUY();
    }

    swapBuffers() {
      const e = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e;
    }

    addPass(e) {
      this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }

    insertPass(e, t) {
      this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }

    removePass(e) {
      const t = this.passes.indexOf(e);
      -1 !== t && this.passes.splice(t, 1);
    }

    isLastEnabledPass(e) {
      for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return !1;

      return !0;
    }

    render(e) {
      void 0 === e && (e = this.clock.getDelta());
      const t = this.renderer.getRenderTarget();
      let n = !1;

      for (let t = 0, r = this.passes.length; t < r; t++) {
        const r = this.passes[t];

        if (!1 !== r.enabled) {
          if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), r.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), r.needsSwap) {
            if (n) {
              const t = this.renderer.getContext(),
                    n = this.renderer.state.buffers.stencil;
              n.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n.setFunc(t.EQUAL, 1, 4294967295);
            }

            this.swapBuffers();
          }

          void 0 !== p && (r instanceof p ? n = !0 : r instanceof h && (n = !1));
        }
      }

      this.renderer.setRenderTarget(t);
    }

    reset(e) {
      if (void 0 === e) {
        const t = this.renderer.getSize(new i.FM8());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }

      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }

    setSize(e, t) {
      this._width = e, this._height = t;
      const n = this._width * this._pixelRatio,
            r = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);

      for (let e = 0; e < this.passes.length; e++) this.passes[e].setSize(n, r);
    }

    setPixelRatio(e) {
      this._pixelRatio = e, this.setSize(this._width, this._height);
    }

  } {
    constructor(e, t) {
      super(e, t);
    }

    setPixelRatio(e, t = !0) {
      const n = this.setSize;
      t || (this.setSize = () => {}), super.setPixelRatio(e), t || (this.setSize = n);
    }

  }

  function _(e, t) {
    let n;

    do {
      n = Object.getOwnPropertyDescriptor(e, t);
    } while (!n && (e = Object.getPrototypeOf(e)));

    return n;
  }

  function m(e, t, n = !1, r = !1) {
    const i = _(e, t);

    return !!(null == i ? void 0 : i.set) || n && !1 !== (null == i ? void 0 : i.writable) && void 0 === (null == i ? void 0 : i.get) || r && !i;
  }

  function g(e, t, n, r = !1, i = !1) {
    return !(!e || !m(e, t, r, i) || (e[t] = n, 0));
  }

  function v(e, t) {
    for (; e.length > 0;) {
      if (!t) return;
      const n = e.splice(0, 1)[0];

      if (!(n.length < 1)) {
        if (!(n in t)) return console.error("invalid access, check", n, t), t;
        t = t[n];
      }
    }

    return t;
  }

  function b(e, t) {
    return Object.keys(e).find(n => e[n] === t);
  }

  function x(e, ...t) {
    return "function" == typeof e && (e = e(...t)), e;
  }

  function y(e, t, n) {
    for (const r of n) {
      const n = e[r];
      void 0 !== n && g(t, r, n, !0);
    }
  }

  function w(e) {
    return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
  }

  function S(e, t, n) {
    return e.replace(new RegExp(w(t), "g"), n);
  }

  String.raw;

  const M = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        T = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        E = (e, ...t) => String.raw({
    raw: e
  }, ...t),
        A = (e, ...t) => {
    let n = String.raw({
      raw: e
    }, ...t);
    return n = S(n, "%", "%25"), n = S(n, "> <", "><"), n = S(n, "; }", ";}"), n = S(n, "<", "%3c"), n = S(n, ">", "%3e"), n = S(n, '"', "'"), n = S(n, "#", "%23"), n = S(n, "{", "%7b"), n = S(n, "}", "%7d"), n = S(n, "|", "%7c"), n = S(n, "^", "%5e"), n = S(n, "`", "%60"), n = S(n, "@", "%40"), n = S(n, "&", "&amp;"), "data:image/svg+xml;charset=UTF-8," + n;
  };

  function C(e) {
    if (!e) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return (t, n) => {
      let r;
      Object.defineProperty(t, n, {
        get: () => r,

        set(t) {
          var i;
          if (r === t) return;
          r = t;
          const s = [n, t];
          if ("string" == typeof e) null === (i = this[e]) || void 0 === i || i.call(this, ...s);else if ("function" == typeof e) {
            let t = !1;

            if (e.name) {
              let n = this;

              for (; n;) {
                if (n[e.name] === e) {
                  e.call(this, ...s), t = !0;
                  break;
                }

                n = Object.getPrototypeOf(n);
              }
            }

            t || (e.name && this[e.name].name === `bound ${e.name}` ? this[e.name](...s) : e(...s));
          }
        }

      });
    };
  }

  function R(e, t) {
    for (const n of t) if (!e.includes(n)) return !1;

    return !0;
  }

  String.prototype.replaceAll || (String.prototype.replaceAll = function (e, t) {
    return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e, "g"), t);
  });

  class k {
    constructor(e = 0, t = 0) {
      k.prototype.isVector2 = !0, this.x = e, this.y = t;
    }

    get width() {
      return this.x;
    }

    set width(e) {
      this.x = e;
    }

    get height() {
      return this.y;
    }

    set height(e) {
      this.y = e;
    }

    set(e, t) {
      return this.x = e, this.y = t, this;
    }

    setScalar(e) {
      return this.x = e, this.y = e, this;
    }

    setX(e) {
      return this.x = e, this;
    }

    setY(e) {
      return this.y = e, this;
    }

    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;

        case 1:
          this.y = t;
          break;

        default:
          throw new Error("index is out of range: " + e);
      }

      return this;
    }

    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        default:
          throw new Error("index is out of range: " + e);
      }
    }

    clone() {
      return new this.constructor(this.x, this.y);
    }

    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }

    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }

    addScalar(e) {
      return this.x += e, this.y += e, this;
    }

    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }

    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }

    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }

    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }

    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }

    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }

    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }

    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }

    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }

    applyMatrix3(e) {
      const t = this.x,
            n = this.y,
            r = e.elements;
      return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
    }

    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }

    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }

    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }

    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }

    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }

    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }

    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }

    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }

    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }

    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }

    dot(e) {
      return this.x * e.x + this.y * e.y;
    }

    cross(e) {
      return this.x * e.y - this.y * e.x;
    }

    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }

    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }

    normalize() {
      return this.divideScalar(this.length() || 1);
    }

    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }

    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }

    distanceToSquared(e) {
      const t = this.x - e.x,
            n = this.y - e.y;
      return t * t + n * n;
    }

    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }

    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }

    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }

    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
    }

    equals(e) {
      return e.x === this.x && e.y === this.y;
    }

    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }

    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }

    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }

    rotateAround(e, t) {
      const n = Math.cos(t),
            r = Math.sin(t),
            i = this.x - e.x,
            s = this.y - e.y;
      return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this;
    }

    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }

    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }

  }

  class P extends i.ZzF {
    expandByObject(e, t = !1, n = !1) {
      var r;
      if (!1 === (null === (r = e.userData) || void 0 === r ? void 0 : r.bboxVisible)) return this;
      if (!e.visible && n) return this;
      e.updateWorldMatrix(!1, !1);
      const i = e.geometry;
      if (void 0 !== i) if (t && null != i.attributes && void 0 !== i.attributes.position) {
        const t = i.attributes.position;

        for (let n = 0, r = t.count; n < r; n++) O.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(O);
      } else null === i.boundingBox && i.computeBoundingBox(), D.copy(i.boundingBox), D.applyMatrix4(e.matrixWorld), this.union(D);
      const s = e.children;

      for (let e = 0, r = s.length; e < r; e++) this.expandByObject(s[e], t, n);

      return this;
    }

    expandByObjects(e, t = !1, n = !1) {
      for (let r = 0, i = e.length; r < i; r++) this.expandByObject(e[r], t, n);

      return this;
    }

    getPoints() {
      return [new i.Pa4(this.min.x, this.min.y, this.min.z), new i.Pa4(this.min.x, this.min.y, this.max.z), new i.Pa4(this.min.x, this.max.y, this.min.z), new i.Pa4(this.min.x, this.max.y, this.max.z), new i.Pa4(this.max.x, this.min.y, this.min.z), new i.Pa4(this.max.x, this.min.y, this.max.z), new i.Pa4(this.max.x, this.max.y, this.min.z), new i.Pa4(this.max.x, this.max.y, this.max.z)];
    }

    getScreenSpaceBounds(e) {
      const t = this.getPoints(),
            n = new i.TUj();

      for (const r of t) {
        const t = r.project(e);
        n.min.min(t), n.max.max(t);
      }

      return n;
    }

  }

  const D = new P(),
        O = new i.Pa4();

  function L(e, t) {
    let n, r;
    if (Array.isArray(e)) for (const i of e) {
      const e = L(i, t);
      void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max));
    }
    const s = e;

    if (void 0 !== s.geometry) {
      const o = s.geometry.vertices;

      if (void 0 === o && void 0 !== s.geometry.attributes && "position" in s.geometry.attributes) {
        const o = new i.Pa4(),
              a = s.geometry.attributes.position;

        for (let i = 0; i < a.count * a.itemSize; i += a.itemSize) {
          o.set(a.array[i], a.array[i + 1], a.array[3]);
          const s = o.applyMatrix4(e.matrixWorld).project(t),
                l = new k(s.x, s.y);
          void 0 === n || void 0 === r ? (n = l.clone(), r = l.clone()) : (n.min(l), r.max(l));
        }
      } else for (const i of o) {
        const s = i.clone().applyMatrix4(e.matrixWorld).project(t),
              o = new k(s.x, s.y);
        void 0 === n || void 0 === r ? (n = o.clone(), r = o.clone()) : (n.min(o), r.max(o));
      }
    }

    if (void 0 !== e.children) for (const i of e.children) {
      const e = L(i, t);
      void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max));
    }
    return new i.TUj(n, r);
  }

  function I(e) {
    switch (e) {
      case i.rnI:
        return ["Linear", "( value )"];

      case i.knz:
        return ["sRGB", "( value )"];

      case 3005:
        return ["RGBM", "( value, 16.0 )"];

      default:
        return console.warn("utils: Unsupported encoding:", e), ["Linear", "( value )"];
    }
  }

  function F(e, t) {
    let n;
    return e && e.isTexture ? n = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = i.rnI, t && e && e.isTexture && e.format === i.wk1 && e.type === i.ywz && e.encoding === i.knz && (n = i.rnI), n;
  }

  function N(e, t) {
    const n = I(t);
    return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
  }

  function U(e, t, n) {
    return N(e + "TexelToLinear", F(t, n)) + "\n";
  }

  function B(e, t) {
    return N(e + "TexelToLinear", t) + "\n";
  }

  function j(e, t) {
    const n = I(t);
    return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
  }

  function z(e, t, n) {
    return j(e, F(t, n));
  }

  function V({
    uniforms: e,
    propKey: t,
    thisTarget: n = !1
  } = {}) {
    const r = !!e,
          i = !!t,
          s = n;
    return (n, o) => {
      const a = n => {
        const a = s ? n : r ? e : n.uniforms || n._uniforms;
        let l = i ? t : o;
        s && (l = "_" + l);
        let c = a[l];
        return c || (c = {
          value: null
        }, a[l] = c), c;
      };

      Object.defineProperty(n, o, {
        get() {
          return a(this).value;
        },

        set(e) {
          a(this).value = e, g(this, "uniformsNeedUpdate", !0, !0);
        }

      });
    };
  }

  function G(e, t, n = !1, r) {
    const i = !!t,
          s = !!e;
    return (o, a) => {
      const l = n => ({
        t: i ? t : n.defines || n._defines,
        p: s ? e : a
      });

      Object.defineProperty(o, a, {
        get() {
          const {
            t: e,
            p: t
          } = l(n ? this : this.material);
          return e[t];
        },

        set(e) {
          const {
            t: t,
            p: i
          } = l(n ? this : this.material);

          if (g(t, i, e, !0), "function" == typeof r) {
            const t = [i, e];

            if (r.name) {
              const e = this[r.name];
              e === r ? r.call(this, ...t) : e.name === `bound ${r.name}` ? e(...t) : r(...t);
            } else r(...t);
          } else g(n ? this : this.material, "needsUpdate", !0, !0);
        }

      });
    };
  }

  function H(e) {
    const t = new i.IEO(new Uint8Array([Math.floor(255 * e.r), Math.floor(255 * e.g), Math.floor(255 * e.b), 255]), 1, 1, i.wk1, i.ywz);
    return t.needsUpdate = !0, t.encoding = i.rnI, t;
  }

  function W(e) {
    const t = new i.IEO(new Uint8Array([Math.floor(255 * e.x), Math.floor(255 * e.y), Math.floor(255 * e.z), Math.floor(255 * e.w)]), 1, 1, i.wk1, i.ywz);
    return t.needsUpdate = !0, t;
  }

  function K(e, t, n) {
    const r = e.userData,
          {
      backgroundRender: i,
      transparentRender: s,
      shadowMapRender: o,
      mainRenderPass: a,
      opaqueRender: l,
      transmissionRender: c,
      sceneRender: u,
      screenSpaceRendering: p
    } = r;
    void 0 !== t.backgroundRender && (r.backgroundRender = t.backgroundRender), void 0 !== t.transparentRender && (r.transparentRender = t.transparentRender), void 0 !== t.shadowMapRender && (r.shadowMapRender = t.shadowMapRender), void 0 !== t.mainRenderPass && (r.mainRenderPass = t.mainRenderPass), void 0 !== t.opaqueRender && (r.opaqueRender = t.opaqueRender), void 0 !== t.sceneRender && (r.sceneRender = t.sceneRender), void 0 !== t.transmissionRender && (r.transmissionRender = t.transmissionRender), void 0 !== t.screenSpaceRendering && (r.screenSpaceRendering = t.screenSpaceRendering), n(), r.backgroundRender = i, r.transparentRender = s, r.shadowMapRender = o, r.mainRenderPass = a, r.opaqueRender = l, r.sceneRender = u, r.transmissionRender = c, r.screenSpaceRendering = p;
  }

  function X(e, t) {
    const n = .5 * new P().expandByObject(e, !0, !0).getSize(new i.Pa4()).length();
    void 0 === t && (t = e.userData.autoScaleRadius || 1);
    const r = t / n;
    return isFinite(r) && (e.userData.pseudoCentered ? e.children.forEach(e => {
      e.scale.multiplyScalar(r);
    }) : e.scale.multiplyScalar(r)), e.userData.autoScaled = !0, e.userData.autoScaleRadius = t, e.dispatchEvent({
      type: "objectUpdate"
    }), e;
  }

  function q(e, t = -1) {
    return function (e, t = 1e-4) {
      const n = t > 0;
      t = Math.max(t, Number.EPSILON);
      const r = {},
            s = e.getIndex(),
            o = e.getAttribute("position"),
            a = s ? s.count : o.count;
      let l = 0;
      const c = Object.keys(e.attributes),
            u = {},
            p = {},
            h = [],
            d = ["getX", "getY", "getZ", "getW"];

      for (let t = 0, n = c.length; t < n; t++) {
        const n = c[t];
        u[n] = [];
        const r = e.morphAttributes[n];
        r && (p[n] = new Array(r.length).fill().map(() => []));
      }

      const f = Math.log10(1 / t),
            _ = Math.pow(10, f);

      for (let t = 0; t < a; t++) {
        const i = s ? s.getX(t) : t;
        let o = "";

        for (let t = 0, r = c.length; t < r && n; t++) {
          const n = c[t],
                r = e.getAttribute(n),
                s = r.itemSize;

          for (let e = 0; e < s; e++) o += ~~(r[d[e]](i) * _) + ",";
        }

        if (n && o in r) h.push(r[o]);else {
          for (let t = 0, n = c.length; t < n; t++) {
            const n = c[t],
                  r = e.getAttribute(n),
                  s = e.morphAttributes[n],
                  o = r.itemSize,
                  a = u[n],
                  l = p[n];

            for (let e = 0; e < o; e++) {
              const t = d[e];
              if (a.push(r[t](i)), s) for (let e = 0, n = s.length; e < n; e++) l[e].push(s[e][t](i));
            }
          }

          n && (r[o] = l), h.push(l), l++;
        }
      }

      const m = e.clone();

      for (let t = 0, n = c.length; t < n; t++) {
        const n = c[t],
              r = e.getAttribute(n),
              s = new r.array.constructor(u[n]),
              o = new i.TlE(s, r.itemSize, r.normalized);
        if (m.setAttribute(n, o), n in p) for (let t = 0; t < p[n].length; t++) {
          const r = e.morphAttributes[n][t],
                s = new r.array.constructor(p[n][t]),
                o = new i.TlE(s, r.itemSize, r.normalized);
          m.morphAttributes[n][t] = o;
        }
      }

      return m.setIndex(h), m;
    }(e, t);
  }

  class Y extends r {
    constructor({
      animationLoop: e,
      canvas: t,
      alpha: n = !0,
      targetOptions: r
    }) {
      super(), this._isWebGL2 = !1, this._trackedTargets = [], this.dirty = !0, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = !0, this._displayCanvasScaling = 1, this._renderSize = new i.FM8(512, 512), this._frameCount = 0, this._tempTargets = {}, this.maxTempPerKey = 5, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new i.CP7({
        canvas: t,
        antialias: !0,
        alpha: n,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0
      }), this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderSize = new i.FM8(t.clientWidth, t.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = i.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputEncoding = i.rnI, this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = i._MY, this._renderer.shadowMap.autoUpdate = !1, this.resetShadows(), r.isAntialiased = r.isAntialiased && this.isWebGL2, this._composerTarget = this.createTarget(r, !1), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new f(this._renderer, this._composerTarget), e && this.addEventListener("animationLoop", e);
    }

    get composer() {
      return this._composer;
    }

    get passes() {
      return this._passes;
    }

    get isWebGL2() {
      return this._isWebGL2;
    }

    get composerTarget() {
      return this._composerTarget;
    }

    get renderSize() {
      return this._renderSize;
    }

    get displayCanvasScaling() {
      return this._displayCanvasScaling;
    }

    set displayCanvasScaling(e) {
      e !== this._displayCanvasScaling && (this._displayCanvasScaling = e, this.setSize(void 0, void 0, !0));
    }

    get frameCount() {
      return this._frameCount;
    }

    set pipeline(e) {
      this._pipeline = e, this._passesNeedsUpdate = !0;
    }

    get pipeline() {
      return this._pipeline;
    }

    refreshPipeline() {
      var e, t, n;
      const r = this._passes,
            i = [],
            s = {};

      for (const i of r) {
        if (!1 === i.enabled) continue;
        const r = {
          after: null !== (e = i.after) && void 0 !== e ? e : [],
          before: null !== (t = i.before) && void 0 !== t ? t : [],
          dependencies: new Set(null !== (n = i.required) && void 0 !== n ? n : [])
        };
        s[i.passId] = r;
      }

      for (const [e, t] of Object.entries(s)) {
        const n = new Set([...t.after, ...t.before]);
        t.dependencies.forEach(e => n.has(e) && n.delete(e)), n.forEach(n => {
          const r = s[n];

          if (r) {
            if (r.dependencies.has(e)) throw console.error("cyclic", e, n), "Cyclic dependency";
            t.dependencies.add(n);
          }
        });
      }

      for (;;) {
        let e = !1;
        const t = [...Object.entries(s)];

        for (const [n, o] of t) if (!i.includes(n) && R(i, o.dependencies.values())) {
          const t = Math.max(-1, ...o.after.map(e => i.indexOf(e))),
                a = Math.min(i.length, ...o.before.map(e => {
            const t = i.indexOf(e);
            return t < 0 ? i.length : t;
          }));
          if (t >= a) throw console.error(o, r, i, t, a), "Not possible";
          i.splice(o.after.length > 0 ? t + 1 : a, 0, n), e = !0, delete s[n];
        }

        if (Object.keys(s).length < 1) break;
        if (!e) throw console.log(t, s, i), "Not possible 2";
      }

      return this.pipeline = i, this.pipeline;
    }

    get context() {
      return this._context;
    }

    get rendererObject() {
      return this._renderer;
    }

    _animationLoop(e, t) {
      const n = e - this._lastTime;
      this._lastTime = e, this.frameWaitTime -= n, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({
        type: "animationLoop",
        deltaTime: n,
        time: e,
        renderer: this,
        xrFrame: t
      }));
    }

    get clock() {
      return this._composer.clock;
    }

    registerPass(e, t = !0) {
      var n;
      if (t) for (const t of [...this._passes]) e.passId === t.passId && this.unregisterPass(t);
      this._passes.push(e), null === (n = e.onRegister) || void 0 === n || n.call(e, this), this._passesNeedsUpdate = !0, this._updated();
    }

    unregisterPass(e) {
      var t;

      const n = this._passes.indexOf(e);

      n >= 0 && (null === (t = e.onUnregister) || void 0 === t || t.call(e, this), this._passes.splice(n, 1), this._passesNeedsUpdate = !0, this._updated());
    }

    setSize(e, t, n = !1) {
      !n && (e ? Math.abs(e - this._renderSize.width) : 0) + (t ? Math.abs(t - this._renderSize.height) : 0) < .1 || (e && (this._renderSize.width = e), t && (this._renderSize.height = t), this.rendererObject.xr.enabled || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, !1), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach(e => {
        const t = e,
              n = t.sizeMultiplier;

        if (n) {
          const e = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * n);

          t.setSize(e.width, e.height);
        }
      }), this.dispatchEvent({
        type: "resize"
      }), this._updated(), this.reset());
    }

    blit(e, t, {
      viewport: n,
      material: r,
      shader: s,
      pass: o,
      clear: a = !0
    } = {}) {
      const l = this._composer.copyPass,
            {
        renderToScreen: c,
        material: u,
        uniforms: p,
        clear: h
      } = l;
      r && (l.material = r);

      const d = this._renderer.getViewport(new i.Ltg()),
            f = this._renderer.autoClear,
            _ = this._renderer.getRenderTarget();

      n && this._renderer.setViewport(new i.Ltg().fromArray(n)), this._renderer.autoClear = !1, l.uniforms = l.material.uniforms, l.renderToScreen = !1, l.clear = a, K(this._renderer, {
        sceneRender: !0,
        opaqueRender: !0,
        shadowMapRender: !1,
        backgroundRender: !1,
        transparentRender: !0,
        transmissionRender: !1
      }, () => {
        l.render(this._renderer, null != t ? t : null, {
          texture: e
        }, 0, !1);
      }), l.renderToScreen = c, l.clear = h, l.material = u, l.uniforms = p, this._renderer.autoClear = f, n && this._renderer.setViewport(d), this._renderer.setRenderTarget(_);
    }

    clearColor({
      r: e,
      g: t,
      b: n,
      a: r,
      target: s,
      depth: o = !0,
      stencil: a = !0
    }) {
      var l;

      const c = this._renderer.getClearColor(new i.Ilk()),
            u = this._renderer.getClearAlpha();

      this._renderer.setClearAlpha(null != r ? r : u), this._renderer.setClearColor(new i.Ilk(null != e ? e : c.r, null != t ? t : c.g, null != n ? n : c.b));

      const p = this._renderer.getRenderTarget(),
            h = this._renderer.getActiveCubeFace(),
            d = this._renderer.getActiveMipmapLevel();

      this._renderer.setRenderTarget(null !== (l = s) && void 0 !== l ? l : null), this._renderer.clear(!0, o, a), this._renderer.setRenderTarget(p, h, d), this._renderer.setClearColor(c), this._renderer.setClearAlpha(u);
    }

    renderModel(e, t) {
      this._renderer.render(e.modelObject, t.cameraObject);
    }

    renderScene(e) {
      const t = e.activeCamera;
      t && this.renderModel(e, t);
    }

    _updated() {
      this.dispatchEvent({
        type: "update"
      });
    }

    render() {
      var e;
      this._passesNeedsUpdate && this.refreshPasses();

      for (const t of this._passes) t.passObject.enabled && (null === (e = t.update) || void 0 === e || e.call(t));

      this._composer.render(), this._frameCount += 1, this.dirty = !1;
    }

    updateDirty() {
      this.dirty = this.dirty || this._passes.findIndex(e => e.dirty) >= 0;
    }

    reset() {
      this._frameCount = 0, this.dirty = !0;
    }

    resetShadows() {
      this._renderer.shadowMap.needsUpdate = !0;
    }

    refreshPasses() {
      if (!this._passesNeedsUpdate) return;
      this._passesNeedsUpdate = !1;
      const e = [];

      for (const t of this._pipeline) {
        const n = this._passes.find(e => e.passId === t);

        n ? e.push(n.passObject) : console.warn("Unable to find pass: ", t);
      }

      this._composer.passes.forEach(e => this._composer.removePass(e)), e.forEach(e => this._composer.addPass(e)), this._updated();
    }

    dispose() {
      this._renderer.dispose();
    }

    trackTarget(e) {
      this._trackedTargets.push(e);
    }

    removeTrackedTarget(e) {
      const t = this._trackedTargets.indexOf(e);

      t >= 0 && this._trackedTargets.splice(t, 1);
    }

    createTarget({
      sizeMultiplier: e,
      isAntialiased: t = !1,
      encoding: n = i.rnI,
      type: r = i.ywz,
      format: s = i.wk1,
      depthBuffer: o = !0,
      depthTexture: a = !1,
      size: l,
      textureCount: c = 1,
      ...u
    } = {}, p = !0) {
      t = t && this.isWebGL2, void 0 !== e && void 0 !== l && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), l = l || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e = e || 1));
      const h = a ? new i.$YQ(l.width, l.height, i.ywz) : void 0,
            d = this.createTargetCustom(c > 1 ? {
        width: l.width,
        height: l.height,
        count: c
      } : l, {
        encoding: n,
        type: r,
        format: s,
        depthBuffer: o,
        depthTexture: h
      }, c > 1 ? i.kFz : i.dd2);
      return this._processNewTarget(d, e, p), this._setTargetOptions(d, u), d;
    }

    _processNewTarget(e, t, n) {
      return void 0 !== t && (e.sizeMultiplier = t), n && this.trackTarget(e), e;
    }

    disposeTarget(e) {
      if (e) {
        if (e.isTemporary) return this.releaseTempTarget(e);
        this.removeTrackedTarget(e), e.dispose();
      }
    }

    createTargetCustom({
      width: e,
      height: t,
      count: n
    }, r = {}, s) {
      var o;
      const a = this._processNewTarget;
      let l = [e, t];

      if (n && n > 1 && l.push(n), (null == s ? void 0 : s.prototype) === i.oAp.prototype) {
        if (e !== t) throw "Width and height of cube render target must be equal";
        l = [e];
      }

      r = {
        format: i.wk1,
        minFilter: i.wem,
        magFilter: i.wem,
        generateMipmaps: !1,
        type: i.ywz,
        encoding: i.rnI,
        ...r
      };
      const c = [...l, r];
      return new class extends (null !== (o = s) && void 0 !== o ? o : i.dd2) {
        constructor(...e) {
          super(...e), Array.isArray(this.texture) ? this.texture.forEach(e => {
            e.encoding = r.encoding, e.toJSON = () => ({});
          }) : this.texture.toJSON = () => ({});
        }

        clone(e = !0) {
          if (this.isTemporary) throw "Cloning temporary render targets not supported";
          if (Array.isArray(this.texture)) throw "Cloning multiple render targets not supported";
          const t = super.clone();
          return t.texture.isRenderTargetTexture = !0, a(t, this.sizeMultiplier || 1, e);
        }

      }(...c);
    }

    getTempTarget(e = {}) {
      var t;
      const n = Z(e);
      let r;
      return (null === (t = this._tempTargets[n]) || void 0 === t ? void 0 : t.length) && (r = this._tempTargets[n].pop()), r ? this._setTargetOptions(r, e) : (r = this.createTarget(e), this._processNewTempTarget(r, n)), r;
    }

    _processNewTempTarget(e, t) {
      return e.isTemporary = !0, e.targetKey = t, void 0 === this._tempTargets[t] && (this._tempTargets[t] = []), e;
    }

    releaseTempTarget(e) {
      const t = e.targetKey;
      if (!t || !e.isTemporary) throw "Not a temp target";
      this._tempTargets[t].length > this.maxTempPerKey ? e.dispose() : this._tempTargets[t].push(e);
    }

    updateShaderProperties(e) {
      return e.uniforms.frameCount ? e.uniforms.frameCount.value = this.frameCount : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }

    _setTargetOptions(e, t) {
      var n, r, s;
      e.texture.minFilter = null !== (n = t.minFilter) && void 0 !== n ? n : i.wem, e.texture.magFilter = null !== (r = t.magFilter) && void 0 !== r ? r : i.wem, e.texture.generateMipmaps = null !== (s = t.generateMipmaps) && void 0 !== s && s, e.texture.generateMipmaps && e.texture.minFilter === i.wem && (e.texture.minFilter = i.FDw), e.texture.generateMipmaps || e.texture.minFilter !== i.FDw || (e.texture.minFilter = i.wem);
    }

  }

  function Z(e = {}) {
    var t, n;
    return [e.sizeMultiplier, e.isAntialiased, e.encoding, e.type, e.format, e.depthBuffer, e.depthTexture, null === (t = e.size) || void 0 === t ? void 0 : t.width, null === (n = e.size) || void 0 === n ? void 0 : n.height].join(";");
  }

  const J = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];

  function $() {
    const e = 4294967295 * Math.random() | 0,
          t = 4294967295 * Math.random() | 0,
          n = 4294967295 * Math.random() | 0,
          r = 4294967295 * Math.random() | 0;
    return (J[255 & e] + J[e >> 8 & 255] + J[e >> 16 & 255] + J[e >> 24 & 255] + "-" + J[255 & t] + J[t >> 8 & 255] + "-" + J[t >> 16 & 15 | 64] + J[t >> 24 & 255] + "-" + J[63 & n | 128] + J[n >> 8 & 255] + "-" + J[n >> 16 & 255] + J[n >> 24 & 255] + J[255 & r] + J[r >> 8 & 255] + J[r >> 16 & 255] + J[r >> 24 & 255]).toLowerCase();
  }

  function Q(e, t, n) {
    return Math.max(t, Math.min(n, e));
  }

  function ee(e, t, n) {
    return (1 - n) * e + n * t;
  }

  Math.PI, Math.PI;
  const te = 0,
        ne = 1,
        re = 3,
        ie = 4,
        se = 1006,
        oe = "srgb",
        ae = "srgb-linear";

  function le(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
  }

  function ce(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055;
  }

  const ue = {
    [oe]: {
      [ae]: le
    },
    [ae]: {
      [oe]: ce
    }
  },
        pe = {
    legacyMode: !0,

    get workingColorSpace() {
      return ae;
    },

    set workingColorSpace(e) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },

    convert: function (e, t, n) {
      if (this.legacyMode || t === n || !t || !n) return e;

      if (ue[t] && void 0 !== ue[t][n]) {
        const r = ue[t][n];
        return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e;
      }

      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (e, t) {
      return this.convert(e, this.workingColorSpace, t);
    },
    toWorkingColorSpace: function (e, t) {
      return this.convert(e, t, this.workingColorSpace);
    }
  },
        he = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
        de = {
    r: 0,
    g: 0,
    b: 0
  },
        fe = {
    h: 0,
    s: 0,
    l: 0
  },
        _e = {
    h: 0,
    s: 0,
    l: 0
  };

  function me(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e;
  }

  function ge(e, t) {
    return t.r = e.r, t.g = e.g, t.b = e.b, t;
  }

  class ve {
    constructor(e, t, n) {
      return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n);
    }

    set(e) {
      return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this;
    }

    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }

    setHex(e, t = "srgb") {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, pe.toWorkingColorSpace(this, t), this;
    }

    setRGB(e, t, n, r = "srgb-linear") {
      return this.r = e, this.g = t, this.b = n, pe.toWorkingColorSpace(this, r), this;
    }

    setHSL(e, t, n, r = "srgb-linear") {
      if (e = function (e, t) {
        return (e % t + t) % t;
      }(e, 1), t = Q(t, 0, 1), n = Q(n, 0, 1), 0 === t) this.r = this.g = this.b = n;else {
        const r = n <= .5 ? n * (1 + t) : n + t - n * t,
              i = 2 * n - r;
        this.r = me(i, r, e + 1 / 3), this.g = me(i, r, e), this.b = me(i, r, e - 1 / 3);
      }
      return pe.toWorkingColorSpace(this, r), this;
    }

    setStyle(e, t = "srgb") {
      function n(t) {
        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }

      let r;

      if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
        let e;
        const i = r[1],
              s = r[2];

        switch (i) {
          case "rgb":
          case "rgba":
            if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, pe.toWorkingColorSpace(this, t), n(e[4]), this;
            if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, pe.toWorkingColorSpace(this, t), n(e[4]), this;
            break;

          case "hsl":
          case "hsla":
            if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
              const r = parseFloat(e[1]) / 360,
                    i = parseInt(e[2], 10) / 100,
                    s = parseInt(e[3], 10) / 100;
              return n(e[4]), this.setHSL(r, i, s, t);
            }

        }
      } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const e = r[1],
              n = e.length;
        if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, pe.toWorkingColorSpace(this, t), this;
        if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, pe.toWorkingColorSpace(this, t), this;
      }

      return e && e.length > 0 ? this.setColorName(e, t) : this;
    }

    setColorName(e, t = "srgb") {
      const n = he[e.toLowerCase()];
      return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }

    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }

    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }

    copySRGBToLinear(e) {
      return this.r = le(e.r), this.g = le(e.g), this.b = le(e.b), this;
    }

    copyLinearToSRGB(e) {
      return this.r = ce(e.r), this.g = ce(e.g), this.b = ce(e.b), this;
    }

    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }

    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }

    getHex(e = "srgb") {
      return pe.fromWorkingColorSpace(ge(this, de), e), Q(255 * de.r, 0, 255) << 16 ^ Q(255 * de.g, 0, 255) << 8 ^ Q(255 * de.b, 0, 255) << 0;
    }

    getHexString(e = "srgb") {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }

    getHSL(e, t = "srgb-linear") {
      pe.fromWorkingColorSpace(ge(this, de), t);
      const n = de.r,
            r = de.g,
            i = de.b,
            s = Math.max(n, r, i),
            o = Math.min(n, r, i);
      let a, l;
      const c = (o + s) / 2;
      if (o === s) a = 0, l = 0;else {
        const e = s - o;

        switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
          case n:
            a = (r - i) / e + (r < i ? 6 : 0);
            break;

          case r:
            a = (i - n) / e + 2;
            break;

          case i:
            a = (n - r) / e + 4;
        }

        a /= 6;
      }
      return e.h = a, e.s = l, e.l = c, e;
    }

    getRGB(e, t = "srgb-linear") {
      return pe.fromWorkingColorSpace(ge(this, de), t), e.r = de.r, e.g = de.g, e.b = de.b, e;
    }

    getStyle(e = "srgb") {
      return pe.fromWorkingColorSpace(ge(this, de), e), e !== oe ? `color(${e} ${de.r} ${de.g} ${de.b})` : `rgb(${255 * de.r | 0},${255 * de.g | 0},${255 * de.b | 0})`;
    }

    offsetHSL(e, t, n) {
      return this.getHSL(fe), fe.h += e, fe.s += t, fe.l += n, this.setHSL(fe.h, fe.s, fe.l), this;
    }

    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }

    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }

    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }

    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }

    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }

    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }

    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }

    lerpColors(e, t, n) {
      return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
    }

    lerpHSL(e, t) {
      this.getHSL(fe), e.getHSL(_e);
      const n = ee(fe.h, _e.h, t),
            r = ee(fe.s, _e.s, t),
            i = ee(fe.l, _e.l, t);
      return this.setHSL(n, r, i), this;
    }

    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }

    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }

    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }

    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }

    toJSON() {
      return this.getHex();
    }

    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }

  }

  ve.NAMES = he;
  const be = new Map();

  function xe(e) {
    return (t, n) => {
      const r = t.constructor;
      if (r === Object) throw new Error("All properties in an object are serialized by default");
      be.has(r) || be.set(r, []), be.get(r).push([e || n, n]);
    };
  }

  const ye = {
    obj: (e, t) => Object.fromEntries(Object.entries(e).map(([e, n]) => [e, Me(n, !1, t)])),
    vec4: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      w: e.w,
      isVector4: !0
    }),
    vec3: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      isVector3: !0
    }),
    vec2: e => ({
      x: e.x,
      y: e.y,
      isVector2: !0
    }),
    color: e => ({
      r: e.r,
      g: e.g,
      b: e.b,
      isColor: !0
    }),
    quat: e => ({
      x: e.x,
      y: e.y,
      z: e.z,
      w: e.w,
      isQuaternion: !0
    }),
    texture: (e, t) => {
      if (!(null == e ? void 0 : e.isTexture)) throw new Error("Expected a texture");
      if (e.isRenderTargetTexture) return;
      if (null == t ? void 0 : t.textures[e.uuid]) return {
        uuid: e.uuid,
        resource: "textures"
      };
      const n = e.source.data;
      e.userData.rootPath && (e.source.data = null);
      let r = e.toJSON(t);
      return e.userData.rootPath && (delete t.images[e.source.uuid], e.source.data = n), (null == t ? void 0 : t.textures) && (t.textures[r.uuid] || (t.textures[r.uuid] = r), r = {
        uuid: r.uuid,
        resource: "textures"
      }), r;
    },
    material: (e, t) => {
      var n;
      if (!(null == e ? void 0 : e.isMaterial)) throw new Error("Expected a material");
      if (null == t ? void 0 : t.materials[e.uuid]) return {
        uuid: e.uuid,
        resource: "materials"
      };
      e.userData.rootPath && console.error("TODO: handle material with root path");
      const r = null != t ? t : {
        textures: {},
        images: {}
      },
            i = {},
            s = {};

      for (const [t, o] of Object.entries(e)) if ((null === (n = o) || void 0 === n ? void 0 : n.isTexture) && !t.startsWith("_")) {
        const n = ye.texture(o, r);
        i[t] = n, s[t] = o, e[t] = n ? {
          isTexture: !0,
          toJSON: () => n
        } : null;
      }

      let o = e.toJSON(t);

      for (const [t, n] of Object.entries(s)) e[t] = n, delete s[t];

      if (t) {
        for (const [e, t] of Object.entries(i)) t && (o[e] = t);

        (null == t ? void 0 : t.materials) && (t.materials[o.uuid] || (t.materials[o.uuid] = o), o = {
          uuid: o.uuid,
          resource: "materials"
        });
      } else {
        for (const [e, t] of Object.entries(i)) o[e] = t.uuid;

        o.textures = Object.values(r.textures), o.images = Object.values(r.images);
      }

      return o;
    }
  },
        we = e => (t, n) => {
    var r, i;
    return null !== (i = null === (r = null == n ? void 0 : n.copy) || void 0 === r ? void 0 : r.call(n, t)) && void 0 !== i ? i : new e().copy(t);
  },
        Se = {
    obj: (e, t, n) => Object.assign(t, Object.fromEntries(Object.entries(e).map(([e, r]) => [e, Te(r, null == t ? void 0 : t[e], !1, n)]))),
    vec4: we(i.Ltg),
    vec3: we(i.Pa4),
    vec2: we(k),
    color: we(ve),
    quat: we(i._fP)
  };

  function Me(e, t, n) {
    var r, i;
    if ("function" == typeof e) return;
    if (Array.isArray(e)) return e.map(e => Me(e, !1, n));

    if ("object" != typeof e) {
      if ("number" == typeof e) {
        if (e === 1 / 0) return "Infinity";
        if (e === -1 / 0) return "-Infinity";
        if (isNaN(e)) return "NaN";
      }

      return e;
    }

    if (!e) return e;
    let s = null !== (r = e.constructor) && void 0 !== r ? r : Object;
    if (s === Object) return ye.obj(e, n);
    if (e.isVector2) return ye.vec2(e);
    if (e.isVector3) return ye.vec3(e);
    if (e.isVector4) return ye.vec4(e);
    if (e.isColor) return ye.color(e);
    if (e.isQuaternion) return ye.quat(e);
    if (e.isTexture) return ye.texture(e, n);
    if (e.isMaterial) return ye.material(e, n);
    if (!t && "function" == typeof e.toJSON) return e.toJSON(n);
    const o = {};

    for (; s && s !== Object;) null === (i = be.get(s)) || void 0 === i || i.forEach(([t, r]) => {
      const i = e[r];
      o[t] = Me(i, !1, n);
    }), s = Object.getPrototypeOf(s);

    return e.serializableClassId && (o.serializableClassId = e.serializableClassId), o;
  }

  function Te(e, t, n, r) {
    var i, s, o;
    let a = t;
    if (void 0 === e) return a;
    if ("number" == typeof t) return "Infinity" === e ? 1 / 0 : "-Infinity" === e ? -1 / 0 : "NaN" === e ? NaN : e;

    if (Array.isArray(e)) {
      const t = e.length;
      Array.isArray(a) || (a = []);

      for (let n = 0; n < t; n++) {
        const t = e[n],
              i = a.length > n ? Te(t, a[n], !1, r) : Te(t, void 0, !1, r);
        a.length <= n ? a.push(i) : a[n] = i;
      }

      return a;
    }

    let l = !1;
    if (e && e.resource && "string" == typeof e.resource && (e = null === (i = r[e.resource]) || void 0 === i ? void 0 : i[e.uuid], l = !0), !a && e) if (e.serializableClassId) {
      const t = Ee.get(e.serializableClassId);
      t && (a = new t());
    } else "object" != typeof e || e.constructor && e.constructor !== Object || (a = {});
    if ("function" == typeof a) return console.error("cannot deserialize over function", a, e), a;

    if (e && "object" == typeof e) {
      if (e.isVector2) return Se.vec2(e, a);
      if (e.isVector3) return Se.vec3(e, a);
      if (e.isVector4) return Se.vec4(e, a);
      if (e.isColor) return Se.color(e, a);
      if (e.isQuaternion) return Se.quat(e, a);
    }

    if (null == e || null == a || "object" != typeof a || a.isTexture) return l && (e ? e.__useCount = e.__useCount ? e.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e;
    let c = null !== (s = a.constructor) && void 0 !== s ? s : Object;
    if (c === Object) return Se.obj(e, a, r);
    if (!n && "function" == typeof a.fromJSON) return a.isMaterial && Object.entries(e).forEach(([t, n]) => {
      var i;
      if (!n || !n.resource || "string" != typeof n.resource) return;
      const s = null === (i = r[n.resource]) || void 0 === i ? void 0 : i[n.uuid];
      e[t] = s || null;
    }), a.fromJSON(e, r), a;

    for (; c && c !== Object;) null === (o = be.get(c)) || void 0 === o || o.forEach(([t, n]) => {
      const i = a[n],
            s = Te(e[t], i, !1, r);
      s !== i && g(a, n, s, !0);
    }), c = Object.getPrototypeOf(c);

    return a;
  }

  const Ee = new Map();

  function Ae(e) {
    return t => (t = class extends t {
      constructor() {
        super(...arguments), this.serializableClassId = e;
      }

    }, Ee.set(e, t), t);
  }

  const Ce = {
    type: "change"
  },
        Re = {
    type: "start"
  },
        ke = {
    type: "end"
  };

  class Pe extends i.pBf {
    constructor(e, t) {
      super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new i.Pa4(), this.minDistance = .01, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown"
      }, this.mouseButtons = {
        LEFT: i.RsA.ROTATE,
        MIDDLE: i.RsA.DOLLY,
        RIGHT: i.RsA.PAN
      }, this.touches = {
        ONE: i.QmN.ROTATE,
        TWO: i.QmN.DOLLY_PAN
      }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
        return a.phi;
      }, this.getAzimuthalAngle = function () {
        return a.theta;
      }, this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function (e) {
        e.addEventListener("keydown", H), this._domElementKeyEvents = e;
      }, this.saveState = function () {
        n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
      }, this.reset = function () {
        n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Ce), n.update(), s = r.NONE;
      }, this.update = function () {
        const t = new i.Pa4(),
              h = new i._fP().setFromUnitVectors(e.up, new i.Pa4(0, 1, 0)),
              d = h.clone().invert(),
              f = new i.Pa4(),
              _ = new i._fP(),
              m = 2 * Math.PI;

        return function () {
          const e = n.object.position;
          t.copy(e).sub(n.target), t.applyQuaternion(h), a.setFromVector3(t), n.autoRotate && s === r.NONE && M(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
          let i = n.minAzimuthAngle,
              g = n.maxAzimuthAngle;
          isFinite(i) && isFinite(g) && (i < -Math.PI ? i += m : i > Math.PI && (i -= m), g < -Math.PI ? g += m : g > Math.PI && (g -= m), a.theta = i <= g ? Math.max(i, Math.min(g, a.theta)) : a.theta > (i + g) / 2 ? Math.max(i, a.theta) : Math.min(g, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), n.enableDamping && (a.radius *= 1 + l.radius * n.dampingFactor), a.radius *= c, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), t.setFromSpherical(a), t.applyQuaternion(d), e.copy(n.target).add(t), n.object.lookAt(n.target);
          let v = !1;
          return !0 === n.enableDamping && Math.abs(l.theta) + Math.abs(l.phi) + Math.abs(l.radius) + u.length() > .001 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, l.radius *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor), v = !0) : (l.set(0, 0, 0), u.set(0, 0, 0)), c = 1, !!(p || v || f.distanceToSquared(n.object.position) > o || 8 * (1 - _.dot(n.object.quaternion)) > o) && (n.dispatchEvent(Ce), f.copy(n.object.position), _.copy(n.object.quaternion), p = !1, !0);
        };
      }(), this.stopDamping = function () {
        l.set(0, 0, 0), u.set(0, 0, 0);
      }, this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", B), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", G), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", H);
      };
      const n = this,
            r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let s = r.NONE;
      const o = 1e-6,
            a = new i.$V(),
            l = new i.$V();
      let c = 1;
      const u = new i.Pa4();
      let p = !1;

      const h = new i.FM8(),
            d = new i.FM8(),
            f = new i.FM8(),
            _ = new i.FM8(),
            m = new i.FM8(),
            g = new i.FM8(),
            v = new i.FM8(),
            b = new i.FM8(),
            x = new i.FM8(),
            y = [],
            w = {};

      function S() {
        return n.enableDamping ? 1 : Math.pow(.95, n.zoomSpeed);
      }

      function M(e) {
        l.theta -= e;
      }

      function T(e) {
        l.phi -= e;
      }

      this.rotateUp = T, this.rotateLeft = M;

      const E = function () {
        const e = new i.Pa4();
        return function (t, n) {
          e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), u.add(e);
        };
      }(),
            A = function () {
        const e = new i.Pa4();
        return function (t, r) {
          !0 === n.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), u.add(e);
        };
      }(),
            C = function () {
        const e = new i.Pa4();
        return function (t, r) {
          const i = n.domElement;

          if (n.object.isPerspectiveCamera) {
            const s = n.object.position;
            e.copy(s).sub(n.target);
            let o = e.length();
            o *= Math.tan(n.object.fov / 2 * Math.PI / 180), E(2 * t * o / i.clientHeight, n.object.matrix), A(2 * r * o / i.clientHeight, n.object.matrix);
          } else n.object.isOrthographicCamera ? (E(t * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), A(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
        };
      }();

      function R(e, t = 0) {
        n.object.isPerspectiveCamera ? (c /= e, l.radius -= t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
      }

      function k(e, t = 0) {
        n.object.isPerspectiveCamera ? (c *= e, l.radius += t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
      }

      function P(e) {
        h.set(e.clientX, e.clientY);
      }

      function D(e) {
        _.set(e.clientX, e.clientY);
      }

      function O() {
        if (1 === y.length) h.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
                t = .5 * (y[0].pageY + y[1].pageY);
          h.set(e, t);
        }
      }

      function L() {
        if (1 === y.length) _.set(y[0].pageX, y[0].pageY);else {
          const e = .5 * (y[0].pageX + y[1].pageX),
                t = .5 * (y[0].pageY + y[1].pageY);

          _.set(e, t);
        }
      }

      function I() {
        const e = y[0].pageX - y[1].pageX,
              t = y[0].pageY - y[1].pageY,
              n = Math.sqrt(e * e + t * t);
        v.set(0, n);
      }

      function F(e) {
        if (1 == y.length) d.set(e.pageX, e.pageY);else {
          const t = q(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
          d.set(n, r);
        }
        f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
        const t = n.domElement;
        M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d);
      }

      function N(e) {
        if (1 === y.length) m.set(e.pageX, e.pageY);else {
          const t = q(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
          m.set(n, r);
        }
        g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m);
      }

      function U(e) {
        const t = q(e),
              r = e.pageX - t.x,
              i = e.pageY - t.y,
              s = Math.sqrt(r * r + i * i);
        b.set(0, s), x.set(0, Math.pow(b.y / v.y, n.zoomSpeed)), R(x.y), v.copy(b);
      }

      function B(e) {
        !1 !== n.enabled && (0 === y.length && (n.domElement.setPointerCapture(e.pointerId), n.domElement.addEventListener("pointermove", j), n.domElement.addEventListener("pointerup", z)), function (e) {
          y.push(e);
        }(e), "touch" === e.pointerType ? function (e) {
          switch (X(e), y.length) {
            case 1:
              switch (n.touches.ONE) {
                case i.QmN.ROTATE:
                  if (!1 === n.enableRotate) return;
                  O(), s = r.TOUCH_ROTATE;
                  break;

                case i.QmN.PAN:
                  if (!1 === n.enablePan) return;
                  L(), s = r.TOUCH_PAN;
                  break;

                default:
                  s = r.NONE;
              }

              break;

            case 2:
              switch (n.touches.TWO) {
                case i.QmN.DOLLY_PAN:
                  if (!1 === n.enableZoom && !1 === n.enablePan) return;
                  n.enableZoom && I(), n.enablePan && L(), s = r.TOUCH_DOLLY_PAN;
                  break;

                case i.QmN.DOLLY_ROTATE:
                  if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                  n.enableZoom && I(), n.enableRotate && O(), s = r.TOUCH_DOLLY_ROTATE;
                  break;

                default:
                  s = r.NONE;
              }

              break;

            default:
              s = r.NONE;
          }

          s !== r.NONE && n.dispatchEvent(Re);
        }(e) : function (e) {
          let t;

          switch (e.button) {
            case 0:
              t = n.mouseButtons.LEFT;
              break;

            case 1:
              t = n.mouseButtons.MIDDLE;
              break;

            case 2:
              t = n.mouseButtons.RIGHT;
              break;

            default:
              t = -1;
          }

          switch (t) {
            case i.RsA.DOLLY:
              if (!1 === n.enableZoom) return;
              !function (e) {
                v.set(e.clientX, e.clientY);
              }(e), s = r.DOLLY;
              break;

            case i.RsA.ROTATE:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === n.enablePan) return;
                D(e), s = r.PAN;
              } else {
                if (!1 === n.enableRotate) return;
                P(e), s = r.ROTATE;
              }

              break;

            case i.RsA.PAN:
              if (e.ctrlKey || e.metaKey || e.shiftKey) {
                if (!1 === n.enableRotate) return;
                P(e), s = r.ROTATE;
              } else {
                if (!1 === n.enablePan) return;
                D(e), s = r.PAN;
              }

              break;

            default:
              s = r.NONE;
          }

          s !== r.NONE && n.dispatchEvent(Re);
        }(e));
      }

      function j(e) {
        !1 !== n.enabled && ("touch" === e.pointerType ? function (e) {
          switch (X(e), s) {
            case r.TOUCH_ROTATE:
              if (!1 === n.enableRotate) return;
              F(e), n.update();
              break;

            case r.TOUCH_PAN:
              if (!1 === n.enablePan) return;
              N(e), n.update();
              break;

            case r.TOUCH_DOLLY_PAN:
              if (!1 === n.enableZoom && !1 === n.enablePan) return;
              !function (e) {
                n.enableZoom && U(e), n.enablePan && N(e);
              }(e), n.update();
              break;

            case r.TOUCH_DOLLY_ROTATE:
              if (!1 === n.enableZoom && !1 === n.enableRotate) return;
              !function (e) {
                n.enableZoom && U(e), n.enableRotate && F(e);
              }(e), n.update();
              break;

            default:
              s = r.NONE;
          }
        }(e) : function (e) {
          switch (s) {
            case r.ROTATE:
              if (!1 === n.enableRotate) return;
              !function (e) {
                d.set(e.clientX, e.clientY), f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                const t = n.domElement;
                M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d), n.update();
              }(e);
              break;

            case r.DOLLY:
              if (!1 === n.enableZoom) return;
              !function (e) {
                b.set(e.clientX, e.clientY), x.subVectors(b, v), x.y > 0 ? R(S()) : x.y < 0 && k(S()), v.copy(b), n.update();
              }(e);
              break;

            case r.PAN:
              if (!1 === n.enablePan) return;
              !function (e) {
                m.set(e.clientX, e.clientY), g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m), n.update();
              }(e);
          }
        }(e));
      }

      function z(e) {
        K(e), 0 === y.length && (n.domElement.releasePointerCapture(e.pointerId), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z)), n.dispatchEvent(ke), s = r.NONE;
      }

      function V(e) {
        K(e);
      }

      function G(e) {
        !1 !== n.enabled && !1 !== n.enableZoom && s === r.NONE && (e.preventDefault(), n.dispatchEvent(Re), function (e) {
          let t = 0;

          switch (e.deltaMode) {
            case 2:
              t += 1 * e.deltaY;
              break;

            case 1:
              t += .4 * e.deltaY;
              break;

            default:
              t += .01 * e.deltaY;
          }

          e.deltaY < 0 ? k(S(), t * n.zoomSpeed) : e.deltaY > 0 && R(S(), -t * n.zoomSpeed), n.update();
        }(e), n.dispatchEvent(ke));
      }

      function H(e) {
        !1 !== n.enabled && !1 !== n.enablePan && function (e) {
          let t = !1;

          switch (e.code) {
            case n.keys.UP:
              C(0, n.keyPanSpeed), t = !0;
              break;

            case n.keys.BOTTOM:
              C(0, -n.keyPanSpeed), t = !0;
              break;

            case n.keys.LEFT:
              C(n.keyPanSpeed, 0), t = !0;
              break;

            case n.keys.RIGHT:
              C(-n.keyPanSpeed, 0), t = !0;
          }

          t && (e.preventDefault(), n.update());
        }(e);
      }

      function W(e) {
        !1 !== n.enabled && e.preventDefault();
      }

      function K(e) {
        delete w[e.pointerId];

        for (let t = 0; t < y.length; t++) if (y[t].pointerId == e.pointerId) return void y.splice(t, 1);
      }

      function X(e) {
        let t = w[e.pointerId];
        void 0 === t && (t = new i.FM8(), w[e.pointerId] = t), t.set(e.pageX, e.pageY);
      }

      function q(e) {
        const t = e.pointerId === y[0].pointerId ? y[1] : y[0];
        return w[t.pointerId];
      }

      this.zoomIn = function (e) {
        R(S(), e * n.zoomSpeed);
      }, this.zoomOut = function (e) {
        k(S(), e * n.zoomSpeed);
      }, n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", B), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", G, {
        passive: !1
      }), this.update();
    }

  }

  var De,
      Oe = new Uint8Array(16);

  function Le() {
    if (!De && !(De = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return De(Oe);
  }

  for (var Ie = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Fe = function (e) {
    return "string" == typeof e && Ie.test(e);
  }, Ne = [], Ue = 0; Ue < 256; ++Ue) Ne.push((Ue + 256).toString(16).substr(1));

  var Be = function (e, t, n) {
    var r = (e = e || {}).random || (e.rng || Le)();

    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
      n = n || 0;

      for (var i = 0; i < 16; ++i) t[n + i] = r[i];

      return t;
    }

    return function (e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n = (Ne[e[t + 0]] + Ne[e[t + 1]] + Ne[e[t + 2]] + Ne[e[t + 3]] + "-" + Ne[e[t + 4]] + Ne[e[t + 5]] + "-" + Ne[e[t + 6]] + Ne[e[t + 7]] + "-" + Ne[e[t + 8]] + Ne[e[t + 9]] + "-" + Ne[e[t + 10]] + Ne[e[t + 11]] + Ne[e[t + 12]] + Ne[e[t + 13]] + Ne[e[t + 14]] + Ne[e[t + 15]]).toLowerCase();
      if (!Fe(n)) throw TypeError("Stringified UUID is invalid");
      return n;
    }(r);
  };

  const je = new Map();

  function ze(e, t) {
    return (n, r) => {
      const i = n.constructor;
      if (i === Object) throw new Error("All properties in an object are serialized by default");
      je.has(i) || je.set(i, []);
      const s = je.get(i);
      if (!(s.findIndex(e => e.propKey === r) < 0)) throw new Error(`Property ${r} already has a uiConfig decorator`);
      s.push({
        params: t || {},
        propKey: r,
        uiType: e
      });
    };
  }

  function Ve(e, t) {
    return ze("checkbox", {
      label: e,
      params: t
    });
  }

  function Ge(e, t) {
    return ze("monitor", {
      label: e,
      params: t
    });
  }

  function He(e, t, n, r) {
    return ze("slider", {
      label: e,
      bounds: t,
      stepSize: n,
      params: r
    });
  }

  function We(e, t, n, r) {
    return ze("vec", {
      label: e,
      bounds: t,
      stepSize: n,
      params: r
    });
  }

  function Ke(e, t, n) {
    return ze("dropdown", {
      label: e,
      children: t,
      params: n
    });
  }

  function Xe(e, t) {
    return ze("button", {
      label: e,
      params: t
    });
  }

  function qe(e, t) {
    return ze("input", {
      label: e,
      params: t
    });
  }

  function Ye(e, t) {
    return ze("color", {
      label: e,
      params: t
    });
  }

  function Ze(e, t) {
    return ze("image", {
      label: e,
      params: t
    });
  }

  function Je(e) {
    let t = null == e ? void 0 : e.constructor;
    if (!e || !t) return [];
    const n = [],
          r = [];

    for (; t && t !== Object;) r.push(t), t = Object.getPrototypeOf(t);

    return r.reverse().forEach(t => {
      var r;
      null === (r = je.get(t)) || void 0 === r || r.forEach(({
        params: t,
        propKey: r,
        uiType: i
      }) => {
        var s;
        let o;

        if (i || (o = null === (s = e[r]) || void 0 === s ? void 0 : s.uiConfig), o || (o = {
          property: [e, r],
          type: i || "input"
        }), t) {
          const n = "function" == typeof t.params ? t.params(e) : t.params || {};
          delete t.params, Object.assign(o, { ...t,
            ...n
          });
        }

        n.push(o);
      });
    }), n;
  }

  function $e(e, t, n = {}) {
    return {
      type: "folder",
      label: e,
      children: Je(t),
      uuid: Be(),
      ...n
    };
  }

  function Qe(e, t) {
    return n => class extends n {
      constructor() {
        super(...arguments), this.uiConfig = $e(e, this, t || {});
      }

    };
  }

  var et = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let tt = class extends Pe {
    constructor() {
      super(...arguments), this.type = "OrbitControls", this.enableDamping = !0, this.dampingFactor = .08, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableZoom = !0, this.zoomSpeed = .15, this.maxZoomSpeed = .2, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.panSpeed = 1, this.minDistance = .01, this.maxDistance = 1e3, this.minZoom = .01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.screenSpacePanning = !0, this.keyPanSpeed = 7;
    }

    zoomIn(e) {
      super.zoomIn(e);
    }

    zoomOut(e) {
      super.zoomOut(e);
    }

  };
  et([xe()], tt.prototype, "type", void 0), et([Ve(), xe()], tt.prototype, "enableDamping", void 0), et([qe(), xe()], tt.prototype, "dampingFactor", void 0), et([Ve(), xe()], tt.prototype, "autoRotate", void 0), et([qe(), xe()], tt.prototype, "autoRotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableZoom", void 0), et([qe(), xe()], tt.prototype, "zoomSpeed", void 0), et([qe(), xe()], tt.prototype, "maxZoomSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableRotate", void 0), et([qe(), xe()], tt.prototype, "rotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enablePan", void 0), et([qe(), xe()], tt.prototype, "panSpeed", void 0), et([qe(), xe()], tt.prototype, "minDistance", void 0), et([qe(), xe()], tt.prototype, "maxDistance", void 0), et([qe(), xe()], tt.prototype, "minZoom", void 0), et([qe(), xe()], tt.prototype, "maxZoom", void 0), et([qe(), xe()], tt.prototype, "minPolarAngle", void 0), et([qe(), xe()], tt.prototype, "maxPolarAngle", void 0), et([qe(), xe()], tt.prototype, "minAzimuthAngle", void 0), et([qe(), xe()], tt.prototype, "maxAzimuthAngle", void 0), et([xe()], tt.prototype, "screenSpacePanning", void 0), et([xe()], tt.prototype, "keyPanSpeed", void 0), tt = et([Qe("Orbit Controls")], tt);

  class nt extends r {
    constructor(e, t, n) {
      super(), this._controlsMode = "", this._isActiveCamera = !1, this._interactionsEnabled = !0, this.autoLookAtTarget = !0, this.near = .01, this.far = 50, this._options = {
        type: "PerspectiveCamera",
        aspect: "auto",
        focus: 10,
        fov: 25,
        zoom: 1,
        frustumSize: 1,
        top: 1,
        bottom: -1,
        left: -1,
        right: 1,
        controlsMode: "orbit",
        controlsEnabled: !0
      }, this._position = new i.Pa4(0, 0, 10), this._target = new i.Pa4(0, 0, 0), this.uiConfig = {
        type: "folder",
        label: "Camera",
        limitedUi: !0,
        children: [{
          type: "input",
          property: [this._options, "fov"],
          onChange: () => {
            this.refreshCameraOptions();
          },
          limitedUi: !0
        }, {
          type: "button",
          label: "Zoom in",
          value: () => {
            var e;
            null === (e = this._controls) || void 0 === e || e.zoomIn(1);
          }
        }, {
          type: "button",
          label: "Zoom out",
          value: () => {
            var e;
            null === (e = this._controls) || void 0 === e || e.zoomOut(1);
          }
        }, () => {
          var e;
          return null === (e = this._controls) || void 0 === e ? void 0 : e.uiConfig;
        }]
      }, this.assetType = "model", this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != n ? n : document.body, this._camera = null != e ? e : "OrthographicCamera" === (null == t ? void 0 : t.type) ? new i.iKG(-1, 1, 1, -1) : new i.cPb(), this._camera.userData.iCamera = this;
      const r = null != t ? t : this._options,
            s = e;
      e && (s.isPerspectiveCamera ? (r.fov = s.fov, r.focus = s.focus, r.aspect = s.aspect <= 0 || s.userData.autoAspect ? "auto" : s.aspect, r.zoom = s.zoom) : s.isOrthographicCamera && (r.left = s.left, r.right = s.right, r.top = s.top, r.bottom = s.bottom, r.zoom = s.zoom), r.near = s.near, r.far = s.far, this._position.copy(e.position), this.refreshTarget()), this.positionUpdated(!1), e || this.targetUpdated(!1), this.setCameraOptions(r), n && (n.style.touchAction = "none");
    }

    get controls() {
      return this._controls;
    }

    get target() {
      return this._target;
    }

    set target(e) {
      const t = this._target.sub(e).length() > .01;
      this._target.copy(e), t && this.targetUpdated();
    }

    get position() {
      return this._position;
    }

    set position(e) {
      const t = this._position.sub(e).length() > .01;
      this._position.copy(e), t && this.positionUpdated();
    }

    getCameraOptions() {
      return { ...this._options
      };
    }

    setCameraOptions(e, t = !0) {
      const n = { ...e
      };
      Object.keys(n).forEach(e => "frustumSize" !== e && void 0 === n[e] && delete n[e]), Object.assign(this._options, n), this._refreshCameraOptions(!1), this.refreshCameraControls(!1), t && this.setDirty();
    }

    _refreshCameraOptions(e = !0) {
      let t = this._camera,
          n = this._options.aspect;

      if ("auto" === n && (n = this._container.clientWidth / this._container.clientHeight), "PerspectiveCamera" === this._options.type && (t = t, t.fov = this._options.fov, t.focus = this._options.focus, t.aspect = n), "OrthographicCamera" === this._options.type) {
        t = t;
        const e = this._options.frustumSize;
        void 0 !== e ? (t.top = e / 2, t.bottom = -e / 2, t.left = n * e / 2, t.right = -n * e / 2) : (t.top = this._options.top, t.bottom = this._options.bottom, t.left = this._options.left, t.right = this._options.right);
      }

      t.zoom = this._options.zoom, this._nearFarChanged(), e && this.setDirty();
    }

    get interactionsEnabled() {
      return this._interactionsEnabled && this._isActiveCamera && this._options.controlsEnabled;
    }

    set interactionsEnabled(e) {
      this._interactionsEnabled !== e && (this._interactionsEnabled = e, this.refreshCameraControls(!0));
    }

    _nearFarChanged() {
      this._camera && (this._camera.near = this.near, this._camera.far = this.far, this._camera.updateProjectionMatrix());
    }

    refreshAspect(e = !0) {
      "auto" === this._options.aspect && this._refreshCameraOptions(e);
    }

    refreshTarget() {
      var e;
      (null === (e = this._controls) || void 0 === e ? void 0 : e.enabled) ? this._target.copy(this._controls.target) : this._target.set(0, 0, -1).applyQuaternion(this._camera.getWorldQuaternion(new i._fP()));
    }

    _initCameraControls() {
      const e = this._options.controlsMode;

      switch (e) {
        case "orbit":
          this._controls = new tt(this._camera, this._container), this._controls.screenSpacePanning = !0, this._controls.addEventListener("change", this.setDirty);
      }

      this._controlsMode = e;
    }

    _disposeCameraControls() {
      var e;

      switch (this._controlsMode) {
        case "orbit":
          null === (e = this._controls) || void 0 === e || e.dispose();
      }

      this._controlsMode = "", this._controls = void 0;
    }

    refreshCameraControls(e = !0) {
      if (this._options.controlsEnabled) {
        const e = this._options.controlsMode;
        this._controls ? this._controlsMode !== e && (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e;
      }

      if (this._controls) {
        const e = this.interactionsEnabled;
        this._controls.enabled = e, e && this._camera.up.copy(i.Tme.DefaultUp);
      }

      e && this.setDirty();
    }

    setDirty() {
      this._position.copy(this._camera.position), this._controls && this._controls.enabled && this._target.copy(this._controls.target), this.dispatchEvent({
        type: "update"
      });
    }

    activateMain() {
      this._isActiveCamera || (this._isActiveCamera = !0, this.cameraObject.userData.__lastScale = this.cameraObject.scale.clone(), this.cameraObject.scale.divide(this.cameraObject.getWorldScale(new i.Pa4())), this.refreshCameraControls(!0), this.refreshAspect());
    }

    deactivateMain() {
      this._isActiveCamera && (this._isActiveCamera = !1, this.cameraObject.userData.__lastScale && (this.cameraObject.scale.copy(this.cameraObject.userData.__lastScale), delete this.cameraObject.userData.__lastScale), this.refreshCameraControls(!0));
    }

    get cameraObject() {
      return this._camera;
    }

    get modelObject() {
      return this._camera;
    }

    dispose() {}

    targetUpdated(e = !0) {
      var t;
      const n = this.target;
      null === (t = this._controls) || void 0 === t || t.target.set(n.x, n.y, n.z), this._controls && this._controls.enabled ? (this._controls.update(), e && this.setDirty()) : this._camera && (this.autoLookAtTarget && this._camera.lookAt(n), e && this.setDirty());
    }

    positionUpdated(e = !0) {
      const t = this.position;
      this._camera.position.set(t.x, t.y, t.z), e && this.setDirty();
    }

    updateShaderProperties(e) {
      var t;
      return (null === (t = e.uniforms.cameraPositionWorld) || void 0 === t ? void 0 : t.value) && this._camera.getWorldPosition(e.uniforms.cameraPositionWorld.value), e.uniforms.cameraNearFar ? e.uniforms.cameraNearFar.value.set(this._camera.near, this._camera.far) : console.warn("BaseRenderer: no uniform: cameraNearFar"), e.uniforms.projection && (e.uniforms.projection.value = this._camera.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.type ? "1" : "0", e.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.type ? "1" : "0", this;
    }

    toJSON(e) {
      return Object.assign({}, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return Te(e, this, !0, t), this.positionUpdated(!1), this.targetUpdated(!1), this.refreshCameraOptions(), this;
    }

    refreshCameraOptions(e = !0) {
      this.setCameraOptions(this._options, e);
    }

  }

  et([xe("camControls")], nt.prototype, "_controls", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "near", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "far", void 0), et([xe("camOptions")], nt.prototype, "_options", void 0), et([xe("position")], nt.prototype, "_position", void 0), et([xe("target")], nt.prototype, "_target", void 0);

  class rt {
    constructor() {
      this._processors = new Map();
    }

    add(e, t) {
      var n;
      this._processors.has(e) || this._processors.set(e, []), null === (n = this._processors.get(e)) || void 0 === n || n.push(t);
    }

    remove(e, t) {
      const n = this._processors.get(e),
            r = (null == n ? void 0 : n.indexOf(t)) || (null == n ? void 0 : n.findIndex(e => e.process && e.process === t.process || e.processAsync && e.processAsync === t.processAsync));

      !n || !r || r < 0 || n.splice(r, 1);
    }

    get(e) {
      var t;
      return null !== (t = this._processors.get(e)) && void 0 !== t ? t : [];
    }

    async process(e, t, n) {
      var r, i, s, o;
      const a = this.get(e),
            l = t.assetType;

      for (const e of a) e.forAssetType === l && (t = null !== (i = null === (r = e.process) || void 0 === r ? void 0 : r.call(e, t, n)) && void 0 !== i ? i : t, t = null !== (o = await (null === (s = e.processAsync) || void 0 === s ? void 0 : s.call(e, t, n))) && void 0 !== o ? o : t);

      return t;
    }

    dispose() {
      this._processors.clear();
    }

  }

  class it {
    constructor(e, {
      pseudoCenter: t = !1,
      autoScale: n = !1,
      autoScaleRadius: r = 2,
      license: s = "",
      ...o
    } = {}) {
      if (this.assetType = "model", this._modelObject = new i.Tme(), this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), n ? e && !e.userData.autoScaled && X(e, e.userData.autoScaleRadius || r) : e.userData.autoScaled = !0, e && t && !e.userData.pseudoCentered) {
        const t = new P().expandByObject(e, !0, !0).getCenter(new i.Pa4());
        this._modelObject.position.copy(t).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e), this._modelObject.name = e.name + "-centered", this._modelObject.userData.pseudoCentered = !0;
      } else t || (e.userData.pseudoCentered = !0), this._modelObject = e;

      this._modelObject.userData.iModel = this, this._modelObject.userData.setDirty = this.setDirty, this._modelObject.userData.updateBounds = this.updateBounds, this._modelObject.addEventListener("added", this.updateBounds), this._modelObject.addEventListener("removed", this.updateBounds), this.license = s, this.updateBounds();
    }

    get modelObject() {
      return this._modelObject;
    }

    get license() {
      return this._modelObject.userData.license;
    }

    set license(e) {
      this._modelObject.userData.license = e;
    }

    addEventListener(e, t) {
      this._modelObject.addEventListener(e, t);
    }

    dispatchEvent(e) {
      this._modelObject.dispatchEvent(e);
    }

    hasEventListener(e, t) {
      return this._modelObject.hasEventListener(e, t);
    }

    removeEventListener(e, t) {
      this._modelObject.removeEventListener(e, t);
    }

    dispose() {
      const e = this._modelObject.userData.dispose;
      e && "function" == typeof e ? e() : this._modelObject.removeFromParent();
    }

    setDirty(e) {
      var t, n;
      this.dispatchEvent({ ...e,
        type: "objectUpdate"
      }), null === (n = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    updateBounds() {
      this.setDirty();
    }

    get uiConfig() {
      return this._uiConfig || (this._uiConfig = st(this._modelObject, !1)), this._uiConfig;
    }

    clone() {
      return new it(this._modelObject.clone(), {
        pseudoCenter: !1,
        autoScale: !1
      });
    }

  }

  function st(e, t) {
    const n = {
      type: "folder",
      label: e.name || "unnamed",
      expanded: !0,
      limitedUi: !0,
      children: [{
        type: "checkbox",
        label: "Visible",
        property: [e, "visible"],
        limitedUi: !0
      }, {
        type: "button",
        label: "Pick/Focus",
        value: () => {
          e.dispatchEvent({
            type: "select",
            ui: !0,
            value: e
          });
        }
      }, {
        type: "button",
        label: "Pick Parent",
        hidden: () => !e.parent,
        value: () => {
          const t = e.parent;
          t && t.dispatchEvent({
            type: "select",
            ui: !0,
            value: t
          });
        }
      }, {
        type: "input",
        label: "Name",
        property: [e, "name"]
      }, {
        type: "checkbox",
        label: "Casts Shadow",
        hidden: () => !e.isMesh,
        property: [e, "castShadow"]
      }, {
        type: "checkbox",
        label: "Receive Shadow",
        hidden: () => !e.isMesh,
        property: [e, "receiveShadow"]
      }, {
        type: "vec3",
        label: "Position",
        property: [e, "position"],
        limitedUi: !0
      }, {
        type: "vec3",
        label: "Rotation",
        property: [e, "rotation"],
        limitedUi: !0
      }, {
        type: "vec3",
        label: "Scale",
        property: [e, "scale"]
      }, {
        type: "button",
        label: "Auto Scale",
        value: () => {
          const t = parseFloat(prompt("Auto Scale Radius", e.userData.autoScaleRadius || "2") || "0");
          Math.abs(t) > 1e-4 && X(e, t);
        }
      }, void 0 !== e.userData.license ? {
        type: "input",
        label: "License/Credits",
        property: [e.userData, "license"],
        limitedUi: !0
      } : {}]
    },
          r = e;

    if ((null == r ? void 0 : r.isMesh) && !1 !== t) {
      const e = [() => {
        var e;
        return null === (e = r.geometry) || void 0 === e ? void 0 : e.uiConfig;
      }, () => {
        var e;
        return Array.isArray(r.material) ? r.material.length < 1 ? void 0 : {
          label: "Materials",
          type: "folder",
          children: r.material.map(e => null == e ? void 0 : e.uiConfig).filter(e => e)
        } : null === (e = r.material) || void 0 === e ? void 0 : e.uiConfig;
      }];
      n.children.push(...e);
    }

    return n;
  }

  function ot(e) {
    return {
      label: "Geometry",
      type: "folder",
      children: [{
        type: "input",
        property: [e, "uuid"],
        disabled: !0
      }, {
        type: "button",
        label: "Create uv2 from uv",
        value: () => {
          e.hasAttribute("uv2") && !confirm("uv2 already exists, replace with uv data?") || e.setAttribute("uv2", e.getAttribute("uv"));
        }
      }, {
        type: "input",
        label: "Mesh count",

        get value() {
          var t, n, r;
          return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0;
        },

        set value(e) {},

        disabled: !0
      }]
    };
  }

  function at(e, t) {
    const n = e.modelObject;
    return n.traverse(r => {
      lt(r, r !== n ? e : void 0, t);
    }), e;
  }

  function lt(e, t, n) {
    var r;
    if (!e) return void console.warn("setupIModel: object is undefined");
    if (e.userData || (e.userData = {}), e.userData.__iModelSetup && e.modelObject) return e;
    e.userData.__iModelSetup = !0;
    const i = [];

    if (i.push(() => {
      e.parent && e.removeFromParent();
    }), e.isLight && !e.assetType ? (e.assetType = "light", e.lightObject = e) : e.isCamera ? (e.assetType = "camera", e.cameraObject = e) : e.assetType || (e.assetType = "model"), e.modelObject || (e.modelObject = e), !e.userData.setDirty) {
      e.userData.setDirty = t => {
        var n, r;
        e.dispatchEvent({ ...t,
          type: "objectUpdate"
        }), null === (r = null === (n = e.uiConfig) || void 0 === n ? void 0 : n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !0);
      };

      const t = t => {
        var n, r, i, s;
        const o = null !== (r = null === (n = e.parent) || void 0 === n ? void 0 : n.userData.parentRoot) && void 0 !== r ? r : e.parent;
        o !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = o;
        }), null === (s = (i = e.userData).setDirty) || void 0 === s || s.call(i);
      },
            n = () => {
        var t, n;
        void 0 !== e.userData.parentRoot && e.traverse(e => {
          e.userData.parentRoot = void 0;
        }), null === (n = (t = e.userData).setDirty) || void 0 === n || n.call(t);
      };

      e.addEventListener("added", t), e.addEventListener("removed", n), i.push(() => {
        e.removeEventListener("added", t), e.removeEventListener("removed", n);
      });
    }

    e.userData.dispose ? console.warn("onDispose already set, disposing might be buggy.") : e.userData.dispose = () => i.forEach(e => e());
    const s = e;
    s.isMesh && !s.userData.__meshSetup && (s.userData.setMaterial || (s.userData.setMaterial = e => ht(s, e)), s.userData.setGeometry || (s.userData.setGeometry = (e, t = !1) => dt(s, e, t), s.userData.setGeometry(s.geometry, !0)), e.userData.__keepShadowDef || (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0), i.push(() => {
      const e = s.userData.setMaterial(void 0),
            t = s.userData.setGeometry(void 0);

      for (const t of e);

      t && 0 === t.userData.appliedMeshes.size && !1 !== t.userData.disposeOnIdle && t.dispose();
    }), s.userData.__meshSetup = !0), e.uiConfig || "model" !== e.assetType || (e.uiConfig = st(e), i.push(() => {
      e.uiConfig = void 0;
    })), t && (e.userData.parentRoot = t), i.push(() => {
      delete e.userData.parentRoot;
    });

    const o = t => {
      var n;
      const r = null !== (n = e.userData.parentRoot) && void 0 !== n ? n : e.parent;
      (null == r ? void 0 : r.modelObject) && r.dispatchEvent(t);
    };

    e.addEventListener("objectUpdate", o), e.addEventListener("materialUpdate", o), e.addEventListener("select", o), i.push(() => {
      e.removeEventListener("objectUpdate", o), e.removeEventListener("materialUpdate", o), e.removeEventListener("select", o);
    });
    const a = e.clone;
    e.clone = (...t) => {
      const r = e.userData,
            i = {};
      Object.entries(r).forEach(([e, t]) => {
        (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("__") || ut.includes(e)) && (i[e] = t, delete r[e]);
      });
      let s = a.call(e, ...t);
      Object.entries(i).forEach(([e, t]) => {
        r[e] = t, delete i[e];
      });
      const o = e.userData.parentRoot;
      return o && "model" !== o.assetType && console.warn("Cloning an object with a parent that is not an IModel is not supported"), s = lt(s, o, n), s.userData.cloneParent = e.uuid, s;
    }, i.push(() => {
      e.clone = a;
    });
    const l = e.add;
    return e.add = (...t) => (t.forEach(t => lt(t, e.userData.parentRoot || e, n)), l.call(e, ...t)), i.push(() => {
      e.add = l;
    }), e = null !== (r = null == n ? void 0 : n(e)) && void 0 !== r ? r : e, i.push(() => {
      e.modelObject = void 0, e.userData = {};
    }), e;
  }

  const ct = ["appliedMeshes"],
        ut = ["parentRoot", "iCamera"];

  function pt(e, t) {
    if (t) for (const n of Object.keys(t)) ut.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
    return e;
  }

  function ht(e, t) {
    var n, r, i, s;
    const o = (Array.isArray(t) ? t : [t]).map(e => null == e ? void 0 : e.materialObject).filter(e => e);
    if (e.material == o || 1 === o.length && e.material === o[0]) return [];
    e.userData.__materialUpdater || (e.userData.__materialUpdater = () => {
      e.dispatchEvent({
        type: "materialUpdate"
      });
    });
    const a = Array.isArray(e.material) ? [...e.material] : [e.material];

    for (const t of a) t && (t.removeEventListener("materialUpdate", e.userData.__materialUpdater), null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.appliedMeshes) || void 0 === r || r.delete(e));

    const l = [];

    for (const t of o) t.userData.appliedMeshes || (t.userData.appliedMeshes = new Set()), l.push(t), t && (t.addEventListener("materialUpdate", e.userData.__materialUpdater), t.userData.appliedMeshes.add(e));

    return e.material = 1 !== l.length ? l : l[0], e.traverseAncestors(t => {
      t.isRootScene && t.refreshEnvMapIntensity(e);
    }), e.dispatchEvent({
      type: "materialChanged",
      material: t
    }), null === (s = null === (i = e.uiConfig) || void 0 === i ? void 0 : i.uiRefresh) || void 0 === s || s.call(i, "postFrame", !0), a;
  }

  function dt(e, t, n = !1) {
    var r, i, s, o, a, l;
    e.userData.__objectUpdater || (e.userData.__objectUpdater = t => {
      e.dispatchEvent({ ...t,
        type: "objectUpdate"
      });
    });
    let c = e.geometry;
    const u = c;
    return (c !== t || n) && (c && (c.removeEventListener("geometryUpdate", e.userData.__objectUpdater), null === (i = null === (r = c.userData) || void 0 === r ? void 0 : r.appliedMeshes) || void 0 === i || i.delete(e)), c = t, c && !c.userData.appliedMeshes && (c.userData.appliedMeshes = new Set()), e.geometry = c, c && (c.addEventListener("geometryUpdate", e.userData.__objectUpdater), null === (o = null === (s = c.userData) || void 0 === s ? void 0 : s.appliedMeshes) || void 0 === o || o.add(e))), t.uiConfig || (t.uiConfig = ot(e.geometry)), e.dispatchEvent({
      type: "geometryChanged",
      geometry: t
    }), null === (l = null === (a = e.uiConfig) || void 0 === a ? void 0 : a.uiRefresh) || void 0 === l || l.call(a, "postFrame", !0), u === c ? void 0 : u;
  }

  var ft = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class _t extends i.xsS {
    constructor(e) {
      super(), this.isRootScene = !0, this.assetType = "model", this._sceneBounds = new P(), this._sceneBoundingRadius = 0, this._processors = new rt(), this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this._dummyCam = new nt(new i.cPb(), {
        controlsMode: "",
        controlsEnabled: !1
      }), this.environment = null, this.background = null, this.minNearDistance = .2, this.setDirty = this.setDirty.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e, this.modelRoot = lt(new i.ZAu(), void 0), this.modelRoot.userData.rootSceneModelRoot = !0, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, {
        addToRoot: !0,
        autoScale: !1
      }), this.addSceneObject(this.defaultCamera, {
        addToRoot: !0
      }), this.activeCamera = this.defaultCamera, this.boxHelper = new i.GQ(this.getBounds());
    }

    refreshEnvMapIntensity(e) {
      return (null == e ? void 0 : e.isObject3D) || (e = this), (null != e ? e : this).traverse(e => {
        const t = e.material;
        t && void 0 !== t.envMapIntensity && !t.userData.separateEnvMapIntensity && (t.envMapIntensity = this.envMapIntensity, t.needsUpdate = !0);
      }), this.setDirty(), this;
    }

    get activeCamera() {
      return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam;
    }

    set activeCamera(e) {
      const t = this.activeCamera;

      if (e || (e = this.defaultCamera), t !== e) {
        if (t && (t.deactivateMain(), t.removeEventListener("update", this._activeCameraUpdate)), e) {
          e.activateMain(), e.addEventListener("update", this._activeCameraUpdate);

          let t = this._cameras.indexOf(e);

          t < 0 && (this._cameras.push(e), t = this._cameras.length - 1), this._activeCamera = t;
        } else this._activeCamera = -1;

        this.dispatchEvent({
          type: "activeCameraChange"
        }), this.setDirty();
      }
    }

    get modelObject() {
      return this;
    }

    addModel(e, t = {}) {
      return "model" !== e.assetType && console.error("Invalid asset type for ", e, ", adding anyway"), this.addSceneObject(e, t);
    }

    addWidget(e, t = {}) {
      "widget" !== e.assetType && console.warn("Invalid asset type for ", e, ", adding anyway"), this.add(e.modelObject);
    }

    _addModel(e, t = {}) {
      return this._addObject3D(null == e ? void 0 : e.modelObject, t);
    }

    addSceneObject(e, t) {
      if (!e) return e;
      const n = e.assetType;
      let r = !1;

      switch (n) {
        case "model":
          r = e.modelObject.isCamera, r && (t = { ...t,
            autoScale: !1
          }), this._addModel(e, t);
          break;

        case "material":
          break;

        case "texture":
          this.dispatchEvent({
            type: "textureAdded",
            texture: e
          });
          break;

        case "light":
          this._addLight(e, t);

          break;

        default:
          console.warn("Unknown asset imported", e, n);
      }

      return this.dispatchEvent({
        type: "addSceneObject",
        object: e
      }), e;
    }

    _addObject3D(e, {
      autoScale: t = !0,
      autoScaleRadius: n = 2,
      addToRoot: r = !1
    } = {}) {
      const i = e;
      i ? (t && !i.userData.autoScaled && X(i, i.userData.autoScaleRadius || n), i.traverse(e => {
        e.isMesh && !e.userData.__keepShadowDef && (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0);
      }), this.refreshEnvMapIntensity(i), r ? this.modelObject.add(i) : this.modelRoot.add(i), this.setDirty()) : console.error("Invalid Model, cannot add.");
    }

    _onEnvironmentChange() {
      this.dispatchEvent({
        type: "environmentChanged",
        environment: this.getEnvironment()
      }), this._onSceneUpdate();
    }

    add(...e) {
      return super.add(...e), this._onSceneUpdate(), this;
    }

    async setEnvironment(e) {
      if (!e) return this.environment = null, this.dispatchEvent({
        type: "environmentChanged"
      }), void this._onSceneUpdate();
      if ("texture" !== (null == e ? void 0 : e.assetType)) return void console.error("Unknown Environment type", e);
      e.mapping === i.xfE && (e.mapping = i.dSO, e.needsUpdate = !0);
      const t = (e = await this.processors.process("environment", e, {})).textureObject || e;
      this.environment = t, this._onEnvironmentChange();
    }

    getEnvironment() {
      return this.environment;
    }

    async setBackground(e) {
      var t;
      let n;
      if (!e || "texture" === e.assetType || e.isColor || e.isVector4) n = "texture" === (null === (t = e) || void 0 === t ? void 0 : t.assetType) && (e = await this.processors.process("background", e, {})).textureObject || e;else {
        if ("string" != typeof e && "number" != typeof e) return void console.error("Unknown Background type", e);
        n = new i.Ilk(e);
      }
      this.background = n, this._onSceneUpdate({
        geometryChanged: !1
      });
    }

    getBackground() {
      return this.background;
    }

    get processors() {
      return this._processors;
    }

    setDirty(e) {
      return (null == e ? void 0 : e.sceneUpdate) ? this._onSceneUpdate(e) : this.dispatchEvent({
        type: "update"
      }), this;
    }

    _activeCameraUpdate() {
      this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({
        type: "activeCameraUpdate"
      });
    }

    _onSceneUpdate(e = {}) {
      var t, n, r;
      this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(!1, !0), null === (r = null === (n = null === (t = this.boxHelper) || void 0 === t ? void 0 : t.box) || void 0 === n ? void 0 : n.copy) || void 0 === r || r.call(n, this._sceneBounds), this._sceneBoundingRadius = this._sceneBounds.getSize(new i.Pa4()).length() / 2, this.dispatchEvent({ ...e,
        type: "sceneUpdate"
      });
    }

    _onSceneMaterialUpdate() {
      this.dispatchEvent({
        type: "sceneMaterialUpdate"
      });
    }

    dispose() {
      this.clear();
    }

    findObjectsByName(e, t) {
      const n = [];
      return (null != t ? t : this.modelObject).traverse(t => {
        t.name === e && n.push(t);
      }), n;
    }

    addLight(e, t = {}) {
      this.addSceneObject(e, t);
    }

    _addLight(e, {
      setDefaultLayer: t = !0,
      addToRoot: n = !1,
      ...r
    } = {}) {
      var i;
      const s = e.lightObject;
      s && (null === (i = s.children) || void 0 === i || i.length, n ? this.add(s) : this.modelRoot.add(s));
    }

    getBounds(e = !1, t = !0) {
      return new P().expandByObject(this.modelObject, e, t);
    }

    refreshActiveCameraNearFar() {
      const e = this.activeCamera;
      if (!e) return;
      const t = this.getBounds(!1),
            n = e.cameraObject.getWorldPosition(new i.Pa4()).sub(t.getCenter(new i.Pa4())),
            r = 1.5 * t.getSize(new i.Pa4()).length() / 2,
            s = n.length(),
            o = Math.max(this.minNearDistance, s - r),
            a = Math.max(o + 1, s + r);
      e.near = o, e.far = a;
    }

    updateShaderProperties(e) {
      return e.uniforms.sceneBoundingRadius ? e.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this;
    }

    toJSON(e) {
      return Me(this, !0, e);
    }

    fromJSON(e, t) {
      const n = e.environment;
      return void 0 !== n && (this.setEnvironment(Te(n, this.getEnvironment(), !1, t)), delete e.environment), Te(e, this, !0, t), e.environment = n, this;
    }

  }

  function mt() {
    const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return e.style.display = "block", e;
  }

  function gt(e, t) {
    const n = t || "/";
    return new RegExp(n + "{1,}", "g"), e.join(n);
  }

  function vt(e, t) {
    const n = window.URL.createObjectURL(e),
          r = document.createElement("a");
    r.style.display = "none", r.href = n, r.download = t, document.body.appendChild(r), r.click(), setTimeout(() => {
      document.body.removeChild(r), window.URL.revokeObjectURL(n);
    }, 1e3);
  }

  async function bt(e) {
    return new Promise((t, n) => {
      const r = new FileReader();
      r.onload = e => t(r.result), r.onerror = e => n(r.error), r.onabort = e => n(new Error("Read aborted")), r.readAsDataURL(e);
    });
  }

  function xt(e, t) {
    return vt(e, null != t ? t : e.name);
  }

  async function yt(e = !1, t = !1, n) {
    const r = document.createElement("input");
    r.type = "file", r.multiple = e, r.accept = n || "*", r.webkitdirectory = t, r.style.display = "none", document.body.appendChild(r), r.click();
    const i = await new Promise(e => {
      r.onchange = t => {
        e(Array.from(r.files || []));
      };
    });
    return document.body.removeChild(r), i;
  }

  function wt({
    innerHTML: e = "",
    id: t,
    classList: n,
    addToBody: r = !0,
    elementTag: i = "div"
  }) {
    const s = document.createElement(i);
    return t && (s.id = t), s.innerHTML = e, n && s.classList.add(...n), r && document.body.appendChild(s), s;
  }

  async function St(e) {
    return new Promise((t, n) => {
      const r = new Image();
      r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "sync", r.src = e;
    });
  }

  function Mt(e) {
    const t = document.createElement("style");
    return t.type = "text/css", t.innerText = e, document.head.appendChild(t), t;
  }

  async function Tt(e) {
    return new Promise((t, n) => {
      const r = document.createElement("script");
      r.setAttribute("src", e), r.addEventListener("load", t), r.addEventListener("error", n), document.body.appendChild(r);
    });
  }

  function Et(e, t = 8192) {
    var n;
    if (!e.width || !e.height) return "";
    const r = document.createElement("canvas");
    r.width = Math.min(t, e.width), r.height = Math.floor(1 + r.width * e.height / e.width);
    const i = e instanceof ImageBitmap && Math.abs(r.width - e.width) < .5 ? r.getContext("bitmaprenderer") : void 0;
    i ? i.transferFromImageBitmap(e) : null === (n = r.getContext("2d")) || void 0 === n || n.drawImage(e, 0, 0, r.width, r.height);
    const s = r.toDataURL("image/png");
    return r.remove(), s;
  }

  async function At(e) {
    return new Promise((t, n) => {
      const r = new Image();
      r.addEventListener("load", () => {
        const e = document.createElement("canvas");
        e.width = r.width, e.height = r.height;
        const i = e.getContext("2d");
        if (!i) return void n(new Error("Could not get 2d context"));
        i.drawImage(r, 0, 0, e.width, e.height);
        const s = i.getImageData(0, 0, e.width, e.height);
        t(s), e.remove(), r.remove();
      }, !1), r.addEventListener("error", e => {
        r.remove(), n(e);
      }, !1), r.src = e;
    });
  }

  function Ct() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }

  function Rt() {
    let e = !1;
    return function (t) {
      (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0);
    }(navigator.userAgent || navigator.vendor || window.opera), e;
  }

  function kt(e) {
    return new URL(window.location.href).searchParams.get(e);
  }

  function Pt(e, t, n = !1) {
    const r = new URLSearchParams(location.search);
    null == t ? r.has(e) && r.delete(e) : r.set(e, t), n ? window.location.search = r.toString() : window.history.replaceState({}, "", "?" + r.toString());
  }

  function Dt(e) {
    return e.replace(/\w\S*/g, function (e) {
      return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
    });
  }

  function Ot(e, {
    backgroundColor: t = "",
    displayPixelRatio: n = 1,
    width: r = 512,
    height: i = 512
  }) {
    const s = document.createElement("canvas"),
          o = s.getContext("2d"),
          a = n,
          l = r,
          c = i;
    return s.width = l * a, s.height = c * a, s.style.width = `${l}`, s.style.height = `${c}`, (null == t ? void 0 : t.length) > 0 && (o.fillStyle = t, o.fillRect(0, 0, s.width, s.height)), o.drawImage(e, 0, 0, s.width, s.height), s;
  }

  ft([xe()], _t.prototype, "defaultCamera", void 0), ft([C(_t.prototype.refreshEnvMapIntensity), xe()], _t.prototype, "envMapIntensity", void 0), ft([xe()], _t.prototype, "environment", void 0), ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function (e, t) {
    const n = new Uint8Array(this);
    null == t && (t = n.length);
    const r = new ArrayBuffer(t - e),
          i = new Uint8Array(r);

    for (let t = 0; t < i.length; t++) i[t] = n[t + e];

    return r;
  });

  class Lt extends i.jyz {
    constructor(e, t) {
      super(e), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.textures = [], this.setTextureIds(t);
    }

    setTextureIds(e) {
      this.textures.map(e => e.id).join(";") !== e.join(";") && (this.textures = e.map(e => ({
        id: e,
        encoding: i.rnI
      })), this.needsUpdate = !0);
    }

    _setUniformTexSize(e, t) {
      var n, r, i, s;
      if (!t || !e) return;
      const o = null !== (r = null === (n = t.image) || void 0 === n ? void 0 : n.width) && void 0 !== r ? r : 512,
            a = null !== (s = null === (i = t.image) || void 0 === i ? void 0 : i.height) && void 0 !== s ? s : 512,
            l = e.value;
      l.isVector2 || console.warn("uniform is not a Vector2"), l && Math.abs(l.x - o) + Math.abs(l.y - a) > .1 && (l.x = o, l.y = a, this.uniformsNeedUpdate = !0);
    }

    onBeforeRender(e, t, n, r, i) {
      var s, o;

      this._setUniformTexSize(this.uniforms.screenSize, null === (s = e.getRenderTarget()) || void 0 === s ? void 0 : s.texture);

      for (const e of this.textures) {
        const t = e.id,
              n = null === (o = this.uniforms[t]) || void 0 === o ? void 0 : o.value;
        n && (this._setUniformTexSize(this.uniforms[t + "Size"], n), n.encoding !== e.encoding && (e.encoding = n.encoding, this.needsUpdate = !0));
      }

      super.onBeforeRender(e, t, n, r, i);
    }

    onBeforeCompile(e, t) {
      e.fragmentShader = this.textures.map(e => {
        var t, n;
        return `uniform sampler2D ${e.id}; \n` + B(null !== (t = e.id) && void 0 !== t ? t : "input", null !== (n = e.encoding) && void 0 !== n ? n : i.rnI);
      }).join("\n") + e.fragmentShader, super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey() + this.textures.map(e => e.id + e.encoding).join(";");
    }

    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }

    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }

    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }

  }

  function It(e, ...t) {
    const n = e.fragmentShader;
    return new Lt({
      defines: Object.assign({}, e.defines),
      uniforms: e.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: n
    }, t);
  }

  class Ft extends u {
    constructor(e, ...t) {
      super(It(e, ...t), t.length < 1 ? Ft.DEFAULT_TEX_ID : t[0]), this.onDirty = [], this.enabled = !0, this.setDirty = this.setDirty.bind(this);
    }

    dispose() {
      var e, t, n, r;
      null === (t = null === (e = this.material) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e), null === (r = null === (n = this.fsQuad) || void 0 === n ? void 0 : n.dispose) || void 0 === r || r.call(n), this.onDirty = [];
    }

    setDirty() {
      this.onDirty.forEach(e => e());
    }

    updateShaderProperties(e) {
      e && (Array.isArray(e) || (e = [e]), e.forEach(e => null == e ? void 0 : e.updateShaderProperties(this.material)));
    }

    render(e, t, n, r, i) {
      this.enabled && super.render(e, t, n, r, i);
    }

  }

  Ft.DEFAULT_TEX_ID = "tDiffuse", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Enabled"), xe()], Ft.prototype, "enabled", void 0);

  class Nt extends o {
    constructor(e, t, n, r, s) {
      super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new i.Ilk();
    }

    render(e, t, n, r, i, s) {
      const o = e.autoClear;
      let a, l;

      if (e.autoClear = !1, void 0 !== this.overrideMaterial && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, s);
      }

      if (this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), s) {
        const t = e.getContext();
        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, null);
      }

      this.clearColor && e.setClearColor(this._oldClearColor, a), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l), e.autoClear = o;
    }

  }

  class Ut extends Ft {
    constructor(e, t = "c = a + b;", n = "", r) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: M`
                varying vec2 vUv;
                
                ${n}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${t}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: r
          },
          ...e
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }

  }

  class Bt extends i.jyz {
    constructor(e = !0) {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nout vec3 vViewPosition;void main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}",
        fragmentShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#include <packing>\nuniform float alphaTest;\n#endif\n#ifndef gl_FragColor \nlayout(location=0)out vec4 gDepthNormal;layout(location=1)out vec4 gFlags;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <alphamap_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;in vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){\n#ifdef USE_ALPHAMAP\n#ifdef ALPHA_I_RGBA_PACKING\nif(1.-unpackRGBAToDepth(texture2D(alphaMap,vUv))<alphaTest)discard;\n#else\nif(texture2D(alphaMap,vUv).g<alphaTest)discard;\n#endif\n#endif\n#include <normal_fragment_begin>\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);vec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#ifndef gl_FragColor \ngDepthNormal=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);gFlags=flags;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}",
        uniforms: {
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          flags: {
            value: new i.Ltg(1, 1, 1, 1)
          }
        },
        glslVersion: e ? i.LSk : i.v9Y
      });
    }

    onBeforeRender(e, t, n, r, s) {
      var o, a;
      let l = s.material;
      Array.isArray(l) && (l = l[0]), this.uniforms.alphaMap.value = null !== (o = null == l ? void 0 : l.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !l || !l.alphaTest || l.alphaTest < 1e-7 ? .001 : l.alphaTest, this.uniforms.flags.value.x = !1 === (null == l ? void 0 : l.userData.postTonemap) ? 0 : 1;
      let c = this.uniforms.alphaMap.value ? 1 : void 0;
      c !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = c, this.needsUpdate = !0), c = l.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, c !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = c, this.needsUpdate = !0), this.side = null !== (a = l.side) && void 0 !== a ? a : i.ehD;
    }

  }

  var jt = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET\nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nvec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn texture2D(tGBufferFlags,uv);\n#else\nreturn vec4(1.);\n#endif\n}\n#endif\n",
      zt = i.M8C.generateUUID;

  class Vt {
    static ApplyMaterialExtensions(e, t, n, r) {
      for (const i of n) this.ApplyMaterialExtension(e, t, i, r);
    }

    static ApplyMaterialExtension(e, t, n, r) {
      var i, s;
      let o = null !== (i = x(n.parsFragmentSnippet, r, e)) && void 0 !== i ? i : "";
      o.length && (t.fragmentShader = t.fragmentShader.replace(this.FragVoidMain, `\n${o}\n${this.FragVoidMain}`)), o = null !== (s = x(n.parsVertexSnippet, r, e)) && void 0 !== s ? s : "", o.length && (t.vertexShader = t.vertexShader.replace(this.VertVoidMain, `\n${o}\n${this.VertVoidMain}`)), n.extraUniforms && (t.uniforms = Object.assign(t.uniforms, n.extraUniforms)), n.shaderExtender && n.shaderExtender(t, e, r), e.lastShader = t;
    }

    static CacheKeyForExtensions(e, t) {
      let n = "";

      for (const r of t) n += this.CacheKeyForExtension(e, r);

      return n;
    }

    static CacheKeyForExtension(e, t) {
      let n = "";
      return t.customCacheKey && (n += t.customCacheKey), t.computeCacheKey && (n += t.computeCacheKey(e)), n;
    }

    static RegisterExtensions(e, t) {
      const n = [];
      if (t) for (const r of t) r.uuid || (r.uuid = zt()), r.setDirty || (r.setDirty = () => {
        r.updateVersion || (r.updateVersion = 0), r.updateVersion++;
      }), r.isCompatible && r.isCompatible(e) && n.push(r);
      return e.onObjectRenderExtension || (e.onObjectRenderExtension = (n, r) => {
        var i, s;
        null === (s = null !== (i = e.materialExtensions) && void 0 !== i ? i : t) || void 0 === s || s.forEach(t => {
          var i, s;
          null === (i = t.onObjectRender) || void 0 === i || i.call(t, n, e, r), e.lastShader && (null === (s = x(t.updaters)) || void 0 === s || s.forEach(t => null == t ? void 0 : t.updateShaderProperties(e.lastShader))), t.updateVersion !== e.materialObject.userData["_" + t.uuid + "_version"] && (e.materialObject.userData["_" + t.uuid + "_version"] = t.updateVersion, e.materialObject.needsUpdate = !0);
        });
      }), n;
    }

    static MaterialBeforeRender(e, t, n) {
      var r, i;
      null === (i = (r = e).onObjectRenderExtension) || void 0 === i || i.call(r, t, n);
    }

  }

  Vt.FragVoidMain = "void main() {", Vt.VertVoidMain = "void main() {";
  const Gt = {
    name: "",
    fog: !0,
    blending: i.bdR,
    side: i.Wl3,
    vertexColors: !1,
    opacity: 1,
    transparent: !1,
    blendSrc: i.k74,
    blendDst: i.LgZ,
    blendEquation: i.bGH,
    blendSrcAlpha: null,
    blendDstAlpha: null,
    blendEquationAlpha: null,
    depthFunc: i.vCF,
    depthTest: !0,
    depthWrite: !0,
    stencilWriteMask: 255,
    stencilFunc: i.cum,
    stencilRef: 0,
    stencilFuncMask: 255,
    stencilFail: i.x5V,
    stencilZFail: i.x5V,
    stencilZPass: i.x5V,
    stencilWrite: !1,
    clippingPlanes: null,
    clipIntersection: !1,
    clipShadows: !1,
    shadowSide: null,
    colorWrite: !0,
    precision: null,
    polygonOffset: !1,
    polygonOffsetFactor: 0,
    polygonOffsetUnits: 0,
    dithering: !1,
    alphaTest: 0,
    alphaToCoverage: !1,
    premultipliedAlpha: !1,
    visible: !0,
    toneMapped: !0,
    userData: {},
    wireframeLinecap: "round",
    wireframeLinejoin: "round"
  },
        Ht = { ...Gt,
    color: "#000000",
    roughness: 0,
    metalness: 0,
    map: null,
    lightMap: null,
    lightMapIntensity: 0,
    aoMap: null,
    aoMapIntensity: 0,
    emissive: "#000000",
    emissiveIntensity: 0,
    emissiveMap: null,
    bumpMap: null,
    bumpScale: 0,
    normalMap: null,
    normalMapType: i.IOt,
    normalScale: new i.FM8(1, 1),
    displacementMap: null,
    displacementScale: 0,
    displacementBias: 0,
    roughnessMap: null,
    metalnessMap: null,
    alphaMap: null,
    envMap: null,
    envMapIntensity: 0,
    refractionRatio: 0,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1,
    morphTargets: !1,
    morphNormals: !1,
    flatShading: !1,
    glossiness: 0,
    glossinessMap: null,
    specularColor: new ve(0),
    specularColorMap: null
  },
        Wt = { ...Ht,
    clearcoat: 0,
    clearcoatMap: null,
    clearcoatRoughness: 0,
    clearcoatRoughnessMap: null,
    clearcoatNormalScale: new i.FM8(1, 1),
    clearcoatNormalMap: null,
    reflectivity: .5,
    sheen: 0,
    sheenColor: new ve(0),
    sheenColorMap: null,
    sheenRoughness: 1,
    sheenRoughnessMap: null,
    specularIntensity: 1,
    specularIntensityMap: null,
    specularColor: new ve(1, 1, 1),
    specularColorMap: null,
    transmission: 0,
    transmissionMap: null,
    thickness: 0,
    thicknessMap: null,
    attenuationDistance: 0,
    attenuationColor: new ve(1, 1, 1)
  };

  class Kt extends i.EJi {
    constructor(e) {
      var t;
      super(e), this.typeSlug = Kt.TypeSlug, this.isMeshStandardMaterial2 = !0, this.extraUniformsToUpload = {}, this.assetType = "material", this.materialObject = this, this.fog = !1, this.userData.setDirty = () => {
        var e, t;
        this.needsUpdate = !0, this.dispatchEvent({
          type: "materialUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.materialExtensions = Vt.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : []);
    }

    registerMaterialExtensions(e) {
      this.materialExtensions = [...this.materialExtensions, ...Vt.RegisterExtensions(this, e)];
    }

    unregisterMaterialExtensions(e) {}

    _makeSamplerUi(e = "map") {
      const t = "map" === e;
      return {
        type: "folder",
        label: e + " Sampler",
        hidden: () => !this[e],
        children: [() => {
          var n;
          return {
            type: "vec2",
            label: "Repeat",
            hidden: () => !t && this.map,
            bounds: [0, 100],
            stepSize: .001,
            property: [this[e], "repeat"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "vec2",
            label: "Offset",
            hidden: () => !t && this.map,
            bounds: [0, 2],
            property: [this[e], "offset"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "vec2",
            label: "Center",
            hidden: () => !t && this.map,
            bounds: [-2, 2],
            property: [this[e], "center"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var n;
          return {
            type: "input",
            label: "Rotation",
            hidden: () => !t && this.map,
            bounds: [-Math.PI, Math.PI],
            property: [this[e], "rotation"],
            onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Encoding",
            property: [this[e], "encoding"],
            children: [["Linear", i.rnI], ["sRGB", i.knz]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              const t = this[e];
              t && (t.needsUpdate = !0, this[e] = t.clone(), this[e].uuid = t.uuid, t.dispose());
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "checkbox",
            label: "Flip Y",
            property: [this[e], "flipY"],
            onChange: [() => {
              const t = this[e];
              t && (t.needsUpdate = !0, this[e] = t.clone(), this[e].uuid = t.uuid, t.dispose());
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Wrap S",
            property: [this[e], "wrapS"],
            children: [["ClampToEdge", i.uWy], ["MirroredRepeat", i.OoA], ["Repeat", i.rpg]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Wrap T",
            property: [this[e], "wrapT"],
            children: [["ClampToEdge", i.uWy], ["MirroredRepeat", i.OoA], ["Repeat", i.rpg]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "input",
            label: "Anisotropy",
            bounds: [1, 6],
            stepSize: 1,
            property: [this[e], "anisotropy"],
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0), this.needsUpdate = !0;
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Min Filter",
            property: [this[e], "minFilter"],
            children: [["Linear", se], ["Nearest", i.TyD]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }, () => {
          var t;
          return {
            type: "dropdown",
            label: "Mag Filter",
            property: [this[e], "magFilter"],
            children: [["Linear", se], ["Nearest", i.TyD]].map(e => ({
              label: e[0],
              value: e[1]
            })),
            onChange: [() => {
              this[e] && (this[e].needsUpdate = !0);
            }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
          };
        }]
      };
    }

    get uiConfig() {
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, {
        type: "color",
        property: [this, "color"],
        limitedUi: !0
      }, {
        type: "image",
        property: [this, "map"]
      }, this._makeSamplerUi("map"), {
        type: "folder",
        label: "Rough/Metal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "roughness"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "metalness"],
          limitedUi: !0
        }, {
          type: "image",
          property: [this, "roughnessMap"]
        }, this._makeSamplerUi("roughnessMap"), {
          type: "image",
          property: [this, "metalnessMap"]
        }, this._makeSamplerUi("metalnessMap")]
      }, {
        type: "folder",
        label: "Bump/Normal",
        limitedUi: !0,
        children: [{
          type: "slider",
          bounds: [0, .2],
          stepSize: .001,
          property: [this, "bumpScale"],
          hidden: () => !this.bumpMap
        }, {
          type: "image",
          property: [this, "bumpMap"]
        }, this._makeSamplerUi("bumpMap"), {
          type: "image",
          property: [this, "normalMap"]
        }, {
          type: "vec2",
          property: [this, "normalScale"],
          hidden: () => !this.normalMap
        }, {
          type: "dropdown",
          hidden: () => !this.normalMap,
          property: [this, "normalMapType"],
          children: [["TangentSpace", i.IOt], ["ObjectSpace", i.PA7]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, this._makeSamplerUi("normalMap"), {
          type: "slider",
          bounds: [0, 10],
          stepSize: .001,
          property: [this, "displacementScale"],
          hidden: () => !this.displacementMap
        }, {
          type: "image",
          property: [this, "displacementMap"]
        }, this._makeSamplerUi("displacementMap")]
      }, {
        type: "folder",
        label: "Sheen",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheen"]
        }, {
          type: "color",
          hidden: () => this.sheen < .001,
          property: [this, "sheenColor"]
        }, {
          type: "image",
          property: [this, "sheenColorMap"]
        }, this._makeSamplerUi("sheenColorMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "sheenRoughness"]
        }, {
          type: "image",
          property: [this, "sheenRoughnessMap"]
        }, this._makeSamplerUi("sheenRoughnessMap")]
      }, {
        type: "folder",
        label: "Clearcoat",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoat"]
        }, {
          type: "slider",
          bounds: [0, 1],
          hidden: () => this.clearcoat < .001,
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatMap"]
        }, this._makeSamplerUi("clearcoatMap"), {
          type: "slider",
          bounds: [0, 1],
          property: [this, "clearcoatRoughness"]
        }, {
          type: "image",
          property: [this, "clearcoatRoughnessMap"]
        }, this._makeSamplerUi("clearcoatRoughnessMap"), {
          type: "image",
          property: [this, "clearcoatNormalMap"]
        }, {
          type: "vec2",
          property: [this, "clearcoatNormalScale"],
          hidden: () => !this.clearcoatNormalMap
        }, this._makeSamplerUi("clearcoatNormalMap")]
      }, {
        type: "folder",
        label: "Emission",
        children: [{
          type: "color",
          property: [this, "emissive"]
        }, {
          type: "slider",
          bounds: [0, 10],
          property: [this, "emissiveIntensity"]
        }, {
          type: "image",
          property: [this, "emissiveMap"]
        }, this._makeSamplerUi("emissiveMap")]
      }, {
        type: "folder",
        label: "Refraction",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "reflectivity"]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "transmission"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 1],
          stepSize: .001,
          property: [this, "thickness"]
        }, {
          type: "image",
          property: [this, "transmissionMap"]
        }, this._makeSamplerUi("transmissionMap"), {
          type: "image",
          property: [this, "thicknessMap"]
        }, this._makeSamplerUi("thicknessMap")]
      }, {
        type: "folder",
        label: "Blending",
        children: [{
          type: "slider",
          bounds: [0, 1],
          property: [this, "opacity"]
        }, {
          type: "checkbox",
          property: [this, "transparent"],
          onChange: () => {
            var e, t;
            null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e);
          }
        }, {
          type: "checkbox",
          property: [this, "depthWrite"],
          onChange: () => {
            var e, t;
            null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e);
          }
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [this, "alphaTest"]
        }, {
          type: "checkbox",
          property: [this, "dithering"]
        }, {
          type: "dropdown",
          label: "Blending",
          property: [this, "blending"],
          children: [["None", te], ["Normal", ne], ["Additive", i.WMw], ["Subtractive", re], ["Multiply", ie]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "image",
          property: [this, "alphaMap"]
        }, this._makeSamplerUi("alphaMap"), {
          type: "checkbox",
          label: "Render to Depth",
          hidden: () => !this.transparent && this.transmission < .001,
          getValue: () => !0 === this.userData.renderToDepth,
          setValue: e => {
            var t, n;
            this.userData.renderToDepth = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t);
          }
        }, {
          type: "checkbox",
          label: "Inverse AlphaMap",
          hidden: () => !this.transparent,
          getValue: () => !0 === this.userData.inverseAlphaMap,
          setValue: e => {
            var t, n;
            this.userData.inverseAlphaMap = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t);
          }
        }]
      }, {
        type: "folder",
        label: "AO/Lightmap",
        children: [{
          type: "slider",
          bounds: [0, 2],
          property: [this, "aoMapIntensity"]
        }, {
          type: "image",
          property: [this, "aoMap"]
        }, this._makeSamplerUi("aoMap"), {
          type: "slider",
          bounds: [0, 2],
          property: [this, "lightMapIntensity"]
        }, {
          type: "image",
          property: [this, "lightMap"]
        }, this._makeSamplerUi("lightMap")]
      }, {
        type: "dropdown",
        label: "Side",
        property: [this, "side"],
        children: [["Front", i.Wl3], ["Back", i._Li], ["Double", i.ehD]].map(e => ({
          label: e[0],
          value: e[1]
        }))
      }, {
        type: "checkbox",
        property: [this, "flatShading"]
      }, {
        type: "input",
        label: "Mesh count",
        getValue: () => {
          var e, t, n;
          return null !== (n = null === (t = null === (e = this.userData) || void 0 === e ? void 0 : e.appliedMeshes) || void 0 === t ? void 0 : t.size) && void 0 !== n ? n : 0;
        },
        setValue: e => {},
        disabled: !0
      }, {
        type: "button",
        label: `Download ${this.typeSlug}`,
        value: () => {
          vt(new Blob([JSON.stringify(this.toJSON(), null, 2)], {
            type: "application/json"
          }), `standard-material.${this.typeSlug}`);
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Physical Material",
        expanded: !0,
        children: this._uiConfigChildren,
        uuid: "MSM2_" + this.uuid,
        limitedUi: !0
      }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(e => {
        var t;
        return null === (t = e.getUiConfig) || void 0 === t ? void 0 : t.call(e, this);
      })].filter(e => e), this._uiConfig;
    }

    onBeforeCompile(e, t) {
      const n = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]],
            r = [["#include <uv_vertex>", "mainStart"]];

      for (const t of r) e.vertexShader = e.vertexShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);

      for (const t of n) e.fragmentShader = e.fragmentShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);

      Vt.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), e.vertexShader = e.vertexShader.replaceAll("#glMarker", "// "), e.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey() + Vt.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap;
    }

    onBeforeRender(e, t, n, r, i) {
      var s;
      super.onBeforeRender(e, t, n, r, i), Vt.MaterialBeforeRender(this, i, e);
      const o = this.userData.inverseAlphaMap ? 1 : 0;
      o !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = o, this.needsUpdate = !0), this.map && (null === (s = this.extraUniformsToUpload) || void 0 === s ? void 0 : s.uvTransform) && i.userData.cloneRotI > 0 && this.extraUniformsToUpload.uvTransform.value.setUvTransform(this.map.offset.x * this.map.repeat.x * i.userData.cloneRotI / (i.userData.rotationCount || 1), this.map.offset.y * this.map.repeat.y * i.userData.cloneRotI / (i.userData.rotationCount || 1), this.map.repeat.x, this.map.repeat.y, this.map.rotation, this.map.center.x, this.map.center.y);
    }

    copyProps(e, t = !1) {
      var n, r;
      if (!t && !["MeshStandardMaterial", Kt.TYPE, "MeshPhysicalMaterial"].includes(e.type)) return console.warn("Material type is not supported:", e.type), this;
      const i = {};
      y(e, i, Array.from(Object.keys(Wt)));
      const s = i.userData;
      delete i.userData;

      for (const e of Object.keys(i)) void 0 === i[e] && delete i[e];

      return this.setValues(i), s && qt(this.userData, s), null === (r = (n = this.userData).setDirty) || void 0 === r || r.call(n), this;
    }

    toJSON(e) {
      const t = this.userData;
      this.userData = {};
      const n = super.toJSON(e);
      this.userData = t, n.userData = {}, qt(n.userData, t), n.userData.uuid = this.userData.uuid, n.type = Kt.TYPE;

      for (const e of Object.keys(n)) void 0 === n[e] && delete n[e];

      return n;
    }

    fromJSON(e, t, n = !1) {
      return Array.isArray(e.normalScale) && (e.normalScale = new i.FM8().fromArray(e.normalScale)), Array.isArray(e.clearcoatNormalScale) && (e.clearcoatNormalScale = new i.FM8().fromArray(e.clearcoatNormalScale)), this.copyProps(e, n);
    }

    clone() {
      return super.clone();
    }

  }

  Kt.TypeSlug = "pmat", Kt.TYPE = "MeshStandardMaterial2";
  const Xt = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid"];

  function qt(e, t) {
    if (t) for (const n of Object.keys(t)) Xt.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
    return e;
  }

  const Yt = {
    materialType: Kt.TYPE,
    name: "standard",
    color: "#ffffff"
  };

  class Zt extends r {
    constructor() {
      super(), this._templates = [Yt], this._materials = [], this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this);
    }

    findOrCreate(e, t) {
      let n = this.findMaterial(e);
      return n || (n = this.generateFromTemplate(e, t)), n;
    }

    generateFromTemplate(e, t) {
      const n = this.findTemplate(e);
      if (n) return this._generateFromTemplate(n, null != t ? t : {});
    }

    generateFromTemplateType(e, t) {
      const n = this._templates.find(t => t.materialType === e);

      if (n) return this._generateFromTemplate(n, null != t ? t : {});
    }

    findTemplate(e) {
      return this._templates.find(t => t.name === e);
    }

    registerMaterial(e) {
      if (this._materials.includes(e)) return;
      const t = this.findMaterial(e.uuid);
      t ? console.warn("Material UUID already exists", e, t) : this._materials.push(e);
    }

    registerMaterialObject(e) {
      const t = e.materialObject ? e : Object.assign(e, {
        assetType: "material",
        materialObject: e
      });
      return this.registerMaterial(t), t;
    }

    unregisterMaterial(e) {
      this._materials = this._materials.filter(t => t.uuid !== e.uuid);
    }

    registerMaterialTemplate(e) {
      e.templateUUID || (e.templateUUID = Be());

      const t = this._templates.find(t => t.templateUUID === e.templateUUID);

      t ? console.warn("MaterialTemplate already exists", e, t) : this._templates.push(e);
    }

    unregisterMaterialTemplate(e) {
      this._templates = this._templates.filter(t => t.templateUUID !== e.templateUUID);
    }

    dispose() {}

    findMaterial(e) {
      return e ? this._materials.find(t => t.uuid === e) : void 0;
    }

    findMaterialsByName(e) {
      return this._materials.filter(t => t.name === e);
    }

    getMaterialsOfType(e) {
      return e ? this._materials.filter(t => t.typeSlug === e) : [];
    }

    getAllMaterials() {
      return [...this._materials];
    }

    processModel(e, t) {
      return g(e, "modelObject", this._processModel(e.modelObject, t)), e;
    }

    _processMaterial(e, t) {
      var n, r, i;
      if (!e) return;
      if (null === (n = e.materialObject) || void 0 === n ? void 0 : n.isMaterial) return e;
      let s = e.mmMaterial;

      if (!s) {
        const n = (null === (r = e.userData) || void 0 === r ? void 0 : r.uuid) || e.uuid;
        s = this.findMaterial(n), s ? s.copyProps(e) : s = this.generateFromTemplate(null !== (i = t.materialTemplate) && void 0 !== i ? i : "standard", !1 !== t.useSourceMaterial && e.isMaterial ? e : {}), e.mmMaterial = s;
      }

      return s;
    }

    processMaterial(e, t) {
      return !1 !== t.register && this.registerMaterial(e), e.materialObject || (e = this._processMaterial(e, { ...t,
        register: !1
      })), e;
    }

    registerMaterialExtension(e) {
      this._materialExtensions.includes(e) || this._materialExtensions.push(e);
    }

    unregisterMaterialExtension(e) {
      const t = this._materialExtensions.indexOf(e);

      t >= 0 && this._materialExtensions.splice(t, 1);
    }

    exportMaterial(e, t, n = !0, r = !1) {
      const i = Me(e, !1),
            s = JSON.stringify(i, null, n ? 0 : 2),
            o = (t || e.name || "physical_material") + "." + e.typeSlug,
            a = new File([s], o, {
        type: "application/json"
      });
      return r && xt(a), a;
    }

  }

  class Jt extends Zt {
    _generateFromTemplate(e, t) {
      var n, r, s, o, a;
      let l;
      const c = { ...e
      };
      c.customMaterialExtensions = [...(null !== (n = c.customMaterialExtensions) && void 0 !== n ? n : []), ...this._materialExtensions];
      let u = {};

      switch (e.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
          t && y(t, c, Array.from(Object.keys(Wt))), u = c.userData, delete c.userData, l = new Kt({
            customMaterialExtensions: c.customMaterialExtensions
          }).fromJSON(c, void 0, !0), u && (qt(l.userData, u), u.uuid && (l.uuid = u.uuid), c.userData = u, u = {}), l.userData.uuid = l.uuid, null === (s = (r = l.userData).setDirty) || void 0 === s || s.call(r);
          break;

        case "basic":
          l = new i.vBJ(c);
          break;

        case "shadow":
          l = new i.Tn7(c);
          break;

        default:
          u = null, t && t.userData && (u = t.userData, delete t.userData), l = (null === (o = e.generator) || void 0 === o ? void 0 : o.call(e, c, t)) || void 0, t && u && (t.userData = u), u && l && (qt(l.userData, u), (null == u ? void 0 : u.uuid) && (l.uuid = u.uuid), u = null), l && (l.userData.uuid = l.uuid);
      }

      if (l) {
        t.runtimeMaterial && (l.userData.__runtimeMaterial = !0);
        const n = l;
        return l.clone = () => {
          n.userData.cloneId || (n.userData.cloneId = "0", n.userData.cloneCount = 0), n.userData.cloneCount += 1;
          const t = this.generateFromTemplate(e.name);
          return t && (t.copyProps(n), t.userData.cloneId = t.userData.cloneId + "_" + n.userData.cloneCount, t.userData.cloneCount = 0, t.name = t.name + "_" + t.userData.cloneId), null == t ? void 0 : t.materialObject;
        }, t && (this.findMaterial(null == t ? void 0 : t.uuid) && this.unregisterMaterial(t), this.findMaterial(null === (a = null == t ? void 0 : t.materialObject) || void 0 === a ? void 0 : a.uuid) && this.unregisterMaterial(t.materialObject)), this.registerMaterialObject(n);
      }
    }

    _processModel(e, t) {
      var n;
      let r = e.material;

      if (r) {
        let i = !0;
        Array.isArray(r) || (r = [r], i = !1);
        const s = [];

        for (const e of r) {
          const n = this._processMaterial(e, t);

          s.push(null == n ? void 0 : n.materialObject);
        }

        const o = null !== (n = e.userData.setMaterial) && void 0 !== n ? n : t => {
          e.material = t;
        };
        e.material = null, o(i ? s : s[0]);
      }

      if (!1 !== t.recursive) for (let n = 0; n < e.children.length; n++) e.children[n] = this._processModel(e.children[n], t);
      return e;
    }

  }

  class $t {
    constructor(e, t, n, r) {
      this.cls = e, this.ext = t, this.root = n, this.onCtor = r;
    }

    ctor(e) {
      const t = this.cls && new this.cls(e.loadingManager);
      return "function" == typeof this.onCtor ? this.onCtor(t, e) : t;
    }

  }

  function Qt(e) {
    var t;
    if (!e || "" === e || e.match(/__MACOSX\/.*\._/)) return "";
    const n = null !== (t = (e = e.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t ? t : "",
          r = n.lastIndexOf(".");
    return "" === n || r < 1 ? "" : n.slice(r + 1);
  }

  function en(e) {
    return e.substring(e.lastIndexOf("/") + 1);
  }

  class tn extends i.hH6 {
    load(e, t, n, r) {
      return super.load(e, e => {
        try {
          if ("string" != typeof e) throw new Error("Invalid JSON");
          null == t || t(JSON.parse(e));
        } catch (e) {
          null == r || r(e);
        }
      }, n, r);
    }

  }

  class nn extends i.yxD {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    parse(e) {
      const t = function (e, t) {
        switch (e) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (t || ""));
            break;

          case 2:
            console.error("THREE.RGBELoader Write Error: " + (t || ""));
            break;

          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
            break;

          default:
          case 4:
            console.error("THREE.RGBELoader: Error: " + (t || ""));
        }

        return -1;
      },
            n = function (e, t, n) {
        t = t || 1024;
        let r = e.pos,
            i = -1,
            s = 0,
            o = "",
            a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));

        for (; 0 > (i = a.indexOf("\n")) && s < t && r < e.byteLength;) o += a, s += a.length, r += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));

        return -1 < i && (!1 !== n && (e.pos += s + i + 1), o + a.slice(0, i));
      },
            r = function (e, t, n, r) {
        const i = e[t + 3],
              s = Math.pow(2, i - 128) / 255;
        n[r + 0] = e[t + 0] * s, n[r + 1] = e[t + 1] * s, n[r + 2] = e[t + 2] * s, n[r + 3] = 1;
      },
            s = function (e, t, n, r) {
        const s = e[t + 3],
              o = Math.pow(2, s - 128) / 255;
        n[r + 0] = i.A5E.toHalfFloat(Math.min(e[t + 0] * o, 65504)), n[r + 1] = i.A5E.toHalfFloat(Math.min(e[t + 1] * o, 65504)), n[r + 2] = i.A5E.toHalfFloat(Math.min(e[t + 2] * o, 65504)), n[r + 3] = i.A5E.toHalfFloat(1);
      },
            o = new Uint8Array(e);

      o.pos = 0;

      const a = function (e) {
        const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
              i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
              s = /^\s*FORMAT=(\S+)\s*$/,
              o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
              a = {
          valid: 0,
          string: "",
          comments: "",
          programtype: "RGBE",
          format: "",
          gamma: 1,
          exposure: 1,
          width: 0,
          height: 0
        };
        let l, c;
        if (e.pos >= e.byteLength || !(l = n(e))) return t(1, "no header found");
        if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");

        for (a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(e), !1 !== l;) if (a.string += l + "\n", "#" !== l.charAt(0)) {
          if ((c = l.match(r)) && (a.gamma = parseFloat(c[1])), (c = l.match(i)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break;
        } else a.comments += l + "\n";

        return 2 & a.valid ? 4 & a.valid ? a : t(3, "missing image size specifier") : t(3, "missing format specifier");
      }(o);

      if (-1 !== a) {
        const e = a.width,
              n = a.height,
              l = function (e, n, r) {
          const i = n;
          if (i < 8 || i > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
          if (i !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
          const s = new Uint8Array(4 * n * r);
          if (!s.length) return t(4, "unable to allocate buffer space");
          let o = 0,
              a = 0;
          const l = 4 * i,
                c = new Uint8Array(4),
                u = new Uint8Array(l);
          let p = r;

          for (; p > 0 && a < e.byteLength;) {
            if (a + 4 > e.byteLength) return t(1);
            if (c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != i) return t(3, "bad rgbe scanline format");
            let n,
                r = 0;

            for (; r < l && a < e.byteLength;) {
              n = e[a++];
              const i = n > 128;
              if (i && (n -= 128), 0 === n || r + n > l) return t(3, "bad scanline data");

              if (i) {
                const t = e[a++];

                for (let e = 0; e < n; e++) u[r++] = t;
              } else u.set(e.subarray(a, a + n), r), r += n, a += n;
            }

            const h = i;

            for (let e = 0; e < h; e++) {
              let t = 0;
              s[o] = u[e + t], t += i, s[o + 1] = u[e + t], t += i, s[o + 2] = u[e + t], t += i, s[o + 3] = u[e + t], o += 4;
            }

            p--;
          }

          return s;
        }(o.subarray(o.pos), e, n);

        if (-1 !== l) {
          let t, o, c;

          switch (this.type) {
            case i.VzW:
              c = l.length / 4;
              const e = new Float32Array(4 * c);

              for (let t = 0; t < c; t++) r(l, 4 * t, e, 4 * t);

              t = e, o = i.VzW;
              break;

            case i.cLu:
              c = l.length / 4;
              const n = new Uint16Array(4 * c);

              for (let e = 0; e < c; e++) s(l, 4 * e, n, 4 * e);

              t = n, o = i.cLu;
              break;

            default:
              console.error("THREE.RGBELoader: unsupported type: ", this.type);
          }

          return {
            width: e,
            height: n,
            data: t,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            type: o
          };
        }
      }

      return null;
    }

    setDataType(e) {
      return this.type = e, this;
    }

    load(e, t, n, r) {
      return super.load(e, function (e, n) {
        switch (e.type) {
          case i.VzW:
          case i.cLu:
            e.encoding = i.rnI, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !0;
        }

        t && t(e, n);
      }, n, r);
    }

  }

  function rn(e) {
    Us.Importers.push(new $t(class extends nn {
      constructor(t) {
        super(t), this.setDataType(Bs(e));
      }

    }, ["hdr"], !1));
  }

  class sn extends i.aNw {
    constructor(e) {
      super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) {
        return new pn(e);
      }), this.register(function (e) {
        return new vn(e);
      }), this.register(function (e) {
        return new bn(e);
      }), this.register(function (e) {
        return new dn(e);
      }), this.register(function (e) {
        return new fn(e);
      }), this.register(function (e) {
        return new _n(e);
      }), this.register(function (e) {
        return new mn(e);
      }), this.register(function (e) {
        return new un(e);
      }), this.register(function (e) {
        return new gn(e);
      }), this.register(function (e) {
        return new hn(e);
      }), this.register(function (e) {
        return new ln(e);
      }), this.register(function (e) {
        return new xn(e);
      });
    }

    load(e, t, n, r) {
      const s = this;
      let o;
      o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.Zp0.extractUrlBase(e), this.manager.itemStart(e);

      const a = function (t) {
        r ? r(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e);
      },
            l = new i.hH6(this.manager);

      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (n) {
        try {
          s.parse(n, o, function (n) {
            t(n), s.manager.itemEnd(e);
          }, a);
        } catch (e) {
          a(e);
        }
      }, n, a);
    }

    setDRACOLoader(e) {
      return this.dracoLoader = e, this;
    }

    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }

    setKTX2Loader(e) {
      return this.ktx2Loader = e, this;
    }

    setMeshoptDecoder(e) {
      return this.meshoptDecoder = e, this;
    }

    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }

    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }

    parse(e, t, n, r) {
      let s;
      const o = {},
            a = {};
      if ("string" == typeof e) s = e;else if (i.Zp0.decodeText(new Uint8Array(e, 0, 4)) === yn) {
        try {
          o[an.KHR_BINARY_GLTF] = new wn(e);
        } catch (e) {
          return void (r && r(e));
        }

        s = o[an.KHR_BINARY_GLTF].content;
      } else s = i.Zp0.decodeText(new Uint8Array(e));
      const l = JSON.parse(s);
      if (void 0 === l.asset || l.asset.version[0] < 2) return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
      const c = new Hn(l, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      c.fileLoader.setRequestHeader(this.requestHeader);

      for (let e = 0; e < this.pluginCallbacks.length; e++) {
        const t = this.pluginCallbacks[e](c);
        a[t.name] = t, o[t.name] = !0;
      }

      if (l.extensionsUsed) for (let e = 0; e < l.extensionsUsed.length; ++e) {
        const t = l.extensionsUsed[e],
              n = l.extensionsRequired || [];

        switch (t) {
          case an.KHR_MATERIALS_UNLIT:
            o[t] = new cn();
            break;

          case an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[t] = new En();
            break;

          case an.KHR_DRACO_MESH_COMPRESSION:
            o[t] = new Sn(l, this.dracoLoader);
            break;

          case an.KHR_TEXTURE_TRANSFORM:
            o[t] = new Mn();
            break;

          case an.KHR_MESH_QUANTIZATION:
            o[t] = new An();
            break;

          default:
            n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".');
        }
      }
      c.setExtensions(o), c.setPlugins(a), c.parse(n, r);
    }

    parseAsync(e, t) {
      const n = this;
      return new Promise(function (r, i) {
        n.parse(e, t, r, i);
      });
    }

  }

  function on() {
    let e = {};
    return {
      get: function (t) {
        return e[t];
      },
      add: function (t, n) {
        e[t] = n;
      },
      remove: function (t) {
        delete e[t];
      },
      removeAll: function () {
        e = {};
      }
    };
  }

  const an = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };

  class ln {
    constructor(e) {
      this.parser = e, this.name = an.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }

    _markDefs() {
      const e = this.parser,
            t = this.parser.json.nodes || [];

      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n];
        r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light);
      }
    }

    _loadLight(e) {
      const t = this.parser,
            n = "light:" + e;
      let r = t.cache.get(n);
      if (r) return r;
      const s = t.json,
            o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
      let a;
      const l = new i.Ilk(16777215);
      void 0 !== o.color && l.fromArray(o.color);
      const c = void 0 !== o.range ? o.range : 0;

      switch (o.type) {
        case "directional":
          a = new i.Ox3(l), a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        case "point":
          a = new i.cek(l), a.distance = c;
          break;

        case "spot":
          a = new i.PMe(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
          break;

        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
      }

      return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r;
    }

    createNodeAttachment(e) {
      const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            i = (r.extensions && r.extensions[this.name] || {}).light;
      return void 0 === i ? null : this._loadLight(i).then(function (e) {
        return n._getNodeRef(t.cache, i, e);
      });
    }

  }

  class cn {
    constructor() {
      this.name = an.KHR_MATERIALS_UNLIT;
    }

    getMaterialType() {
      return i.vBJ;
    }

    extendParams(e, t, n) {
      const r = [];
      e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
      const s = t.pbrMetallicRoughness;

      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          const t = s.baseColorFactor;
          e.color.fromArray(t), e.opacity = t[3];
        }

        void 0 !== s.baseColorTexture && r.push(n.assignTexture(e, "map", s.baseColorTexture, i.knz));
      }

      return Promise.all(r);
    }

  }

  class un {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }

    extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name].emissiveStrength;
      return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve();
    }

  }

  class pn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_CLEARCOAT;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];

      if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
        const e = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new i.FM8(e, e);
      }

      return Promise.all(s);
    }

  }

  class hn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_IRIDESCENCE;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(i);
    }

  }

  class dn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_SHEEN;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [];
      t.sheenColor = new i.Ilk(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      const o = r.extensions[this.name];
      return void 0 !== o.sheenColorFactor && t.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, i.knz)), void 0 !== o.sheenRoughnessTexture && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), r.extras && void 0 !== r.extras.sheenFactor && (t.sheen = r.extras.sheenFactor, delete r.extras.sheenFactor), Promise.all(s);
    }

  }

  class fn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_TRANSMISSION;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i);
    }

  }

  class _n {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_VOLUME;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];
      t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 0;
      const a = o.attenuationColor || [1, 1, 1];
      return t.attenuationColor = new i.Ilk(a[0], a[1], a[2]), Promise.all(s);
    }

  }

  class mn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_IOR;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve();
    }

  }

  class gn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_MATERIALS_SPECULAR;
    }

    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? i.EJi : null;
    }

    extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const s = [],
            o = r.extensions[this.name];
      t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const a = o.specularColorFactor || [1, 1, 1];
      return t.specularColor = new i.Ilk(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, i.knz)), Promise.all(s);
    }

  }

  class vn {
    constructor(e) {
      this.parser = e, this.name = an.KHR_TEXTURE_BASISU;
    }

    loadTexture(e) {
      const t = this.parser,
            n = t.json,
            r = n.textures[e];
      if (!r.extensions || !r.extensions[this.name]) return null;
      const i = r.extensions[this.name],
            s = t.options.ktx2Loader;

      if (!s) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }

      return t.loadTextureImage(e, i.source, s);
    }

  }

  class bn {
    constructor(e) {
      this.parser = e, this.name = an.EXT_TEXTURE_WEBP, this.isSupported = null;
    }

    loadTexture(e) {
      const t = this.name,
            n = this.parser,
            r = n.json,
            i = r.textures[e];
      if (!i.extensions || !i.extensions[t]) return null;
      const s = i.extensions[t],
            o = r.images[s.source];
      let a = n.textureLoader;

      if (o.uri) {
        const e = n.options.manager.getHandler(o.uri);
        null !== e && (a = e);
      }

      return this.detectSupport().then(function (i) {
        if (i) return n.loadTextureImage(e, s.source, a);
        if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(e);
      });
    }

    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function (e) {
        const t = new Image();
        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
          e(1 === t.height);
        };
      })), this.isSupported;
    }

  }

  class xn {
    constructor(e) {
      this.name = an.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }

    loadBufferView(e) {
      const t = this.parser.json,
            n = t.bufferViews[e];

      if (n.extensions && n.extensions[this.name]) {
        const e = n.extensions[this.name],
              r = this.parser.getDependency("buffer", e.buffer),
              i = this.parser.options.meshoptDecoder;

        if (!i || !i.supported) {
          if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }

        return Promise.all([r, i.ready]).then(function (t) {
          const n = e.byteOffset || 0,
                r = e.byteLength || 0,
                s = e.count,
                o = e.byteStride,
                a = new ArrayBuffer(s * o),
                l = new Uint8Array(t[0], n, r);
          return i.decodeGltfBuffer(new Uint8Array(a), s, o, l, e.mode, e.filter), a;
        });
      }

      return null;
    }

  }

  const yn = "glTF";

  class wn {
    constructor(e) {
      this.name = an.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t = new DataView(e, 0, 12);
      if (this.header = {
        magic: i.Zp0.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0)
      }, this.header.magic !== yn) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n = this.header.length - 12,
            r = new DataView(e, 12);
      let s = 0;

      for (; s < n;) {
        const t = r.getUint32(s, !0);
        s += 4;
        const n = r.getUint32(s, !0);

        if (s += 4, 1313821514 === n) {
          const n = new Uint8Array(e, 12 + s, t);
          this.content = i.Zp0.decodeText(n);
        } else if (5130562 === n) {
          const n = 12 + s;
          this.body = e.slice(n, n + t);
        }

        s += t;
      }

      if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }

  }

  class Sn {
    constructor(e, t) {
      if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = an.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
    }

    decodePrimitive(e, t) {
      const n = this.json,
            r = this.dracoLoader,
            i = e.extensions[this.name].bufferView,
            s = e.extensions[this.name].attributes,
            o = {},
            a = {},
            l = {};

      for (const e in s) {
        const t = In[e] || e.toLowerCase();
        o[t] = s[e];
      }

      for (const t in e.attributes) {
        const r = In[t] || t.toLowerCase();

        if (void 0 !== s[t]) {
          const i = n.accessors[e.attributes[t]],
                s = Pn[i.componentType];
          l[r] = s, a[r] = !0 === i.normalized;
        }
      }

      return t.getDependency("bufferView", i).then(function (e) {
        return new Promise(function (t) {
          r.decodeDracoFile(e, function (e) {
            for (const t in e.attributes) {
              const n = e.attributes[t],
                    r = a[t];
              void 0 !== r && (n.normalized = r);
            }

            t(e);
          }, o, l);
        });
      });
    }

  }

  class Mn {
    constructor() {
      this.name = an.KHR_TEXTURE_TRANSFORM;
    }

    extendTexture(e, t) {
      return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
    }

  }

  class Tn extends i.Wid {
    constructor(e) {
      super(), this.isGLTFSpecularGlossinessMaterial = !0;
      const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
            r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
            s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
            o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
            a = {
        specular: {
          value: new i.Ilk().setHex(16777215)
        },
        glossiness: {
          value: 1
        },
        specularMap: {
          value: null
        },
        glossinessMap: {
          value: null
        }
      };
      this._extraUniforms = a, this.onBeforeCompile = function (e) {
        for (const t in a) e.uniforms[t] = a[t];

        e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o);
      }, Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (e) {
            a.specular.value = e;
          }
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (e) {
            a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
          }
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (e) {
            a.glossiness.value = e;
          }
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (e) {
            a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
          }
        }
      }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e);
    }

    copy(e) {
      return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }

  }

  class En {
    constructor() {
      this.name = an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
    }

    getMaterialType() {
      return Tn;
    }

    extendParams(e, t, n) {
      const r = t.extensions[this.name];
      e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
      const s = [];

      if (Array.isArray(r.diffuseFactor)) {
        const t = r.diffuseFactor;
        e.color.fromArray(t), e.opacity = t[3];
      }

      if (void 0 !== r.diffuseTexture && s.push(n.assignTexture(e, "map", r.diffuseTexture, i.knz)), e.emissive = new i.Ilk(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new i.Ilk(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
        const t = r.specularGlossinessTexture;
        s.push(n.assignTexture(e, "glossinessMap", t)), s.push(n.assignTexture(e, "specularMap", t, i.knz));
      }

      return Promise.all(s);
    }

    createMaterial(e) {
      const t = new Tn(e);
      return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = i.IOt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t;
    }

  }

  class An {
    constructor() {
      this.name = an.KHR_MESH_QUANTIZATION;
    }

  }

  class Cn extends i._C8 {
    constructor(e, t, n, r) {
      super(e, t, n, r);
    }

    copySampleValue_(e) {
      const t = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            i = e * r * 3 + r;

      for (let e = 0; e !== r; e++) t[e] = n[i + e];

      return t;
    }

    interpolate_(e, t, n, r) {
      const i = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = 2 * o,
            l = 3 * o,
            c = r - t,
            u = (n - t) / c,
            p = u * u,
            h = p * u,
            d = e * l,
            f = d - l,
            _ = -2 * h + 3 * p,
            m = h - p,
            g = 1 - _,
            v = m - p + u;

      for (let e = 0; e !== o; e++) {
        const t = s[f + e + o],
              n = s[f + e + a] * c,
              r = s[d + e + o],
              l = s[d + e] * c;
        i[e] = g * t + v * n + _ * r + m * l;
      }

      return i;
    }

  }

  const Rn = new i._fP();

  class kn extends Cn {
    interpolate_(e, t, n, r) {
      const i = super.interpolate_(e, t, n, r);
      return Rn.fromArray(i).normalize().toArray(i), i;
    }

  }

  const Pn = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
        Dn = {
    9728: i.TyD,
    9729: i.wem,
    9984: i.YLQ,
    9985: i.qyh,
    9986: i.aH4,
    9987: i.D1R
  },
        On = {
    33071: i.uWy,
    33648: i.OoA,
    10497: i.rpg
  },
        Ln = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  },
        In = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  },
        Fn = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  },
        Nn = {
    CUBICSPLINE: void 0,
    LINEAR: i.NMF,
    STEP: i.Syv
  };

  function Un(e, t, n) {
    for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]);
  }

  function Bn(e, t) {
    void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
  }

  function jn(e, t) {
    if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];

    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const n = t.extras.targetNames;

      if (e.morphTargetInfluences.length === n.length) {
        e.morphTargetDictionary = {};

        for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }

  function zn(e) {
    const t = e.extensions && e.extensions[an.KHR_DRACO_MESH_COMPRESSION];
    let n;
    return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Vn(t.attributes) : e.indices + ":" + Vn(e.attributes) + ":" + e.mode, n;
  }

  function Vn(e) {
    let t = "";
    const n = Object.keys(e).sort();

    for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";

    return t;
  }

  function Gn(e) {
    switch (e) {
      case Int8Array:
        return 1 / 127;

      case Uint8Array:
        return 1 / 255;

      case Int16Array:
        return 1 / 32767;

      case Uint16Array:
        return 1 / 65535;

      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }

  class Hn {
    constructor(e = {}, t = {}) {
      this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new on(), this.associations = new Map(), this.primitiveCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
            r = navigator.userAgent.indexOf("Firefox") > -1,
            s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      "undefined" == typeof createImageBitmap || n || r && s < 98 ? this.textureLoader = new i.dpR(this.options.manager) : this.textureLoader = new i.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new i.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
    }

    setExtensions(e) {
      this.extensions = e;
    }

    setPlugins(e) {
      this.plugins = e;
    }

    parse(e, t) {
      const n = this,
            r = this.json,
            i = this.extensions;
      this.cache.removeAll(), this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }), Promise.all(this._invokeAll(function (e) {
        return e.beforeRoot && e.beforeRoot();
      })).then(function () {
        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]);
      }).then(function (t) {
        const s = {
          scene: t[0][r.scene || 0],
          scenes: t[0],
          animations: t[1],
          cameras: t[2],
          asset: r.asset,
          parser: n,
          userData: {}
        };
        Un(i, s, r), Bn(s, r), Promise.all(n._invokeAll(function (e) {
          return e.afterRoot && e.afterRoot(s);
        })).then(function () {
          e(s);
        });
      }).catch(t);
    }

    _markDefs() {
      const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];

      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n].joints;

        for (let t = 0, n = r.length; t < n; t++) e[r[t]].isBone = !0;
      }

      for (let t = 0, r = e.length; t < r; t++) {
        const r = e[t];
        void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera);
      }
    }

    _addNodeRef(e, t) {
      void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }

    _getNodeRef(e, t, n) {
      if (e.refs[t] <= 1) return n;

      const r = n.clone(),
            i = (e, t) => {
        const n = this.associations.get(e);
        null != n && this.associations.set(t, n);

        for (const [n, r] of e.children.entries()) i(r, t.children[n]);
      };

      return i(n, r), r.name += "_instance_" + e.uses[t]++, r;
    }

    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);

      for (let n = 0; n < t.length; n++) {
        const r = e(t[n]);
        if (r) return r;
      }

      return null;
    }

    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const n = [];

      for (let r = 0; r < t.length; r++) {
        const i = e(t[r]);
        i && n.push(i);
      }

      return n;
    }

    getDependency(e, t) {
      const n = e + ":" + t;
      let r = this.cache.get(n);

      if (!r) {
        switch (e) {
          case "scene":
            r = this.loadScene(t);
            break;

          case "node":
            r = this.loadNode(t);
            break;

          case "mesh":
            r = this._invokeOne(function (e) {
              return e.loadMesh && e.loadMesh(t);
            });
            break;

          case "accessor":
            r = this.loadAccessor(t);
            break;

          case "bufferView":
            r = this._invokeOne(function (e) {
              return e.loadBufferView && e.loadBufferView(t);
            });
            break;

          case "buffer":
            r = this.loadBuffer(t);
            break;

          case "material":
            r = this._invokeOne(function (e) {
              return e.loadMaterial && e.loadMaterial(t);
            });
            break;

          case "texture":
            r = this._invokeOne(function (e) {
              return e.loadTexture && e.loadTexture(t);
            });
            break;

          case "skin":
            r = this.loadSkin(t);
            break;

          case "animation":
            r = this._invokeOne(function (e) {
              return e.loadAnimation && e.loadAnimation(t);
            });
            break;

          case "camera":
            r = this.loadCamera(t);
            break;

          default:
            throw new Error("Unknown type: " + e);
        }

        this.cache.add(n, r);
      }

      return r;
    }

    getDependencies(e) {
      let t = this.cache.get(e);

      if (!t) {
        const n = this,
              r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
        t = Promise.all(r.map(function (t, r) {
          return n.getDependency(e, r);
        })), this.cache.add(e, t);
      }

      return t;
    }

    loadBuffer(e) {
      const t = this.json.buffers[e],
            n = this.fileLoader;
      if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
      if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[an.KHR_BINARY_GLTF].body);
      const r = this.options;
      return new Promise(function (e, s) {
        n.load(i.Zp0.resolveURL(t.uri, r.path), e, void 0, function () {
          s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
        });
      });
    }

    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function (e) {
        const n = t.byteLength || 0,
              r = t.byteOffset || 0;
        return e.slice(r, r + n);
      });
    }

    loadAccessor(e) {
      const t = this,
            n = this.json,
            r = this.json.accessors[e];
      if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
      const s = [];
      return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (e) {
        const s = e[0],
              o = Ln[r.type],
              a = Pn[r.componentType],
              l = a.BYTES_PER_ELEMENT,
              c = l * o,
              u = r.byteOffset || 0,
              p = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
              h = !0 === r.normalized;
        let d, f;

        if (p && p !== c) {
          const e = Math.floor(u / p),
                n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
          let c = t.cache.get(n);
          c || (d = new a(s, e * p, r.count * p / l), c = new i.vpT(d, p / l), t.cache.add(n, c)), f = new i.kB5(c, o, u % p / l, h);
        } else d = null === s ? new a(r.count * o) : new a(s, u, r.count * o), f = new i.TlE(d, o, h);

        if (void 0 !== r.sparse) {
          const t = Ln.SCALAR,
                n = Pn[r.sparse.indices.componentType],
                l = r.sparse.indices.byteOffset || 0,
                c = r.sparse.values.byteOffset || 0,
                u = new n(e[1], l, r.sparse.count * t),
                p = new a(e[2], c, r.sparse.count * o);
          null !== s && (f = new i.TlE(f.array.slice(), f.itemSize, f.normalized));

          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            if (f.setX(t, p[e * o]), o >= 2 && f.setY(t, p[e * o + 1]), o >= 3 && f.setZ(t, p[e * o + 2]), o >= 4 && f.setW(t, p[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }

        return f;
      });
    }

    loadTexture(e) {
      const t = this.json,
            n = this.options,
            r = t.textures[e].source,
            i = t.images[r];
      let s = this.textureLoader;

      if (i.uri) {
        const e = n.manager.getHandler(i.uri);
        null !== e && (s = e);
      }

      return this.loadTextureImage(e, r, s);
    }

    loadTextureImage(e, t, n) {
      const r = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
      if (this.textureCache[l]) return this.textureCache[l];
      const c = this.loadImageSource(t, n).then(function (t) {
        t.flipY = !1, o.name && (t.name = o.name);
        const n = (s.samplers || {})[o.sampler] || {};
        return t.magFilter = Dn[n.magFilter] || i.wem, t.minFilter = Dn[n.minFilter] || i.D1R, t.wrapS = On[n.wrapS] || i.rpg, t.wrapT = On[n.wrapT] || i.rpg, r.associations.set(t, {
          textures: e
        }), t;
      }).catch(function () {
        return null;
      });
      return this.textureCache[l] = c, c;
    }

    loadImageSource(e, t) {
      const n = this.json,
            r = this.options;
      if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then(e => e.clone());
      const s = n.images[e],
            o = self.URL || self.webkitURL;
      let a = s.uri || "",
          l = !1;
      if (void 0 !== s.bufferView) a = this.getDependency("bufferView", s.bufferView).then(function (e) {
        l = !0;
        const t = new Blob([e], {
          type: s.mimeType
        });
        return a = o.createObjectURL(t), a;
      });else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
      const c = Promise.resolve(a).then(function (e) {
        return new Promise(function (n, s) {
          let o = n;
          !0 === t.isImageBitmapLoader && (o = function (e) {
            const t = new i.xEZ(e);
            t.needsUpdate = !0, n(t);
          }), t.load(i.Zp0.resolveURL(e, r.path), o, void 0, s);
        });
      }).then(function (e) {
        var t;
        return !0 === l && o.revokeObjectURL(a), e.userData.mimeType = s.mimeType || ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e;
      }).catch(function (e) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e;
      });
      return this.sourceCache[e] = c, c;
    }

    assignTexture(e, t, n, r) {
      const i = this;
      return this.getDependency("texture", n.index).then(function (s) {
        if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[an.KHR_TEXTURE_TRANSFORM]) {
          const e = void 0 !== n.extensions ? n.extensions[an.KHR_TEXTURE_TRANSFORM] : void 0;

          if (e) {
            const t = i.associations.get(s);
            s = i.extensions[an.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), i.associations.set(s, t);
          }
        }

        return void 0 !== r && (s.encoding = r), e[t] = s, s;
      });
    }

    assignFinalMaterial(e) {
      const t = e.geometry;
      let n = e.material;
      const r = void 0 === t.attributes.tangent,
            s = void 0 !== t.attributes.color,
            o = void 0 === t.attributes.normal;

      if (e.isPoints) {
        const e = "PointsMaterial:" + n.uuid;
        let t = this.cache.get(e);
        t || (t = new i.UY4(), i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t;
      } else if (e.isLine) {
        const e = "LineBasicMaterial:" + n.uuid;
        let t = this.cache.get(e);
        t || (t = new i.nls(), i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t;
      }

      if (r || s || o) {
        let e = "ClonedMaterial:" + n.uuid + ":";
        n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), o && (e += "flat-shading:");
        let t = this.cache.get(e);
        t || (t = n.clone(), s && (t.vertexColors = !0), o && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t;
      }

      n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n;
    }

    getMaterialType() {
      return i.Wid;
    }

    loadMaterial(e) {
      const t = this,
            n = this.json,
            r = this.extensions,
            s = n.materials[e];
      let o;
      const a = {},
            l = s.extensions || {},
            c = [];

      if (l[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const e = r[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else if (l[an.KHR_MATERIALS_UNLIT]) {
        const e = r[an.KHR_MATERIALS_UNLIT];
        o = e.getMaterialType(), c.push(e.extendParams(a, s, t));
      } else {
        const n = s.pbrMetallicRoughness || {};

        if (a.color = new i.Ilk(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
          const e = n.baseColorFactor;
          a.color.fromArray(e), a.opacity = e[3];
        }

        void 0 !== n.baseColorTexture && c.push(t.assignTexture(a, "map", n.baseColorTexture, i.knz)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        }), c.push(Promise.all(this._invokeAll(function (t) {
          return t.extendMaterialParams && t.extendMaterialParams(e, a);
        })));
      }

      !0 === s.doubleSided && (a.side = i.ehD);
      const u = s.alphaMode || "OPAQUE";

      if ("BLEND" === u ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === u && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new i.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
        const e = s.normalTexture.scale;
        a.normalScale.set(e, e);
      }

      return void 0 !== s.occlusionTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== i.vBJ && (a.emissive = new i.Ilk().fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== i.vBJ && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, i.knz)), Promise.all(c).then(function () {
        let n;
        return n = o === Tn ? r[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new o(a), s.name && (n.name = s.name), Bn(n, s), t.associations.set(n, {
          materials: e
        }), s.extensions && Un(r, n, s), n;
      });
    }

    createUniqueName(e) {
      const t = i.iUV.sanitizeNodeName(e || "");
      let n = t;

      for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;

      return this.nodeNamesUsed[n] = !0, n;
    }

    loadGeometries(e) {
      const t = this,
            n = this.extensions,
            r = this.primitiveCache;

      function s(e) {
        return n[an.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (n) {
          return Kn(n, e, t);
        });
      }

      const o = [];

      for (let n = 0, a = e.length; n < a; n++) {
        const a = e[n],
              l = zn(a),
              c = r[l];
        if (c) o.push(c.promise);else {
          let e;
          e = a.extensions && a.extensions[an.KHR_DRACO_MESH_COMPRESSION] ? s(a) : Kn(new i.u9r(), a, t), r[l] = {
            primitive: a,
            promise: e
          }, o.push(e);
        }
      }

      return Promise.all(o);
    }

    loadMesh(e) {
      const t = this,
            n = this.json,
            r = this.extensions,
            s = n.meshes[e],
            o = s.primitives,
            a = [];

      for (let e = 0, t = o.length; e < t; e++) {
        const t = void 0 === o[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new i.Wid({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: i.Wl3
        })), l.DefaultMaterial) : this.getDependency("material", o[e].material);
        a.push(t);
      }

      var l;
      return a.push(t.loadGeometries(o)), Promise.all(a).then(function (n) {
        const a = n.slice(0, n.length - 1),
              l = n[n.length - 1],
              c = [];

        for (let n = 0, u = l.length; n < u; n++) {
          const u = l[n],
                p = o[n];
          let h;
          const d = a[n];
          if (4 === p.mode || 5 === p.mode || 6 === p.mode || void 0 === p.mode) h = !0 === s.isSkinnedMesh ? new i.TUv(u, d) : new i.Kj0(u, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), 5 === p.mode ? h.geometry = Xn(h.geometry, i.UlW) : 6 === p.mode && (h.geometry = Xn(h.geometry, i.z$h));else if (1 === p.mode) h = new i.ejS(u, d);else if (3 === p.mode) h = new i.x12(u, d);else if (2 === p.mode) h = new i.blk(u, d);else {
            if (0 !== p.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
            h = new i.woe(u, d);
          }
          Object.keys(h.geometry.morphAttributes).length > 0 && jn(h, s), h.name = t.createUniqueName(s.name || "mesh_" + e), Bn(h, s), p.extensions && Un(r, h, p), t.assignFinalMaterial(h), c.push(h);
        }

        s.extensions && c.forEach(e => Un(r, e, s));

        for (let n = 0, r = c.length; n < r; n++) t.associations.set(c[n], {
          meshes: e,
          primitives: n
        });

        if (1 === c.length) return c[0];
        const u = new i.ZAu();
        t.associations.set(u, {
          meshes: e
        });

        for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);

        return u;
      });
    }

    loadCamera(e) {
      let t;
      const n = this.json.cameras[e],
            r = n[n.type];
      if (r) return "perspective" === n.type ? t = new i.cPb(i.M8C.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new i.iKG(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Bn(t, n), Promise.resolve(t);
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }

    loadSkin(e) {
      const t = this.json.skins[e],
            n = {
        joints: t.joints
      };
      return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) {
        return n.inverseBindMatrices = e, n;
      });
    }

    loadAnimation(e) {
      const t = this.json.animations[e],
            n = [],
            r = [],
            s = [],
            o = [],
            a = [];

      for (let e = 0, i = t.channels.length; e < i; e++) {
        const i = t.channels[e],
              l = t.samplers[i.sampler],
              c = i.target,
              u = void 0 !== c.node ? c.node : c.id,
              p = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
              h = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
        n.push(this.getDependency("node", u)), r.push(this.getDependency("accessor", p)), s.push(this.getDependency("accessor", h)), o.push(l), a.push(c);
      }

      return Promise.all([Promise.all(n), Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a)]).then(function (n) {
        const r = n[0],
              s = n[1],
              o = n[2],
              a = n[3],
              l = n[4],
              c = [];

        for (let e = 0, t = r.length; e < t; e++) {
          const t = r[e],
                n = s[e],
                u = o[e],
                p = a[e],
                h = l[e];
          if (void 0 === t) continue;
          let d;

          switch (t.updateMatrix(), Fn[h.path]) {
            case Fn.weights:
              d = i.dUE;
              break;

            case Fn.rotation:
              d = i.iLg;
              break;

            case Fn.position:
            case Fn.scale:
            default:
              d = i.yC1;
          }

          const f = t.name ? t.name : t.uuid,
                _ = void 0 !== p.interpolation ? Nn[p.interpolation] : i.NMF,
                m = [];

          Fn[h.path] === Fn.weights ? t.traverse(function (e) {
            e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid);
          }) : m.push(f);
          let g = u.array;

          if (u.normalized) {
            const e = Gn(g.constructor),
                  t = new Float32Array(g.length);

            for (let n = 0, r = g.length; n < r; n++) t[n] = g[n] * e;

            g = t;
          }

          for (let e = 0, t = m.length; e < t; e++) {
            const t = new d(m[e] + "." + Fn[h.path], n.array, g, _);
            "CUBICSPLINE" === p.interpolation && (t.createInterpolant = function (e) {
              return new (this instanceof i.iLg ? kn : Cn)(this.times, this.values, this.getValueSize() / 3, e);
            }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t);
          }
        }

        const u = t.name ? t.name : "animation_" + e;
        return new i.m7l(u, void 0, c);
      });
    }

    createNodeMesh(e) {
      const t = this.json,
            n = this,
            r = t.nodes[e];
      return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function (e) {
        const t = n._getNodeRef(n.meshCache, r.mesh, e);

        return void 0 !== r.weights && t.traverse(function (e) {
          if (e.isMesh) for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t];
        }), t;
      });
    }

    loadNode(e) {
      const t = this.json,
            n = this.extensions,
            r = this,
            s = t.nodes[e],
            o = s.name ? r.createUniqueName(s.name) : "";
      return function () {
        const t = [],
              n = r._invokeOne(function (t) {
          return t.createNodeMesh && t.createNodeMesh(e);
        });

        return n && t.push(n), void 0 !== s.camera && t.push(r.getDependency("camera", s.camera).then(function (e) {
          return r._getNodeRef(r.cameraCache, s.camera, e);
        })), r._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        }).forEach(function (e) {
          t.push(e);
        }), Promise.all(t);
      }().then(function (t) {
        let a;
        if (a = !0 === s.isBone ? new i.N$j() : t.length > 1 ? new i.ZAu() : 1 === t.length ? t[0] : new i.Tme(), a !== t[0]) for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);

        if (s.name && (a.userData.name = s.name, a.name = o), Bn(a, s), s.extensions && Un(n, a, s), void 0 !== s.matrix) {
          const e = new i.yGw();
          e.fromArray(s.matrix), a.applyMatrix4(e);
        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);

        return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a;
      });
    }

    loadScene(e) {
      const t = this.json,
            n = this.extensions,
            r = this.json.scenes[e],
            s = this,
            o = new i.ZAu();
      r.name && (o.name = s.createUniqueName(r.name)), Bn(o, r), r.extensions && Un(n, o, r);
      const a = r.nodes || [],
            l = [];

      for (let e = 0, n = a.length; e < n; e++) l.push(Wn(a[e], o, t, s));

      return Promise.all(l).then(function () {
        return s.associations = (e => {
          const t = new Map();

          for (const [e, n] of s.associations) (e instanceof i.F5T || e instanceof i.xEZ) && t.set(e, n);

          return e.traverse(e => {
            const n = s.associations.get(e);
            null != n && t.set(e, n);
          }), t;
        })(o), o;
      });
    }

  }

  function Wn(e, t, n, r) {
    const s = n.nodes[e];
    return r.getDependency("node", e).then(function (e) {
      if (void 0 === s.skin) return e;
      let t;
      return r.getDependency("skin", s.skin).then(function (e) {
        t = e;
        const n = [];

        for (let e = 0, i = t.joints.length; e < i; e++) n.push(r.getDependency("node", t.joints[e]));

        return Promise.all(n);
      }).then(function (n) {
        return e.traverse(function (e) {
          if (!e.isMesh) return;
          const r = [],
                s = [];

          for (let e = 0, o = n.length; e < o; e++) {
            const o = n[e];

            if (o) {
              r.push(o);
              const n = new i.yGw();
              void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(n);
            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]);
          }

          e.bind(new i.OdW(r, s), e.matrixWorld);
        }), e;
      });
    }).then(function (e) {
      t.add(e);
      const i = [];

      if (s.children) {
        const t = s.children;

        for (let s = 0, o = t.length; s < o; s++) {
          const o = t[s];
          i.push(Wn(o, e, n, r));
        }
      }

      return Promise.all(i);
    });
  }

  function Kn(e, t, n) {
    const r = t.attributes,
          s = [];

    function o(t, r) {
      return n.getDependency("accessor", t).then(function (t) {
        e.setAttribute(r, t);
      });
    }

    for (const t in r) {
      const n = In[t] || t.toLowerCase();
      n in e.attributes || s.push(o(r[t], n));
    }

    if (void 0 !== t.indices && !e.index) {
      const r = n.getDependency("accessor", t.indices).then(function (t) {
        e.setIndex(t);
      });
      s.push(r);
    }

    return Bn(e, t), function (e, t, n) {
      const r = t.attributes,
            s = new i.ZzF();
      if (void 0 === r.POSITION) return;
      {
        const e = n.json.accessors[r.POSITION],
              t = e.min,
              o = e.max;
        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");

        if (s.set(new i.Pa4(t[0], t[1], t[2]), new i.Pa4(o[0], o[1], o[2])), e.normalized) {
          const t = Gn(Pn[e.componentType]);
          s.min.multiplyScalar(t), s.max.multiplyScalar(t);
        }
      }
      const o = t.targets;

      if (void 0 !== o) {
        const e = new i.Pa4(),
              t = new i.Pa4();

        for (let r = 0, i = o.length; r < i; r++) {
          const i = o[r];

          if (void 0 !== i.POSITION) {
            const r = n.json.accessors[i.POSITION],
                  s = r.min,
                  o = r.max;

            if (void 0 !== s && void 0 !== o) {
              if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), r.normalized) {
                const e = Gn(Pn[r.componentType]);
                t.multiplyScalar(e);
              }

              e.max(t);
            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }

        s.expandByVector(e);
      }

      e.boundingBox = s;
      const a = new i.aLr();
      s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = a;
    }(e, t, n), Promise.all(s).then(function () {
      return void 0 !== t.targets ? function (e, t, n) {
        let r = !1,
            i = !1,
            s = !1;

        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (s = !0), r && i && s) break;
        }

        if (!r && !i && !s) return Promise.resolve(e);
        const o = [],
              a = [],
              l = [];

        for (let c = 0, u = t.length; c < u; c++) {
          const u = t[c];

          if (r) {
            const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
            o.push(t);
          }

          if (i) {
            const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
            a.push(t);
          }

          if (s) {
            const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
            l.push(t);
          }
        }

        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (t) {
          const n = t[0],
                o = t[1],
                a = t[2];
          return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = o), s && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e;
        });
      }(e, t.targets, n) : e;
    });
  }

  function Xn(e, t) {
    let n = e.getIndex();

    if (null === n) {
      const t = [],
            r = e.getAttribute("position");
      if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;

      for (let e = 0; e < r.count; e++) t.push(e);

      e.setIndex(t), n = e.getIndex();
    }

    const r = n.count - 2,
          s = [];
    if (t === i.z$h) for (let e = 1; e <= r; e++) s.push(n.getX(0)), s.push(n.getX(e)), s.push(n.getX(e + 1));else for (let e = 0; e < r; e++) e % 2 == 0 ? (s.push(n.getX(e)), s.push(n.getX(e + 1)), s.push(n.getX(e + 2))) : (s.push(n.getX(e + 2)), s.push(n.getX(e + 1)), s.push(n.getX(e)));
    s.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o = e.clone();
    return o.setIndex(s), o;
  }

  class qn extends sn {
    constructor(e) {
      super(e), this.isGLTFLoader2 = !0;
    }

    async loadAsync(e, t) {
      const n = await super.loadAsync(e, t),
            r = n ? n.scene || n.scenes && n.scenes.length > 0 && n.scenes[0] : void 0;
      return r && n.animations.length > 0 && (r.animations = n.animations), r.traverse(e => {
        e.userData.gltfUUID && (e.uuid = e.userData.gltfUUID, delete e.userData.gltfUUID);
      }), r;
    }

    register(e) {
      return super.register(e);
    }

  }

  class Yn extends i.hH6 {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    async loadAsync(e, t) {
      const n = await this.parseAsync(e, t, !1),
            r = new i.IEO(n.data, n.width, n.height, i.wk1, this.type);
      return r.needsUpdate = !0, r.flipY = !0, r.encoding = i.rnI, r.minFilter = i.wem, r.magFilter = i.wem, r.source.data.complete = !0, r;
    }

    async parseAsync(e, t, n = !1) {
      if (!e.startsWith("data:")) {
        this.responseType = "blob";
        const n = await super.loadAsync(e, t);
        e = (e = await bt(n)).replace("application/octet-stream", "image/png");
      }

      const r = await At(e);
      let s = Uint8Array;
      return this.type === i.cLu ? s = Uint16Array : this.type === i.VzW && (s = Uint32Array), {
        data: function (e, t = 3, n = Uint16Array, r = !1) {
          let s;
          const o = e.byteLength >> 2,
                a = new n(o * t);

          for (let n = 0; n < o; n++) s = Math.pow(2, e[4 * n + 3] - 136), r ? (a[n * t] = Math.min(e[4 * n] * s, 65504), a[n * t + 1] = Math.min(e[4 * n + 1] * s, 65504), a[n * t + 2] = Math.min(e[4 * n + 2] * s, 65504)) : (a[n * t] = i.A5E.toHalfFloat(Math.min(e[4 * n] * s, 65504)), a[n * t + 1] = i.A5E.toHalfFloat(Math.min(e[4 * n + 1] * s, 65504)), a[n * t + 2] = i.A5E.toHalfFloat(Math.min(e[4 * n + 2] * s, 65504))), 4 === t && (a[n * t + 3] = i.A5E.toHalfFloat(1));

          return a;
        }(r.data, 4, s, n),
        width: r.width,
        height: r.height
      };
    }

    setDataType(e) {
      return this.type = e, this;
    }

  }

  class Zn extends i.Gql {
    constructor(e) {
      super(e), this._imageLoader = new i.S3k(e);
    }

    parseTextures2(e, t, n) {
      var r;

      for (const s of e) {
        const e = null === (r = null == s ? void 0 : s.userData) || void 0 === r ? void 0 : r.rootPath;

        if (e && (!s.image || !t[s.image])) {
          const r = new i.Hw6(this._imageLoader.load(e, n));
          if (!r) continue;
          s.image && (r.uuid = s.image), t[r.uuid] = r, s.image = r.uuid;
        }
      }

      return super.parseTextures(e, t);
    }

    parseMaterials2(e, t, n) {
      const r = {};
      return e.forEach(e => {
        if (!e) return;
        const i = { ...e
        },
              s = Object.keys(i);

        for (const e of s) if ("map" === e || e.endsWith("Map")) {
          const n = i[e];
          "string" == typeof n && (t[n] ? i[e] = t[n] : (console.warn(`Texture ${n} not found`), delete i[e]));
        }

        const o = n.generateFromTemplateType(i.type, i);
        o && (r[e.uuid] = o);
      }), r;
    }

  }

  const Jn = "WEBGI_viewer";

  function $n(e) {
    Us.Importers.push(new $t(qn, ["gltf", "glb", "data:model/gltf"], !0, (t, n) => {
      if (!t) return t;
      const r = t,
            i = new Zn(n.loadingManager);
      return r.register(rr(i)), r.register(nr(i)), r.register(ir(i)), r.register(e => new cr(e)), r.register(e => new ur(e)), r.register(e => new pr(e)), r.register(t => {
        var s, o, a, l, c, u, p, h, d;

        const f = Be() + ".drc",
              _ = Be() + ".ktx2",
              m = null === (a = null === (o = null === (s = t.json) || void 0 === s ? void 0 : s.extensionsRequired) || void 0 === o ? void 0 : o.includes) || void 0 === a ? void 0 : a.call(o, "KHR_draco_mesh_compression");

        if (m) {
          const e = n.registerFile(f);
          e && r.setDRACOLoader(e);
        }

        (null === (u = null === (c = null === (l = t.json) || void 0 === l ? void 0 : l.extensionsUsed) || void 0 === c ? void 0 : c.includes) || void 0 === u ? void 0 : u.call(c, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (r.setMeshoptDecoder(window.MeshoptDecoder), t.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
        const g = null === (d = null === (h = null === (p = t.json) || void 0 === p ? void 0 : p.extensionsUsed) || void 0 === h ? void 0 : h.includes) || void 0 === d ? void 0 : d.call(h, "KHR_texture_basisu");

        if (g) {
          const e = n.registerFile(_);
          e && (r.setKTX2Loader(e), t.options.ktx2Loader = e);
        }

        return {
          name: "GLTF2_HELPER_PLUGIN",
          afterRoot: async r => (m && n.unregisterFile(f), g && n.unregisterFile(_), sr(t, e, i))
        };
      }), r;
    }));
  }

  const Qn = "WEBGI_light_extras",
        er = "WEBGI_object3d_extras",
        tr = "WEBGI_material_extras",
        nr = e => e => ({
    name: "__" + er,
    afterRoot: async e => {
      (e.scenes || (e.scene ? [e.scene] : [])).forEach(e => {
        e.traverse(e => {
          var t, n;
          if (!e.isObject3D) return;
          const r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[er];
          if (!r) return void (e.isLight && !e.isAmbientLight && (e.castShadow = !0));
          const i = void 0 !== r.castShadow || void 0 !== r.receiveShadow;
          void 0 !== r.castShadow && (e.castShadow = r.castShadow), void 0 !== r.receiveShadow && (e.receiveShadow = r.receiveShadow), void 0 !== r.visible && (e.visible = r.visible), void 0 !== r.frustumCulled && (e.frustumCulled = r.frustumCulled), void 0 !== r.renderOrder && (e.renderOrder = r.renderOrder), void 0 !== r.layers && (e.layers.mask = r.layers), i && (e.userData.__keepShadowDef = !0), delete e.userData.gltfExtensions[er];
        });
      });
    }
  }),
        rr = e => e => ({
    name: "__" + tr,
    afterRoot: async e => {
      (e.scenes || (e.scene ? [e.scene] : [])).forEach(e => {
        e.traverse(e => {
          var t, n;
          const r = null == e ? void 0 : e.material;
          if (!(null == r ? void 0 : r.isMaterial)) return;
          const i = null === (n = null === (t = r.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[tr];
          i && (void 0 !== i.emissiveIntensity && (r.emissiveIntensity = i.emissiveIntensity), void 0 !== i.fog && (r.fog = i.fog), void 0 !== i.flatShading && (r.flatShading = i.flatShading), void 0 !== i.blending && (r.blending = i.blending), void 0 !== i.shadowSide && (r.shadowSide = i.shadowSide), void 0 !== i.depthTest && (r.depthTest = i.depthTest), void 0 !== i.depthWrite && (r.depthWrite = i.depthWrite), void 0 !== i.colorWrite && (r.colorWrite = i.colorWrite), void 0 !== i.wireframe && (r.wireframe = i.wireframe), void 0 !== i.wireframeLinewidth && (r.wireframeLinewidth = i.wireframeLinewidth), void 0 !== i.wireframeLinecap && (r.wireframeLinecap = i.wireframeLinecap), void 0 !== i.wireframeLinejoin && (r.wireframeLinejoin = i.wireframeLinejoin), void 0 !== i.rotation && (r.rotation = i.rotation), void 0 !== i.dithering && (r.dithering = i.dithering), void 0 !== i.alphaToCoverage && (r.alphaToCoverage = i.alphaToCoverage), void 0 !== i.premultipliedAlpha && (r.premultipliedAlpha = i.premultipliedAlpha), void 0 !== i.toneMapped && (r.toneMapped = i.toneMapped), void 0 !== i.reflectivity && (r.reflectivity = i.reflectivity), delete r.userData.gltfExtensions[tr]);
        });
      });
    }
  }),
        ir = e => t => ({
    name: "__" + Qn,
    afterRoot: async t => {
      (t.scenes || (t.scene ? [t.scene] : [])).forEach(t => {
        t.traverse(t => {
          var n, r;
          if (!t.isLight) return;
          const i = null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.gltfExtensions) || void 0 === r ? void 0 : r[Qn];
          i && (!t.shadow && i.shadow && console.error("Light has no shadow, cannot import", t, i), i.shadow && t.shadow && (void 0 !== i.shadow.bias && (t.shadow.bias = i.shadow.bias), void 0 !== i.shadow.normalBias && (t.shadow.normalBias = i.shadow.normalBias), void 0 !== i.shadow.radius && (t.shadow.radius = i.shadow.radius), void 0 !== i.shadow.mapSize && t.shadow.mapSize.fromArray(i.shadow.mapSize), void 0 !== i.shadow.camera && (t.shadow.camera = e.parseObject(i.shadow.camera))), delete t.userData.gltfExtensions[Qn]);
        });
      });
    }
  });

  async function sr(e, t, n, r) {
    var i;

    if (!r) {
      const n = e.json.scenes || [];

      if (1 !== n.length) {
        for (const r of n) await sr(e, t, r);

        return;
      }

      r = n[0];
    }

    const s = null === (i = r.extensions) || void 0 === i ? void 0 : i[Jn];
    if (!s) return;
    const o = [];
    Object.values(s.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && o.push(e.url), "Uint8Array" === e.url.type && e.url.data && o.push(e.url));
      });
    });

    for (const t of o) {
      const n = t.data.image,
            r = e.json.images[n],
            i = await e.getDependency("bufferView", r.bufferView);

      if (r.mimeType.startsWith("image/") && "Uint16Array" === t.type && "rgbe" === t.encoding) {
        const e = new Blob([i], {
          type: r.mimeType
        }),
              n = "data:image/png;base64," + btoa(await e.text());
        t.data = (await new Yn().parseAsync(n, void 0, !0)).data, delete t.encoding;
      } else t.data = i;
    }

    await t.getPlugin(Vs).importViewerConfig(s, n);
  }

  const or = "WEBGI_materials_bumpmap",
        ar = "WEBGI_materials_alphamap",
        lr = "WEBGI_materials_lightmap";

  class cr {
    constructor(e) {
      this.parser = e, this.name = or;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.bumpScale && (t.bumpScale = s.bumpScale), void 0 !== s.bumpTexture && i.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(i);
    }

  }

  class ur {
    constructor(e) {
      this.parser = e, this.name = lr;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.lightMapIntensity && (t.lightMapIntensity = s.lightMapIntensity), void 0 !== s.lightMapTexture && i.push(n.assignTexture(t, "lightMap", s.lightMapTexture)), Promise.all(i);
    }

  }

  class pr {
    constructor(e) {
      this.parser = e, this.name = ar;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser,
            r = n.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const i = [],
            s = r.extensions[this.name];
      return void 0 !== s.alphaTexture && i.push(n.assignTexture(t, "alphaMap", s.alphaTexture)), Promise.all(i);
    }

  }

  var hr = __webpackgi_require__(23);

  function dr() {
    Us.Importers.push(new $t(hr.Q, ["drc"], !0));
  }

  var fr = {},
      _r = Uint8Array,
      mr = Uint16Array,
      gr = Uint32Array,
      vr = new _r([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      br = new _r([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      xr = new _r([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      yr = function (e, t) {
    for (var n = new mr(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];

    var i = new gr(n[30]);

    for (r = 1; r < 30; ++r) for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;

    return [n, i];
  },
      wr = yr(vr, 2),
      Sr = wr[0],
      Mr = wr[1];

  Sr[28] = 258, Mr[258] = 28;

  for (var Tr = yr(br, 0), Er = Tr[0], Ar = Tr[1], Cr = new mr(32768), Rr = 0; Rr < 32768; ++Rr) {
    var kr = (43690 & Rr) >>> 1 | (21845 & Rr) << 1;
    kr = (61680 & (kr = (52428 & kr) >>> 2 | (13107 & kr) << 2)) >>> 4 | (3855 & kr) << 4, Cr[Rr] = ((65280 & kr) >>> 8 | (255 & kr) << 8) >>> 1;
  }

  var Pr = function (e, t, n) {
    for (var r = e.length, i = 0, s = new mr(t); i < r; ++i) ++s[e[i] - 1];

    var o,
        a = new mr(t);

    for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;

    if (n) {
      o = new mr(1 << t);
      var l = 15 - t;

      for (i = 0; i < r; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[Cr[p] >>> l] = c;
    } else for (o = new mr(r), i = 0; i < r; ++i) e[i] && (o[i] = Cr[a[e[i] - 1]++] >>> 15 - e[i]);

    return o;
  },
      Dr = new _r(288);

  for (Rr = 0; Rr < 144; ++Rr) Dr[Rr] = 8;

  for (Rr = 144; Rr < 256; ++Rr) Dr[Rr] = 9;

  for (Rr = 256; Rr < 280; ++Rr) Dr[Rr] = 7;

  for (Rr = 280; Rr < 288; ++Rr) Dr[Rr] = 8;

  var Or = new _r(32);

  for (Rr = 0; Rr < 32; ++Rr) Or[Rr] = 5;

  var Lr = Pr(Dr, 9, 0),
      Ir = Pr(Dr, 9, 1),
      Fr = Pr(Or, 5, 0),
      Nr = Pr(Or, 5, 1),
      Ur = function (e) {
    for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);

    return t;
  },
      Br = function (e, t, n) {
    var r = t / 8 | 0;
    return (e[r] | e[r + 1] << 8) >> (7 & t) & n;
  },
      jr = function (e, t) {
    var n = t / 8 | 0;
    return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t);
  },
      zr = function (e) {
    return (e / 8 | 0) + (7 & e && 1);
  },
      Vr = function (e, t, n) {
    (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
    var r = new (e instanceof mr ? mr : e instanceof gr ? gr : _r)(n - t);
    return r.set(e.subarray(t, n)), r;
  },
      Gr = function (e, t, n) {
    var r = e.length;
    if (!r || n && !n.l && r < 5) return t || new _r(0);
    var i = !t || n,
        s = !n || n.i;
    n || (n = {}), t || (t = new _r(3 * r));

    var o = function (e) {
      var n = t.length;

      if (e > n) {
        var r = new _r(Math.max(2 * n, e));
        r.set(t), t = r;
      }
    },
        a = n.f || 0,
        l = n.p || 0,
        c = n.b || 0,
        u = n.l,
        p = n.d,
        h = n.m,
        d = n.n,
        f = 8 * r;

    do {
      if (!u) {
        n.f = a = Br(e, l, 1);

        var _ = Br(e, l + 1, 3);

        if (l += 3, !_) {
          var m = e[(A = zr(l) + 4) - 4] | e[A - 3] << 8,
              g = A + m;

          if (g > r) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
          continue;
        }

        if (1 == _) u = Ir, p = Nr, h = 9, d = 5;else {
          if (2 != _) throw "invalid block type";
          var v = Br(e, l, 31) + 257,
              b = Br(e, l + 10, 15) + 4,
              x = v + Br(e, l + 5, 31) + 1;
          l += 14;

          for (var y = new _r(x), w = new _r(19), S = 0; S < b; ++S) w[xr[S]] = Br(e, l + 3 * S, 7);

          l += 3 * b;
          var M = Ur(w),
              T = (1 << M) - 1,
              E = Pr(w, M, 1);

          for (S = 0; S < x;) {
            var A,
                C = E[Br(e, l, T)];
            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;else {
              var R = 0,
                  k = 0;

              for (16 == A ? (k = 3 + Br(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + Br(e, l, 7), l += 3) : 18 == A && (k = 11 + Br(e, l, 127), l += 7); k--;) y[S++] = R;
            }
          }

          var P = y.subarray(0, v),
              D = y.subarray(v);
          h = Ur(P), d = Ur(D), u = Pr(P, h, 1), p = Pr(D, d, 1);
        }

        if (l > f) {
          if (s) throw "unexpected EOF";
          break;
        }
      }

      i && o(c + 131072);

      for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
        var F = (R = u[jr(e, l) & O]) >>> 4;

        if ((l += 15 & R) > f) {
          if (s) throw "unexpected EOF";
          break;
        }

        if (!R) throw "invalid length/literal";
        if (F < 256) t[c++] = F;else {
          if (256 == F) {
            I = l, u = null;
            break;
          }

          var N = F - 254;

          if (F > 264) {
            var U = vr[S = F - 257];
            N = Br(e, l, (1 << U) - 1) + Sr[S], l += U;
          }

          var B = p[jr(e, l) & L],
              j = B >>> 4;
          if (!B) throw "invalid distance";

          if (l += 15 & B, D = Er[j], j > 3 && (U = br[j], D += jr(e, l) & (1 << U) - 1, l += U), l > f) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + 131072);

          for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];

          c = z;
        }
      }

      n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d);
    } while (!a);

    return c == t.length ? t : Vr(t, 0, c);
  },
      Hr = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8;
  },
      Wr = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16;
  },
      Kr = function (e, t) {
    for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
      s: r,
      f: e[r]
    });

    var i = n.length,
        s = n.slice();
    if (!i) return [Qr, 0];

    if (1 == i) {
      var o = new _r(n[0].s + 1);
      return o[n[0].s] = 1, [o, 1];
    }

    n.sort(function (e, t) {
      return e.f - t.f;
    }), n.push({
      s: -1,
      f: 25001
    });
    var a = n[0],
        l = n[1],
        c = 0,
        u = 1,
        p = 2;

    for (n[0] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    };

    var h = s[0].s;

    for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);

    var d = new mr(h + 1),
        f = Xr(n[u - 1], d, 0);

    if (f > t) {
      r = 0;
      var _ = 0,
          m = f - t,
          g = 1 << m;

      for (s.sort(function (e, t) {
        return d[t.s] - d[e.s] || e.f - t.f;
      }); r < i; ++r) {
        var v = s[r].s;
        if (!(d[v] > t)) break;
        _ += g - (1 << f - d[v]), d[v] = t;
      }

      for (_ >>>= m; _ > 0;) {
        var b = s[r].s;
        d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r;
      }

      for (; r >= 0 && _; --r) {
        var x = s[r].s;
        d[x] == t && (--d[x], ++_);
      }

      f = t;
    }

    return [new _r(d), f];
  },
      Xr = function (e, t, n) {
    return -1 == e.s ? Math.max(Xr(e.l, t, n + 1), Xr(e.r, t, n + 1)) : t[e.s] = n;
  },
      qr = function (e) {
    for (var t = e.length; t && !e[--t];);

    for (var n = new mr(++t), r = 0, i = e[0], s = 1, o = function (e) {
      n[r++] = e;
    }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
      if (!i && s > 2) {
        for (; s > 138; s -= 138) o(32754);

        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(i), --s; s > 6; s -= 6) o(8304);

        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }

      for (; s--;) o(i);

      s = 1, i = e[a];
    }

    return [n.subarray(0, r), t];
  },
      Yr = function (e, t) {
    for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];

    return n;
  },
      Zr = function (e, t, n) {
    var r = n.length,
        i = zr(t + 2);
    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];

    for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];

    return 8 * (i + 4 + r);
  },
      Jr = function (e, t, n, r, i, s, o, a, l, c, u) {
    Hr(t, u++, n), ++i[256];

    for (var p = Kr(i, 15), h = p[0], d = p[1], f = Kr(s, 15), _ = f[0], m = f[1], g = qr(h), v = g[0], b = g[1], x = qr(_), y = x[0], w = x[1], S = new mr(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;

    for (M = 0; M < y.length; ++M) S[31 & y[M]]++;

    for (var T = Kr(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[xr[C - 1]]; --C);

    var R,
        k,
        P,
        D,
        O = c + 5 << 3,
        L = Yr(i, Dr) + Yr(s, Or) + o,
        I = Yr(i, h) + Yr(s, _) + o + 14 + 3 * C + Yr(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
    if (O <= L && O <= I) return Zr(t, u, e.subarray(l, l + c));

    if (Hr(t, u, 1 + (I < L)), u += 2, I < L) {
      R = Pr(h, d, 0), k = h, P = Pr(_, m, 0), D = _;
      var F = Pr(E, A, 0);

      for (Hr(t, u, b - 257), Hr(t, u + 5, w - 1), Hr(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) Hr(t, u + 3 * M, E[xr[M]]);

      u += 3 * C;

      for (var N = [v, y], U = 0; U < 2; ++U) {
        var B = N[U];

        for (M = 0; M < B.length; ++M) {
          var j = 31 & B[M];
          Hr(t, u, F[j]), u += E[j], j > 15 && (Hr(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12);
        }
      }
    } else R = Lr, k = Dr, P = Fr, D = Or;

    for (M = 0; M < a; ++M) if (r[M] > 255) {
      j = r[M] >>> 18 & 31, Wr(t, u, R[j + 257]), u += k[j + 257], j > 7 && (Hr(t, u, r[M] >>> 23 & 31), u += vr[j]);
      var z = 31 & r[M];
      Wr(t, u, P[z]), u += D[z], z > 3 && (Wr(t, u, r[M] >>> 5 & 8191), u += br[z]);
    } else Wr(t, u, R[r[M]]), u += k[r[M]];

    return Wr(t, u, R[256]), u + k[256];
  },
      $r = new gr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
      Qr = new _r(0),
      ei = function (e, t, n, r, i, s) {
    var o = e.length,
        a = new _r(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(r, a.length - i),
        c = 0;
    if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
      var p = u + 65535;
      p < o ? c = Zr(l, c, e.subarray(u, p)) : (l[u] = s, c = Zr(l, c, e.subarray(u, o)));
    } else {
      for (var h = $r[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new mr(32768), g = new mr(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function (t) {
        return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _;
      }, y = new gr(25e3), w = new mr(288), S = new mr(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
        var R = x(u),
            k = 32767 & u,
            P = g[R];

        if (m[k] = P, g[R] = k, A <= u) {
          var D = o - u;

          if ((M > 7e3 || E > 24576) && D > 423) {
            c = Jr(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;

            for (var O = 0; O < 286; ++O) w[O] = 0;

            for (O = 0; O < 30; ++O) S[O] = 0;
          }

          var L = 2,
              I = 0,
              F = f,
              N = k - P & 32767;
          if (D > 2 && R == x(u - N)) for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
            if (e[u + L] == e[u + L - N]) {
              for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);

              if (z > L) {
                if (L = z, I = N, z > U) break;
                var V = Math.min(N, z - 2),
                    G = 0;

                for (O = 0; O < V; ++O) {
                  var H = u - N + O + 32768 & 32767,
                      W = H - m[H] + 32768 & 32767;
                  W > G && (G = W, P = H);
                }
              }
            }

            N += (k = P) - (P = m[k]) + 32768 & 32767;
          }

          if (I) {
            y[E++] = 268435456 | Mr[L] << 18 | Ar[I];
            var K = 31 & Mr[L],
                X = 31 & Ar[I];
            T += vr[K] + br[X], ++w[257 + K], ++S[X], A = u + L, ++M;
          } else y[E++] = e[u], ++w[e[u]];
        }
      }

      c = Jr(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = Zr(l, c + 1, Qr));
    }
    return Vr(a, 0, r + zr(c) + i);
  },
      ti = function () {
    for (var e = new Int32Array(256), t = 0; t < 256; ++t) {
      for (var n = t, r = 9; --r;) n = (1 & n && -306674912) ^ n >>> 1;

      e[t] = n;
    }

    return e;
  }(),
      ni = function () {
    var e = -1;
    return {
      p: function (t) {
        for (var n = e, r = 0; r < t.length; ++r) n = ti[255 & n ^ t[r]] ^ n >>> 8;

        e = n;
      },
      d: function () {
        return ~e;
      }
    };
  },
      ri = function () {
    var e = 1,
        t = 0;
    return {
      p: function (n) {
        for (var r = e, i = t, s = n.length, o = 0; o != s;) {
          for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];

          r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16);
        }

        e = r, t = i;
      },
      d: function () {
        return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
      }
    };
  },
      ii = function (e, t, n, r, i) {
    return ei(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i);
  },
      si = function (e, t) {
    var n = {};

    for (var r in e) n[r] = e[r];

    for (var r in t) n[r] = t[r];

    return n;
  },
      oi = function (e, t, n) {
    for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
      var a = r[o],
          l = s[o];

      if ("function" == typeof a) {
        t += ";" + l + "=";
        var c = a.toString();
        if (a.prototype) {
          if (-1 != c.indexOf("[native code]")) {
            var u = c.indexOf(" ", 8) + 1;
            t += c.slice(u, c.indexOf("(", u));
          } else for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
        } else t += c;
      } else n[l] = a;
    }

    return [t, n];
  },
      ai = [],
      li = function (e, t, n, r) {
    var i;

    if (!ai[n]) {
      for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = oi(e[l], s, o))[0], o = i[1];

      ai[n] = oi(e[a], s, o);
    }

    var c = si({}, ai[n][1]);
    return function (e, t, n, r, i) {
      var s = new Worker(fr[t] || (fr[t] = URL.createObjectURL(new Blob([e], {
        type: "text/javascript"
      }))));
      return s.onerror = function (e) {
        return i(e.error, null);
      }, s.onmessage = function (e) {
        return i(null, e.data);
      }, s.postMessage(n, r), s;
    }(ai[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function (e) {
      var t = [];

      for (var n in e) (e[n] instanceof _r || e[n] instanceof mr || e[n] instanceof gr) && t.push((e[n] = new e[n].constructor(e[n])).buffer);

      return t;
    }(c), r);
  },
      ci = function () {
    return [_r, mr, gr, vr, br, xr, Sr, Er, Ir, Nr, Cr, Pr, Ur, Br, jr, zr, Vr, Gr, Ui, _i, mi];
  },
      ui = function () {
    return [_r, mr, gr, vr, br, xr, Mr, Ar, Lr, Dr, Fr, Or, Cr, $r, Qr, Pr, Hr, Wr, Kr, Xr, qr, Yr, Zr, Jr, zr, Vr, ei, ii, Li, _i];
  },
      pi = function () {
    return [Mi, Ai, Si, ni, ti];
  },
      hi = function () {
    return [Ti, Ei];
  },
      di = function () {
    return [Ci, Si, ri];
  },
      fi = function () {
    return [Ri];
  },
      _i = function (e) {
    return postMessage(e, [e.buffer]);
  },
      mi = function (e) {
    return e && e.size && new _r(e.size);
  },
      gi = function (e, t, n, r, i, s) {
    var o = li(n, r, i, function (e, t) {
      o.terminate(), s(e, t);
    });
    return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
      o.terminate();
    };
  },
      vi = function (e) {
    return e.ondata = function (e, t) {
      return postMessage([e, t], [e.buffer]);
    }, function (t) {
      return e.push(t.data[0], t.data[1]);
    };
  },
      bi = function (e, t, n, r, i) {
    var s,
        o = li(e, r, i, function (e, n) {
      e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]));
    });
    o.postMessage(n), t.push = function (e, n) {
      if (s) throw "stream finished";
      if (!t.ondata) throw "no stream handler";
      o.postMessage([e, s = n], [e.buffer]);
    }, t.terminate = function () {
      o.terminate();
    };
  },
      xi = function (e, t) {
    return e[t] | e[t + 1] << 8;
  },
      yi = function (e, t) {
    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
  },
      wi = function (e, t) {
    return yi(e, t) + 4294967296 * yi(e, t + 4);
  },
      Si = function (e, t, n) {
    for (; n; ++t) e[t] = n, n >>>= 8;
  },
      Mi = function (e, t) {
    var n = t.filename;

    if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Si(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
      e[3] = 8;

      for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r);
    }
  },
      Ti = function (e) {
    if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
    var t = e[3],
        n = 10;
    4 & t && (n += e[10] | 2 + (e[11] << 8));

    for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);

    return n + (2 & t);
  },
      Ei = function (e) {
    var t = e.length;
    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
  },
      Ai = function (e) {
    return 10 + (e.filename && e.filename.length + 1 || 0);
  },
      Ci = function (e, t) {
    var n = t.level,
        r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
    e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1);
  },
      Ri = function (e) {
    if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
    if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
  };

  function ki(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }

  var Pi = function () {
    function e(e, t) {
      t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
    }

    return e.prototype.p = function (e, t) {
      this.ondata(ii(e, this.o, 0, 0, !t), t);
    }, e.prototype.push = function (e, t) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      this.d = t, this.p(e, t || !1);
    }, e;
  }(),
      Di = function () {
    return function (e, t) {
      bi([ui, function () {
        return [vi, Pi];
      }], this, ki.call(this, e, t), function (e) {
        var t = new Pi(e.data);
        onmessage = vi(t);
      }, 6);
    };
  }();

  function Oi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ui], function (e) {
      return _i(Li(e.data[0], e.data[1]));
    }, 0, n);
  }

  function Li(e, t) {
    return ii(e, t || {}, 0, 0);
  }

  var Ii = function () {
    function e(e) {
      this.s = {}, this.p = new _r(0), this.ondata = e;
    }

    return e.prototype.e = function (e) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      var t = this.p.length,
          n = new _r(t + e.length);
      n.set(this.p), n.set(e, t), this.p = n;
    }, e.prototype.c = function (e) {
      this.d = this.s.i = e || !1;
      var t = this.s.b,
          n = Gr(this.p, this.o, this.s);
      this.ondata(Vr(n, t, this.s.b), this.d), this.o = Vr(n, this.s.b - 32768), this.s.b = this.o.length, this.p = Vr(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e.prototype.push = function (e, t) {
      this.e(e), this.c(t);
    }, e;
  }(),
      Fi = function () {
    return function (e) {
      this.ondata = e, bi([ci, function () {
        return [vi, Ii];
      }], this, 0, function () {
        var e = new Ii();
        onmessage = vi(e);
      }, 7);
    };
  }();

  function Ni(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ci], function (e) {
      return _i(Ui(e.data[0], mi(e.data[1])));
    }, 1, n);
  }

  function Ui(e, t) {
    return Gr(e, t);
  }

  var Bi = function () {
    function e(e, t) {
      this.c = ni(), this.l = 0, this.v = 1, Pi.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      Pi.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e), this.l += e.length;
      var n = ii(e, this.o, this.v && Ai(this.o), t && 8, !t);
      this.v && (Mi(n, this.o), this.v = 0), t && (Si(n, n.length - 8, this.c.d()), Si(n, n.length - 4, this.l)), this.ondata(n, t);
    }, e;
  }(),
      ji = function () {
    return function (e, t) {
      bi([ui, pi, function () {
        return [vi, Pi, Bi];
      }], this, ki.call(this, e, t), function (e) {
        var t = new Bi(e.data);
        onmessage = vi(t);
      }, 8);
    };
  }();

  function zi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ui, pi, function () {
      return [Vi];
    }], function (e) {
      return _i(Vi(e.data[0], e.data[1]));
    }, 2, n);
  }

  function Vi(e, t) {
    t || (t = {});
    var n = ni(),
        r = e.length;
    n.p(e);
    var i = ii(e, t, Ai(t), 8),
        s = i.length;
    return Mi(i, t), Si(i, s - 8, n.d()), Si(i, s - 4, r), i;
  }

  var Gi = function () {
    function e(e) {
      this.v = 1, Ii.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (Ii.prototype.e.call(this, e), this.v) {
        var n = this.p.length > 3 ? Ti(this.p) : 4;
        if (n >= this.p.length && !t) return;
        this.p = this.p.subarray(n), this.v = 0;
      }

      if (t) {
        if (this.p.length < 8) throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }

      Ii.prototype.c.call(this, t);
    }, e;
  }(),
      Hi = function () {
    return function (e) {
      this.ondata = e, bi([ci, hi, function () {
        return [vi, Ii, Gi];
      }], this, 0, function () {
        var e = new Gi();
        onmessage = vi(e);
      }, 9);
    };
  }();

  function Wi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ci, hi, function () {
      return [Ki];
    }], function (e) {
      return _i(Ki(e.data[0]));
    }, 3, n);
  }

  function Ki(e, t) {
    return Gr(e.subarray(Ti(e), -8), t || new _r(Ei(e)));
  }

  var Xi = function () {
    function e(e, t) {
      this.c = ri(), this.v = 1, Pi.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      Pi.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e);
      var n = ii(e, this.o, this.v && 2, t && 4, !t);
      this.v && (Ci(n, this.o), this.v = 0), t && Si(n, n.length - 4, this.c.d()), this.ondata(n, t);
    }, e;
  }(),
      qi = function () {
    return function (e, t) {
      bi([ui, di, function () {
        return [vi, Pi, Xi];
      }], this, ki.call(this, e, t), function (e) {
        var t = new Xi(e.data);
        onmessage = vi(t);
      }, 10);
    };
  }();

  function Yi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ui, di, function () {
      return [Zi];
    }], function (e) {
      return _i(Zi(e.data[0], e.data[1]));
    }, 4, n);
  }

  function Zi(e, t) {
    t || (t = {});
    var n = ri();
    n.p(e);
    var r = ii(e, t, 2, 4);
    return Ci(r, t), Si(r, r.length - 4, n.d()), r;
  }

  var Ji = function () {
    function e(e) {
      this.v = 1, Ii.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (Ii.prototype.e.call(this, e), this.v) {
        if (this.p.length < 2 && !t) return;
        this.p = this.p.subarray(2), this.v = 0;
      }

      if (t) {
        if (this.p.length < 4) throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }

      Ii.prototype.c.call(this, t);
    }, e;
  }(),
      $i = function () {
    return function (e) {
      this.ondata = e, bi([ci, fi, function () {
        return [vi, Ii, Ji];
      }], this, 0, function () {
        var e = new Ji();
        onmessage = vi(e);
      }, 11);
    };
  }();

  function Qi(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return gi(e, t, [ci, fi, function () {
      return [es];
    }], function (e) {
      return _i(es(e.data[0], mi(e.data[1])));
    }, 5, n);
  }

  function es(e, t) {
    return Gr((Ri(e), e.subarray(2, -4)), t);
  }

  var ts = function () {
    function e(e) {
      this.G = Gi, this.I = Ii, this.Z = Ji, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no stream handler";
      if (this.s) this.s.push(e, t);else {
        if (this.p && this.p.length) {
          var n = new _r(this.p.length + e.length);
          n.set(this.p), n.set(e, this.p.length);
        } else this.p = e;

        if (this.p.length > 2) {
          var r = this,
              i = function () {
            r.ondata.apply(r, arguments);
          };

          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
        }
      }
    }, e;
  }(),
      ns = function () {
    function e(e) {
      this.G = Hi, this.I = Fi, this.Z = $i, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      ts.prototype.push.call(this, e, t);
    }, e;
  }();

  function rs(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Wi(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ni(e, t, n) : Qi(e, t, n);
  }

  function is(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Ki(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ui(e, t) : es(e, t);
  }

  var ss = function (e, t, n, r) {
    for (var i in e) {
      var s = e[i],
          o = t + i;
      s instanceof _r ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], si(r, s[1])] : ss(s, o + "/", n, r);
    }
  },
      os = "undefined" != typeof TextEncoder && new TextEncoder(),
      as = "undefined" != typeof TextDecoder && new TextDecoder(),
      ls = 0;

  try {
    as.decode(Qr, {
      stream: !0
    }), ls = 1;
  } catch (Eu) {}

  var cs = function (e) {
    for (var t = "", n = 0;;) {
      var r = e[n++],
          i = (r > 127) + (r > 223) + (r > 239);
      if (n + i > e.length) return [t, Vr(e, n - 1)];
      i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r);
    }
  },
      us = function () {
    function e(e) {
      this.ondata = e, ls ? this.t = new TextDecoder() : this.p = Qr;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";

      if (t = !!t, this.t) {
        if (this.ondata(this.t.decode(e, {
          stream: !0
        }), t), t) {
          if (this.t.decode().length) throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p) throw "stream finished";
        var n = new _r(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length);
        var r = cs(n),
            i = r[0],
            s = r[1];

        if (t) {
          if (s.length) throw "invalid utf-8 data";
          this.p = null;
        } else this.p = s;

        this.ondata(i, t);
      }
    }, e;
  }(),
      ps = function () {
    function e(e) {
      this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";
      if (this.d) throw "stream finished";
      this.ondata(hs(e), this.d = t || !1);
    }, e;
  }();

  function hs(e, t) {
    if (t) {
      for (var n = new _r(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);

      return n;
    }

    if (os) return os.encode(e);

    var i = e.length,
        s = new _r(e.length + (e.length >> 1)),
        o = 0,
        a = function (e) {
      s[o++] = e;
    };

    for (r = 0; r < i; ++r) {
      if (o + 5 > s.length) {
        var l = new _r(o + 8 + (i - r << 1));
        l.set(s), s = l;
      }

      var c = e.charCodeAt(r);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }

    return Vr(s, 0, o);
  }

  function ds(e, t) {
    if (t) {
      for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));

      return n;
    }

    if (as) return as.decode(e);
    var i = cs(e),
        s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }

  var fs = function (e) {
    return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
  },
      _s = function (e, t) {
    return t + 30 + xi(e, t + 26) + xi(e, t + 28);
  },
      ms = function (e, t, n) {
    var r = xi(e, t + 28),
        i = ds(e.subarray(t + 46, t + 46 + r), !(2048 & xi(e, t + 8))),
        s = t + 46 + r,
        o = yi(e, t + 20),
        a = n && 4294967295 == o ? gs(e, s) : [o, yi(e, t + 24), yi(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
    return [xi(e, t + 10), l, c, i, s + xi(e, t + 30) + xi(e, t + 32), u];
  },
      gs = function (e, t) {
    for (; 1 != xi(e, t); t += 4 + xi(e, t + 2));

    return [wi(e, t + 12), wi(e, t + 4), wi(e, t + 20)];
  },
      vs = function (e) {
    var t = 0;
    if (e) for (var n in e) {
      var r = e[n].length;
      if (r > 65535) throw "extra field too long";
      t += r + 4;
    }
    return t;
  },
      bs = function (e, t, n, r, i, s, o, a) {
    var l = r.length,
        c = n.extra,
        u = a && a.length,
        p = vs(c);
    Si(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
    var h = new Date(null == n.mtime ? Date.now() : n.mtime),
        d = h.getFullYear() - 1980;
    if (d < 0 || d > 119) throw "date not in range 1980-2099";
    if (Si(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (Si(e, t, n.crc), Si(e, t + 4, s), Si(e, t + 8, n.size)), Si(e, t + 12, l), Si(e, t + 14, p), t += 16, null != o && (Si(e, t, u), Si(e, t + 6, n.attrs), Si(e, t + 10, o), t += 14), e.set(r, t), t += l, p) for (var f in c) {
      var _ = c[f],
          m = _.length;
      Si(e, t, +f), Si(e, t + 2, m), e.set(_, t + 4), t += 4 + m;
    }
    return u && (e.set(a, t), t += u), t;
  },
      xs = function (e, t, n, r, i) {
    Si(e, t, 101010256), Si(e, t + 8, n), Si(e, t + 10, n), Si(e, t + 12, r), Si(e, t + 16, i);
  },
      ys = function () {
    function e(e) {
      this.filename = e, this.c = ni(), this.size = 0, this.compression = 0;
    }

    return e.prototype.process = function (e, t) {
      this.ondata(null, e, t);
    }, e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
      this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
    }, e;
  }(),
      ws = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), ys.call(this, e), this.d = new Pi(t, function (e, t) {
        n.ondata(null, e, t);
      }), this.compression = 8, this.flag = fs(t.level);
    }

    return e.prototype.process = function (e, t) {
      try {
        this.d.push(e, t);
      } catch (e) {
        this.ondata(e, null, t);
      }
    }, e.prototype.push = function (e, t) {
      ys.prototype.push.call(this, e, t);
    }, e;
  }(),
      Ss = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), ys.call(this, e), this.d = new Di(t, function (e, t, r) {
        n.ondata(e, t, r);
      }), this.compression = 8, this.flag = fs(t.level), this.terminate = this.d.terminate;
    }

    return e.prototype.process = function (e, t) {
      this.d.push(e, t);
    }, e.prototype.push = function (e, t) {
      ys.prototype.push.call(this, e, t);
    }, e;
  }(),
      Ms = function () {
    function e(e) {
      this.ondata = e, this.u = [], this.d = 1;
    }

    return e.prototype.add = function (e) {
      var t = this;
      if (2 & this.d) throw "stream finished";
      var n = hs(e.filename),
          r = n.length,
          i = e.comment,
          s = i && hs(i),
          o = r != e.filename.length || s && i.length != s.length,
          a = r + vs(e.extra) + 30;
      if (r > 65535) throw "filename too long";
      var l = new _r(a);
      bs(l, 0, e, n, o);

      var c = [l],
          u = function () {
        for (var e = 0, n = c; e < n.length; e++) {
          var r = n[e];
          t.ondata(null, r, !1);
        }

        c = [];
      },
          p = this.d;

      this.d = 0;
      var h = this.u.length,
          d = si(e, {
        f: n,
        u: o,
        o: s,
        t: function () {
          e.terminate && e.terminate();
        },
        r: function () {
          if (u(), p) {
            var e = t.u[h + 1];
            e ? e.r() : t.d = 1;
          }

          p = 1;
        }
      }),
          f = 0;
      e.ondata = function (n, r, i) {
        if (n) t.ondata(n, r, i), t.terminate();else if (f += r.length, c.push(r), i) {
          var s = new _r(16);
          Si(s, 0, 134695760), Si(s, 4, e.crc), Si(s, 8, f), Si(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1;
        } else p && u();
      }, this.u.push(d);
    }, e.prototype.end = function () {
      var e = this;

      if (2 & this.d) {
        if (1 & this.d) throw "stream finishing";
        throw "stream finished";
      }

      this.d ? this.e() : this.u.push({
        r: function () {
          1 & e.d && (e.u.splice(-1, 1), e.e());
        },
        t: function () {}
      }), this.d = 3;
    }, e.prototype.e = function () {
      for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + vs(l.extra) + (l.o ? l.o.length : 0);

      for (var s = new _r(n + 22), o = 0, a = this.u; o < a.length; o++) {
        var l = a[o];
        bs(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + vs(l.extra) + (l.o ? l.o.length : 0), t += l.b;
      }

      xs(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2;
    }, e.prototype.terminate = function () {
      for (var e = 0, t = this.u; e < t.length; e++) t[e].t();

      this.d = 2;
    }, e;
  }();

  function Ts(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    var r = {};
    ss(e, "", r, t);

    var i = Object.keys(r),
        s = i.length,
        o = 0,
        a = 0,
        l = s,
        c = new Array(s),
        u = [],
        p = function () {
      for (var e = 0; e < u.length; ++e) u[e]();
    },
        h = function () {
      var e = new _r(a + 22),
          t = o,
          r = a - o;
      a = 0;

      for (var i = 0; i < l; ++i) {
        var s = c[i];

        try {
          var u = s.c.length;
          bs(e, a, s, s.f, s.u, u);
          var p = 30 + s.f.length + vs(s.extra),
              h = a + p;
          e.set(s.c, h), bs(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u;
        } catch (e) {
          return n(e, null);
        }
      }

      xs(e, o, c.length, r, t), n(null, e);
    };

    s || h();

    for (var d = function (e) {
      var t = i[e],
          l = r[t],
          d = l[0],
          f = l[1],
          _ = ni(),
          m = d.length;

      _.p(d);

      var g = hs(t),
          v = g.length,
          b = f.comment,
          x = b && hs(b),
          y = x && x.length,
          w = vs(f.extra),
          S = 0 == f.level ? 0 : 8,
          M = function (r, i) {
        if (r) p(), n(r, null);else {
          var l = i.length;
          c[e] = si(f, {
            size: m,
            crc: _.d(),
            c: i,
            f: g,
            m: x,
            u: v != t.length || x && b.length != y,
            compression: S
          }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h();
        }
      };

      if (v > 65535 && M("filename too long", null), S) {
        if (m < 16e4) try {
          M(null, Li(d, f));
        } catch (e) {
          M(e, null);
        } else u.push(Oi(d, f, M));
      } else M(null, d);
    }, f = 0; f < l; ++f) d(f);

    return p;
  }

  function Es(e, t) {
    t || (t = {});
    var n = {},
        r = [];
    ss(e, "", n, t);
    var i = 0,
        s = 0;

    for (var o in n) {
      var a = n[o],
          l = a[0],
          c = a[1],
          u = 0 == c.level ? 0 : 8,
          p = (S = hs(o)).length,
          h = c.comment,
          d = h && hs(h),
          f = d && d.length,
          _ = vs(c.extra);

      if (p > 65535) throw "filename too long";
      var m = u ? Li(l, c) : l,
          g = m.length,
          v = ni();
      v.p(l), r.push(si(c, {
        size: l.length,
        crc: v.d(),
        c: m,
        f: S,
        m: d,
        u: p != o.length || d && h.length != f,
        o: i,
        compression: u
      })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g;
    }

    for (var b = new _r(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
      var S = r[w];
      bs(b, S.o, S, S.f, S.u, S.c.length);
      var M = 30 + S.f.length + vs(S.extra);
      b.set(S.c, S.o + M), bs(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0);
    }

    return xs(b, i, r.length, y, x), b;
  }

  var As = function () {
    function e() {}

    return e.prototype.push = function (e, t) {
      this.ondata(null, e, t);
    }, e.compression = 0, e;
  }(),
      Cs = function () {
    function e() {
      var e = this;
      this.i = new Ii(function (t, n) {
        e.ondata(null, t, n);
      });
    }

    return e.prototype.push = function (e, t) {
      try {
        this.i.push(e, t);
      } catch (n) {
        this.ondata(n, e, t);
      }
    }, e.compression = 8, e;
  }(),
      Rs = function () {
    function e(e, t) {
      var n = this;
      t < 32e4 ? this.i = new Ii(function (e, t) {
        n.ondata(null, e, t);
      }) : (this.i = new Fi(function (e, t, r) {
        n.ondata(e, t, r);
      }), this.terminate = this.i.terminate);
    }

    return e.prototype.push = function (e, t) {
      this.i.terminate && (e = Vr(e, 0)), this.i.push(e, t);
    }, e.compression = 8, e;
  }(),
      ks = function () {
    function e(e) {
      this.onfile = e, this.k = [], this.o = {
        0: As
      }, this.p = Qr;
    }

    return e.prototype.push = function (e, t) {
      var n = this;
      if (!this.onfile) throw "no callback";
      if (!this.p) throw "stream finished";

      if (this.c > 0) {
        var r = Math.min(this.c, e.length),
            i = e.subarray(0, r);
        if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t);
      } else {
        var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
        this.p.length ? e.length ? ((l = new _r(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;

        for (var c = l.length, u = this.c, p = u && this.d, h = function () {
          var e,
              t = yi(l, o);

          if (67324752 == t) {
            s = 1, a = o, d.d = null, d.c = 0;

            var r = xi(l, o + 6),
                i = xi(l, o + 8),
                p = 2048 & r,
                h = 8 & r,
                f = xi(l, o + 26),
                _ = xi(l, o + 28);

            if (c > o + 30 + f + _) {
              var m = [];
              d.k.unshift(m), s = 2;
              var g,
                  v = yi(l, o + 18),
                  b = yi(l, o + 22),
                  x = ds(l.subarray(o + 30, o += 30 + f), !p);
              4294967295 == v ? (e = h ? [-2] : gs(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
              var y = {
                name: x,
                compression: i,
                start: function () {
                  if (!y.ondata) throw "no callback";

                  if (v) {
                    var e = n.o[i];
                    if (!e) throw "unknown compression type " + i;

                    (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function (e, t, n) {
                      y.ondata(e, t, n);
                    };

                    for (var t = 0, r = m; t < r.length; t++) {
                      var s = r[t];
                      g.push(s, !1);
                    }

                    n.k[0] == m && n.c ? n.d = g : g.push(Qr, !0);
                  } else y.ondata(null, Qr, !0);
                },
                terminate: function () {
                  g && g.terminate && g.terminate();
                }
              };
              v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y);
            }

            return "break";
          }

          if (u) {
            if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
            if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
          }
        }, d = this; o < c - 4 && "break" !== h(); ++o);

        if (this.p = Qr, u < 0) {
          var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == yi(l, a - 16) && 4)) : l.subarray(0, o);
          p ? p.push(f, !!s) : this.k[+(2 == s)].push(f);
        }

        if (2 & s) return this.push(l.subarray(o), t);
        this.p = l.subarray(o);
      }

      if (t) {
        if (this.c) throw "invalid zip file";
        this.p = null;
      }
    }, e.prototype.register = function (e) {
      this.o[e.compression] = e;
    }, e;
  }();

  function Ps(e, t) {
    if ("function" != typeof t) throw "no callback";

    for (var n = [], r = function () {
      for (var e = 0; e < n.length; ++e) n[e]();
    }, i = {}, s = e.length - 22; 101010256 != yi(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);

    var o = xi(e, s + 8);
    o || t(null, {});
    var a = o,
        l = yi(e, s + 16),
        c = 4294967295 == l;

    if (c) {
      if (s = yi(e, s - 12), 101075792 != yi(e, s)) return void t("invalid zip file", null);
      a = o = yi(e, s + 32), l = yi(e, s + 48);
    }

    for (var u = function (s) {
      var a = ms(e, l, c),
          u = a[0],
          p = a[1],
          h = a[2],
          d = a[3],
          f = a[4],
          _ = a[5],
          m = _s(e, _);

      l = f;

      var g = function (e, n) {
        e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i));
      };

      if (u) {
        if (8 == u) {
          var v = e.subarray(m, m + p);
          if (p < 32e4) try {
            g(null, Ui(v, new _r(h)));
          } catch (e) {
            g(e, null);
          } else n.push(Ni(v, {
            size: h
          }, g));
        } else g("unknown compression type " + u, null);
      } else g(null, Vr(e, m, m + p));
    }, p = 0; p < a; ++p) u();

    return r;
  }

  function Ds(e) {
    for (var t = {}, n = e.length - 22; 101010256 != yi(e, n); --n) if (!n || e.length - n > 65558) throw "invalid zip file";

    var r = xi(e, n + 8);
    if (!r) return {};
    var i = yi(e, n + 16),
        s = 4294967295 == i;

    if (s) {
      if (n = yi(e, n - 12), 101075792 != yi(e, n)) throw "invalid zip file";
      r = yi(e, n + 32), i = yi(e, n + 48);
    }

    for (var o = 0; o < r; ++o) {
      var a = ms(e, i, s),
          l = a[0],
          c = a[1],
          u = a[2],
          p = a[3],
          h = a[4],
          d = a[5],
          f = _s(e, d);

      if (i = h, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[p] = Ui(e.subarray(f, f + c), new _r(u));
      } else t[p] = Vr(e, f, f + c);
    }

    return t;
  }

  class Os extends i.hH6 {
    load(e, t, n, r) {
      return this.setResponseType("arraybuffer"), super.load(e, e => {
        const n = Ds(new Uint8Array(e)),
              r = new Map(Object.entries(n).map(([e, t]) => [e, new File([t], e)]));
        null == t || t(r);
      }, n, r);
    }

  }

  function Ls() {
    Us.Importers.push(new $t(Os, ["zip"], !0));
  }

  class Is extends i.Ox3 {
    constructor(e, t) {
      super(), this.assetType = "light", this.isDirectionalLight2 = !0, this.color = new i.Ilk(e), this.intensity = t || 1, this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.target.position.set(0, 0, -1), this.add(this.target);
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = this.target,
            r = e.userData;
      return e.userData = {}, super.copy(e, t), pt(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Directional Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [-.1, .1],
          stepSize: .005,
          label: "Shadow Normal Bias",
          property: [null == this ? void 0 : this.shadow, "normalBias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [.1, 50],
          label: "Shadow frustum",
          getValue: () => 2 * this.shadow.camera.right,
          setValue: e => {
            this.shadow.camera.left = -e / 2, this.shadow.camera.right = e / 2, this.shadow.camera.top = e / 2, this.shadow.camera.bottom = -e / 2;
          },
          onChange: this.userData.setDirty
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "DirectionalLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      if ("DirectionalLight2" !== e.type) return null;
      const n = e.target,
            r = e.object;
      return e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld(), delete e.target), e.object && delete e.object, Te(e, this, !0, t), n && (e.target = n), r && (void 0 !== r.color && this.color.set(r.color), void 0 !== r.intensity && (this.intensity = r.intensity), e.object = r), this;
    }

  }

  class Fs extends i.PMe {
    constructor(e, t, n, r, i, s) {
      super(e, t, n, r, i, s), this.assetType = "light", this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.target.position.set(0, 0, -1), this.add(this.target);
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = this.target,
            r = e.userData;
      return e.userData = {}, super.copy(e, t), pt(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Spot Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 30],
          property: [this, "intensity"]
        }, {
          type: "slider",
          bounds: [0, 2],
          property: [this, "angle"]
        }, {
          type: "slider",
          bounds: [0, .9999],
          property: [this, "penumbra"]
        }, {
          type: "vec3",
          label: "Rotation",
          property: [this, "rotation"]
        }, {
          type: "vec3",
          label: "Position",
          property: [this, "position"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [this, "castShadow"]
        }, {
          type: "vec2",
          label: "Shadow Map Size",
          property: [null == this ? void 0 : this.shadow, "mapSize"],
          onChange: () => {
            var e, t;
            null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null;
          }
        }, {
          type: "slider",
          bounds: [-.001, .001],
          stepSize: 2e-5,
          label: "Shadow Bias",
          property: [null == this ? void 0 : this.shadow, "bias"],
          onChange: this.userData.setDirty
        }, {
          type: "slider",
          bounds: [0, 5],
          label: "Shadow radius",
          property: [null == this ? void 0 : this.shadow, "radius"],
          onChange: this.userData.setDirty
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "SpotLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return "SpotLight2" !== e.type ? null : (e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld()), e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), void 0 !== e.object.distance && (this.distance = e.object.distance), void 0 !== e.object.angle && (this.angle = e.object.angle), void 0 !== e.object.decay && (this.decay = e.object.decay), void 0 !== e.object.penumbra && (this.penumbra = e.object.penumbra), Te(e, this, !0, t), this) : this);
    }

  }

  class Ns extends i.Mig {
    constructor(e, t) {
      super(e, t), this.assetType = "light", this.userData.setDirty = () => {
        var e, t;
        this.dispatchEvent({
          type: "objectUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      };
    }

    get lightObject() {
      return this;
    }

    get modelObject() {
      return this;
    }

    copy(e, t) {
      const n = e.userData;
      return e.userData = {}, super.copy(e, t), pt(this.userData, n), this;
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ambient Light",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "visible"]
        }, {
          type: "color",
          label: "Color",
          property: [this, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 20],
          property: [this, "intensity"]
        }]
      };
    }

    toJSON(e) {
      const t = super.toJSON(e);
      return t.type = "AmbientLight2", Object.assign(t, Me(this, !0, e));
    }

    fromJSON(e, t) {
      return "AmbientLight2" !== e.type ? null : e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), Te(e, this, !0, t), this) : this;
    }

  }

  class Us extends r {
    constructor(e, t = !1) {
      super(), this._processors = new rt(), this._logger = console.log, this._loaderCache = [], this._fileDatabase = new Map(), this._cachedAssets = [], t || (this._logger = () => {}), this._viewer = e, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new i.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), Ls(), rn(e.renderer.rendererObject), $n(e), dr();
    }

    get processors() {
      return this._processors;
    }

    get loadingManager() {
      return this._loadingManager;
    }

    _onLoad() {
      this.dispatchEvent({
        type: "onLoad"
      });
    }

    _onProgress(e, t, n) {
      this.dispatchEvent({
        type: "onProgress",
        url: e,
        loaded: t,
        total: n
      });
    }

    _onError(e) {
      this.dispatchEvent({
        type: "onError",
        url: e
      });
    }

    _onStart(e, t, n) {
      this.dispatchEvent({
        type: "onStart",
        url: e,
        loaded: t,
        total: n
      });
    }

    _urlModifier(e) {
      var t;
      let n = decodeURI(e);
      const r = null === (t = this._rootContext) || void 0 === t ? void 0 : t.rootUrl;
      n.includes("://") || !r || n.startsWith(r) || (n = r + n), n = n.replace("./", ""), n = n.replace(/^(\/\/)/, "/"), n = n.replace(/\?.*$/, "");

      const i = this._fileDatabase.get(n);

      return i ? i.ext ? (i.objectUrl || (i.objectUrl = URL.createObjectURL(i) + "#" + n), i.objectUrl) : (console.error("Unable to determine file extension", i), e) : e;
    }

    _createLoader(e) {
      const t = this._getImporter(e),
            n = null == t ? void 0 : t.ctor(this);

      return n && (null == t || t.ext.forEach(e => {
        const t = new RegExp(e.startsWith("data:") ? "^" + e + "\\/" : "\\." + e + "$", "i");

        this._loadingManager.addHandler(t, n);
      })), n && (this._loaderCache.push({
        loader: n,
        files: []
      }), this.dispatchEvent({
        type: "loaderCreate",
        loader: n
      })), n;
    }

    async importFiles(e, t, n = {}) {
      const r = new Map();
      let {
        allowedExtensions: i
      } = n;
      if (i && i.length < 1 && (i = void 0), 0 === e.size) return r;
      this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "start"
      });
      const s = [],
            o = [];
      if (e.forEach((e, t) => {
        var n;
        this.registerFile(t, e);
        const r = e.ext;
        r && (null === (n = null == i ? void 0 : i.includes(r.toLowerCase())) || void 0 === n || n) && (this._isRootFileExtension(r) ? s.push(t) : o.push(t));
      }), s.length > 0) for (const e of s) {
        const t = await this._importFile(e, void 0, n);
        r.set(e, t);
      } else for (const e of o) {
        const t = await this._importFile(e, void 0, n);
        r.set(e, t);
      }
      return this.dispatchEvent({
        type: "importFiles",
        files: Object.keys(e),
        state: "end"
      }), e.forEach((e, t) => {
        this.unregisterFile(t);
      }), r;
    }

    registerFile(e, t) {
      var n, r, i;
      e = e.replace(/\?.*$/, "");
      const s = null !== (n = null == t ? void 0 : t.ext) && void 0 !== n ? n : null === (i = Qt(null !== (r = null == t ? void 0 : t.name) && void 0 !== r ? r : e)) || void 0 === i ? void 0 : i.toLowerCase();
      t && (t.ext || (t.ext = s), this._fileDatabase.set(e, t));

      let o = this._getLoader(e);

      if (o || (o = this._createLoader(null != t ? t : {
        name: e,
        ext: s
      })), o) for (const t of this._loaderCache) if (t.loader === o) {
        t.files.push(e);
        break;
      }
      return o;
    }

    unregisterFile(e) {
      e = e.replace(/\?.*$/, "");

      const t = this._fileDatabase.get(e);

      (null == t ? void 0 : t.objectUrl) && (URL.revokeObjectURL(t.objectUrl), t.objectUrl = void 0), t && this._fileDatabase.delete(e);
    }

    _isRootFileExtension(e) {
      return null != Us.Importers.find(t => t.root && t.ext.includes(e.toLowerCase()));
    }

    resolveURL(e) {
      return this._loadingManager.resolveURL(e);
    }

    async _importFile(e, t, n = {}) {
      var r, s;
      if (null === (r = t) || void 0 === r ? void 0 : r.__imported) return t.__imported;
      let o;
      this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "downloading"
      });

      try {
        this.registerFile(e, t), n.rootPath = e;
        const r = this.resolveURL(e),
              a = e.replace(/\?.*$/, ""),
              l = null !== (s = n.fileHandler) && void 0 !== s ? s : (await this._loadingManager.getHandler(a)) || (t ? await this._loadingManager.getHandler(t.name || t.ext || "") : void 0);
        if (!l) throw new Error("AssetImporter: Unable to find loader for " + e);
        this._rootContext = {
          path: e,
          url: r,
          rootUrl: i.Zp0.extractUrlBase(e),
          baseUrl: i.Zp0.extractUrlBase(r)
        }, o = await l.loadAsync(e + (n.queryString ? (e.includes("?") ? "&" : "?") + n.queryString : "")), this._rootContext = void 0, this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "adding"
        }), o && (o = !1 !== n.processImported ? await this.processImported(o, n) : [o]), t ? this._logger("AssetImporter: loaded", e) : this._logger("AssetImporter: downloaded", e), t && this.unregisterFile(e);
      } catch (n) {
        return console.error("AssetImporter: Unable to import file", e, t), console.error(n), this.dispatchEvent({
          type: "importFile",
          path: e,
          state: "error",
          error: n
        }), [];
      }

      return this.dispatchEvent({
        type: "importFile",
        path: e,
        state: "done"
      }), t && (t.__imported = o), o;
    }

    _getImporter(e, t = !1) {
      return Us.Importers.find(n => {
        if (t && !n.root) return !1;
        const r = n.ext.find(t => {
          var n, r, i;
          return e.ext && t === e.ext.toLowerCase() || (null === (r = null === (n = e.name) || void 0 === n ? void 0 : n.toLowerCase()) || void 0 === r ? void 0 : r.endsWith("." + t.toLowerCase())) || (null == t ? void 0 : t.startsWith("data:")) && (null === (i = e.name) || void 0 === i ? void 0 : i.startsWith(t));
        });
        return !!r && (e.ext = r, !0);
      });
    }

    _getLoader(e) {
      var t;
      return null !== (t = this._loadingManager.getHandler(e)) && void 0 !== t ? t : void 0;
    }

    async importAsset(e, t = {}) {
      var n;
      if (!e) return [];

      if (!this._cachedAssets.includes(e)) {
        if (1 === Object.entries(e).length && e.path) {
          const t = this._cachedAssets.find(t => t.path === e.path);

          t && Object.assign(e, t);
        }

        const t = this._cachedAssets.findIndex(t => t.path === e.path);

        t >= 0 && this._cachedAssets.splice(t, 1), this._cachedAssets.push(e);
      }

      return (null == e ? void 0 : e.preImported) || (e.preImported = this._importFile(t.pathOverride || e.path, "function" == typeof (null === (n = e.file) || void 0 === n ? void 0 : n.arrayBuffer) ? e.file : void 0, t)), await e.preImported;
    }

    async importSingle(e, t = {}) {
      var n;
      return null === (n = await this.importAsset(e, t)) || void 0 === n ? void 0 : n[0];
    }

    async importSinglePath(e, t) {
      var n;
      return null === (n = await this.importPath(e, t)) || void 0 === n ? void 0 : n[0];
    }

    async importPath(e, t = {}) {
      const n = t.pathOverride;
      void 0 !== n && delete t.pathOverride;
      const r = JSON.stringify(t);
      void 0 !== n && (t.pathOverride = n);
      let i;
      return i = this._cachedAssets.find(t => t.path === e && t._options === r) || {
        path: e
      }, i._options = r, await this.importAsset(i, t);
    }

    async processImportedSingle(e, t = {}) {
      return (await this.processImported(e, t))[0];
    }

    async processImported(e, t = {}) {
      var n, r, s;

      if (Array.isArray(e)) {
        const n = [];

        for (const r of e) n.push(...(await this.processImported(r, t)));

        return n;
      }

      if (null === (n = null == e ? void 0 : e.userData) || void 0 === n ? void 0 : n.rootSceneModelRoot) return t.rootSceneImported = !0, e.animations && e.children[0] && (e.children[0].animations || (e.children[0].animations = []), e.children[0].animations.push(...e.animations)), this.processImported([...e.children], t);
      if ((null === (r = null == e ? void 0 : e.userData) || void 0 === r ? void 0 : r.iModel) && (e = e.userData.iModel), e.assetImporterProcessed && !t.forceImporterReprocess) return [e];

      if (!e.assetType) {
        if (e.isBufferGeometry && (e = new i.Kj0(e, new i.Wid())), e.isObject3D) {
          e = e.isLight ? js(e) : new it(e, t);
          const n = [];
          e.modelObject.traverse(t => {
            t !== e.modelObject && n.push([t, js(t)]);
          });

          for (const e of n) {
            const t = e[0].parent;
            t && (t.remove(e[0]), t.add(e[1]));
          }

          !t.rootPath || e.modelObject.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.modelObject.userData.rootPath = t.rootPath);
        }

        e.isTexture && (e.assetType = "texture", void 0 !== t.generageMipmaps && (e.generateMipmaps = t.generageMipmaps), e.generateMipmaps || e.isRenderTargetTexture || (e.minFilter = e.minFilter === i.D1R ? i.wem : e.minFilter, e.magFilter = e.magFilter === i.D1R ? i.wem : e.magFilter), !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath)), e.isMaterial && (e.assetType = "material", !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath));
      }

      if (null != e.assetType) return (e = await this._processors.process(e.assetType, e, {})).assetImporterProcessed = !0, [e];
      if (e instanceof Map) return [...(await this.importFiles(e, void 0, t)).values()].flat();

      if (e.type) {
        const t = this._viewer.getPluginByType(e.type);

        if (t) {
          let n = e._importedResources || {};
          return e.resources && (n = await (null === (s = this._viewer.getManager()) || void 0 === s ? void 0 : s.importConfigResources(e.resources)), delete e.resources, e._importedResources = n), "function" == typeof t.fromJSON && (await Promise.resolve(t.fromJSON(e, n)), e.assetImporterProcessed = !1), [];
        }
      } else if (e.plugins) return await this._viewer.getManager().importViewerConfig(e), e.assetImporterProcessed = !1, [];

      return console.warn("unknown asset type: ", e), [e];
    }

    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }

  }

  function Bs(e) {
    if (!e) return i.ywz;
    const t = e.extensions.has("EXT_color_buffer_half_float") || e.capabilities.isWebGL2 && e.extensions.has("EXT_color_buffer_float"),
          n = e.capabilities.isWebGL2 || e.extensions.has("OES_texture_float") || e.extensions.has("WEBGL_color_buffer_float");
    return t ? i.cLu : n ? i.VzW : i.ywz;
  }

  function js(e) {
    var t, n, r;
    if (!e.isLight) return e;
    if ("light" === e.assetType) return e;
    if (e.uiConfig) return console.warn("ui config already exists, not supported", e), e;
    let i;

    if (e.children.length, e.isDirectionalLight && (i = new Is()), e.isAmbientLight && (i = new Ns()), e.isSpotLight && (i = new Fs()), i) {
      null === (n = (t = i.lightObject).copy) || void 0 === n || n.call(t, e);
      const s = e.parent;
      "model" === (null === (r = s) || void 0 === r ? void 0 : r.assetType) && (s.remove(e), e.dispose(), s.add(i.lightObject)), lt(i.lightObject, s);
    }

    return i;
  }

  Us.Importers = [new $t(tn, ["json"], !1), new $t(i.hH6, ["txt"], !1), new $t(Yn, ["rgbe.png", "hdr.png", "hdrpng"], !1), new $t(i.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], !1)];

  class zs extends i.u7G {
    constructor(e) {
      super(e);
    }

    async loadAsync(e, t) {
      var n;
      const r = new i.hH6(this.manager);
      r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
      const s = await r.loadAsync(e, t);

      try {
        const e = JSON.parse(s);

        if (e.images && this.importer) {
          const t = {};

          for (const r of e.images) {
            if (!r.url || !r.uuid) continue;
            const e = null === (n = await this.importer.importPath(r.url, {
              processImported: !1
            })) || void 0 === n ? void 0 : n[0],
                  s = null == e ? void 0 : e.source;
            if (!e || !s) continue;
            const o = new i.Hw6(s.data);
            o.uuid = r.uuid, t[o.uuid] = o, e.dispose();
          }

          return this.parse(e, t);
        }

        return this.parse(e);
      } catch (t) {
        throw console.error(t), this.manager.itemError(e), t;
      }
    }

    parse(e, t) {
      var n, r;
      let s;
      const o = {
        p: new Promise(e => {
          s = e;
        })
      };

      if (e.images || e.textures) {
        const n = new Zn(this.manager);
        let r = {};

        const i = e => {
          s(), o.p = void 0, Object.values(r).forEach(e => {
            var t;
            e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
          });
        },
              a = t || n.parseImages(e.images, i);

        r = n.parseTextures2(e.textures, a, i), this.setTextures(r);
      }

      this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
      const a = { ...e
      };

      if (Object.entries(a).forEach(([e, t]) => {
        t && "string" == typeof t && this.textures[t] && (a[e] = this.textures[t]);
      }), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), void 0 !== e.normalScale) {
        let t = e.normalScale;
        !1 === Array.isArray(t) && (t = [t, t]), a.normalScale = new i.FM8().fromArray(t);
      }

      let l = e.type;
      "MeshPhysicalMaterial" !== l && "MeshStandardMaterial" !== l || (l = Kt.TYPE);
      const c = null !== (r = null === (n = this.materials) || void 0 === n ? void 0 : n.generateFromTemplateType(l, a)) && void 0 !== r ? r : super.parse(e);
      return this.setTextures({}), c.userData.imageLoadAwaiter = o, c;
    }

  }

  class Vs extends r {
    constructor(e, t, {
      simpleCache: n = !1,
      storage: r
    } = {}) {
      if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (n || r) && (i.CtF.enabled = !0, r instanceof Cache)) {
        const e = { ...i.CtF
        };
        i.CtF.get = (t, n, i) => n ? t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") ? Promise.resolve(void 0) : r.match(t).then(e => {
          if (e) switch (n) {
            case "arraybuffer":
              return e.arrayBuffer();

            case "blob":
              return e.blob();

            case "document":
              return e.text().then(e => new DOMParser().parseFromString(e, null != i ? i : "text/html"));

            case "json":
              return e.json();

            default:
              if (void 0 === i) return e.text();
              {
                const t = /charset="?([^;"\s]*)"?/i.exec(i),
                      n = t && t[1] ? t[1].toLowerCase() : void 0,
                      r = new TextDecoder(n);
                return e.arrayBuffer().then(e => r.decode(e));
              }
          }
        }) : e.get(t), i.CtF.add = (t, n, i) => {
          i || e.add(t, n), t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") || r.put(t, new Response(n, {
            status: 200
          }));
        }, i.CtF.remove = (t, n) => {
          n || e.remove(t), r.delete(t);
        };
      }

      this._importer = e, this._materials = t;
    }

    async addAsset(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const n = await this._importer.importAsset(e, t);
      return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), []);
    }

    async addFromPath(e, t = {}) {
      if (!this._importer || !this._viewer) return [];
      const n = await this._importer.importPath(e, t);
      return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), []);
    }

    addProcessedAssets(e, t) {
      return e.map(e => {
        var n;
        return null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.addSceneObject(e, t);
      });
    }

    async addAssetSingle(e, t = {}) {
      var n;
      return e ? null === (n = await ("string" == typeof e ? this.addFromPath : this.addAsset)(e, t)) || void 0 === n ? void 0 : n[0] : void 0;
    }

    async addImported(e, t = {}) {
      var n;
      return null === (n = this._importer) || void 0 === n ? void 0 : n.processImported(e, t).then(e => (this.addProcessedAssets(e, t), e));
    }

    async addImportedSingle(e, t = {}) {
      return this.addImported(e, t).then(e => null == e ? void 0 : e[0]);
    }

    _sceneUpdated(e) {
      var t;

      if ("addSceneObject" === e.type) {
        const n = e.object;

        switch (n.assetType) {
          case "material":
            null === (t = this._materials) || void 0 === t || t.processMaterial(n, {});
        }
      } else console.error("Unexpected");
    }

    async onAdded(e) {
      this._viewer = e, this._materials || (this._materials = new Jt(), this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new Us(e, !!e.getPluginByType("debug")), this._importer.processors.add("model", {
        forAssetType: "model",
        process: (e, t) => (at(e, e => {
          var t;
          return null === (t = this._materials) || void 0 === t ? void 0 : t.processModel(e, {
            recursive: !1
          });
        }), e)
      }), this._importer.processors.add("model", {
        forAssetType: "model",
        process: this._materials.processModel
      }), this._importer.processors.add("material", {
        forAssetType: "material",
        process: (e, t) => {
          var n;
          return (null === (n = this.materials) || void 0 === n ? void 0 : n.findMaterial(e.uuid)) && (console.warn("imported material uuid already exists, creating new uuid"), e.uuid = $(), e.userData.uuid && (e.userData.uuid = e.uuid)), this._materials.processMaterial(e, t);
        }
      })), Us.Importers.push(new $t(zs, [Kt.TypeSlug], !1, e => (e && (e.materials = this._materials), e && (e.importer = this._importer), e)));
      const t = this.importViewerConfig.bind(this);
      Us.Importers.push(new $t(class extends tn {
        async loadAsync(e, n) {
          return t(await super.loadAsync(e, n));
        }

      }, [Vs.ViewerTypeSlug], !0));
    }

    async onDispose(e) {}

    async onRemove(e) {
      var t, n;
      e === this._viewer && (null === (t = this._importer) || void 0 === t || t.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (n = this._materials) || void 0 === n || n.dispose(), this._materials = void 0);
    }

    get importer() {
      return this._importer;
    }

    get exporter() {
      var e, t;
      return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("AssetExporterPlugin")) || void 0 === t ? void 0 : t.exporter;
    }

    get materials() {
      return this._materials;
    }

    exportViewerConfig() {
      if (!this._viewer) return {};

      const e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      },
            t = this._viewer.toJSON(e);

      return t.resources = e, t;
    }

    exportPluginPresets(e) {
      var t;
      const n = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      return {
        plugins: null === (t = this._viewer) || void 0 === t ? void 0 : t.serializePlugins(n, e),
        resources: n
      };
    }

    exportPluginPreset(e) {
      if (!e.toJSON) return;
      const t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      },
            n = e.toJSON(t);
      return n.resources = t, n;
    }

    async importPluginPreset(e, t) {
      var n;
      const r = e.type;
      if (!(t = t || (null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType(r)))) return void console.warn(`No plugin found for type ${r} to import preset`);
      if (!t.fromJSON) return void console.warn(`Plugin ${r} does not support importing presets`);
      const i = e.resources || {};
      return e.resources && delete e.resources, await t.fromJSON(e, i), i && (e.resources = i), t;
    }

    async importViewerConfig(e, t) {
      var n;
      if (!this._viewer || !this._importer) return void console.warn("No viewer or importer");
      const r = await this.importConfigResources(e.resources || {}, t);

      this._viewer.fromJSON(e, r);

      for (const e of Object.values(r.materials)) e.__useCount ? delete e.__useCount : null === (n = this._materials) || void 0 === n || n.unregisterMaterial(e);

      for (const e of Object.values(r.textures)) e.__useCount && delete e.__useCount;
    }

    async importConfigResources(e, t) {
      var n, r, s;
      if (!this._importer) throw "Importer not initialized yet.";
      const o = {};
      t = null != t ? t : new Zn(this._importer.loadingManager), o.animations = t.parseAnimations(e.animations), o.shapes = t.parseShapes(e.shapes), o.geometries = t.parseGeometries(e.geometries, o.shapes), o.images = await t.parseImagesAsync(Object.values(e.images));

      for (const t of Object.values(e.textures)) {
        const e = null === (n = null == t ? void 0 : t.userData) || void 0 === n ? void 0 : n.rootPath;

        if (e && (!t.image || !o.images[t.image])) {
          const n = null === (r = await this._importer.importPath(e, {
            processImported: !1
          })) || void 0 === r ? void 0 : r[0],
                s = null == n ? void 0 : n.source;
          if (!n || !s) continue;
          const a = new i.Hw6(s.data);
          t.image && (a.uuid = t.image), o.images[a.uuid] = a, t.image = a.uuid, n.dispose();
        }
      }

      o.textures = t.parseTextures2(Object.values(e.textures), o.images, () => {
        Object.values(o.textures).forEach(e => {
          var t;
          e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0);
        });
      });

      for (const e of Object.entries(o.textures)) e[1] = null === (s = await this._importer.processImported(e[1], {})) || void 0 === s ? void 0 : s[0], e[1] ? o.textures[e[0]] = e[1] : delete o.textures[e[0]];

      const a = Object.values(e.materials);

      for (const e of a) Object.entries(e).forEach(([t, n]) => {
        n && n.resource && n.uuid && "textures" === n.resource && (e[t] = n.uuid);
      });

      return o.materials = t.parseMaterials2(a, o.textures, this._materials), e.object && (o.object = t.parseObject(e.object, o.geometries, o.materials, o.textures, o.animations), e.skeletons && (o.skeletons = t.parseSkeletons(e.skeletons, o.object), t.bindSkeletons(o.object, o.skeletons))), o;
    }

  }

  Vs.PluginType = "AssetManager", Vs.ViewerTypeSlug = "vjson";

  class Gs extends r {
    constructor() {
      super(...arguments), this._dirty = !1;
    }

    get dirty() {
      return this._dirty;
    }

    set dirty(e) {
      this._dirty = e;
    }

    async onAdded(e) {
      this._viewer = e;
    }

    async onDispose(e) {}

    async onRemove(e) {
      this._viewer !== e && console.error("Wrong viewer"), this._viewer = void 0;
    }

    toJSON(e) {
      const t = Me(this, !0, e);
      return t.type = this.constructor.PluginType, this.dispatchEvent({
        type: "serialize",
        data: t
      }), t;
    }

    fromJSON(e, t) {
      return e.type !== this.constructor.PluginType ? null : (Te(e, this, !0, t), this.dispatchEvent({
        type: "deserialize",
        data: e
      }), this);
    }

  }

  function Hs(e, t, n) {
    return { ...t,

      get dirty() {
        return t.dirty || !1;
      },

      set dirty(e) {
        g(t, "dirty", e, !0);
      },

      update() {
        var e, r, i;
        this.passObject.enabled && (null === (r = (e = this.passObject).updateShaderProperties) || void 0 === r || r.call(e, x(n)), null === (i = t.update) || void 0 === i || i.call(this));
      },

      onRegister(n) {
        var r, i, s;
        this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.registerMaterialExtension(this.passObject.materialExtension)), null === (s = t.onRegister) || void 0 === s || s.call(this, n);
      },

      onUnregister(n) {
        var r, i, s;
        this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s = t.onUnregister) || void 0 === s || s.call(this, n);
      },

      dispose() {
        var e, n, r;
        null === (n = (e = this.passObject).dispose) || void 0 === n || n.call(e), null === (r = t.dispose) || void 0 === r || r.call(this);
      }

    };
  }

  class Ws extends Gs {
    constructor() {
      super(), this._enabledTemp = !0;
    }

    _update(e) {
      var t;
      return (null === (t = this._pass) || void 0 === t ? void 0 : t.enabled) && this.enabled || !1;
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || this._enabledTemp;
    }

    set enabled(e) {
      var t;
      (null === (t = this._pass) || void 0 === t ? void 0 : t.passObject) && (this._pass.passObject.enabled = e), this._enabledTemp = e;
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = {
        enabled: !0,
        passId: this.passId,
        passObject: this.passCtor(e),
        after: this._afterFilters,
        before: this._beforeFilters,
        required: this._requiredFilters,

        set dirty(t) {
          t && e.setDirty();
        },

        get dirty() {
          return !1;
        },

        dispose() {
          var e, t;
          null === (t = null === (e = this.passObject) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e);
        },

        update: () => this._update(e)
      };
      this._pass = t, void 0 !== t.passObject.onDirty && t.passObject.onDirty.push(() => t.dirty = !0), e.renderer.registerPass(this._pass), this.enabled = this._enabledTemp;
    }

    async onRemove(e) {
      var t, n;
      this._pass && e.renderer.unregisterPass(this._pass), null === (n = null === (t = this._pass) || void 0 === t ? void 0 : t.dispose) || void 0 === n || n.call(t), this._pass = void 0, await super.onRemove(e);
    }

    get pass() {
      return this._pass;
    }

    toJSON(e) {
      var t, n;
      const r = super.toJSON(e);
      if (!r.type) return r;
      const i = this.pass;
      return i && (r.pass = Me(null !== (n = null === (t = i) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : i, !1, e)), r;
    }

    fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;

      if (e.pass) {
        const i = this.pass;
        i && Te(e.pass, null !== (r = null === (n = i) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : i, !1, t);
      }

      return this;
    }

  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], Ws.prototype, "enabled", null);
  const Ks = new Set(),
        Xs = new Set();

  class qs extends Nt {
    constructor(e, t, n, r) {
      super(void 0, void 0, t, null != n ? n : new ve(1, 1, 1), null != r ? r : 1), this.target = e;
    }

    render(e, t, n, r, i) {
      const s = e.getRenderTarget(),
            o = e.getActiveCubeFace(),
            a = e.getActiveMipmapLevel();
      this.scene.traverse(({
        material: e
      }) => {
        e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (Ks.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (Xs.add([e, e.transmission]), e.transmission = 0));
      }), K(e, {
        shadowMapRender: !1,
        backgroundRender: !1,
        opaqueRender: !0,
        transparentRender: !1,
        transmissionRender: !1,
        mainRenderPass: !1
      }, () => super.render(e, t, this.target, r, i)), Ks.forEach(e => e.transparent = !e.transparent), Ks.clear(), Xs.forEach(([e, t]) => e.transmission = t), Xs.clear(), e.setRenderTarget(s, o, a);
    }

  }

  class Ys extends Ws {
    constructor(e = !0) {
      super(), this.renderFlagsBuffer = e, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = [];
    }

    passCtor(e) {
      var t, n;
      const r = (null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.isWebGL2) && this.renderFlagsBuffer,
            s = e.renderer.createTarget({
        depthBuffer: !0,
        type: i.ywz,
        textureCount: r ? 2 : 1
      });
      Array.isArray(s.texture) ? (s.texture[0].name = "gbufferDepthNormal", s.texture[1].name = "gbufferFlags", this._gbufferTextures = s.texture) : (s.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(s.texture)), this._gbufferTarget = s;
      const o = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("debug");
      return o && (o.addTexture("gbuffer depth normal", () => this.getDepthNormal(), [40, 510, 200, 100]), this._gbufferTextures.length > 1 && o.addTexture("gbuffer flags", () => this.getFlagsTexture(), [40, 310, 200, 100])), new qs(s, new Bt(r));
    }

    _update(e) {
      if (!super._update(e)) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }

    getDepthNormal() {
      return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0;
    }

    getFlagsTexture() {
      return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0;
    }

    async onDispose(e) {}

    async onRemove(e) {
      return this._gbufferTarget && (e.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e);
    }

    getTarget() {
      return this._gbufferTarget;
    }

    getUnpackSnippet() {
      return jt;
    }

    updateShaderProperties(e) {
      var t, n;

      if (e.uniforms.tNormalDepth ? e.uniforms.tNormalDepth.value = null !== (t = this.getDepthNormal()) && void 0 !== t ? t : void 0 : console.warn("BaseRenderer: no uniform: tNormalDepth"), e.uniforms.tGBufferFlags) {
        e.uniforms.tGBufferFlags.value = null !== (n = this.getFlagsTexture()) && void 0 !== n ? n : void 0;
        const t = e.uniforms.tGBufferFlags.value ? 1 : 0;
        t !== e.defines.GBUFFER_HAS_FLAGS && (e.defines.GBUFFER_HAS_FLAGS = t, e.needsUpdate = !0);
      }

      return this;
    }

  }

  Ys.PluginType = "GBuffer";

  class Zs extends Nt {
    constructor(e, t = !0) {
      super(), this._viewer = e, this._doTransmissionFix = t, this.clear = !0, this.clearColor = new ve(0, 0, 0), this.clearAlpha = 0, this.clearDepth = !1, this._blendPass = new Ut({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);");
    }

    get transparentTarget() {
      return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        isAntialiased: !1,
        encoding: i.rnI,
        type: i.cLu,
        format: i.wk1,
        minFilter: i.wem,
        magFilter: i.wem,
        depthBuffer: !1
      })), this._transparentTarget;
    }

    _releaseTransparentTarget() {
      this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0;
    }

    render(e, t, n, r, i) {
      var s;
      let o = !1;
      if (e.userData.mainRenderPass = !0, !this._doTransmissionFix) return super.render(e, t, n, r, i), this.needsSwap = o, void (e.userData.mainRenderPass = void 0);
      const a = e.userData;
      a || console.error("threejs is not patched?");
      const l = this._viewer.useGBufferDepth;
      let c;

      if (l) {
        const t = null === (s = this._viewer.getPlugin(Ys)) || void 0 === s ? void 0 : s.getTarget();

        if (t) {
          const n = e.properties.get(t);
          c = n.__webglDepthRenderbuffer || n.__webglDepthbuffer;
        } else console.warn("No Gbuffer present for depth prepass.");
      }

      let u = () => {
        super.render(e, void 0, n, r, i, c);
      };

      if (this._viewer.useRgbm) {
        if (this._viewer.useRgbm) {
          if (o = !1, !e.info.autoReset) throw "renderer.info.autoReset must be true";
          {
            const t = e.autoClearDepth;
            e.autoClearDepth = !l, K(e, {
              shadowMapRender: !0,
              backgroundRender: !0,
              opaqueRender: !0,
              transparentRender: !1,
              transmissionRender: !1
            }, u), e.autoClearDepth = t;
          }

          if (!l) {
            const t = e.properties.get(n);
            c = t.__webglDepthRenderbuffer || t.__webglDepthbuffer;
          }

          u = () => {
            super.render(e, void 0, this.transparentTarget, r, i, c);
          };

          {
            const t = this.clear,
                  n = e.autoClearDepth;
            e.autoClearDepth = !1, this.clear = !0, K(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !0,
              transmissionRender: !1
            }, u), this.clear = t, e.autoClearDepth = n;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0);
          {
            const r = this.clear;
            this.clear = !1, a.transmissionRenderTarget = o ? t : n, K(e, {
              shadowMapRender: !1,
              backgroundRender: !1,
              opaqueRender: !1,
              transparentRender: !1,
              transmissionRender: !0
            }, u), a.transmissionRenderTarget = void 0, this.clear = r;
          }
          e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0);
        }
      } else {
        {
          const t = this.clear,
                n = e.autoClearDepth;
          e.autoClearDepth = !l, this.clear = !0, K(e, {
            shadowMapRender: !0,
            backgroundRender: !0,
            opaqueRender: !0,
            transparentRender: !0,
            transmissionRender: !1
          }, u), this.clear = t, e.autoClearDepth = n;
        }
        {
          this._viewer.renderer.blit(n.texture, t, {
            clear: !0
          });

          const r = this.clear;
          this.clear = !1, a.transmissionRenderTarget = t, K(e, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !1,
            transparentRender: !1,
            transmissionRender: !0
          }, u), a.transmissionRenderTarget = void 0, this.clear = r;
        }
        o = !1;
      }

      this._releaseTransparentTarget(), this.needsSwap = o, e.userData.mainRenderPass = void 0;
    }

  }

  function Js(e, t) {
    return e.multiplyScalar(e.w * t), e.w = 1, e;
  }

  function $s(e, t) {
    return Js(e, t), new ve(e.x, e.y, e.z);
  }

  function Qs(e, t) {
    const n = Math.max(e.x, Math.max(e.y, e.z));
    let r = Math.max(Math.min(n / t, 1), 0);
    return r = Math.ceil(255 * r) / 255, e.divideScalar(r * t), e.w = r, e;
  }

  function eo(e, t) {
    return Qs(new i.Ltg(e.r, e.g, e.b, 1), t);
  }

  var to = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  function no(e) {
    return Object.getPrototypeOf(e).constructor.PluginType;
  }

  i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("uniform sampler2D t2D;", "uniform sampler2D t2D;\nuniform float intensity;"), i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("texture2D( t2D, vUv )", "texture2D( t2D, vUv )*intensity");

  class ro extends r {
    constructor({
      isAntialiased: e = !1,
      useRgbm: n = !0,
      useGBufferDepth: r = !1,
      ...o
    }) {
      var a, l;
      super(), this.console = console, this._state = t.None, this.plugins = {}, this._needsResize = !1, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(e => this.resize()) : void 0, this._lastSize = new i.FM8(), this._onContextRestore = e => {
        this.enabled = !0, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({
          sceneUpdate: !0,
          frameFade: !1
        });
      }, this._onContextLost = e => {
        this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = !1;
      }, this.resize = () => {
        this._needsResize = !0, this.setDirty();
      }, this._needsReset = !0, this.enabled = !0, this.renderEnabled = !0, this._isRenderingFrame = !1, this.maxFramePerLoop = 1, this._rawBackground = null, this.backgroundIntensity = 1, this._sceneEnvironmentChanged = async () => {
        this._rawBackground === io && (await this.scene.setBackground(this.scene.getEnvironment()));
      }, this._useRgbm = n, this._useGBufferDepth = r, this._canvas = o.canvas || mt();
      let c = o.container;
      if (c && !o.canvas && c.appendChild(this._canvas), c || (c = null !== (a = this._canvas.parentElement) && void 0 !== a ? a : void 0), !c) throw new Error("No container.");
      this._container = c, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function () {
        try {
          const e = window.location.href;
          if (e.startsWith("http://localhost:8062") || e.startsWith("https://localhost:8062")) return !0;
          const t = "https://europe-west1-pixotronics-320918.cloudfunctions.net/viewer-hit-test";
          await fetch(t + "/?u=" + encodeURIComponent(e), {
            mode: "no-cors",
            method: "POST",
            credentials: "omit",
            cache: "no-store",
            keepalive: !1,
            referrer: "about:client",
            referrerPolicy: "unsafe-url"
          });
        } catch (e) {
          return !1;
        }
      }(), async function () {
        var e;
        const t = window.location.href,
              n = "https://dev-sandbox.pixotronics.com/webgi/";
        if (!t.startsWith(n)) return !0;
        if (null !== kt("noUpdate")) return !0;
        const r = null === (e = t.match(/\/webgi\/([0-9.a-zA-Z]+)/)) || void 0 === e ? void 0 : e[1],
              i = (await (await fetch(n + "version.txt")).text()).split("\n")[0];

        if (r && r !== i) {
          if (confirm(`New version ${i} is available, do you want to open?`)) {
            const e = window.location.href.replace(r, i);
            return window.location.href = e, !1;
          }

          window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate");
        }
      }();
      const u = new nt(void 0, void 0, this._canvas);
      this.addEventListener("postFrame", () => {
        var e, t;
        const n = h.scene.activeCamera;

        if (n && n.interactionsEnabled) {
          if (0 === (null === (e = this.getPluginByType("Progressive")) || void 0 === e ? void 0 : e.postFrameConvergedRecordingDelta())) return;
          null === (t = n.controls) || void 0 === t || t.update();
        }
      }), this.scene = new _t(u), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this._renderer = new Y({
        canvas: this._canvas,
        animationLoop: this._animationLoop,
        targetOptions: {
          isAntialiased: false,
          encoding: n ? 3005 : i.rnI,
          type: n ? i.ywz : i.cLu,
          depthBuffer: !r
        }
      }), this._isAntialiased = false;
      let p = !0;
      this._renderer.rendererObject.userData || (p = !1, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !p;
      const h = this;
      this.renderFilter = {
        passId: "render",
        passObject: new Zs(this, p),

        update() {
          const e = this.passObject;
          e.scene = h.scene.modelObject, e.camera = h.scene.activeCamera.cameraObject;
        }

      }, [this.renderFilter, {
        passId: "screen",
        after: ["render"],
        required: ["render"],
        passObject: new Ft({ ...s,
          fragmentShader: "\n                       varying vec2 vUv;\n                       " + (null !== (l = o.screenFragmentShader) && void 0 !== l ? l : M`
                        void main() {

                            vec4 texel = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            gl_FragColor = LinearTosRGB(texel);// Gamma Correction

                        }
                    `),
          uniforms: {
            tDiffuse: {
              value: null
            }
          }
        }, "tDiffuse")
      }].forEach(e => this._renderer.registerPass(e)), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("sceneMaterialUpdate", e => this.setDirty(this.scene, e)), this.scene.addEventListener("sceneUpdate", e => {
        this.setDirty(this.scene, e), !1 !== e.geometryChanged && this.renderer.resetShadows();
      }), this.scene.addEventListener("update", e => this.setDirty(this.scene, e)), this._renderer.addEventListener("update", e => this.setDirty(this._renderer, e)), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1), this.renderer.addEventListener("resize", () => {
        this.scene.activeCamera.refreshAspect();
      }), this.setBackground("#ffffff"), this.console.log("WebGi Viewer instance initialized, version: ", ro.VERSION);
    }

    get useRgbm() {
      return this._useRgbm;
    }

    get useGBufferDepth() {
      return this._useGBufferDepth;
    }

    get isAntialiased() {
      return this._isAntialiased;
    }

    setDirty(e, t) {
      this._needsReset = !0, e = null != e ? e : this, this.dispatchEvent({ ...(null != t ? t : {}),
        type: "update",
        source: e
      });
    }

    get renderer() {
      return this._renderer;
    }

    dispose() {
      var e;
      this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1), null === (e = window.webGiViewers) || void 0 === e || e.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({
        type: "dispose"
      });
    }

    _animationLoop({
      time: e,
      deltaTime: t,
      xrFrame: n
    }) {
      var r, i;
      if (this.enabled && this.renderEnabled) if (this._isRenderingFrame) this.console.warn("animation loop: frame skip");else {
        this._isRenderingFrame = !0;

        for (let s = 0; s < this.maxFramePerLoop; s++) {
          if (this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._needsResize) {
            const e = [this._canvas.clientWidth, this._canvas.clientHeight];

            if (n) {
              const t = null === (i = null === (r = this._renderer.rendererObject.xr.getCamera()) || void 0 === r ? void 0 : r.cameras[0]) || void 0 === i ? void 0 : i.viewport;
              t ? (0 === t.x && 0 === t.y || this.console.warn("x and y must be 0?"), e[0] = t.width, e[1] = t.height, this.console.log("resize for xr", e)) : this._needsResize = !1;
            }

            this._needsResize && (this._renderer.setSize(...e), this._needsResize = !1);
          }

          this.dispatchEvent({
            type: "preFrame",
            target: this,
            time: e,
            deltaTime: t,
            xrFrame: n
          });
          const s = Object.values(this.plugins).filter(e => e.dirty);
          s.length > 0 && this.setDirty(s), this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._renderer.updateDirty();
          const o = this._renderer.dirty;

          if (o) {
            this.dispatchEvent({
              type: "preRender",
              target: this
            });

            try {
              this._renderer.render();
            } catch (e) {
              this.console.error(e), this.enabled = !1;
            }

            this.dispatchEvent({
              type: "postRender",
              target: this
            });
          }

          if (this.dispatchEvent({
            type: "postFrame",
            target: this
          }), !o) break;
        }

        this._isRenderingFrame = !1;
      }
    }

    get state() {
      return this._state;
    }

    get container() {
      return this._container;
    }

    get canvas() {
      return this._canvas;
    }

    getPlugin(e) {
      return this.plugins[e.PluginType];
    }

    getPluginByType(e) {
      return this.plugins[e];
    }

    async addPlugin(e, ...t) {
      var n;
      let r;
      r = e.prototype ? new e(...t) : e;
      const i = no(r);
      return i ? (null === (n = r.dependencies) || void 0 === n || n.forEach(e => {
        this.getPlugin(e) || (this.console.log("Adding plugin dependency", e.name, "for", i), this.addPlugin(e));
      }), this.plugins[i] && this.console.error(`Plugin of type ${i} already exists`, this.plugins[i], r), this.plugins[i] = r, await r.onAdded(this), this.dispatchEvent({
        type: "addPlugin",
        target: this,
        plugin: r
      }), this.setDirty(r), r) : (this.console.error("PluginType is not defined for", r), r);
    }

    async removePlugin(e, t = !0) {
      const n = no(e);
      this.plugins[n] && (await e.onRemove(this), delete this.plugins[n], t && (await e.onDispose(this)), this.setDirty(e));
    }

    createCamera(e) {
      var t;
      const n = null !== (t = e.userData.iCamera) && void 0 !== t ? t : new nt(e, {
        controlsMode: "",
        controlsEnabled: !1
      }, this.container);
      return n.autoLookAtTarget = !1, n;
    }

    _backgroundIntensityChanged() {
      var e, t, n, r;
      const s = null !== (r = null === (n = null === (t = null === (e = this._renderer) || void 0 === e ? void 0 : e.rendererObject) || void 0 === t ? void 0 : t.background.getPlaneMesh()) || void 0 === n ? void 0 : n.material.uniforms) && void 0 !== r ? r : i.Vj0.background.uniforms;
      s.intensity || (s.intensity = {
        value: 1
      }), s.intensity.value = this.backgroundIntensity, this.setDirty();
    }

    async setBackgroundColor(e) {
      const t = new ve().set(e).convertSRGBToLinear();
      return this.setBackground(t);
    }

    async setBackground(e) {
      if (this._rawBackground = e, null != e && ("string" == typeof e || "number" == typeof e || e.isVector4 || e.isColor)) {
        if (e === io) return this._sceneEnvironmentChanged();
        const t = e.isVector4 ? W(e) : H(e.isColor ? e : new ve(e));
        return t.assetType = "texture", this.scene.setBackground(t);
      }

      return !e && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode"), this.scene.setBackground(e);
    }

    getBackground(e = !1) {
      var t, n, r;
      if (e) return this._rawBackground;
      let i = null !== (t = this._rawBackground) && void 0 !== t ? t : this.scene.getBackground();
      return i ? ((null === (n = i) || void 0 === n ? void 0 : n.isVector4) && (i = $s(i, 7).getHexString()), (null === (r = i) || void 0 === r ? void 0 : r.isColor) ? i.getHexString() : this._rawBackground === io ? this.scene.getEnvironment() : i) : null;
    }

    getManager() {
      return this.getPluginByType("AssetManager");
    }

    resetCamera({
      rootObject: e,
      centerOffset: t = new i.Pa4(1, 1, 1),
      targetOffset: n = new i.Pa4(0, 0, 0),
      ...r
    } = {}) {
      if (this.scene.activeCamera) {
        this.scene.matrixWorldNeedsUpdate = !0, this.scene.updateMatrixWorld(!0);
        const r = e ? new P().expandByObject(e, !0, !0) : this.scene.getBounds(!0),
              s = r.getCenter(new i.Pa4()),
              o = .5 * r.getSize(new i.Pa4()).length();
        s.add(n.clone().multiplyScalar(o)), this.scene.activeCamera.position = new i.Pa4(s.x + t.x * o, s.y + t.y * o, s.z + t.z * o), this.scene.activeCamera.target = s, this.setDirty();
      }
    }

    async createObject3D(e) {
      var t;
      return null === (t = this.getManager()) || void 0 === t ? void 0 : t.addImportedSingle(e || new i.Tme(), {
        autoScale: !1,
        pseudoCenter: !1
      });
    }

    createPhysicalMaterial(e) {
      var t, n, r, i, s;

      if (null === (t = e) || void 0 === t ? void 0 : t.isMaterial) {
        const t = null === (r = null === (n = this.getManager()) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e.uuid);
        if (t) return t;
      }

      return null === (s = null === (i = this.getManager()) || void 0 === i ? void 0 : i.materials) || void 0 === s ? void 0 : s.generateFromTemplate("standard", e);
    }

    serializePlugins(e, t) {
      return Object.entries(this.plugins).map(n => {
        var r, i;
        if (!t || t.includes(n[1].constructor.PluginType)) return null === (i = (r = n[1]).toJSON) || void 0 === i ? void 0 : i.call(r, e);
      }).filter(e => !!e);
    }

    deserializePlugins(e, t) {
      return e.forEach(e => {
        var n;
        if (!e.type) return void this.console.warn("Invalid plugin to import ", e);
        const r = this.getPluginByType(e.type);
        r && (null === (n = r.fromJSON) || void 0 === n || n.call(r, e, t));
      }), this;
    }

    toJSON(e, t) {
      return Object.assign({
        version: ro.VERSION,
        plugins: this.serializePlugins(e, t)
      }, Me(this, !0, e));
    }

    async fromJSON(e, t) {
      return Te(e, this, !0, t), Array.isArray(e.plugins) && this.deserializePlugins(e.plugins, t), await this.setBackground(this._rawBackground), this;
    }

  }

  ro.VERSION = "0.4.5", to([xe()], ro.prototype, "scene", void 0), to([xe("background")], ro.prototype, "_rawBackground", void 0), to([xe(), C(ro.prototype._backgroundIntensityChanged)], ro.prototype, "backgroundIntensity", void 0);
  const io = "envMapBackground";

  class so extends Ft {
    constructor(e) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: M`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tDiffuse2: {
            value: e
          },
          weight: {
            value: new i.Ltg(1, 1, 1, 1)
          },
          weight2: {
            value: new i.Ltg(1, 1, 1, 1)
          }
        }
      }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0;
    }

    set weights2(e) {
      this.uniforms.weight2.value.copy(e);
    }

    get weights2() {
      return this.uniforms.weight2.value;
    }

    set weights1(e) {
      this.uniforms.weight.value.copy(e);
    }

    get weights1() {
      return this.uniforms.weight.value;
    }

    set blendTexture(e) {
      this.uniforms.tDiffuse2.value = e;
    }

  }

  class oo extends Gs {
    constructor() {
      super(), this._pipeline = [];
    }

    get passes() {
      if (!this._passes) throw "Plugin not yet added to the viewer";
      return this._passes;
    }

    get pipeline() {
      return this._pipeline;
    }

    set pipeline(e) {
      this._pipeline = e;
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = this.createPasses(e);
      this._passes = Object.fromEntries(t.map(t => (t.passId || (console.warn("no id found for pass", t), t.passId = Be()), e.renderer.registerPass(t, !0), [t.passId, t])));
    }

    async onRemove(e) {
      var t;

      if (this._passes) {
        for (const n of [...Object.values(this._passes)]) {
          const r = n;
          e.renderer.unregisterPass(r), null === (t = null == r ? void 0 : r.dispose) || void 0 === t || t.call(r);
        }

        this._passes = void 0;
      }

      await super.onRemove(e);
    }

    toJSON(e) {
      var t, n;
      const r = super.toJSON(e);
      if (!r.type) return r;
      const i = Object.entries(this.passes);
      r.passes = {};

      for (const [s, o] of i) r.passes[s] = Me(null !== (n = null === (t = o) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : o, !1, e);

      return r;
    }

    fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;

      if (e.passes) {
        const i = Object.entries(this.passes);

        for (const [s, o] of i) Te(e.passes[s], null !== (r = null === (n = o) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : o, !1, t);
      }

      return this;
    }

  }

  var ao = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const lo = [{
    x: 0,
    y: 0
  }, {
    x: -.5,
    y: 0
  }, {
    x: -.375,
    y: -.25
  }, {
    x: -.1875,
    y: -.125
  }, {
    x: -.125,
    y: -.375
  }, {
    x: .0625,
    y: -.0625
  }, {
    x: .125,
    y: -.3125
  }, {
    x: .375,
    y: -.4375
  }, {
    x: .3125,
    y: -.1875
  }, {
    x: .25,
    y: .0625
  }, {
    x: .4375,
    y: .25
  }, {
    x: .1875,
    y: .3125
  }, {
    x: 0,
    y: .4375
  }, {
    x: -.0625,
    y: .1875
  }, {
    x: -.25,
    y: .375
  }, {
    x: -.4375,
    y: .5
  }, {
    x: -.3125,
    y: .125
  }];

  class co extends oo {
    constructor(e = 2 * lo.length) {
      super(), this.enabled = !0, this.jitter = !0, this._hasSetOffset = !1, this.trackedJitterCameras = new Set(), this._addSceneObject = e => {
        const t = e.object;
        (t.modelObject || t.lightObject) && (t.modelObject || t.lightObject).traverse(e => {
          var t;
          (null === (t = null == e ? void 0 : e.shadow) || void 0 === t ? void 0 : t.camera) && e.shadow.mapSize && this.trackedJitterCameras.add([e.shadow.camera, e.shadow.mapSize]);
        });
      }, this._jitterCamera = e => {
        var t;
        const n = e.target;

        if (this.jitter && n.renderer.frameCount > 2) {
          const e = (e, t) => {
            const r = { ...lo[n.renderer.frameCount % lo.length]
            };
            e.setViewOffset(t.width, t.height, r.x, r.y, t.width, t.height);
          },
                r = n.scene.activeCamera.cameraObject;

          e(r, {
            width: n.canvas.clientWidth * n.renderer.displayCanvasScaling,
            height: n.canvas.clientHeight * n.renderer.displayCanvasScaling
          }), this.trackedJitterCameras.forEach(t => e(...t)), this._hasSetOffset = !0, null === (t = this._viewer) || void 0 === t || t.renderer.resetShadows();
        }
      }, this._resetCameraJitter = e => {
        const t = e.target;
        this._hasSetOffset && (t.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = !1);
      }, this.uiConfig = $e("Progressive", this), this.maxFrameCount = e;
    }

    async onAdded(e) {
      return this._lastFrame = e.renderer.composerTarget.clone(!0), await super.onAdded(e);
    }

    async onRemove(e) {
      e.removeEventListener("preRender", this._jitterCamera), e.removeEventListener("postRender", this._resetCameraJitter), e.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrame && e.renderer.disposeTarget(this._lastFrame), this._lastFrame = void 0, await super.onRemove(e);
    }

    get lastFrame() {
      return this._lastFrame;
    }

    createPasses(e) {
      e.addEventListener("preRender", this._jitterCamera), e.addEventListener("postRender", this._resetCameraJitter), e.scene.addEventListener("addSceneObject", this._addSceneObject);
      const t = this;
      return [Hs(e, {
        passId: "progressive",

        get dirty() {
          var e;
          return t.jitter && ((null === (e = t._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) || 0) < t.maxFrameCount;
        },

        after: ["render"],
        before: ["tonemap", "screen"],
        required: ["render"],
        passObject: new class extends so {
          render(n, r, i, s, o) {
            if (e.renderer.frameCount < 1) return this.needsSwap = !1, void ((null == i ? void 0 : i.texture) && e.renderer.blit(i.texture, t.lastFrame, {}));
            this.needsSwap = !0, super.render(n, r, i, s, o), e.renderer.blit(r.texture, t.lastFrame, {});
          }

        }(),

        update() {
          if (!t.lastFrame) return void console.error("lastFrame render target undefined");
          let n = 1 / (Math.max(e.renderer.frameCount, 0) + 1);
          this.passObject.weights1.set(n, n, n, n), n = 1 - n, this.passObject.weights2.set(n, n, n, n), this.passObject.blendTexture = t.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = !0;
        }

      })];
    }

    isConverged(e = !1) {
      var t;
      return ((null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e ? 1 : 0);
    }

    updateShaderProperties(e) {
      var t, n;
      return e.uniforms.tLastFrame && (e.uniforms.tLastFrame.value = null !== (n = null === (t = this.lastFrame) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : void 0), this;
    }

    postFrameConvergedRecordingDelta(e = "CanvasRecorder") {
      const t = this._viewer.getPluginByType(e);

      return t && t.isRecording() && t.convergeMode ? this.isConverged(!0) ? 1 / t.videoFrameRate : 0 : -1;
    }

  }

  co.PluginType = "Progressive", ao([xe(), qe("Frame count")], co.prototype, "maxFrameCount", void 0), ao([xe(), Ve("Jitter")], co.prototype, "jitter", void 0);

  var uo = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const po = i.dZ3;
  let ho = class extends Ft {
    constructor(e = !1) {
      super({
        vertexShader: s.vertexShader,
        uniforms: {
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tGBufferFlags: {
            value: null
          },
          opacity: {
            value: 1
          }
        },
        defines: {
          TONEMAP_BACKGROUND: 0,
          TRANSPARENT_BACKGROUND: 0,
          GBUFFER_HAS_FLAGS: 0
        },
        fragmentShader: `\n${e ? jt : ""}\n#define USE_DEPTH_TONEMAP ${e ? "1" : "0"}\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));gl_FragColor=opacity*texel;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getGBufferFlags(vUv).x>0.5;\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nif(getDepth(vUv)>0.999)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#include <tonemapping_fragment>\n#if USE_DEPTH_TONEMAP > 0\n}else{\n#if TRANSPARENT_BACKGROUND > 0\ngl_FragColor.a=0.;\n#endif\n}\n#endif\n#include <encodings_fragment>\n}\n                `
      }, "tDiffuse"), this.uiConfig = void 0, this.toneMapping = i.LY2, this.tonemapBackground = !0, this.clipBackground = !1, this.exposure = 1;
    }

    render(e, t, n, r, s) {
      const {
        toneMapping: o,
        toneMappingExposure: a,
        outputEncoding: l
      } = e;
      let c = this.tonemapBackground ? "1" : "0";
      this.material.defines.TONEMAP_BACKGROUND !== c && (this.material.defines.TONEMAP_BACKGROUND = c, this.material.needsUpdate = !0), c = this.clipBackground ? "1" : "0", this.material.defines.TRANSPARENT_BACKGROUND !== c && (this.material.defines.TRANSPARENT_BACKGROUND = c, this.material.needsUpdate = !0), e.toneMapping = this.toneMapping, e.toneMappingExposure = this.exposure, e.outputEncoding = i.knz, this.material.toneMapped = !0, this.material.needsUpdate = !0, super.render(e, t, n, r, s), e.toneMapping = o, e.toneMappingExposure = a, e.outputEncoding = l, this.needsSwap = !0;
    }

  };
  uo([Ke("Mode", [["Linear", i.EoG], ["Reinhard", i.CdI], ["Cineon", i.YGz], ["ACESFilmic", i.LY2], ["Uncharted2", po]].map(e => ({
    label: e[0],
    value: e[1]
  })), {
    limitedUi: !0
  }), xe()], ho.prototype, "toneMapping", void 0), uo([Ve("Tonemap Background", {
    limitedUi: !0
  }), xe()], ho.prototype, "tonemapBackground", void 0), uo([Ve("Clip Background"), xe()], ho.prototype, "clipBackground", void 0), uo([He("Exposure", [0, 2 * Math.PI], .01, {
    limitedUi: !0
  }), xe()], ho.prototype, "exposure", void 0), ho = uo([Qe("Tonemapping")], ho), i.WdD.tonemapping_pars_fragment = i.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");

  class fo extends Ws {
    constructor(e = !1, t = !0) {
      super(), this.depthTonemap = e, this.renderToScreen = t, this.passId = "tonemap", this.dependencies = [Ys], this._beforeFilters = [], this._afterFilters = ["render"], this._requiredFilters = ["render"], this._setDirty = this._setDirty.bind(this);
    }

    async onAdded(e) {
      return this.renderToScreen && g(e.renderer.passes.find(e => "screen" === e.passId), "enabled", !1, !0, !0), super.onAdded(e);
    }

    passCtor(e) {
      var t, n;
      const r = new ho(this.depthTonemap);
      return g(null === (n = null === (t = r.uiConfig) || void 0 === t ? void 0 : t.children) || void 0 === n ? void 0 : n.find(e => {
        var t;
        return "Enabled" === (null === (t = e) || void 0 === t ? void 0 : t.label);
      }), "hidden", !0, !0), r;
    }

    _update(e) {
      var t;
      return !!super._update(e) && (this._pass.passObject.updateShaderProperties(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Ys)), !0);
    }

    get exposure() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.exposure) && void 0 !== t ? t : 1;
    }

    set exposure(e) {
      var t;
      const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      n && (n.exposure = e, this._setDirty());
    }

    get toneMapping() {
      var e, t;
      return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.toneMapping) && void 0 !== t ? t : i.EoG;
    }

    set toneMapping(e) {
      var t;
      const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      n && (n.toneMapping = e, this._setDirty());
    }

    _setDirty() {
      this.pass && (this.pass.dirty = !0);
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this._setDirty)), s;
    }

  }

  fo.PluginType = "Tonemap";

  var _o = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}",
      mo = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS\nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED\n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n",
      go = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS\nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n",
      vo = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS\nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n",
      bo = "#define PI 3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}",
      xo = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP\n#define pow2(a) a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH 1.0\n#define LOD_COLOR 5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n",
      yo = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}",
      wo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS\n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n",
      So = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Mo = class extends Ft {
    constructor(e, t, n, r = !0) {
      super({
        vertexShader: _o,
        fragmentShader: `\n\nvarying vec2 vUv;\n\n${go}\n${mo}\n${vo}\n${bo}\n${n}\n\n${xo}\n\n${yo}\n\nuniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}\n#include <encodings_fragment>\n}\n\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 0
          },
          boost: {
            value: new i.Pa4(0, 0, 0)
          },
          objectRadius: {
            value: 0
          },
          autoRadius: {
            value: !1
          },
          power: {
            value: 0
          },
          maskFrontFactor: {
            value: -.1
          },
          tolerance: {
            value: 0
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new i.yGw()
          },
          cameraPositionWorld: {
            value: new i.Pa4()
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSR_STEP_COUNT: 16,
          SSR_LOW_QUALITY_FRAMES: 2,
          SSR_MASK_FRONT_RAYS: !0,
          SSR_INLINE: r ? "1" : "0",
          SSR_NON_PHYSICAL: "0"
        }
      }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSR_ENABLED) return;
          const r = "#glMarker beforeModulation";
          e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSR_ENABLED) && SSR_ENABLED > 0\nvec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;\n#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0\nalphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);\n#endif\n#ifdef USE_TRANSMISSION\nalphaModifier*=1.-transmission;\n#endif\nfloat vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){\n#if defined(SSR_INLINE) && SSR_INLINE > 0\nssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);\n#else\nssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));\n#endif \n}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);\n#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0\ndiffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=vec3(0.);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);\n#else\nreflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`);
        },
        onObjectRender: (e, t, n) => {
          var r, i, s, o;
          let a = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r.ssreflDisabled) ? 1 : 0;
          t.materialObject.defines.SSR_ENABLED !== a && (t.materialObject.defines.SSR_ENABLED = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_STEP_COUNT, t.materialObject.defines.SSR_STEP_COUNT !== a && (t.materialObject.defines.SSR_STEP_COUNT = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_LOW_QUALITY_FRAMES, t.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== a && (t.materialObject.defines.SSR_LOW_QUALITY_FRAMES = a, t.materialObject.needsUpdate = !0), a = this.material.defines.PERSPECTIVE_CAMERA, t.materialObject.defines.PERSPECTIVE_CAMERA !== a && (t.materialObject.defines.PERSPECTIVE_CAMERA = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_INLINE, t.materialObject.defines.SSR_INLINE !== a && (t.materialObject.defines.SSR_INLINE = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t.materialObject.defines.SSR_MASK_FRONT_RAYS !== a && (t.materialObject.defines.SSR_MASK_FRONT_RAYS = a, t.materialObject.needsUpdate = !0), a = (null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssreflNonPhysical) ? "1" : "0", t.materialObject.defines.SSR_NON_PHYSICAL !== a && (t.materialObject.defines.SSR_NON_PHYSICAL = a, t.materialObject.needsUpdate = !0), a = null !== (o = null === (s = this._target) || void 0 === s ? void 0 : s.texture) && void 0 !== o ? o : null, this.materialExtension.extraUniforms.tSSRMap.value !== a && (this.materialExtension.extraUniforms.tSSRMap.value = a, t.materialObject.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + U("tSSRMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2) + U("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e.capabilities.isWebGL2) + (this._inline ? `\n#if 1\n// #if SSR_INLINE\n    ${go}\n    \n    #define THREE_PACKING_INCLUDED\n    ${mo}\n    \n    ${vo}\n    ${bo}\n    ${jt}\n    \n    ${xo}\n    \n    ${yo}\n// #endif // SSR_INLINE\n#endif\n` : "") + `\n\n${wo}\n\n        `;
        },
        extraUniforms: {
          tSSRMap: {
            value: null
          },
          ssrPower: this.material.uniforms.power,
          ssrIntensity: this.material.uniforms.intensity,
          ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor,
          ssrBoost: this.material.uniforms.boost,
          tNormalDepth: this.material.uniforms.tNormalDepth,
          tLastFrame: this.material.uniforms.tLastFrame,
          objectRadius: this.material.uniforms.objectRadius,
          autoRadius: this.material.uniforms.autoRadius,
          tolerance: this.material.uniforms.tolerance,
          frameCount: this.material.uniforms.frameCount,
          projection: this.material.uniforms.projection,
          cameraPositionWorld: this.material.uniforms.cameraPositionWorld,
          cameraNearFar: this.material.uniforms.cameraNearFar,
          sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssreflDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 1, this.boost = new i.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = !0, this.power = 1.1, this.tolerance = .5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = !0, this.maskFrontFactor = -.2, this._renderer = e, this._target = t, this.needsSwap = !1, this._inline = r;
    }

    render(e, t, n, r, i) {
      if (this._inline) this.needsSwap = !1;else {
        if (!this._target) throw "Target must be set when inline = false";
        this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.needsSwap = !1;
      }
    }

  };
  So([He("Intensity", [0, 4]), xe(), V()], Mo.prototype, "intensity", void 0), So([We("Boost"), xe(), V()], Mo.prototype, "boost", void 0), So([He("Object Radius", [.01, 2]), xe(), V()], Mo.prototype, "objectRadius", void 0), So([Ve("Auto radius"), xe(), V()], Mo.prototype, "autoRadius", void 0), So([He("Power", [0, 3]), xe(), V()], Mo.prototype, "power", void 0), So([He("Tolerance", [.1, 5]), xe(), V()], Mo.prototype, "tolerance", void 0), So([He("Step count", [1, 32], 1), xe(), G("SSR_STEP_COUNT")], Mo.prototype, "stepCount", void 0), So([He("Low Quality Frames", [0, 4], 1), xe(), G("SSR_LOW_QUALITY_FRAMES")], Mo.prototype, "lowQualityFrames", void 0), So([Ve("Ignore front rays"), xe(), G("SSR_MASK_FRONT_RAYS")], Mo.prototype, "maskFrontRays", void 0), So([He("Mask front rays factor", [-1, 1], .01, e => ({
    hidden: () => !e.maskFrontRays
  })), xe(), V()], Mo.prototype, "maskFrontFactor", void 0), Mo = So([Qe("Screen Space Reflections")], Mo);

  class To extends oo {
    constructor() {
      super(), this.dependencies = [Vs, Ys, co], this.inlineSSR = !0, this.setDirty = this.setDirty.bind(this);
    }

    get ssrTarget() {
      return this._ssrTarget;
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssr) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssr.passObject.enabled = e);
    }

    async onAdded(e) {
      var t, n;
      e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    createPasses(e) {
      var t, n;
      return this._ssrTarget = this.inlineSSR ? void 0 : e.renderer.createTarget({
        sizeMultiplier: 1
      }), [Hs(e, {
        passId: "ssr",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new Mo(e.renderer, this._ssrTarget, null !== (n = null === (t = e.getPlugin(Ys)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : "", this.inlineSSR)
      }, () => [e.getPlugin(Ys), e.getPlugin(co), e.scene.activeCamera, e.renderer, e.scene])];
    }

    async onRemove(e) {
      return this._ssrTarget && e.renderer.disposeTarget(this._ssrTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }

  }

  To.PluginType = "SSReflection";

  var Eo = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Ao extends Ft {
    constructor(e, t, n = "rgba") {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: t + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}",
        uniforms: {
          bilDirection: {
            value: new i.FM8(1, 0)
          },
          tNormalDepth: {
            value: null
          },
          tDiffuse: {
            value: e.texture
          },
          tDiffuseSize: {
            value: new i.FM8()
          }
        },
        defines: {
          B_SRC_ACCESSOR: n
        }
      }, "tDiffuse", "tDiffuse2"), this.smoothEnabled = !0, this.edgeSharpness = .1, this._target = e, this.clear = !1, this.needsSwap = !1;
    }

    render(e, t, n, r, i) {
      var s, o, a, l;
      this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s = this.uniforms.tDiffuse.value) || void 0 === s ? void 0 : s.image.width) || 0, (null === (o = this.uniforms.tDiffuse.value) || void 0 === o ? void 0 : o.image.height) || 0), super.render(e, t, this._target, r, i), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t.texture, this.uniforms.tDiffuseSize.value.set((null === (a = this.uniforms.tDiffuse.value) || void 0 === a ? void 0 : a.image.width) || 0, (null === (l = this.uniforms.tDiffuse.value) || void 0 === l ? void 0 : l.image.height) || 0), super.render(e, this._target, t, r, i));
    }

  }

  Eo([xe(), V()], Ao.prototype, "smoothEnabled", void 0), Eo([xe(), V()], Ao.prototype, "edgeSharpness", void 0);

  var Co = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Ro extends Ft {
    constructor(e, t, n) {
      super({
        defines: {
          LINEAR_DEPTH: 1,
          NUM_SAMPLES: 11,
          NUM_SPIRAL_TURNS: 3,
          DEPTH_NORMAL_TEXTURE: 1,
          DEPTH_PACKING_MODE: 2,
          PERSPECTIVE_CAMERA: 1
        },
        uniforms: {
          tLastThis: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          screenSize: {
            value: new i.FM8(512, 512)
          },
          saoData: {
            value: new i.Ltg()
          },
          frameCount: {
            value: 0
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          projection: {
            value: new i.yGw()
          },
          saoBiasEpsilon: {
            value: new i.Pa4(1, 1, 1)
          }
        },
        vertexShader: _o,
        fragmentShader: `\n\n${vo}\n\n${n}\n\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);float getViewZFromNDCZ(const in float depth){\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;\n#if DEPTH_PACKING_MODE == 2\nuncodedDepth=texture2D(tNormalDepth,uv);\n#else\nuncodedDepth=texture2D(tDepth,uv);\n#endif\n#if DEPTH_PACKING_MODE == 0\nreturn uncodedDepth.x;\n#elif DEPTH_PACKING_MODE == 1\n#if LINEAR_DEPTH == 1\nreturn pow2(unpackRGBAToDepth(uncodedDepth));\n#else\nreturn unpackRGBAToDepth(uncodedDepth);\n#endif\n#else\nreturn pow2(unpack16(uncodedDepth.xy));\n#endif\n}vec3 getPositionFromOffset(const in vec2 uv,const in vec2 offset,const in float screenSpaceRadius){vec2 uvOffset=uv+floor(screenSpaceRadius*offset)/screenSize;float d=decodeDepth(uvOffset);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);\n#else\nd=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);\n#endif\n}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 offset=vec2(cos(angle),sin(angle));vec3 samplePosition=getPositionFromOffset(uv,offset,screenSpaceRadius);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(centerDepth);\n#else\nfloat centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);\n#endif\nvec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#if NUM_SAMPLES > 1\nsum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 2\nsum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 3\nsum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 4\nsum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 5\nsum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 6\nsum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 7\nsum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 8\nsum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 9\nsum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 10\nsum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\nfloat aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}\n\n            `
      }, "tDiffuse"), this.parameters = {
        intensity: .25,
        occlusionWorldRadius: 1,
        bias: .001,
        falloff: 1,
        edgeSharpness: .3,
        blurEnabled: !0
      }, this._smoothEnabled = !0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          e.defines.SSAO_ENABLED && (e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif\n#endif\n"));
        },
        onObjectRender: (e, t, n) => {
          var r, i;
          this.materialExtension.extraUniforms.tSSAOMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
          const s = t.materialObject,
                o = !s.transparent && s.transmission < .001;
          let a = this.enabled && o && !1 !== n.userData.screenSpaceRendering && !(null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssaoDisabled) ? 1 : 0;
          s.defines.SSAO_ENABLED !== a && (s.defines.SSAO_ENABLED = a, s.needsUpdate = !0), a = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== a && (this.materialExtension.extraUniforms.tSSAOMap.value = a, s.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return M`
             uniform sampler2D tSSAOMap;
             ${U("tSSAOMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}
            ${wo}
        `;
        },
        extraUniforms: {
          tSSAOMap: {
            value: null
          }
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this._renderer = e, this._target = t, this.needsSwap = !1, this.clear = !0, this.bilateralPass = new Ao(this._target, n, "rrrr");
    }

    get smoothEnabled() {
      return this._smoothEnabled;
    }

    set smoothEnabled(e) {
      this._smoothEnabled = e, this.bilateralPass.enabled = e, this.bilateralPass.uniforms.smoothEnabled.value = e;
    }

    render(e, t, n, r, i) {
      this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this._smoothEnabled && this.bilateralPass.render(e, t, n, r, i));
    }

    _updateParameters() {
      const e = this.material.uniforms.saoData.value;
      e.y = this.parameters.intensity, e.z = this.parameters.occlusionWorldRadius;
      const t = this.material.uniforms.saoBiasEpsilon.value;
      t.x = this.parameters.bias, t.y = .001, t.z = this.parameters.falloff;
    }

  }

  Co([xe()], Ro.prototype, "bilateralPass", void 0), Co([xe()], Ro.prototype, "parameters", void 0);

  class ko extends oo {
    constructor() {
      super(), this.dependencies = [Vs, Ys], this.setDirty = this.setDirty.bind(this);
    }

    get aoTarget() {
      return this._aoTarget;
    }

    async onAdded(e) {
      return e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), super.onAdded(e);
    }

    createPasses(e) {
      var t, n;
      return this._aoTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      }), [Hs(e, {
        passId: "ssao",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer"],
        passObject: new Ro(e.renderer, this._aoTarget, null !== (n = null === (t = e.getPlugin(Ys)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : ""),

        update() {
          this.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Ys)]);
        }

      }, () => [e.getPlugin(Ys), e.scene.activeCamera, e.renderer])];
    }

    async onRemove(e) {
      return e.renderer.disposeTarget(this._aoTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssao) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssao) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssao.passObject.enabled = e);
    }

    get uiConfig() {
      var e;
      if (this._uiConfig) return this._uiConfig;
      const t = this,
            n = t.passes.ssao.passObject;
      return this._uiConfig = {
        type: "folder",
        label: "SS Ambient Occlusion",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [n, "enabled"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 4],
          property: [n.parameters, "intensity"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Radius",
          bounds: [.1, 8],
          property: [n.parameters, "occlusionWorldRadius"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Bias",
          bounds: [1e-5, .01],
          property: [n.parameters, "bias"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Falloff",
          bounds: [.01, 3],
          property: [n.parameters, "falloff"],
          onChange: t.setDirty
        }, {
          type: "slider",
          label: "Num samples",
          stepSize: 1,
          bounds: [1, 11],
          property: [null === (e = n.material) || void 0 === e ? void 0 : e.defines, "NUM_SAMPLES"],
          onChange: [() => n.material.needsUpdate = !0, t.setDirty]
        }, {
          type: "checkbox",
          property: [n.bilateralPass, "smoothEnabled"],
          onChange: t.setDirty
        }, {
          type: "vec4",
          property: [n.bilateralPass, "edgeSharpness"],
          onChange: t.setDirty
        }]
      };
    }

  }

  ko.PluginType = "SSAO";

  class Po {
    constructor(e) {
      this._normalsCache = {}, this._renderer = e, this._scene = new i.xsS(), this._mesh = new i.Kj0(), this._mesh.frustumCulled = !1, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Do();
    }

    dispose() {
      this._mesh.material.dispose();
    }

    captureNormalMap(e, t, n = 512) {
      if (!e) throw "No geometry";
      if (e.userData._normalsCaptureMap) return !1;
      const r = null == t ? void 0 : t.split(";").find(e => this._normalsCache[e]);

      if (r) {
        const i = this._normalsCache[r];
        return null == t || t.split(";").forEach(e => e !== r && (this._normalsCache[e] = i)), i.width !== n && console.warn("last cacheKey normalMapRes mismatch, check model", n), e.userData._normalsCaptureMap = i, !1;
      }

      const s = this._renderer.createTargetCustom({
        width: n,
        height: n
      }, {
        minFilter: i.TyD,
        magFilter: i.TyD,
        generateMipmaps: !1,
        type: i.cLu
      }, i.oAp);

      if (!s) throw "Unable to create render target";
      null == t || t.split(";").forEach(e => this._normalsCache[e] = s), s.addEventListener("dispose", () => delete this._normalsCache[t]);
      const o = new i._am(1e-4, 100, s);

      this._scene.add(o);

      const a = e.userData._normalsCaptureOffsets;
      return void 0 !== a.center && this._mesh.material.uniforms.offsetCenter.value.copy(a.center), void 0 !== a.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.copy(a.offsetMatrixInv), void 0 !== a.radius && (this._mesh.material.uniforms.radius.value = a.radius), this._mesh.geometry = e, o.update(this._renderer.rendererObject, this._scene), this._scene.remove(o), this._mesh.geometry = void 0, e.userData._normalsCaptureMap = s, !0;
    }

  }

  class Do extends i.jyz {
    constructor() {
      super({
        vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);vecPosition=(modelMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.);}",
        fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}",
        side: i.ehD,
        clipping: !1,
        uniforms: {
          radius: {
            value: 1
          },
          offsetMatrixInv: {
            value: new i.yGw().identity()
          },
          offsetCenter: {
            value: new i.Pa4()
          }
        }
      });
    }

  }

  function Oo(e) {
    const t = new i.Pa4(0, 0, 0),
          n = new i.Pa4(0, 0, 0),
          r = new i.Pa4(0, 0, 0),
          s = new i.Pa4(0, 0, 0),
          o = e.getAttribute("position"),
          a = e.index;
    if (a) for (let i = Math.max(0, e.drawRange.start), l = Math.min(a.count, e.drawRange.start + e.drawRange.count) - 1; i < l / 3; i += 3) {
      const e = a.getX(i),
            l = a.getX(i + 1),
            c = a.getX(i + 2);
      n.set(o.getX(e), o.getY(e), o.getZ(e)), r.set(o.getX(l), o.getY(l), o.getZ(l)), s.set(o.getX(c), o.getY(c), o.getZ(c)), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s);
    } else {
      const e = o.array;

      for (let i = 0; i < e.length / 3; i += 9) n.set(e[i], e[i + 1], e[i + 2]), r.set(e[i + 3], e[i + 4], e[i + 5]), s.set(e[i + 6], e[i + 7], e[i + 8]), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s);
    }
    t.normalize();
    let l = !1,
        c = 0;

    for (; !l;) {
      const e = c / 3,
            i = a ? a.getX(e) : e,
            s = a ? a.getX(e + 1) : e + 1;
      n.set(o.getX(i), o.getY(i), o.getZ(i)), r.set(o.getX(s), o.getY(s), o.getZ(s)), n.sub(r), n.normalize();
      const u = t.dot(n);
      Math.abs(u - 1) > .001 && n.length() > .5 && (l = !0), c += 3;
    }

    r.crossVectors(n, t), r.normalize(), n.crossVectors(t, r), n.normalize();
    const u = new i.yGw();
    u.elements[0] = n.x, u.elements[1] = n.y, u.elements[2] = n.z, u.elements[3] = 0, u.elements[4] = t.x, u.elements[5] = t.y, u.elements[6] = t.z, u.elements[7] = 0, u.elements[8] = r.x, u.elements[9] = r.y, u.elements[10] = r.z, u.elements[11] = 0, u.elements[12] = 0, u.elements[13] = 0, u.elements[14] = 0, u.elements[15] = 1, e.computeBoundingSphere();
    const p = e.boundingSphere.radius,
          h = new i.yGw().makeScale(p, p, p);
    return u.multiply(h), u;
  }

  const Lo = { ...Gt,
    color: new ve(1, 1, 1),
    envMapIntensity: 1,
    envMapRotation: 0,
    dispersion: .012,
    squashFactor: .98,
    geometryFactor: .5,
    gammaFactor: 1,
    absorptionFactor: 1,
    reflectivity: .5,
    refractiveIndex: 2.4,
    boostFactors: new i.Pa4(.892, .892, .98595025),
    envMap: null,
    wireframe: !1,
    wireframeLinewidth: 0,
    skinning: !1,
    transmission: 0,
    morphTargets: !1,
    morphNormals: !1,
    rayBounces: 1,
    diamondOrientedEnvMap: 0
  };

  var Io = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Fo extends i.jyz {
    constructor(e) {
      super({
        side: i.ehD,
        defines: {
          DIA_ORIENT_ENVMAP: 0,
          RAY_BOUNCES: 5,
          ENV_MAP_TYPE: 0,
          PI: 3.1428
        },
        vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;void main(){vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;}",
        fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform mat4 modelMatrix;uniform mat4 inverseModelMatrix;uniform mat4 offsetMatrixInv;uniform mat4 offsetMatrix;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float radius;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform vec3 centerOffset;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.z*=-1.;\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){return envMapIntensity*(sampleEnvMap(direction));}uniform mat4 projectionMatrix;vec4 SampleSpecularContribution(vec3 direction){direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=centerOffset;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+centerOffset+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-centerOffset);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=centerOffset+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-centerOffset);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=centerOffset+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 traceRay(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 reflectedDirection=reflect(direction,normal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normal,vec3(f0),0.);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);outColor+=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;int count=0;newDirection=(offsetMatrixInv*inverseModelMatrix*vec4(newDirection,0.)).xyz;newDirection=normalize(newDirection);origin=(offsetMatrixInv*inverseModelMatrix*vec4(origin,1.)).xyz;vec3 origin2=origin;origin2=(modelMatrix*offsetMatrix*vec4(origin2,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-centerOffset);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;origin2=(modelMatrix*offsetMatrix*vec4(intersectedPos,1.)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(oldDir,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(DIA_ORIENT_ENVMAP<1?d1:newDirection).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(newDirection,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);\n#if DIA_ORIENT_ENVMAP < 1\ndir0=d1;dir1=(modelMatrix*offsetMatrix*vec4(dir1,0.)).xyz;dir2=(modelMatrix*offsetMatrix*vec4(dir2,0.)).xyz;\n#endif\noutColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);vec3 color=traceRay(vWorldPosition,viewVector,normalizedNormal);gl_FragColor=vec4(color.rgb,1.);\n#include <encodings_fragment>\n}",
        uniforms: {
          envMap: {
            value: e.envMap || null
          },
          envMapRotation: {
            value: 0
          },
          transmission: {
            value: 0
          },
          transmissionSamplerMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new i.FM8()
          },
          normalOffset: {
            value: 0
          },
          distanceOffset: {
            value: 0
          },
          colorCorrection: {
            value: new i.Pa4(1, 1, 1)
          }
        }
      }), this.typeSlug = Fo.TypeSlug, this.assetType = "material", this._envMap = null, this.isDiamondMaterial = !0, this.color = new ve(1, 1, 1), this.envMapIntensity = 1, this.dispersion = .012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = .98, this.geometryFactor = .5, this.gammaFactor = 1, this.boostFactors = new i.Pa4(.892, .892, .98595025), this.transmission = 0, this.reflectivity = .5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = {
        inverseModelMatrix: {
          value: new i.yGw().identity()
        },
        radius: {
          value: 1
        },
        centerOffset: {
          value: new i.Pa4(0, 0, 0)
        },
        offsetMatrix: {
          value: new i.yGw().identity()
        },
        offsetMatrixInv: {
          value: new i.yGw().identity()
        }
      }, this.userData.setDirty = () => {
        var e, t;
        this.needsUpdate = !0, this.dispatchEvent({
          type: "materialUpdate"
        }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
      }, this.userData.separateEnvMapIntensity = !0, this.setValues(e);
    }

    get mmMaterial() {
      return this;
    }

    get materialObject() {
      return this;
    }

    onBeforeRender(e, t, n, r, i) {
      var s, o;
      super.onBeforeRender(e, t, n, r, i), this.uniforms.envMapRotation.value = (null === (s = this.envMap) || void 0 === s ? void 0 : s.rotation) || 0, this.extraUniformsToUpload.inverseModelMatrix.value.copy(i.matrixWorld).invert();
      const a = r.userData._normalsCaptureOffsets;
      a && (this.extraUniformsToUpload.centerOffset.value.copy(a.centerOffset), this.extraUniformsToUpload.offsetMatrix.value.copy(a.offsetMatrix), this.extraUniformsToUpload.offsetMatrixInv.value.copy(a.offsetMatrixInv), this.extraUniformsToUpload.radius.value = a.radius);
      const l = null === (o = r.userData._normalsCaptureMap) || void 0 === o ? void 0 : o.texture;
      this.normalsCaptureMap !== l && (this.normalsCaptureMap = l);
    }

    set envMap(e) {
      var t;
      this._envMap = e, this.uniforms.envMap.value = this._envMap, (null === (t = this._envMap) || void 0 === t ? void 0 : t.isCubeTexture) ? (this.defines.ENV_MAP_TYPE = 0, this.needsUpdate = !0) : (this.defines.ENV_MAP_TYPE = 1, this.needsUpdate = !0);
    }

    get envMap() {
      return this._envMap;
    }

    clone() {
      return super.clone();
    }

    toJSON(e) {
      const t = {};
      return t.name = this.name, t.uuid = this.uuid, t.color = this.color.getHex(), t.envMapIntensity = this.envMapIntensity, t.dispersion = this.dispersion, t.squashFactor = this.squashFactor, t.geometryFactor = this.geometryFactor, t.gammaFactor = this.gammaFactor, t.absorptionFactor = this.absorptionFactor, t.reflectivity = this.reflectivity, t.refractiveIndex = this.refractiveIndex, t.rayBounces = this.rayBounces, t.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t.boostFactors = {
        x: this.boostFactors.x,
        y: this.boostFactors.y,
        z: this.boostFactors.z,
        isVector3: !0
      }, t.transmission = this.transmission, t.isDiamondMaterialParameters = !0, t.type = Fo.TYPE, t.userData = {}, qt(t.userData, this.userData), t.userData.uuid = this.userData.uuid, t;
    }

    get uiConfig() {
      const e = this;
      return this._uiConfigChildren || (this._uiConfigChildren = [{
        type: "input",
        property: [this, "name"]
      }, {
        type: "checkbox",
        property: [this, "wireframe"]
      }, ...Je(this), {
        type: "input",
        label: "Mesh count",

        get value() {
          var t, n, r;
          return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0;
        },

        set value(e) {},

        disabled: !0
      }, {
        type: "input",
        label: "uuid",

        get value() {
          return e.uuid;
        },

        set value(e) {},

        disabled: !0
      }, {
        type: "checkbox",
        label: "Render to Depth",
        hidden: () => 0 === this.transmission,

        get value() {
          return !0 === e.userData.renderToDepth;
        },

        set value(t) {
          e.userData.renderToDepth = t || void 0;
        }

      }, {
        type: "button",
        label: "Download .dmat",
        value: () => {
          vt(new Blob([JSON.stringify(e.toJSON(), null, 2)], {
            type: "application/json"
          }), "diamond-material.dmat");
        }
      }]), this._uiConfig || (this._uiConfig = {
        type: "folder",
        label: "Diamond Material",
        expanded: !0,
        children: this._uiConfigChildren,
        limitedUi: !0
      }), this._uiConfig;
    }

    copyProps(e) {
      var t, n;
      if (!e.isDiamondMaterialParameters && !e.isDiamondMaterial && !e.isDiamond) return console.warn("Material type is not supported", e), this;
      const r = {};
      y(e, r, Array.from(Object.keys(Lo)));
      const i = r.userData;
      return delete r.userData, this.setValues(r), qt(this.userData, i), null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t), this;
    }

    fromJSON(e, t) {
      return this.copyProps(e);
    }

  }

  Fo.TypeSlug = "dmat", Fo.TYPE = "DiamondMaterial", Io([Ye("Color", {
    limitedUi: !0
  }), V()], Fo.prototype, "color", void 0), Io([He("Env Intensity", [0, 5], .01, {
    limitedUi: !0
  }), V()], Fo.prototype, "envMapIntensity", void 0), Io([He("Dispersion", [0, .1], 1e-4, {
    limitedUi: !0
  }), V({
    propKey: "rIndexDelta"
  })], Fo.prototype, "dispersion", void 0), Io([He("Absorption", [0, 15], .01, {
    limitedUi: !0
  }), V()], Fo.prototype, "absorptionFactor", void 0), Io([He("Refractive Index", [0, 4], .01, {
    limitedUi: !0
  }), V()], Fo.prototype, "refractiveIndex", void 0), Io([V()], Fo.prototype, "squashFactor", void 0), Io([V()], Fo.prototype, "geometryFactor", void 0), Io([V()], Fo.prototype, "gammaFactor", void 0), Io([We("RGB Boost", void 0, void 0, {
    limitedUi: !0
  }), V()], Fo.prototype, "boostFactors", void 0), Io([He("Transmission", [0, 1], .01, {
    limitedUi: !0
  }), V()], Fo.prototype, "transmission", void 0), Io([He("Reflectivity", [0, 2], .01, {
    limitedUi: !0
  }), V()], Fo.prototype, "reflectivity", void 0), Io([G("RAY_BOUNCES", void 0, !0), He("Ray Bounces", [1, 16], 1)], Fo.prototype, "rayBounces", void 0), Io([G("DIA_ORIENT_ENVMAP", void 0, !0), He("Diamond Oriented Lighting", [0, 1], 1)], Fo.prototype, "diamondOrientedEnvMap", void 0), Io([V({
    propKey: "tCubeMapNormals"
  })], Fo.prototype, "normalsCaptureMap", void 0);

  class No extends r {
    constructor(e, t, n, r) {
      super(), this._scene = e, this._camera = null != n ? n : this._scene.activeCamera, this.domElement = t, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != r ? r : e => !1 !== e.userData.userSelectable && !1 !== e.userData.bboxVisible && null != e.material && "ShadowMaterial" !== e.material.type, this.raycaster = new i.iMs(), this.mouse = new i.FM8(), this._selected = [], this._hovering = [], this.cursorStyles = {
        default: "grab",
        down: "grabbing"
      }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", e => this.onPointerMove(e)), this.domElement.addEventListener("pointerleave", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointerout", e => this.onPointerLeave(e)), this.domElement.addEventListener("pointercancel", e => this.onPointerCancel(e)), this.domElement.addEventListener("pointerenter", e => this.onPointerEnter(e)), this.domElement.addEventListener("pointerdown", e => this.onPointerDown(e)), this.domElement.addEventListener("pointerup", e => this.onPointerUp(e));
    }

    get scene() {
      return this._scene;
    }

    set scene(e) {
      var t;
      null === (t = this._scene) || void 0 === t || t.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e, this._scene.addEventListener("activeCameraChange", this._activeCameraChange);
    }

    _activeCameraChange() {
      this.camera = this._scene.activeCamera;
    }

    get camera() {
      return this._camera;
    }

    set camera(e) {
      this._camera = e;
    }

    get selectedObject() {
      return this._selected.length > 0 ? this._selected[0] : null;
    }

    set selectedObject(e) {
      1 === this._selected.length && this._selected[0] === e || (this._selected = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "selectedObjectChanged",
        object: this.selectedObject
      }));
    }

    get hoverObject() {
      return this._hovering.length > 0 ? this._hovering[0] : null;
    }

    set hoverObject(e) {
      this._hovering = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
        type: "hoverObjectChanged",
        object: this.hoverObject
      });
    }

    get time() {
      return this._time = Ct(), this._time;
    }

    get isMouseDown() {
      return this.mouseDownDeltaTime < 0;
    }

    get mouseDownDeltaTime() {
      return this._mouseUpTime - this._mouseDownTime;
    }

    onPointerMove(e) {
      !1 !== e.isPrimary && this.updateMouseFromEvent(e);
    }

    onPointerLeave(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this.hoverObject = null);
    }

    onPointerEnter(e) {}

    onPointerCancel(e) {}

    updateMouseFromEvent(e) {
      const t = this.domElement.getBoundingClientRect();
      this.mouse.x = (e.clientX - t.x) / t.width * 2 - 1, this.mouse.y = -(e.clientY - t.y) / t.height * 2 + 1;
    }

    onPointerDown(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time);
    }

    onPointerUp(e) {
      !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time, this.mouseDownDeltaTime < 200 && this.onPointerClick(e));
    }

    onPointerClick(e) {
      if (!1 === e.isPrimary) return;
      this.updateMouseFromEvent(e);
      const t = this.checkIntersection();
      t && this.dispatchEvent({
        type: "hitObject",
        time: this._mouseUpTime,
        intersects: t
      }), this.selectedObject = (null == t ? void 0 : t.selectedObject) || null;
    }

    addPasses() {}

    checkIntersection() {
      var e;
      const t = null === (e = this._camera) || void 0 === e ? void 0 : e.cameraObject;
      if (!t) return null;
      this.raycaster.setFromCamera(this.mouse, t);
      const n = this.raycaster.intersectObject(this._scene.modelObject, !0),
            r = this.selectedObject;

      if (r) {
        const e = n.length - 1 - [...n].reverse().findIndex(e => {
          let t = e.object;

          for (; t;) {
            if (e.object === r) return !0;
            t = t.parent;
          }

          return !1;
        });
        e >= 0 && n.splice(0, e + 1);
      }

      if (n.length > 0) {
        for (const e of n) {
          let t = e.object;

          for (; !(null == t || t.visible && this.selectionCondition(t));) t = t.parent;

          if (t) return {
            selectedObject: t,
            intersect: e,
            intersects: n,
            mouse: this.mouse.toArray()
          };
        }

        return null;
      }

      return null;
    }

    refreshOutlinePass() {
      var e;
      null !== (e = this.hoverObject) && void 0 !== e || this.selectedObject;
    }

    isHovering() {
      return null != this.hoverObject;
    }

    isSelected() {
      return null != this.selectedObject;
    }

  }

  const Uo = new i.iMs(),
        Bo = new i.Pa4(),
        jo = new i.Pa4(),
        zo = new i._fP(),
        Vo = {
    X: new i.Pa4(1, 0, 0),
    Y: new i.Pa4(0, 1, 0),
    Z: new i.Pa4(0, 0, 1)
  },
        Go = {
    type: "change"
  },
        Ho = {
    type: "mouseDown"
  },
        Wo = {
    type: "mouseUp",
    mode: null
  },
        Ko = {
    type: "objectChange"
  };

  class Xo extends i.Tme {
    constructor(e, t) {
      super(), void 0 === t && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
      const n = new fa();
      this._gizmo = n, this.add(n);
      const r = new _a();
      this._plane = r, this.add(r);
      const s = this;

      function o(e, t) {
        let i = t;
        Object.defineProperty(s, e, {
          get: function () {
            return void 0 !== i ? i : t;
          },
          set: function (t) {
            i !== t && (i = t, r[e] = t, n[e] = t, s.dispatchEvent({
              type: e + "-changed",
              value: t
            }), s.dispatchEvent(Go));
          }
        }), s[e] = t, r[e] = t, n[e] = t;
      }

      o("camera", e), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0);

      const a = new i.Pa4(),
            l = new i.Pa4(),
            c = new i._fP(),
            u = new i._fP(),
            p = new i.Pa4(),
            h = new i._fP(),
            d = new i.Pa4(),
            f = new i.Pa4(),
            _ = new i.Pa4(),
            m = new i.Pa4();

      o("worldPosition", a), o("worldPositionStart", l), o("worldQuaternion", c), o("worldQuaternionStart", u), o("cameraPosition", p), o("cameraQuaternion", h), o("pointStart", d), o("pointEnd", f), o("rotationAxis", _), o("rotationAngle", 0), o("eye", m), this._offset = new i.Pa4(), this._startNorm = new i.Pa4(), this._endNorm = new i.Pa4(), this._cameraScale = new i.Pa4(), this._parentPosition = new i.Pa4(), this._parentQuaternion = new i._fP(), this._parentQuaternionInv = new i._fP(), this._parentScale = new i.Pa4(), this._worldScaleStart = new i.Pa4(), this._worldQuaternionInv = new i._fP(), this._worldScale = new i.Pa4(), this._positionStart = new i.Pa4(), this._quaternionStart = new i._fP(), this._scaleStart = new i.Pa4(), this._getPointer = qo.bind(this), this._onPointerDown = Zo.bind(this), this._onPointerHover = Yo.bind(this), this._onPointerMove = Jo.bind(this), this._onPointerUp = $o.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
    }

    updateMatrixWorld() {
      void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
    }

    pointerHover(e) {
      if (void 0 === this.object || !0 === this.dragging) return;
      Uo.setFromCamera(e, this.camera);
      const t = Qo(this._gizmo.picker[this.mode], Uo);
      this.axis = t ? t.object.name : null;
    }

    pointerDown(e) {
      if (void 0 !== this.object && !0 !== this.dragging && 0 === e.button && null !== this.axis) {
        Uo.setFromCamera(e, this.camera);
        const t = Qo(this._plane, Uo, !0);
        t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, Ho.mode = this.mode, this.dispatchEvent(Ho);
      }
    }

    pointerMove(e) {
      const t = this.axis,
            n = this.mode,
            r = this.object;
      let i = this.space;
      if ("scale" === n ? i = "local" : "E" !== t && "XYZE" !== t && "XYZ" !== t || (i = "world"), void 0 === r || null === t || !1 === this.dragging || -1 !== e.button) return;
      Uo.setFromCamera(e, this.camera);
      const s = Qo(this._plane, Uo, !0);

      if (s) {
        if (this.pointEnd.copy(s.point).sub(this.worldPositionStart), "translate" === n) this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i && "XYZ" !== t && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t.indexOf("X") && (this._offset.x = 0), -1 === t.indexOf("Y") && (this._offset.y = 0), -1 === t.indexOf("Z") && (this._offset.z = 0), "local" === i && "XYZ" !== t ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i && (r.position.applyQuaternion(zo.copy(this._quaternionStart).invert()), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), "world" === i && (r.parent && r.position.add(Bo.setFromMatrixPosition(r.parent.matrixWorld)), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Bo.setFromMatrixPosition(r.parent.matrixWorld))));else if ("scale" === n) {
          if (-1 !== t.search("XYZ")) {
            let e = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (e *= -1), jo.set(e, e, e);
          } else Bo.copy(this.pointStart), jo.copy(this.pointEnd), Bo.applyQuaternion(this._worldQuaternionInv), jo.applyQuaternion(this._worldQuaternionInv), jo.divide(Bo), -1 === t.search("X") && (jo.x = 1), -1 === t.search("Y") && (jo.y = 1), -1 === t.search("Z") && (jo.z = 1);

          r.scale.copy(this._scaleStart).multiply(jo), this.scaleSnap && (-1 !== t.search("X") && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Y") && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Z") && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if ("rotate" === n) {
          this._offset.copy(this.pointEnd).sub(this.pointStart);

          const e = 20 / this.worldPosition.distanceTo(Bo.setFromMatrixPosition(this.camera.matrixWorld));
          "E" === t ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Bo.copy(this.rotationAxis).cross(this.eye)) * e) : "X" !== t && "Y" !== t && "Z" !== t || (this.rotationAxis.copy(Vo[t]), Bo.copy(Vo[t]), "local" === i && Bo.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Bo.cross(this.eye).normalize()) * e), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i && "E" !== t && "XYZE" !== t ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(zo.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(zo.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
        }
        this.dispatchEvent(Go), this.dispatchEvent(Ko);
      }
    }

    pointerUp(e) {
      0 === e.button && (this.dragging && null !== this.axis && (Wo.mode = this.mode, this.dispatchEvent(Wo)), this.dragging = !1, this.axis = null);
    }

    dispose() {
      this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
    }

    attach(e) {
      return this.object = e, this.visible = !0, this;
    }

    detach() {
      return this.object = void 0, this.visible = !1, this.axis = null, this;
    }

    reset() {
      this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Go), this.dispatchEvent(Ko), this.pointStart.copy(this.pointEnd));
    }

    getRaycaster() {
      return Uo;
    }

    getMode() {
      return this.mode;
    }

    setMode(e) {
      this.mode = e;
    }

    setTranslationSnap(e) {
      this.translationSnap = e;
    }

    setRotationSnap(e) {
      this.rotationSnap = e;
    }

    setScaleSnap(e) {
      this.scaleSnap = e;
    }

    setSize(e) {
      this.size = e;
    }

    setSpace(e) {
      this.space = e;
    }

    update() {
      console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
    }

  }

  function qo(e) {
    if (this.domElement.ownerDocument.pointerLockElement) return {
      x: 0,
      y: 0,
      button: e.button
    };
    {
      const t = this.domElement.getBoundingClientRect();
      return {
        x: (e.clientX - t.left) / t.width * 2 - 1,
        y: -(e.clientY - t.top) / t.height * 2 + 1,
        button: e.button
      };
    }
  }

  function Yo(e) {
    if (this.enabled) switch (e.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(e));
    }
  }

  function Zo(e) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e)), this.pointerDown(this._getPointer(e)));
  }

  function Jo(e) {
    this.enabled && this.pointerMove(this._getPointer(e));
  }

  function $o(e) {
    this.enabled && (this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e)));
  }

  function Qo(e, t, n) {
    const r = t.intersectObject(e, !0);

    for (let e = 0; e < r.length; e++) if (r[e].object.visible || n) return r[e];

    return !1;
  }

  const ea = new i.USm(),
        ta = new i.Pa4(0, 1, 0),
        na = new i.Pa4(0, 0, 0),
        ra = new i.yGw(),
        ia = new i._fP(),
        sa = new i._fP(),
        oa = new i.Pa4(),
        aa = new i.yGw(),
        la = new i.Pa4(1, 0, 0),
        ca = new i.Pa4(0, 1, 0),
        ua = new i.Pa4(0, 0, 1),
        pa = new i.Pa4(),
        ha = new i.Pa4(),
        da = new i.Pa4();

  class fa extends i.Tme {
    constructor() {
      super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
      const e = new i.vBJ({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0
      }),
            t = new i.nls({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0
      }),
            n = e.clone();
      n.opacity = .15;
      const r = t.clone();
      r.opacity = .5;
      const s = e.clone();
      s.color.setHex(16711680);
      const o = e.clone();
      o.color.setHex(65280);
      const a = e.clone();
      a.color.setHex(255);
      const l = e.clone();
      l.color.setHex(16711680), l.opacity = .5;
      const c = e.clone();
      c.color.setHex(65280), c.opacity = .5;
      const u = e.clone();
      u.color.setHex(255), u.opacity = .5;
      const p = e.clone();
      p.opacity = .25;
      const h = e.clone();
      h.color.setHex(16776960), h.opacity = .25, e.clone().color.setHex(16776960);
      const d = e.clone();
      d.color.setHex(7895160);
      const f = new i.fHI(0, .04, .1, 12);
      f.translate(0, .05, 0);

      const _ = new i.DvJ(.08, .08, .08);

      _.translate(0, .04, 0);

      const m = new i.u9r();
      m.setAttribute("position", new i.a$l([0, 0, 0, 1, 0, 0], 3));
      const g = new i.fHI(.0075, .0075, .5, 3);

      function v(e, t) {
        const n = new i.XvJ(e, .0075, 3, 64, t * Math.PI * 2);
        return n.rotateY(Math.PI / 2), n.rotateX(Math.PI / 2), n;
      }

      g.translate(0, .25, 0);
      const b = {
        X: [[new i.Kj0(f, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(f, s), [-.5, 0, 0], [0, 0, Math.PI / 2]], [new i.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]]],
        Y: [[new i.Kj0(f, o), [0, .5, 0]], [new i.Kj0(f, o), [0, -.5, 0], [Math.PI, 0, 0]], [new i.Kj0(g, o)]],
        Z: [[new i.Kj0(f, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new i.Kj0(f, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]], [new i.Kj0(g, a), null, [Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.pQR(.1, 0), p.clone()), [0, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.15, .15, .01), u.clone()), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), l.clone()), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), c.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
      },
            x = {
        X: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3], [Math.PI / 2, 0, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.pQR(.2, 0), n)]],
        XY: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
      },
            y = {
        START: [[new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]],
        END: [[new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]],
        DELTA: [[new i.x12(function () {
          const e = new i.u9r();
          return e.setAttribute("position", new i.a$l([0, 0, 0, 1, 1, 1], 3)), e;
        }(), r), null, null, null, "helper"]],
        X: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [[new i.x12(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
        Z: [[new i.x12(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
      },
            w = {
        XYZE: [[new i.Kj0(v(.5, 1), d), null, [0, Math.PI / 2, 0]]],
        X: [[new i.Kj0(v(.5, .5), s)]],
        Y: [[new i.Kj0(v(.5, .5), o), null, [0, 0, -Math.PI / 2]]],
        Z: [[new i.Kj0(v(.5, .5), a), null, [0, Math.PI / 2, 0]]],
        E: [[new i.Kj0(v(.75, 1), h), null, [0, Math.PI / 2, 0]]]
      },
            S = {
        AXIS: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
      },
            M = {
        XYZE: [[new i.Kj0(new i.xo$(.25, 10, 8), n)]],
        X: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
        Y: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
        Z: [[new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
        E: [[new i.Kj0(new i.XvJ(.75, .1, 2, 24), n)]]
      },
            T = {
        X: [[new i.Kj0(_, s), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(_, s), [-.5, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(_, o), [0, .5, 0]], [new i.Kj0(g, o)], [new i.Kj0(_, o), [0, -.5, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(_, a), [0, 0, .5], [Math.PI / 2, 0, 0]], [new i.Kj0(g, a), [0, 0, 0], [Math.PI / 2, 0, 0]], [new i.Kj0(_, a), [0, 0, -.5], [-Math.PI / 2, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.15, .15, .01), u), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), l), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.15, .15, .01), c), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.DvJ(.1, .1, .1), p.clone())]]
      },
            E = {
        X: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
        Y: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0], [0, 0, Math.PI]]],
        Z: [[new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3], [Math.PI / 2, 0, 0]], [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
        XY: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]],
        YZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15], [0, Math.PI / 2, 0]]],
        XZ: [[new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
        XYZ: [[new i.Kj0(new i.DvJ(.2, .2, .2), n), [0, 0, 0]]]
      },
            A = {
        X: [[new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [[new i.x12(m, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
        Z: [[new i.x12(m, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
      };

      function C(e) {
        const t = new i.Tme();

        for (const n in e) for (let r = e[n].length; r--;) {
          const i = e[n][r][0].clone(),
                s = e[n][r][1],
                o = e[n][r][2],
                a = e[n][r][3],
                l = e[n][r][4];
          i.name = n, i.tag = l, s && i.position.set(s[0], s[1], s[2]), o && i.rotation.set(o[0], o[1], o[2]), a && i.scale.set(a[0], a[1], a[2]), i.updateMatrix();
          const c = i.geometry.clone();
          c.applyMatrix4(i.matrix), i.geometry = c, i.renderOrder = 1 / 0, i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), t.add(i);
        }

        return t;
      }

      this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = C(b)), this.add(this.gizmo.rotate = C(w)), this.add(this.gizmo.scale = C(T)), this.add(this.picker.translate = C(x)), this.add(this.picker.rotate = C(M)), this.add(this.picker.scale = C(E)), this.add(this.helper.translate = C(y)), this.add(this.helper.rotate = C(S)), this.add(this.helper.scale = C(A)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
    }

    updateMatrixWorld(e) {
      const t = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : sa;
      this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
      let n = [];
      n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);

      for (let e = 0; e < n.length; e++) {
        const r = n[e];
        let i;

        if (r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition), i = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(i * this.size / 4), "helper" !== r.tag) {
          if (r.quaternion.copy(t), "translate" === this.mode || "scale" === this.mode) {
            const e = .99,
                  n = .2;
            "X" === r.name && Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Y" === r.name && Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Z" === r.name && Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XY" === r.name && Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "YZ" === r.name && Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XZ" === r.name && Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1);
          } else "rotate" === this.mode && (ia.copy(t), ta.copy(this.eye).applyQuaternion(zo.copy(t).invert()), -1 !== r.name.search("E") && r.quaternion.setFromRotationMatrix(ra.lookAt(this.eye, na, ca)), "X" === r.name && (zo.setFromAxisAngle(la, Math.atan2(-ta.y, ta.z)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)), "Y" === r.name && (zo.setFromAxisAngle(ca, Math.atan2(ta.x, ta.z)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)), "Z" === r.name && (zo.setFromAxisAngle(ua, Math.atan2(ta.y, ta.x)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)));

          r.visible = r.visible && (-1 === r.name.indexOf("X") || this.showX), r.visible = r.visible && (-1 === r.name.indexOf("Y") || this.showY), r.visible = r.visible && (-1 === r.name.indexOf("Z") || this.showZ), r.visible = r.visible && (-1 === r.name.indexOf("E") || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function (e) {
            return r.name === e;
          })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
        } else r.visible = !1, "AXIS" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = !!this.axis, "X" === this.axis && (zo.setFromEuler(ea.set(0, 0, 0)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Y" === this.axis && (zo.setFromEuler(ea.set(0, 0, Math.PI / 2)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Z" === this.axis && (zo.setFromEuler(ea.set(0, Math.PI / 2, 0)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "XYZE" === this.axis && (zo.setFromEuler(ea.set(0, Math.PI / 2, 0)), ta.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(ra.lookAt(na, ta, ca)), r.quaternion.multiply(zo), r.visible = this.dragging), "E" === this.axis && (r.visible = !1)) : "START" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : "END" === r.name ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : "DELTA" === r.name ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), Bo.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Bo.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(Bo), r.visible = this.dragging) : (r.quaternion.copy(t), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = -1 !== this.axis.search(r.name)));
      }

      super.updateMatrixWorld(e);
    }

  }

  class _a extends i.Kj0 {
    constructor() {
      super(new i._12(1e5, 1e5, 2, 2), new i.vBJ({
        visible: !1,
        wireframe: !0,
        side: i.ehD,
        transparent: !0,
        opacity: .1,
        toneMapped: !1
      })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
    }

    updateMatrixWorld(e) {
      let t = this.space;

      switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t = "local"), pa.copy(la).applyQuaternion("local" === t ? this.worldQuaternion : sa), ha.copy(ca).applyQuaternion("local" === t ? this.worldQuaternion : sa), da.copy(ua).applyQuaternion("local" === t ? this.worldQuaternion : sa), ta.copy(ha), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              ta.copy(this.eye).cross(pa), oa.copy(pa).cross(ta);
              break;

            case "Y":
              ta.copy(this.eye).cross(ha), oa.copy(ha).cross(ta);
              break;

            case "Z":
              ta.copy(this.eye).cross(da), oa.copy(da).cross(ta);
              break;

            case "XY":
              oa.copy(da);
              break;

            case "YZ":
              oa.copy(pa);
              break;

            case "XZ":
              ta.copy(da), oa.copy(ha);
              break;

            case "XYZ":
            case "E":
              oa.set(0, 0, 0);
          }

          break;

        case "rotate":
        default:
          oa.set(0, 0, 0);
      }

      0 === oa.length() ? this.quaternion.copy(this.cameraQuaternion) : (aa.lookAt(Bo.set(0, 0, 0), oa, ta), this.quaternion.setFromRotationMatrix(aa)), super.updateMatrixWorld(e);
    }

  }

  const ma = new i.ZzF(),
        ga = new i.Pa4();

  class va extends i.L5s {
    constructor() {
      super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new i.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new i.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2));
    }

    applyMatrix4(e) {
      const t = this.attributes.instanceStart,
            n = this.attributes.instanceEnd;
      return void 0 !== t && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }

    setPositions(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const n = new i.$TI(t, 6, 1);
      return this.setAttribute("instanceStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceEnd", new i.kB5(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
    }

    setColors(e) {
      let t;
      e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
      const n = new i.$TI(t, 6, 1);
      return this.setAttribute("instanceColorStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceColorEnd", new i.kB5(n, 3, 3)), this;
    }

    fromWireframeGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }

    fromEdgesGeometry(e) {
      return this.setPositions(e.attributes.position.array), this;
    }

    fromMesh(e) {
      return this.fromWireframeGeometry(new i.Uk6(e.geometry)), this;
    }

    fromLineSegments(e) {
      const t = e.geometry;
      return this.setPositions(t.attributes.position.array), this;
    }

    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new i.ZzF());
      const e = this.attributes.instanceStart,
            t = this.attributes.instanceEnd;
      void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), ma.setFromBufferAttribute(t), this.boundingBox.union(ma));
    }

    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new i.aLr()), null === this.boundingBox && this.computeBoundingBox();
      const e = this.attributes.instanceStart,
            t = this.attributes.instanceEnd;

      if (void 0 !== e && void 0 !== t) {
        const n = this.boundingSphere.center;
        this.boundingBox.getCenter(n);
        let r = 0;

        for (let i = 0, s = e.count; i < s; i++) ga.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(ga)), ga.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(ga));

        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }

    toJSON() {}

    applyMatrix(e) {
      return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
    }

  }

  class ba extends va {
    constructor(e) {
      super(), this.isWireframeGeometry2 = !0, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new i.Uk6(e));
    }

  }

  i.rBU.line = {
    worldUnits: {
      value: 1
    },
    linewidth: {
      value: 1
    },
    resolution: {
      value: new i.FM8(1, 1)
    },
    dashOffset: {
      value: 0
    },
    dashScale: {
      value: 1
    },
    dashSize: {
      value: 1
    },
    gapSize: {
      value: 1
    }
  }, i.Vj0.line = {
    uniforms: i.rDY.merge([i.rBU.common, i.rBU.fog, i.rBU.line]),
    vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
    fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
  };

  class xa extends i.jyz {
    constructor(e) {
      super({
        type: "LineMaterial",
        uniforms: i.rDY.clone(i.Vj0.line.uniforms),
        vertexShader: i.Vj0.line.vertexShader,
        fragmentShader: i.Vj0.line.fragmentShader,
        clipping: !0
      }), this.isLineMaterial = !0, Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value;
          },
          set: function (e) {
            this.uniforms.diffuse.value = e;
          }
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines;
          },
          set: function (e) {
            !0 === e ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
          }
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value;
          },
          set: function (e) {
            this.uniforms.linewidth.value = e;
          }
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_DASH" in this.defines);
          },

          set(e) {
            Boolean(e) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === e ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
          }

        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value;
          },
          set: function (e) {
            this.uniforms.dashScale.value = e;
          }
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value;
          },
          set: function (e) {
            this.uniforms.dashSize.value = e;
          }
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value;
          },
          set: function (e) {
            this.uniforms.dashOffset.value = e;
          }
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value;
          },
          set: function (e) {
            this.uniforms.gapSize.value = e;
          }
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value;
          },
          set: function (e) {
            this.uniforms.opacity.value = e;
          }
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value;
          },
          set: function (e) {
            this.uniforms.resolution.value.copy(e);
          }
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
          },
          set: function (e) {
            Boolean(e) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === e ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
          }
        }
      }), this.setValues(e);
    }

  }

  const ya = new i.Pa4(),
        wa = new i.Pa4();

  class Sa extends i.Kj0 {
    constructor(e = new va(), t = new xa({
      color: 16777215 * Math.random()
    })) {
      super(e, t), this.isWireframe = !0, this.type = "Wireframe";
    }

    computeLineDistances() {
      const e = this.geometry,
            t = e.attributes.instanceStart,
            n = e.attributes.instanceEnd,
            r = new Float32Array(2 * t.count);

      for (let e = 0, i = 0, s = t.count; e < s; e++, i += 2) ya.fromBufferAttribute(t, e), wa.fromBufferAttribute(n, e), r[i] = 0 === i ? 0 : r[i - 1], r[i + 1] = r[i] + ya.distanceTo(wa);

      const s = new i.$TI(r, 2, 1);
      return e.setAttribute("instanceDistanceStart", new i.kB5(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new i.kB5(s, 1, 1)), this;
    }

  }

  class Ma extends i.ZAu {
    constructor(e) {
      super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = !1, this.renderOrder = 1, this.userData.bboxVisible = !1, this.userData.setDirty = e, this._updater = this._updater.bind(this);
    }

    _updater() {
      const e = this._object;

      if (e) {
        const t = new P().expandByObject(e, !1);
        t.getCenter(this.position);
        const n = t.getBoundingSphere(new i.aLr()).radius;
        this.scale.setScalar(n * this.boundingScaleMultiplier), this.setVisible(!0);
      } else this.setVisible(!1);
    }

    _initGeometry(e) {
      if (this._geometry) return;
      const t = new ba(e);
      this._geometry = t;
      const n = new xa({
        color: "#ff2222",
        transparent: !0,
        opacity: .9,
        linewidth: 5,
        resolution: new i.FM8(1024, 1024),
        dashed: !1,
        toneMapped: !1
      }),
            r = new Sa(t, n);
      r.computeLineDistances(), r.scale.set(1, 1, 1), r.visible = !0, this.add(r);
    }

    setVisible(e) {
      var t, n;
      e !== this.visible && (this.visible = e, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t));
    }

    attach(e) {
      return this.detach(), e ? (this._object = e, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this;
    }

    detach() {
      var e;
      return this._object ? (null === (e = this._object) || void 0 === e || e.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this;
    }

    get object() {
      return this._object;
    }

  }

  class Ta extends Ma {
    constructor(e) {
      super(e), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new i.nvb(2, 2, 2, 1, 1, 1));
    }

    _updater() {
      super._updater();

      const e = this.object;
      e && (new P().expandByObject(e, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(.1, 100), this.setVisible(!0));
    }

  }

  class Ea extends Ws {
    constructor() {
      super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = !1, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [co], this.fadeOnActiveCameraChange = !0, this.fadeOnMaterialUpdate = !0, this.fadeOnSceneUpdate = !0, this.pointerEnabled = !0, this._fadeCam = e => !1 !== e.frameFade && this.fadeOnActiveCameraChange && this.startTransition(1e3), this._fadeMat = e => {
        !1 !== e.frameFade && this.fadeOnMaterialUpdate && this.startTransition(200);
      }, this._fadeScene = e => {
        !1 !== e.frameFade && this.fadeOnSceneUpdate && this.startTransition(500);
      }, this._onPointerMove = e => {
        var t;
        const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas;
        if (!n) return void (this.pointerEnabled = !1);
        if (!e.buttons || e.target !== n) return void (this.pointerEnabled = !0);
        const r = n.getBoundingClientRect(),
              i = (e.clientX - r.left) / r.width,
              s = (e.clientY - r.top) / r.height;
        this.pointerEnabled = i < 0 || i > 1 || s < 0 || s > 1;
      }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this);
    }

    startTransition(e) {
      this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({
        sizeMultiplier: 1,
        minFilter: i.wem,
        magFilter: i.wem,
        encoding: this._viewer.renderer.composerTarget.texture.encoding
      })), this._fadeTimeState = Math.max(e, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this._toSaveFrame = !0, this.setDirty());
    }

    stopTransition() {
      this._fadeTimeState = 0;
    }

    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("activeCameraChange", this._fadeCam), e.scene.addEventListener("activeCameraUpdate", this.stopTransition), e.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("activeCameraChange", this._fadeCam), e.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e);
    }

    passCtor(e) {
      const t = this,
            n = e.getPlugin(co),
            r = new class extends so {
        constructor() {
          super(...arguments), this._lastTime = 0, this.uiConfig = $e("Frame Fade", this);
        }

        render(r, i, s, o, a) {
          this.needsSwap = !1;
          const l = t._target;
          if (!l || !t.pointerEnabled || !this.enabled || !t.dirty || t._fadeTimeState < .001) return;
          t._toSaveFrame && n.lastFrame && (e.renderer.blit(n.lastFrame.texture, l), this._lastTime = 0, t._toSaveFrame = !1), this.blendTexture = null == l ? void 0 : l.texture;
          const c = t._fadeTimeState / t._fadeTime;
          this.weights2.setScalar(c), this.weights2.w = 1, this.weights1.setScalar(1 - c), this.weights1.w = 1, super.render(r, i, s, o, a), this.needsSwap = !0;
          const u = Ct();
          this._lastTime < 10 && (this._lastTime = u - 10);
          const p = u - this._lastTime;
          this._lastTime = u, t._fadeTimeState -= p;
        }

      }();
      return r.enabled = !0, r;
    }

    setDirty() {
      var e;
      this.enabled && (null === (e = this._viewer) || void 0 === e || e.setDirty());
    }

    get dirty() {
      return this.enabled && this._fadeTimeState > 0;
    }

    set dirty(e) {
      console.warn("FrameFadePlugin.dirty is readonly");
    }

    _update(e) {
      return !!super._update(e) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < .001 && (this._toSaveFrame = !1, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), !0);
    }

    get uiConfig() {
      var e, t;
      return null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
    }

    disable(e) {
      this._disabledBy.includes(e) || this._disabledBy.push(e);
    }

    enable(e) {
      const t = this._disabledBy.indexOf(e);

      t >= 0 && this._disabledBy.splice(t, 1);
    }

    isDisabled() {
      return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled;
    }

  }

  Ea.PluginType = "FrameFade";
  var Aa = i.M8C.degToRad;

  class Ca extends Gs {
    constructor(e = Ta, t = !1, n = !0) {
      super(), this.enabled = !0, this.autoFocus = !1, e && (this._widget = new e(() => {
        this.setDirty();
      })), this._controls = t, this._pickUi = n;
    }

    get picker() {
      return this._picker;
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    getSelectedObject() {
      var e;
      if (this.enabled) return (null === (e = this._picker) || void 0 === e ? void 0 : e.selectedObject) || void 0;
    }

    setSelectedObject(e, t = !1) {
      if (this.enabled && this._picker) {
        const n = this.autoFocus;
        n && !t && (this.autoFocus = !1), this._picker.selectedObject = e || null, this.autoFocus = n;
      }
    }

    async onAdded(e) {
      await super.onAdded(e), this._picker = new No(e.scene, e.canvas, void 0, e => {
        var t, n;
        if (!e.material) return !1;
        let r = e,
            i = !1;

        for (; r;) {
          if (!r.visible) return !1;
          if ("model" === (null !== (t = r.userData.iModel) && void 0 !== t ? t : r).assetType && (i = !0), "widget" === (null !== (n = r.userData.iModel) && void 0 !== n ? n : r).assetType) return !1;
          if (!1 === r.userData.userSelectable) return !1;
          if (!1 === r.userData.bboxVisible) return !1;
          r = r.parent;
        }

        return i;
      }), this._widget && e.scene.addWidget(this._widget), this._transformControls = new Ra(e), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", t => {
        var n, r, s, o, a;
        this.dispatchEvent(t);
        const l = null === (n = this._picker) || void 0 === n ? void 0 : n.selectedObject;

        if (this._pickUi) {
          const e = null === (r = l) || void 0 === r ? void 0 : r.uiConfig,
                t = this.uiConfig;
          t.children = e ? [e] : [], null === (s = t.uiRefresh) || void 0 === s || s.call(t);
        }

        const c = this._widget;
        c && (l ? c.attach(l) : c.detach());
        const u = this._transformControls;
        u && (null === (o = this._viewer) || void 0 === o ? void 0 : o.scene.activeCamera.controls) && (l && u.enabled ? u.attach(l) : u.detach()), this.autoFocus && l && (null === (a = this._viewer) || void 0 === a || a.resetCamera({
          rootObject: l,
          centerOffset: new i.Pa4(4, 4, 4)
        })), e.setDirty();
      }), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this.dispatchEvent), e.scene.addEventListener("addSceneObject", e => {
        var t, n;
        const r = e.object,
              i = this.getSelectedObject();

        if (i && "material" === (null == r ? void 0 : r.assetType) && "function" == typeof (null === (t = i.modelObject) || void 0 === t ? void 0 : t.userData.setMaterial) && confirm("Apply material to selected object?")) {
          const e = i.material;
          if (Array.isArray(e)) console.warn("Dropping on material array not yet fully supported."), i.modelObject.userData.setMaterial(r);else {
            let t = Array.from(null !== (n = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== n ? n : []);
            (t.length > 1 ? !confirm("Apply to all objects using this material?") : t.length < 1) && (t = [i.modelObject]);

            for (const e of t) e && e.userData.setMaterial(r);
          }
        }
      });
    }

    get uiConfig() {
      return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Picker",
        expanded: !0,
        children: [{}]
      } : {};
    }

    get transformControls() {
      return this._transformControls;
    }

    get widget() {
      return this._widget;
    }

  }

  Ca.PluginType = "Picking";

  class Ra extends Xo {
    constructor(e) {
      super(e.scene.activeCamera.cameraObject, e.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = !1, this.userData.bboxVisible = !1, this.addEventListener("objectChange", () => {
        var e;
        null === (e = null == this ? void 0 : this.object) || void 0 === e || e.dispatchEvent({
          type: "objectUpdate",
          fadeFrame: !1
        });
      }), this.addEventListener("dragging-changed", t => {
        const n = null == e ? void 0 : e.getPlugin(Ea);
        n && (n.enabled = !t.value), this._scene.activeCamera.interactionsEnabled = !t.value;
      }), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this);
    }

    _keyDownListener(e) {
      if (this.enabled && this.object) {
        switch (e.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;

          case 16:
            this.setTranslationSnap(100), this.setRotationSnap(Aa(15)), this.setScaleSnap(.25);
            break;

          case 87:
            this.setMode("translate");
            break;

          case 69:
            this.setMode("rotate");
            break;

          case 82:
            this.setMode("scale");
            break;

          case 187:
          case 107:
            this.setSize(this.size + .1);
            break;

          case 189:
          case 109:
            this.setSize(Math.max(this.size - .1, .1));
            break;

          case 88:
            this.showX = !this.showX;
            break;

          case 89:
            this.showY = !this.showY;
            break;

          case 90:
            this.showZ = !this.showZ;
            break;

          case 32:
            this.enabled = !this.enabled;
            break;

          default:
            return;
        }

        this._scene.setDirty({
          sceneUpdate: !0,
          frameFade: !0
        });
      }
    }

    _keyUpListener(e) {
      if (this.enabled) {
        switch (e.keyCode) {
          case 16:
            this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null);
        }

        this.object && e.keyCode;
      }
    }

    _activeCameraChange() {
      this.camera = this._scene.activeCamera.cameraObject;
    }

    dispose() {
      window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose();
    }

  }

  var ka = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Pa extends Gs {
    constructor() {
      super(), this.offsetCache = {}, this.enabled = !0, this.envMap = null, this.forceSceneEnvMap = !1, this.getEnvMap = () => {
        var e;
        return !this.forceSceneEnvMap && this.envMap ? this.envMap : (null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || null;
      }, this._modelProcessor = {
        forAssetType: "model",
        processAsync: async (e, t) => {
          const n = [];
          return e.modelObject.traverse(e => {
            var t, r, i, s;
            const o = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === r ? void 0 : r[Pa.DIAMOND_GLTF_EXTENSION];
            o && e.geometry && (this.prepareDiamondMesh(e, o), delete e.userData.gltfExtensions[Pa.DIAMOND_GLTF_EXTENSION]), e.material && !n.includes(e.material) && (null === (s = null === (i = e.material.userData) || void 0 === i ? void 0 : i.gltfExtensions) || void 0 === s ? void 0 : s[Pa.DIAMOND_GLTF_EXTENSION]) && (e.material.materialObject || console.warn("material not processed", e.material), n.push(e.material));
          }), n.forEach(e => {
            const t = e.userData.gltfExtensions[Pa.DIAMOND_GLTF_EXTENSION];
            t && this._convertToDiamondMaterial(e, t);
          }), e;
        }
      }, this.uiConfig = {
        type: "folder",
        label: "Diamonds",
        children: [{
          type: "toggle",
          label: "Use Scene Environment",
          property: [this, "forceSceneEnvironment"],
          limitedUi: !0
        }, {
          type: "image",
          label: "Environment",
          hidden: () => this.forceSceneEnvMap,
          property: [this, "envMap"],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [0, 2 * Math.PI],
          hidden: () => this.forceSceneEnvMap,
          label: "Env Rotation",
          property: [this, "envMapRotation"],
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Diamond",
          hidden: () => {
            var e, t, n, r;
            return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Kt.TypeSlug;
          },
          value: () => {
            var e, t;
            const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject();
            if (!(null == n ? void 0 : n.material)) return;
            const r = prompt("Cache key?", "");
            let i = parseInt(prompt("Cache size?", "512") || "512");
            isFinite(i) || (i = 512), i < 64 && (i = 64), this.makeDiamond(n.material, {
              cacheKey: r || void 0,
              normalMapRes: i
            }, {}), this.refreshUi();
          },
          limitedUi: !0
        }, {
          type: "button",
          label: "Make Standard",
          hidden: () => {
            var e, t, n, r;
            return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Fo.TypeSlug;
          },
          value: () => {
            var e, t, n, r, i, s;
            const o = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject(),
                  a = null == o ? void 0 : o.material;
            if (!a) return;
            const l = a.userData._baseMaterial,
                  c = (null === (i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials) || void 0 === i ? void 0 : i.findMaterial(l)) || (null === (s = this._viewer) || void 0 === s ? void 0 : s.createPhysicalMaterial({
              color: a.color
            }));

            if (c) {
              const e = confirm("Convert all with this material?") ? Array.from(a.userData.appliedMeshes) : [o];

              for (const t of e) null == t || t.modelObject.userData.setMaterial(c);
            }

            this.refreshUi();
          },
          limitedUi: !0
        }]
      }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this);
    }

    get envMapRotation() {
      var e, t;
      return null !== (t = null === (e = this.envMap) || void 0 === e ? void 0 : e.rotation) && void 0 !== t ? t : 0;
    }

    set envMapRotation(e) {
      var t;
      const n = this.envMap;
      n && (n.rotation = e, null === (t = this._viewer) || void 0 === t || t.scene.setDirty());
    }

    refreshEnvMaps() {
      var e, t, n;
      if (!this._viewer) return;
      const r = this.getEnvMap(),
            i = (null === (t = null === (e = this._viewer.getPlugin(Vs)) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.getMaterialsOfType(Fo.TypeSlug)) || [];

      for (const e of i) e && e.envMap !== r && (e.envMap = r, e.needsUpdate = !0);

      null === (n = this._viewer) || void 0 === n || n.scene.setDirty();
    }

    refreshUi() {
      var e, t, n;
      null === (e = this._viewer) || void 0 === e || e.setDirty(), null === (n = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    async onAdded(e) {
      var t, n, r, i, s, o;
      this._normalCapture = new Po(e.renderer), this.offsetCache = {}, e.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
      const a = e.getPlugin(Vs);
      null === (t = null == a ? void 0 : a.importer) || void 0 === t || t.processors.add("model", this._modelProcessor), null === (n = e.getPlugin(Ca)) || void 0 === n || n.addEventListener("selectedObjectChanged", this.refreshUi);
      const l = this.getEnvMap,
            c = new $t(class extends tn {
        async loadAsync(e, t) {
          var n;
          const r = await super.loadAsync(e, t);
          return r.type === Fo.TYPE || r.isDiamondMaterialParameters ? (r.envMap = l(), null === (n = null == a ? void 0 : a.materials) || void 0 === n ? void 0 : n.generateFromTemplate("diamond", r)) : (console.error("Invalid material type for Diamond Material.", r), null);
        }

      }, [Fo.TypeSlug], !1);
      return Us.Importers.push(c), null === (s = null === (i = null === (r = null == a ? void 0 : a.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Da), null === (o = null == a ? void 0 : a.materials) || void 0 === o || o.registerMaterialTemplate({
        name: "diamond",
        materialType: Fo.TYPE,
        isDiamondMaterialParameters: !0,
        generator: (e, t) => {
          const n = new Fo(e);
          return n.envMap = l(), t && t !== {} && n.copyProps(t), n;
        }
      }), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (t = this._normalCapture) || void 0 === t || t.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (r = null === (n = e.getPlugin(Vs)) || void 0 === n ? void 0 : n.importer) || void 0 === r || r.processors.remove("model", this._modelProcessor), null === (i = e.getPlugin(Ca)) || void 0 === i || i.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e);
    }

    prepareDiamondMesh(e, {
      cacheKey: t,
      normalMapRes: n
    }) {
      var r, i, s;
      e.userData._diamondCacheKey = null != t ? t : e.userData._diamondCacheKey, e.userData._diamondNormalMapRes = null != n ? n : e.userData._diamondNormalMapRes, t = t && t.length > 0 ? t.includes(";" + e.geometry.uuid) ? t : t + ";" + e.geometry.uuid : e.geometry.uuid, this._computeOffsets(e.geometry, e.geometry.uuid);
      const o = null !== (i = null === (r = this._normalCapture) || void 0 === r ? void 0 : r.captureNormalMap(e.geometry, t, n)) && void 0 !== i ? i : [void 0, !1],
            a = null === (s = this._viewer) || void 0 === s ? void 0 : s.getPluginByType("debug");
      a && o && (a.counters.normalsCapture || (a.counters.normalsCapture = 0), a.counters.normalsCapture++, console.log("DEBUG: new normal map captured", a.counters.normalsCapture, t), a.addTexture("normal" + a.counters.normalsCapture, () => {
        var t;
        return null === (t = e.geometry.userData._normalsCaptureMap) || void 0 === t ? void 0 : t.texture;
      }, [40, 110 * a.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", !0));
    }

    makeDiamond(e, t, n) {
      var r, i;
      Array.from(null !== (r = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== r ? r : []).forEach(e => {
        (null == e ? void 0 : e.isMesh) && e.geometry && this.prepareDiamondMesh(e, t);
      }), this._convertToDiamondMaterial(e, n), null === (i = this._viewer) || void 0 === i || i.setDirty();
    }

    _convertToDiamondMaterial(e, t = {
      isDiamond: !0
    }) {
      var n, r, s, o, a, l, c;
      let u = { ...(null != t ? t : {})
      };
      u.isDiamond || u.isDiamondMaterialParameters ? Array.isArray(u.boostFactors) && (u.boostFactors = new i.Pa4().fromArray(u.boostFactors)) : u = {
        isDiamondMaterialParameters: !0
      }, u.color = null !== (s = null !== (n = u.color) && void 0 !== n ? n : null === (r = null == e ? void 0 : e.materialObject) || void 0 === r ? void 0 : r.color) && void 0 !== s ? s : new ve(1, 1, 1);
      const p = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.getManager()) || void 0 === a ? void 0 : a.materials) || void 0 === l ? void 0 : l.generateFromTemplate("diamond", u);
      p && e && (p.userData._baseMaterial = e.uuid), Array.from(null !== (c = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== c ? c : []).forEach(e => {
        (e => {
          var t;
          return null !== (t = e.userData.setMaterial) && void 0 !== t ? t : t => {
            e.material = t.materialObject;
          };
        })(e)(p), this.prepareDiamondMesh(e, t);
      });
    }

    _computeOffsets(e, t, n = !1) {
      const r = t.split(";").find(e => this.offsetCache[e]);

      if (r && !n) {
        const n = this.offsetCache[r];
        return t.split(";").forEach(e => e !== r && (this.offsetCache[e] = n)), e.userData._normalsCaptureOffsets = n, n;
      }

      e.computeBoundingBox();
      const s = e.boundingBox.getCenter(new i.Pa4()),
            o = Oo(e),
            a = o.clone().invert(),
            l = {
        center: s,
        offsetMatrix: o,
        offsetMatrixInv: a,
        radius: 1,
        centerOffset: new i.Pa4().copy(s).applyMatrix4(a)
      };
      return t.split(";").forEach(e => this.offsetCache[e] = l), e.userData._normalsCaptureOffsets = l, l;
    }

  }

  Pa.PluginType = "Diamond", Pa.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", ka([C(Pa.prototype.refreshEnvMaps), xe()], Pa.prototype, "envMap", void 0), ka([C(Pa.prototype.refreshEnvMaps), xe()], Pa.prototype, "forceSceneEnvMap", void 0);

  const Da = e => ({
    writeMaterial: (t, n) => {
      t.isDiamondMaterial && (n.extensions = n.extensions || {}, n.extensions[Pa.DIAMOND_GLTF_EXTENSION] = t.toJSON(), e.extensionsUsed[Pa.DIAMOND_GLTF_EXTENSION] = !0);
    },
    writeMesh: (t, n) => {
      var r, i;
      if (!(null == t ? void 0 : t.material.isDiamondMaterial)) return;
      n.extensions = n.extensions || {};
      const s = {};
      null === (i = null === (r = t.userData) || void 0 === r ? void 0 : r.gltfExtensions) || void 0 === i || delete i[Pa.DIAMOND_GLTF_EXTENSION], t.userData._diamondNormalMapRes && (s.normalMapRes = t.userData._diamondNormalMapRes), t.userData._diamondCacheKey && (s.cacheKey = t.userData._diamondCacheKey), n.extensions[Pa.DIAMOND_GLTF_EXTENSION] = s, e.extensionsUsed[Pa.DIAMOND_GLTF_EXTENSION] = !0;
    }
  });

  var Oa = function () {
    return (Oa = Object.assign || function (e) {
      for (var t, n = 1, r = arguments.length; n < r; n++) for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);

      return e;
    }).apply(this, arguments);
  };

  function La(e, t) {
    var n = {};

    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);

    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
      var i = 0;

      for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
    }

    return n;
  }

  Object.create, Object.create;

  var Ia = function (e, t, n) {
    return Math.min(Math.max(n, e), t);
  };

  function Fa(e, t) {
    return e * Math.sqrt(1 - t * t);
  }

  var Na = ["duration", "bounce"],
      Ua = ["stiffness", "damping", "mass"];

  function Ba(e, t) {
    return t.some(function (t) {
      return void 0 !== e[t];
    });
  }

  function ja(e) {
    var t = e.from,
        n = void 0 === t ? 0 : t,
        r = e.to,
        i = void 0 === r ? 1 : r,
        s = e.restSpeed,
        o = void 0 === s ? 2 : s,
        a = e.restDelta,
        l = La(e, ["from", "to", "restSpeed", "restDelta"]),
        c = {
      done: !1,
      value: n
    },
        u = function (e) {
      var t = Oa({
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1
      }, e);

      if (!Ba(e, Ua) && Ba(e, Na)) {
        var n = function (e) {
          var t,
              n,
              r = e.duration,
              i = void 0 === r ? 800 : r,
              s = e.bounce,
              o = void 0 === s ? .25 : s,
              a = e.velocity,
              l = void 0 === a ? 0 : a,
              c = e.mass,
              u = void 0 === c ? 1 : c,
              p = 1 - o;
          p = Ia(.05, 1, p), i = Ia(.01, 10, i / 1e3), p < 1 ? (t = function (e) {
            var t = e * p,
                n = t * i;
            return .001 - (t - l) / Fa(e, p) * Math.exp(-n);
          }, n = function (e) {
            var n = e * p * i,
                r = n * l + l,
                s = Math.pow(p, 2) * Math.pow(e, 2) * i,
                o = Math.exp(-n),
                a = Fa(Math.pow(e, 2), p);
            return (.001 - t(e) > 0 ? -1 : 1) * ((r - s) * o) / a;
          }) : (t = function (e) {
            return Math.exp(-e * i) * ((e - l) * i + 1) - .001;
          }, n = function (e) {
            return Math.exp(-e * i) * (i * i * (l - e));
          });

          var h = function (e, t, n) {
            for (var r = n, i = 1; i < 12; i++) r -= e(r) / t(r);

            return r;
          }(t, n, 5 / i);

          if (i *= 1e3, isNaN(h)) return {
            stiffness: 100,
            damping: 10,
            duration: i
          };
          var d = Math.pow(h, 2) * u;
          return {
            stiffness: d,
            damping: 2 * p * Math.sqrt(u * d),
            duration: i
          };
        }(e);

        (t = Oa(Oa(Oa({}, t), n), {
          velocity: 0,
          mass: 1
        })).isResolvedFromDuration = !0;
      }

      return t;
    }(l),
        p = u.stiffness,
        h = u.damping,
        d = u.mass,
        f = u.velocity,
        _ = u.duration,
        m = u.isResolvedFromDuration,
        g = za,
        v = za;

    function b() {
      var e = f ? -f / 1e3 : 0,
          t = i - n,
          r = h / (2 * Math.sqrt(p * d)),
          s = Math.sqrt(p / d) / 1e3;

      if (null != a || (a = Math.abs(i - n) <= 1 ? .01 : .4), r < 1) {
        var o = Fa(s, r);
        g = function (n) {
          var a = Math.exp(-r * s * n);
          return i - a * ((e + r * s * t) / o * Math.sin(o * n) + t * Math.cos(o * n));
        }, v = function (n) {
          var i = Math.exp(-r * s * n);
          return r * s * i * (Math.sin(o * n) * (e + r * s * t) / o + t * Math.cos(o * n)) - i * (Math.cos(o * n) * (e + r * s * t) - o * t * Math.sin(o * n));
        };
      } else if (1 === r) g = function (n) {
        return i - Math.exp(-s * n) * (t + (e + s * t) * n);
      };else {
        var l = s * Math.sqrt(r * r - 1);

        g = function (n) {
          var o = Math.exp(-r * s * n),
              a = Math.min(l * n, 300);
          return i - o * ((e + r * s * t) * Math.sinh(a) + l * t * Math.cosh(a)) / l;
        };
      }
    }

    return b(), {
      next: function (e) {
        var t = g(e);
        if (m) c.done = e >= _;else {
          var n = 1e3 * v(e),
              r = Math.abs(n) <= o,
              s = Math.abs(i - t) <= a;
          c.done = r && s;
        }
        return c.value = c.done ? i : t, c;
      },
      flipTarget: function () {
        var e;
        f = -f, n = (e = [i, n])[0], i = e[1], b();
      }
    };
  }

  ja.needsInterpolation = function (e, t) {
    return "string" == typeof e || "string" == typeof t;
  };

  var za = function (e) {
    return 0;
  },
      Va = function (e, t, n) {
    var r = t - e;
    return 0 === r ? 1 : (n - e) / r;
  },
      Ga = function (e, t, n) {
    return -n * e + n * t + e;
  },
      Ha = function (e, t) {
    return function (n) {
      return Math.max(Math.min(n, t), e);
    };
  },
      Wa = function (e) {
    return e % 1 ? Number(e.toFixed(5)) : e;
  },
      Ka = /(-)?([\d]*\.?[\d])+/g,
      Xa = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi,
      qa = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;

  function Ya(e) {
    return "string" == typeof e;
  }

  var Za = {
    test: function (e) {
      return "number" == typeof e;
    },
    parse: parseFloat,
    transform: function (e) {
      return e;
    }
  },
      Ja = Oa(Oa({}, Za), {
    transform: Ha(0, 1)
  }),
      $a = (Oa(Oa({}, Za), {
    default: 1
  }), function (e, t) {
    return function (n) {
      return Boolean(Ya(n) && qa.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t));
    };
  }),
      Qa = function (e, t, n) {
    return function (r) {
      var i;
      if (!Ya(r)) return r;
      var s = r.match(Ka),
          o = s[0],
          a = s[1],
          l = s[2],
          c = s[3];
      return (i = {})[e] = parseFloat(o), i[t] = parseFloat(a), i[n] = parseFloat(l), i.alpha = void 0 !== c ? parseFloat(c) : 1, i;
    };
  },
      el = Ha(0, 255),
      tl = Oa(Oa({}, Za), {
    transform: function (e) {
      return Math.round(el(e));
    }
  }),
      nl = {
    test: $a("rgb", "red"),
    parse: Qa("red", "green", "blue"),
    transform: function (e) {
      var t = e.red,
          n = e.green,
          r = e.blue,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
      return "rgba(" + tl.transform(t) + ", " + tl.transform(n) + ", " + tl.transform(r) + ", " + Wa(Ja.transform(s)) + ")";
    }
  },
      rl = {
    test: $a("#"),
    parse: function (e) {
      var t = "",
          n = "",
          r = "",
          i = "";
      return e.length > 5 ? (t = e.substr(1, 2), n = e.substr(3, 2), r = e.substr(5, 2), i = e.substr(7, 2)) : (t = e.substr(1, 1), n = e.substr(2, 1), r = e.substr(3, 1), i = e.substr(4, 1), t += t, n += n, r += r, i += i), {
        red: parseInt(t, 16),
        green: parseInt(n, 16),
        blue: parseInt(r, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
      };
    },
    transform: nl.transform
  },
      il = function (e) {
    return {
      test: function (t) {
        return Ya(t) && t.endsWith(e) && 1 === t.split(" ").length;
      },
      parse: parseFloat,
      transform: function (t) {
        return "" + t + e;
      }
    };
  },
      sl = (il("deg"), il("%")),
      ol = (il("px"), il("vh"), il("vw"), Oa(Oa({}, sl), {
    parse: function (e) {
      return sl.parse(e) / 100;
    },
    transform: function (e) {
      return sl.transform(100 * e);
    }
  }), {
    test: $a("hsl", "hue"),
    parse: Qa("hue", "saturation", "lightness"),
    transform: function (e) {
      var t = e.hue,
          n = e.saturation,
          r = e.lightness,
          i = e.alpha,
          s = void 0 === i ? 1 : i;
      return "hsla(" + Math.round(t) + ", " + sl.transform(Wa(n)) + ", " + sl.transform(Wa(r)) + ", " + Wa(Ja.transform(s)) + ")";
    }
  }),
      al = function (e, t, n) {
    var r = e * e,
        i = t * t;
    return Math.sqrt(Math.max(0, n * (i - r) + r));
  },
      ll = [rl, nl, ol],
      cl = function (e) {
    return ll.find(function (t) {
      return t.test(e);
    });
  },
      ul = function (e) {
    return "'" + e + "' is not an animatable color. Use the equivalent color code instead.";
  },
      pl = function (e, t) {
    var n = cl(e),
        r = cl(t);
    ul(e), ul(t), n.transform, r.transform;
    var i = n.parse(e),
        s = r.parse(t),
        o = Oa({}, i),
        a = n === ol ? Ga : al;
    return function (e) {
      for (var t in o) "alpha" !== t && (o[t] = a(i[t], s[t], e));

      return o.alpha = Ga(i.alpha, s.alpha, e), n.transform(o);
    };
  },
      hl = function (e) {
    return nl.test(e) || rl.test(e) || ol.test(e);
  },
      dl = function (e) {
    return nl.test(e) ? nl.parse(e) : ol.test(e) ? ol.parse(e) : rl.parse(e);
  },
      fl = function (e) {
    return Ya(e) ? e : e.hasOwnProperty("red") ? nl.transform(e) : ol.transform(e);
  },
      _l = "${c}",
      ml = "${n}";

  function gl(e) {
    var t = [],
        n = 0,
        r = e.match(Xa);
    r && (n = r.length, e = e.replace(Xa, _l), t.push.apply(t, r.map(dl)));
    var i = e.match(Ka);
    return i && (e = e.replace(Ka, ml), t.push.apply(t, i.map(Za.parse))), {
      values: t,
      numColors: n,
      tokenised: e
    };
  }

  function vl(e) {
    return gl(e).values;
  }

  function bl(e) {
    var t = gl(e),
        n = t.values,
        r = t.numColors,
        i = t.tokenised,
        s = n.length;
    return function (e) {
      for (var t = i, n = 0; n < s; n++) t = t.replace(n < r ? _l : ml, n < r ? fl(e[n]) : Wa(e[n]));

      return t;
    };
  }

  var xl = function (e) {
    return "number" == typeof e ? 0 : e;
  },
      yl = {
    test: function (e) {
      var t, n, r, i;
      return isNaN(e) && Ya(e) && (null !== (n = null === (t = e.match(Ka)) || void 0 === t ? void 0 : t.length) && void 0 !== n ? n : 0) + (null !== (i = null === (r = e.match(Xa)) || void 0 === r ? void 0 : r.length) && void 0 !== i ? i : 0) > 0;
    },
    parse: vl,
    createTransformer: bl,
    getAnimatableNone: function (e) {
      var t = vl(e);
      return bl(e)(t.map(xl));
    }
  },
      wl = function (e, t) {
    return function (n) {
      return t(e(n));
    };
  },
      Sl = function () {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];

    return e.reduce(wl);
  };

  function Ml(e, t) {
    return function (e) {
      return "number" == typeof e;
    }(e) ? function (n) {
      return Ga(e, t, n);
    } : hl(e) ? pl(e, t) : Cl(e, t);
  }

  var Tl = function (e, t) {
    var n = function (e, t) {
      for (var n = 0, r = t.length, i = e.length; n < r; n++, i++) e[i] = t[n];

      return e;
    }([], e),
        r = n.length,
        i = e.map(function (e, n) {
      return Ml(e, t[n]);
    });

    return function (e) {
      for (var t = 0; t < r; t++) n[t] = i[t](e);

      return n;
    };
  },
      El = function (e, t) {
    var n = Oa(Oa({}, e), t),
        r = {};

    for (var i in n) void 0 !== e[i] && void 0 !== t[i] && (r[i] = Ml(e[i], t[i]));

    return function (e) {
      for (var t in r) n[t] = r[t](e);

      return n;
    };
  };

  function Al(e) {
    for (var t = yl.parse(e), n = t.length, r = 0, i = 0, s = 0, o = 0; o < n; o++) r || "number" == typeof t[o] ? r++ : void 0 !== t[o].hue ? s++ : i++;

    return {
      parsed: t,
      numNumbers: r,
      numRGB: i,
      numHSL: s
    };
  }

  var Cl = function (e, t) {
    var n = yl.createTransformer(t),
        r = Al(e),
        i = Al(t);
    return r.numHSL === i.numHSL && r.numRGB === i.numRGB && (r.numNumbers, i.numNumbers), Sl(Tl(r.parsed, i.parsed), n);
  },
      Rl = function (e, t) {
    return function (n) {
      return Ga(e, t, n);
    };
  };

  function kl(e, t, n) {
    var r = void 0 === n ? {} : n,
        i = r.clamp,
        s = void 0 === i || i,
        o = r.ease,
        a = r.mixer,
        l = e.length;
    t.length, !o || !Array.isArray(o) || o.length, e[0] > e[l - 1] && (e = [].concat(e), t = [].concat(t), e.reverse(), t.reverse());

    var c = function (e, t, n) {
      for (var r = [], i = n || function (e) {
        return "number" == typeof e ? Rl : "string" == typeof e ? hl(e) ? pl : Cl : Array.isArray(e) ? Tl : "object" == typeof e ? El : void 0;
      }(e[0]), s = e.length - 1, o = 0; o < s; o++) {
        var a = i(e[o], e[o + 1]);

        if (t) {
          var l = Array.isArray(t) ? t[o] : t;
          a = Sl(l, a);
        }

        r.push(a);
      }

      return r;
    }(t, o, a),
        u = 2 === l ? function (e, t) {
      var n = e[0],
          r = e[1],
          i = t[0];
      return function (e) {
        return i(Va(n, r, e));
      };
    }(e, c) : function (e, t) {
      var n = e.length,
          r = n - 1;
      return function (i) {
        var s = 0,
            o = !1;

        if (i <= e[0] ? o = !0 : i >= e[r] && (s = r - 1, o = !0), !o) {
          for (var a = 1; a < n && !(e[a] > i || a === r); a++);

          s = a - 1;
        }

        var l = Va(e[s], e[s + 1], i);
        return t[s](l);
      };
    }(e, c);

    return s ? function (t) {
      return u(Ia(e[0], e[l - 1], t));
    } : u;
  }

  var Pl,
      Dl = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
      Ol = function (e) {
    return function (t) {
      return t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2;
    };
  },
      Ll = function (e) {
    return function (t) {
      return t * t * ((e + 1) * t - e);
    };
  },
      Il = (2, function (e) {
    return Math.pow(e, 2);
  }),
      Fl = Dl(Il),
      Nl = Ol(Il),
      Ul = function (e) {
    return 1 - Math.sin(Math.acos(e));
  },
      Bl = Dl(Ul),
      jl = Ol(Bl),
      zl = Ll(1.525),
      Vl = Dl(zl),
      Gl = Ol(zl),
      Hl = (Pl = Ll(1.525), function (e) {
    return (e *= 2) < 1 ? .5 * Pl(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)));
  }),
      Wl = function (e) {
    if (1 === e || 0 === e) return e;
    var t = e * e;
    return e < .36363636363636365 ? 7.5625 * t : e < .7272727272727273 ? 9.075 * t - 9.9 * e + 3.4 : e < .9 ? 12.066481994459833 * t - 19.63545706371191 * e + 8.898060941828255 : 10.8 * e * e - 20.52 * e + 10.72;
  },
      Kl = Dl(Wl);

  function Xl(e, t) {
    return e.map(function () {
      return t || Nl;
    }).splice(0, e.length - 1);
  }

  function ql(e) {
    var t = e.from,
        n = void 0 === t ? 0 : t,
        r = e.to,
        i = void 0 === r ? 1 : r,
        s = e.ease,
        o = e.offset,
        a = e.duration,
        l = void 0 === a ? 300 : a,
        c = {
      done: !1,
      value: n
    },
        u = Array.isArray(i) ? i : [n, i],
        p = function (e, t) {
      return e.map(function (e) {
        return e * t;
      });
    }(o && o.length === u.length ? o : function (e) {
      var t = e.length;
      return e.map(function (e, n) {
        return 0 !== n ? n / (t - 1) : 0;
      });
    }(u), l);

    function h() {
      return kl(p, u, {
        ease: Array.isArray(s) ? s : Xl(u, s)
      });
    }

    var d = h();
    return {
      next: function (e) {
        return c.value = d(e), c.done = e >= l, c;
      },
      flipTarget: function () {
        u.reverse(), d = h();
      }
    };
  }

  var Yl = {
    keyframes: ql,
    spring: ja,
    decay: function (e) {
      var t = e.velocity,
          n = void 0 === t ? 0 : t,
          r = e.from,
          i = void 0 === r ? 0 : r,
          s = e.power,
          o = void 0 === s ? .8 : s,
          a = e.timeConstant,
          l = void 0 === a ? 350 : a,
          c = e.restDelta,
          u = void 0 === c ? .5 : c,
          p = e.modifyTarget,
          h = {
        done: !1,
        value: i
      },
          d = o * n,
          f = i + d,
          _ = void 0 === p ? f : p(f);

      return _ !== f && (d = _ - i), {
        next: function (e) {
          var t = -d * Math.exp(-e / l);
          return h.done = !(t > u || t < -u), h.value = h.done ? _ : _ + t, h;
        },
        flipTarget: function () {}
      };
    }
  },
      Zl = 1 / 60 * 1e3,
      Jl = "undefined" != typeof performance ? function () {
    return performance.now();
  } : function () {
    return Date.now();
  },
      $l = "undefined" != typeof window ? function (e) {
    return window.requestAnimationFrame(e);
  } : function (e) {
    return setTimeout(function () {
      return e(Jl());
    }, Zl);
  },
      Ql = !0,
      ec = !1,
      tc = !1,
      nc = {
    delta: 0,
    timestamp: 0
  },
      rc = ["read", "update", "preRender", "render", "postRender"],
      ic = rc.reduce(function (e, t) {
    return e[t] = function (e) {
      var t = [],
          n = [],
          r = 0,
          i = !1,
          s = new WeakSet(),
          o = {
        schedule: function (e, o, a) {
          void 0 === o && (o = !1), void 0 === a && (a = !1);
          var l = a && i,
              c = l ? t : n;
          return o && s.add(e), -1 === c.indexOf(e) && (c.push(e), l && i && (r = t.length)), e;
        },
        cancel: function (e) {
          var t = n.indexOf(e);
          -1 !== t && n.splice(t, 1), s.delete(e);
        },
        process: function (a) {
          var l;
          if (i = !0, t = (l = [n, t])[0], (n = l[1]).length = 0, r = t.length) for (var c = 0; c < r; c++) {
            var u = t[c];
            u(a), s.has(u) && (o.schedule(u), e());
          }
          i = !1;
        }
      };
      return o;
    }(function () {
      return ec = !0;
    }), e;
  }, {}),
      sc = rc.reduce(function (e, t) {
    var n = ic[t];
    return e[t] = function (e, t, r) {
      return void 0 === t && (t = !1), void 0 === r && (r = !1), ec || cc(), n.schedule(e, t, r);
    }, e;
  }, {}),
      oc = rc.reduce(function (e, t) {
    return e[t] = ic[t].cancel, e;
  }, {}),
      ac = function (e) {
    return ic[e].process(nc);
  },
      lc = function (e) {
    ec = !1, nc.delta = Ql ? Zl : Math.max(Math.min(e - nc.timestamp, 40), 1), nc.timestamp = e, tc = !0, rc.forEach(ac), tc = !1, ec && (Ql = !1, $l(lc));
  },
      cc = function () {
    ec = !0, Ql = !0, tc || $l(lc);
  },
      uc = sc;

  function pc(e, t, n) {
    return void 0 === n && (n = 0), e - t - n;
  }

  var hc = function (e) {
    var t = function (t) {
      var n = t.delta;
      return e(n);
    };

    return {
      start: function () {
        return uc.update(t, !0);
      },
      stop: function () {
        return oc.update(t);
      }
    };
  };

  function dc(e) {
    var t,
        n,
        r,
        i,
        s,
        o = e.from,
        a = e.autoplay,
        l = void 0 === a || a,
        c = e.driver,
        u = void 0 === c ? hc : c,
        p = e.elapsed,
        h = void 0 === p ? 0 : p,
        d = e.repeat,
        f = void 0 === d ? 0 : d,
        _ = e.repeatType,
        m = void 0 === _ ? "loop" : _,
        g = e.repeatDelay,
        v = void 0 === g ? 0 : g,
        b = e.onPlay,
        x = e.onStop,
        y = e.onComplete,
        w = e.onRepeat,
        S = e.onUpdate,
        M = La(e, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]),
        T = M.to,
        E = 0,
        A = M.duration,
        C = !1,
        R = !0,
        k = function (e) {
      if (Array.isArray(e.to)) return ql;
      if (Yl[e.type]) return Yl[e.type];
      var t = new Set(Object.keys(e));
      return t.has("ease") || t.has("duration") && !t.has("dampingRatio") ? ql : t.has("dampingRatio") || t.has("stiffness") || t.has("mass") || t.has("damping") || t.has("restSpeed") || t.has("restDelta") ? ja : ql;
    }(M);

    (null === (n = (t = k).needsInterpolation) || void 0 === n ? void 0 : n.call(t, o, T)) && (s = kl([0, 100], [o, T], {
      clamp: !1
    }), o = 0, T = 100);
    var P = k(Oa(Oa({}, M), {
      from: o,
      to: T
    }));
    return l && (null == b || b(), (r = u(function (e) {
      if (R || (e = -e), h += e, !C) {
        var t = P.next(Math.max(0, h));
        i = t.value, s && (i = s(i)), C = R ? t.done : h <= 0;
      }

      null == S || S(i), C && (0 === E && (null != A || (A = h)), E < f ? function (e, t, n, r) {
        return r ? e >= t + n : e <= -n;
      }(h, A, v, R) && (E++, "reverse" === m ? h = function (e, t, n, r) {
        return void 0 === n && (n = 0), void 0 === r && (r = !0), r ? pc(t + -e, t, n) : t - (e - t) + n;
      }(h, A, v, R = E % 2 == 0) : (h = pc(h, A, v), "mirror" === m && P.flipTarget()), C = !1, w && w()) : (r.stop(), y && y()));
    })).start()), {
      stop: function () {
        null == x || x(), r.stop();
      }
    };
  }

  const fc = {
    linear: function (e) {
      return e;
    },
    easeIn: Il,
    easeOut: Fl,
    easeInOut: Nl,
    circIn: Ul,
    circOut: Bl,
    circInOut: jl,
    backIn: zl,
    backOut: Vl,
    backInOut: Gl,
    anticipate: Hl,
    bounceOut: Wl,
    bounceIn: Kl,
    bounceInOut: function (e) {
      return e < .5 ? .5 * (1 - Wl(1 - 2 * e)) : .5 * Wl(2 * e - 1) + .5;
    },
    easeInOutSine: function (e) {
      return -(Math.cos(Math.PI * e) - 1) / 2;
    }
  };

  async function _c(e) {
    return new Promise(t => setTimeout(t, Math.max(0, e)));
  }

  function mc(e, t, n) {
    const r = e[t],
          i = () => {
      var t;
      "function" == typeof (null === (t = null == e ? void 0 : e.userData) || void 0 === t ? void 0 : t.setDirty) && e.userData.setDirty(), null == n || n();
    };

    return r.isVector3 || r.isVector2 || r.isVector4 ? e => {
      r.copy(e), i();
    } : n => {
      e[t] = n, i();
    };
  }

  function gc(e) {
    return "boolean" != typeof e;
  }

  async function vc(e, t, n) {
    t in e || console.error("invalid key", t, e);

    const r = mc(e, t),
          i = e[t],
          s = e => {
      var t;
      r(e), null === (t = n.onUpdate) || void 0 === t || t.call(n, e);
    };

    if (gc(i)) return "function" == typeof n.to && (n = { ...n,
      to: n.to(i, e)
    }), bc({ ...n,
      from: i,
      onUpdate: s
    });
    {
      const {
        duration: e
      } = n;
      return _c(null != e ? e : 0).then(() => s(n.to));
    }
  }

  async function bc(e) {
    return new Promise((t, n) => {
      dc({
        onComplete: () => {
          var n;
          null === (n = e.onComplete) || void 0 === n || n.call(e), t();
        },
        onStop: () => {
          var n;
          null === (n = e.onStop) || void 0 === n || n.call(e), t();
        },
        ...e
      });
    });
  }

  var xc,
      yc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let wc = xc = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.animations = [], this.loopAnimations = !0, this.loopRepetitions = 1 / 0, this.timeScale = 0, this.animateOnScroll = !1, this.animationSpeed = 1, this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this.dependencies = [Vs], this._lastFrameTime = 0, this._fadeDisabled = !1, this._objectAdded = e => {
        const t = e.object;
        "model" === t.assetType && t.modelObject && this._viewer && t.modelObject.traverse(e => {
          const t = e.animations;
          if (t.length < 1) return;
          const n = Math.max(...t.map(e => e.duration));
          t.forEach(e => e.duration = n);
          const r = new i.Xcj(this._viewer.scene.modelRoot.modelObject),
                s = t.map(e => r.clipAction(e).setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions));
          this.animations.push({
            mixer: r,
            clips: t,
            actions: s,
            duration: n
          }), this.onPropertyChange();
        });
      }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.onPropertyChange = this.onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this);
    }

    get animationState() {
      return this._animationState;
    }

    get animationTime() {
      return this._animationTime;
    }

    get animationDuration() {
      return this._animationDuration;
    }

    _wheel({
      deltaY: e
    }) {
      this.enabled && Math.abs(e) > .001 && (this._scrollAnimationState = -1 * Math.sign(e));
    }

    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      const n = this._viewer,
            r = this.animateOnScroll;
      if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !r) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(xc.PluginType), this._fadeDisabled = !1));
      const i = Ct() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = i - 1 / 30);
      let s = i - this._lastFrameTime;
      if (s *= this.animationSpeed, this._lastFrameTime = i, r && (s *= this._scrollAnimationState), Math.abs(s) < 1e-4) return;
      const o = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

      if (o && o > 0 && (s = o), 0 !== o && (this.animations.map(e => e.mixer.update(s)), this._animationTime += s, this._animationTime > this._animationDuration && (this._animationTime -= this._animationDuration), this._animationTime < 0 && (this._animationTime += this._animationDuration), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, n.scene.activeCamera.cameraObject.userData.__animatingCamera && n.scene.activeCamera.setDirty(), n.renderer.resetShadows(), n.setDirty(), !this._fadeDisabled)) {
        const e = this._viewer.getPluginByType("FrameFade");

        e && (e.disable(xc.PluginType), this._fadeDisabled = !0);
      }
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Sc(e, this));
    }

    async onAdded(e) {
      var t, n, r, i, s, o;
      null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.scene.addEventListener("addSceneObject", this._objectAdded), null === (o = null === (s = null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.exporter) || void 0 === i ? void 0 : i.getExporter("gltf", "glb")) || void 0 === s ? void 0 : s.extensions) || void 0 === o || o.push(Mc), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel);
      let a = -1;
      return Object.defineProperty(e.scene.modelRoot, "currentTimelineMarker", {
        get: () => a,
        set: t => e.scene.modelRoot.dispatchEvent({
          type: "animationTimelineMarker",
          marker: this.timelineMarkers[a = t]
        })
      }), e.scene.modelRoot.addEventListener("animationTimelineMarker", ({
        marker: e
      }) => {
        var t;
        if (!this._viewer) return;
        if (!e) return this._viewer.scene.activeCamera = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.defaultCamera, void this._viewer.setDirty();
        const n = e.camera;
        n && (n.userData.__animatingCamera = !0, this._viewer.scene.activeCamera = this._viewer.createCamera(n));
      }), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n;
      return e.scene.removeEventListener("addSceneObject", this._objectAdded), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), super.onRemove(e);
    }

    onPropertyChange() {
      "playing" === this._animationState && this.playAnimation(), this._animationDuration = Math.max(...this.animations.map(({
        duration: e
      }) => e));
    }

    onStateChange() {
      var e, t;
      null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.children) || void 0 === t || t.map(e => e && x(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }

    playPauseAnimation() {
      "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation();
    }

    async playClip(e, t = !1) {
      return this.playClips([e], t);
    }

    async playClips(e, t = !1) {
      const n = [];
      return this.animations.forEach(({
        actions: t
      }) => {
        t.forEach(t => {
          e.includes(t.getClip().name) && n.push(t);
        });
      }), this.playAnimation(n, t);
    }

    async playAnimation(e, t = !1) {
      var n, r, s;
      if (!this.enabled) return;
      "playing" === this._animationState && this.stopAnimation(!1), g(null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("Picking")) || void 0 === r ? void 0 : r.transformControls, "enabled", !1);
      let o = 0;
      e || (e = [], this.animations.forEach(({
        mixer: t,
        actions: n,
        clips: r
      }) => {
        e.push(...n);
      }));
      const a = Be();
      this._lastAnimId = a, "paused" !== this._animationState && this.resetAnimation();

      for (const t of e) this.timeScale > 0 && (t.timeScale = this.timeScale), t.setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions), t.play(), o = Math.max(o, t.getClip().duration / t.timeScale);

      if (this._animationState = "playing", null === (s = this._viewer) || void 0 === s || s.setDirty(), o *= this.loopAnimations ? this.loopRepetitions : 1, o /= this.animationSpeed, !isFinite(o)) return;
      const l = 1e3 * o - this._animationTime / this.animationSpeed + .01;
      l > 0 && (await _c(l)), a === this._lastAnimId && this.stopAnimation(t);
    }

    pauseAnimation() {
      var e, t, n;
      this._animationState = "paused", g(null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.transformControls, "enabled", !0), null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = "";
    }

    stopAnimation(e = !1) {
      var t, n;
      this._animationState = "stopped", g(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), "enabled", !0), e ? this.resetAnimation() : null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = "";
    }

    resetAnimation() {
      var e;
      "stopped" === this._animationState ? (this.animations.forEach(({
        mixer: e,
        actions: t,
        clips: n
      }) => {
        e.stopAllAction(), e.setTime(0);
      }), this._animationTime = 0, null === (e = this._viewer) || void 0 === e || e.setDirty()) : this.stopAnimation(!0);
    }

  };
  wc.PluginType = "GLTFAnimation", wc.AnimationMarkersExtension = "WEBGI_animation_markers", yc([Ge()], wc.prototype, "animationState", null), yc([Ge()], wc.prototype, "animationTime", null), yc([Ge()], wc.prototype, "animationDuration", null), yc([C(xc.prototype.onPropertyChange), Ve("Loop", {
    limitedUi: !0
  })], wc.prototype, "loopAnimations", void 0), yc([C(xc.prototype.onPropertyChange)], wc.prototype, "loopRepetitions", void 0), yc([C(xc.prototype.onPropertyChange)], wc.prototype, "timeScale", void 0), yc([Ve(), xe()], wc.prototype, "animateOnScroll", void 0), yc([He("Speed", [.1, 4], .1, {
    limitedUi: !0
  }), xe()], wc.prototype, "animationSpeed", void 0), yc([C(xc.prototype.onStateChange)], wc.prototype, "_animationState", void 0), yc([Xe("Play/Pause", e => ({
    label: () => "playing" === e.animationState ? "Pause" : "Play",
    limitedUi: !0
  }))], wc.prototype, "playPauseAnimation", null), yc([Xe("Stop", {
    limitedUi: !0
  })], wc.prototype, "stopAnimation", null), yc([Xe("Reset", {
    limitedUi: !0
  })], wc.prototype, "resetAnimation", null), wc = xc = yc([Qe("GLTF Animations")], wc);

  class Sc {
    constructor(e, t) {
      this.parser = e, this.name = wc.AnimationMarkersExtension, this.plugin = t;
    }

    async afterRoot(e) {
      var t;
      let n = [];

      for (const e of this.parser.json.scenes) {
        if (!e.extensions) continue;
        const t = e.extensions[this.name];

        for (const e of (null == t ? void 0 : t.markers) || []) {
          const t = void 0 !== e.camera ? await this.parser.getDependency("camera", e.camera) : void 0;

          if (void 0 === e.time) {
            const t = 30;
            e.time = e.frame / t, console.error("Update timeline markers plugin for correct times.");
          }

          n.push({
            name: e.name,
            frame: e.frame,
            time: e.time,
            camera: t
          });
        }
      }

      if (n.length < 1) return;
      n = n.sort((e, t) => e.frame - t.frame);
      const r = null !== (t = e.scene) && void 0 !== t ? t : e.scenes[0];
      if (!r) return;
      r.userData.__markers = n;
      const s = this.plugin.timelineMarkers,
            o = n.map(e => e.time);
      let a = s.length;
      const l = n.map(e => a++),
            c = Math.max(...o) + .01;
      s.push(...n);
      const u = new i.dUE(".currentTimelineMarker", o, l, 2300),
            p = new i.m7l("animationTimelineMarker", c, [u]);
      p.__gltfExport = !1, e.animations.push(p);
    }

  }

  const Mc = e => ({
    afterParse(t) {
      const n = e.json.scenes[e.json.scene || 0];
      n.extensions = n.extensions || {};
      const r = {
        markers: []
      },
            i = [];

      if ((Array.isArray(t) ? t : [t]).forEach(e => e.traverse(e => {
        e.userData.__markers && i.push(...e.userData.__markers);
      })), i.sort((e, t) => e.frame - t.frame), !(i.length < 1)) {
        for (const t of i) {
          const n = t.camera;

          if (n) {
            const i = e.nodeMap.get(n);

            if (void 0 === i) {
              console.warn("Camera not found in gltf export", n, e.nodeMap);
              continue;
            }

            const s = e.json.nodes[i].camera;
            t.camera = s, r.markers.push(t);
          }
        }

        n.extensions[wc.AnimationMarkersExtension] = r, e.extensionsUsed[wc.AnimationMarkersExtension] = !0;
      }
    }

  });

  var Tc,
      Ec = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Ac = Tc = class extends Ft {
    constructor() {
      super({
        vertexShader: s.vertexShader,
        defines: {
          PASS_STEP: 1
        },
        uniforms: {
          tSource: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          opacity: {
            value: 1
          },
          tDiffuseSize: {
            value: new i.FM8()
          },
          weight: {
            value: 1
          },
          tNormalDepth: {
            value: null
          }
        },
        fragmentShader: jt + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}void main(){\n#if PASS_STEP == 0 \ngl_FragColor=weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}"
      }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new i.Ltg(2, .5, 0, 0), this.threshold = 2, this.softThreshold = .5, this.intensity = .5, this.bloomIterations = 4, this.radius = .6, this.power = 1, this.bloomDebug = !1, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = !0, this.userData = {
        setDirty: () => {
          this.setDirty();
        }
      };
    }

    _thresholdsUpdated() {
      this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = .125 / (this.uniforms.prefilter.value.z + 1e-5);
    }

    render(e, t, n, r, s) {
      const o = e.baseRenderer;
      this.material.defines.PASS_STEP = 0, this.clear = !0;
      const a = n;
      let l = .5,
          c = a.width * l,
          u = a.height * l;
      const p = [];
      let h = o.getTempTarget({
        sizeMultiplier: .5,
        type: i.cLu
      });
      p.push(h);
      let d = a;
      this.material.needsUpdate = !0, this.material.uniforms.weight.value = this._weights[0], super.render(e, h, d, r, s), d = h;
      let f = 1;

      for (; f < this.bloomIterations && (c /= 2, u /= 2, l /= 2, !(u < 2 || c < 2)); f++) {
        h = o.getTempTarget({
          sizeMultiplier: l,
          type: i.cLu
        }), p.push(h), this.material.defines.PASS_STEP = 1;
        let t = this._weights[f];
        t = 0 !== this._weights[f - 1] ? this._weights[f] / this._weights[f - 1] : this._weights[f], this.material.uniforms.weight.value = t, this.material.needsUpdate = !0, super.render(e, h, d, r, s), d = h;
      }

      this.clear = !1;
      const _ = e.autoClear;

      for (e.autoClear = !1, f -= 2; f >= 0; f--) h = p[f], p[f] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = !0, this.material.blending = i.WMw, this.material.needsUpdate = !0, e.autoClear = !1, super.render(e, h, d, r, s), this.material.blending = i.jFi, o.releaseTempTarget(d), d = h;

      this.clear = !0, e.autoClear = _, e.autoClear = !0, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = !0, super.render(e, t, d, r, s)) : (this.uniforms.tSource.value = a.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = !0, super.render(e, t, d, r, s), this.uniforms.tSource.value = null), o.releaseTempTarget(d);
    }

    _updateWeights() {
      if (!this._weights) return;
      const e = Math.max(Math.min(this.radius, 1), 0),
            t = 1 / (this.bloomIterations - 1);

      for (let n = 0; n < this.bloomIterations; n++) {
        let r = n * t + .1,
            i = 1.2 - r;
        r = Math.pow(r, this.power), i = Math.pow(i, this.power), this._weights[n] = i * (1 - e) + r * e;
      }

      this.setDirty();
    }

  };
  Ec([V()], Ac.prototype, "prefilter", void 0), Ec([He("Threshold", [0, 2]), C(Tc.prototype._thresholdsUpdated), xe()], Ac.prototype, "threshold", void 0), Ec([He("Soft Threshold", [0, 1]), C(Tc.prototype._thresholdsUpdated), xe()], Ac.prototype, "softThreshold", void 0), Ec([He("Intensity", [0, 3]), xe(), V()], Ac.prototype, "intensity", void 0), Ec([He("Iterations", [0, 7], 1), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "bloomIterations", void 0), Ec([He("Radius", [0, 1], .01), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "radius", void 0), Ec([He("Power", [.2, 10], .01), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "power", void 0), Ec([Ve("Debug")], Ac.prototype, "bloomDebug", void 0), Ac = Tc = Ec([Qe("Bloom")], Ac);

  class Cc extends Ws {
    constructor() {
      super(...arguments), this.passId = "bloom", this._beforeFilters = ["tonemap", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"];
    }

    passCtor(e) {
      return new Ac();
    }

    _update(e) {
      var t, n;
      return null === (t = e.getPlugin(Ys)) || void 0 === t || t.updateShaderProperties(null === (n = this.pass) || void 0 === n ? void 0 : n.passObject.material), super._update(e);
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

    get params() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject;
    }

  }

  Cc.PluginType = "Bloom";

  var Rc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let kc = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {
        ANISOTROPY_DEBUG: !1
      }, this._uniforms = {
        anisotropyFactor: {
          value: 1
        },
        anisotropyNoise: {
          value: 1
        },
        anisotropyDirection: {
          value: 1
        },
        anisotropyDirectionMap: {
          value: null
        },
        frameCount: {
          value: 0
        }
      }, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !t.materialObject.userData._isAnisotropic) return;
          const s = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._anisotropyDirectionMap,
                o = M`
                #include <bsdfs>
                //#if ANISOTROPY_ENABLED
                ${vo}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (s ? U("anisotropyDirectionMap", s, n.capabilities.isWebGL2) : "");
          e.fragmentShader = e.fragmentShader.replace("#include <bsdfs>", o), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tangent*rot2.x+bitangent*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));IncidentLight directLight;").replaceAll("RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )");
          const a = i.WdD.lights_physical_pars_fragment.replace("void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {").replace("BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_pars_fragment>", a);
          const l = M`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + i.WdD.lights_fragment_maps.replace("getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )").replace("getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )");
          e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_maps>", l), e.vertexUvs = !0, e.vertexTangents = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = t.materialObject.userData;
          if (!(null == r ? void 0 : r._isAnisotropic)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          if (!i.geometry.attributes.tangent) throw new Error("No tangents on the geometry");
          this._uniforms.anisotropyFactor.value = r._anisotropyFactor, this._uniforms.anisotropyNoise.value = r._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (n = r._anisotropyDirectionMap) || void 0 === n ? void 0 : n.isTexture) ? r._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = r._anisotropyDirection;
          let s = this.enabled ? 1 : 0;
          t.materialObject.defines.ANISOTROPY_ENABLED !== s && (t.materialObject.defines.ANISOTROPY_ENABLED = s, t.materialObject.needsUpdate = !0), s = +this._defines.ANISOTROPY_DEBUG, t.materialObject.defines.ANISOTROPY_DEBUG !== s && (t.materialObject.defines.ANISOTROPY_DEBUG = s, t.materialObject.needsUpdate = !0), s = r._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s = "CONSTANT"), s = "DIRECTION" === s ? 2 : "ROTATION" === s ? 1 : 0, t.materialObject.defines.ANISOTROPY_TEX_MODE !== s && (t.materialObject.defines.ANISOTROPY_TEX_MODE = s, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n, r;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._isAnisotropic) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._anisotropyDirectionMap) || void 0 === r ? void 0 : r.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer];
        },
        getUiConfig: e => {
          const t = this.makeAnisotropic,
                n = {
            type: "folder",
            label: "Anisotropy",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                return e.materialObject.userData._isAnisotropic || !1;
              },

              set value(r) {
                var i;
                r !== e.materialObject.userData._isAnisotropic && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._isAnisotropic = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0));
              },

              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Factor",
              bounds: [-2, 2],
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyFactor"],
              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Noise",
              bounds: [0, 2],
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyNoise"],
              onChange: this.setDirty
            }, {
              type: "image",
              label: "Texture",
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyDirectionMap"],
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }, {
              type: "dropdown",
              label: "Mode",
              hidden: () => !e.materialObject.userData._isAnisotropic,
              property: [e.materialObject.userData, "_anisotropyDirectionMode"],
              children: ["CONSTANT", "ROTATION", "DIRECTION"].map(e => ({
                label: e
              })),
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }]
          };
          return n;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this.makeSelectedAnisotropic = () => {
        var e, t, n;
        const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
        return "material" === (null == r ? void 0 : r.assetType) && this.makeAnisotropic(r);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    makeAnisotropic(e) {
      var t;
      const n = null === (t = e.materialObject) || void 0 === t ? void 0 : t.userData;
      if (!n) return !1;

      if (void 0 === n._isAnisotropic) {
        const e = n.appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: n
        } of e) !n || n.index && n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1), t && !n.attributes.tangent && n.computeTangents();
        if (!t) return !1;
      }

      return n._isAnisotropic = !0, void 0 === n._anisotropyFactor && (n._anisotropyFactor = 1), void 0 === n._anisotropyNoise && (n._anisotropyNoise = 0), void 0 === n._anisotropyDirectionMode && (n._anisotropyDirectionMode = "DIRECTION"), e.materialObject.needsUpdate = !0, !0;
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new Pc(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(Vs);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Dc);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };
  kc.PluginType = "AnisotropyPlugin", kc.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", Rc([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], kc.prototype, "enabled", void 0), Rc([Xe("Make Anisotropy", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca));
    }
  }))], kc.prototype, "makeSelectedAnisotropic", void 0), kc = Rc([Qe("Anisotropy Materials")], kc);

  class Pc {
    constructor(e) {
      this.parser = e, this.name = kc.ANISOTROPY_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      var n, r, s;
      const o = this.parser,
            a = o.json.materials[e];
      if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
      const l = [],
            c = a.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._isAnisotropic = !0, t.userData._anisotropyFactor = null !== (n = c.anisotropyFactor) && void 0 !== n ? n : 0, t.userData._anisotropyNoise = null !== (s = null !== (r = c.anisotropyNoiseFactor) && void 0 !== r ? r : c.anisotropyNoise) && void 0 !== s ? s : 0;
      let {
        anisotropyDirectionMode: u,
        anisotropyDirection: p
      } = c;
      return u || (u = c.anisotropyTextureMode), p || (p = c.anisotropyRotation), t.userData._anisotropyDirectionMode = u && "number" == typeof (null == p ? void 0 : p.index) ? u : "CONSTANT", "ROTATION" === u || "DIRECTION" === u ? l.push(o.assignTexture(t.userData, "_anisotropyDirectionMap", p).then(e => {
        e.encoding = i.knz;
      })) : t.userData._anisotropyDirection = null != p ? p : 0, Promise.all(l);
    }

    afterRoot(e) {
      return e.scene.traverse(e => {
        var t, n;
        if (!(null === (n = null === (t = e.material) || void 0 === t ? void 0 : t.userData) || void 0 === n ? void 0 : n._isAnisotropic)) return;
        const r = e.geometry;
        r.attributes.tangent || (r.computeTangents(), r.attributes.tangent.needsUpdate = !0);
      }), null;
    }

  }

  const Dc = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._isAnisotropic) return;
      if ((t.userData._anisotropyFactor || 0) < .001) return;
      n.extensions = n.extensions || {};
      const r = {};

      if (r.anisotropyFactor = t.userData._anisotropyFactor || 1, r.anisotropyNoiseFactor = t.userData._anisotropyNoise || 0, r.anisotropyDirectionMode = t.userData._anisotropyDirectionMode || "CONSTANT", t.userData._anisotropyDirectionMap && "CONSTANT" !== r.anisotropyDirectionMode) {
        const n = {
          index: e.processTexture(t.userData._anisotropyDirectionMap)
        };
        e.applyTextureTransform(n, t.userData._anisotropyDirectionMap), r.anisotropyDirection = n;
      } else r.anisotropyDirectionMode = "CONSTANT", r.anisotropyDirection = t.userData._anisotropyDirection || 0;

      n.extensions[kc.ANISOTROPY_GLTF_EXTENSION] = r, e.extensionsUsed[kc.ANISOTROPY_GLTF_EXTENSION] = !0;
    }
  });

  class Oc extends Ft {
    constructor(e, t) {
      super({
        vertexShader: s.vertexShader,
        fragmentShader: t + "\n" + mo + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zx*texelSize));vec3 dtl=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.yz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.xz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=linearToRelativeLuminance(currentColor.rgb);float lum1=linearToRelativeLuminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);\n#if HAS_VELOCITY_BUFFER == 0\nvec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=(texture2D(tVelocity,vUv).xy*2.-1.);screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}",
        uniforms: {
          currentRT: {
            value: null
          },
          previousRT: {
            value: null
          },
          previousRTSize: {
            value: new i.FM8()
          },
          cameraNearFar: {
            value: new i.FM8()
          },
          lastProjectionViewMatrix: {
            value: new i.yGw()
          },
          currentProjectionViewMatrix: {
            value: new i.yGw()
          },
          projection: {
            value: new i.yGw()
          },
          inverseViewMatrix: {
            value: new i.yGw()
          },
          jitterSample: {
            value: new i.FM8()
          },
          firstFrame: {
            value: !0
          },
          tNormalDepth: {
            value: null
          },
          tVelocity: {
            value: null
          }
        },
        defines: {
          HAS_VELOCITY_BUFFER: 0,
          QUALITY: 1,
          UNJITTER: 0
        }
      }, "currentRT", "previousRT"), this.taaEnabled = !0, this.feedBack = new i.FM8(.88, .97), this.uiConfig = {
        type: "folder",
        label: "Temporal AA",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: () => this.onSizeUpdate()
        }, {
          type: "input",
          label: "Feedback",
          property: [this, "feedBack"],
          onChange: this.setDirty
        }]
      }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e, this.clear = !1, this.needsSwap = !0;
    }

    render(e, t, n, r, i) {
      if (!this.taaEnabled || !this.enabled) return void (this.needsSwap = !1);
      this.needsSwap = !0;
      const s = this.uniforms.tVelocity.value ? 1 : 0;
      s !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s, this.material.needsUpdate = !0), this.uniforms.previousRT.value = this.target.texture, super.render(e, t, n, r, i), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = !1;
    }

    updateCameraProperties(e) {
      e && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e.matrixWorld));
    }

    onSizeUpdate() {
      this.uniforms.firstFrame.value = !0, this.setDirty();
    }

    setSize(e, t) {
      super.setSize(e, t), this.onSizeUpdate();
    }

  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe(), V()], Oc.prototype, "feedBack", void 0);

  class Lc extends Ws {
    constructor() {
      super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [Ys];
    }

    passCtor(e) {
      if (!e.getPlugin(co)) throw "Add ProgressivePlugin before TAA";
      const t = new Oc(e.getPlugin(co).lastFrame, e.getPlugin(Ys).getUnpackSnippet());
      return e.renderer.addEventListener("resize", t.onSizeUpdate), t;
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    async onDispose(e) {
      return this.pass && e.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e);
    }

    _update(e) {
      if (!super._update(e)) return !1;
      const t = e.renderer.frameCount,
            n = this._pass.passObject;
      if (n.taaEnabled = t < 1, !n.taaEnabled) return !1;
      const r = e.scene.activeCamera;
      return n.updateShaderProperties([e.getPlugin(Ys), r, e.getPluginByType("VelocityBuffer")]), n.target = e.getPlugin(co).lastFrame, n.updateCameraProperties(null == r ? void 0 : r.cameraObject), !0;
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

  }

  Lc.PluginType = "TAA";

  class Ic {
    static async GetDataUrl(e, {
      mimeType: t = "image/png",
      rect: n = {
        x: 0,
        y: 0,
        width: e.width,
        height: e.height,
        assumeClientRect: !1
      },
      displayPixelRatio: r = 1,
      scale: i = 1
    }) {
      var s, o, a;
      const l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      l.width = n.width * i * r, l.height = n.height * i * r, n.assumeClientRect && (n.x *= e.width / (r * e.clientWidth), n.y *= e.height / (r * e.clientHeight), n.width *= e.width / (r * e.clientWidth), n.height *= e.height / (r * e.clientHeight));
      const c = l.getContext("2d");
      if (!c) return console.error("snapshot: cannot create context"), "";
      const u = e.style.background || (null === (s = e.parentElement) || void 0 === s ? void 0 : s.style.background) || "";

      if (u.includes("url")) {
        const t = null === (o = /url\("(.*)"\)/gi.exec(u)) || void 0 === o ? void 0 : o[1];

        if (t) {
          const i = new Image();
          i.src = t, await new Promise((e, t) => {
            i.onload = () => e(), i.onerror = () => t(), i.complete && e();
          }), c.drawImage(i, i.width * n.x * r / e.width, i.height * n.y * r / e.height, i.width * n.width * r / e.width, i.height * n.height * r / e.height, 0, 0, l.width, l.height);
        }
      } else c.fillStyle = e.style.background || (null === (a = e.parentElement) || void 0 === a ? void 0 : a.style.backgroundColor) || "#00000000", c.fillRect(0, 0, l.width, l.height);

      null == c || c.drawImage(e, n.x * r, n.y * r, n.width * r, n.height * r, 0, 0, l.width, l.height);
      const p = c.canvas.toDataURL(t);
      return l.remove(), p;
    }

    static async GetImage(e, t = {}) {
      const n = await this.GetDataUrl(e, t);
      return new Promise((e, t) => {
        const r = new Image();
        r.onload = () => {
          e(r);
        }, r.src = n;
      });
    }

    static async GetBlob(e, t = {}) {
      return await (await fetch(await this.GetDataUrl(e, t))).blob();
    }

    static async GetFile(e, t = "image.png", n = {}) {
      var r;
      return n.getDataUrl ? await this.GetDataUrl(e, n) : new File([await this.GetBlob(e, n)], t, {
        type: null !== (r = n.mimeType) && void 0 !== r ? r : "image/png",
        lastModified: Ct()
      });
    }

  }

  var Fc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Nc = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.downloadSnapshot = this.downloadSnapshot.bind(this);
    }

    async getFile(e, t = {}) {
      return t.getDataUrl = !1, await this._getFile(e, t);
    }

    async getDataUrl(e = {}) {
      var t;
      return e.getDataUrl = !0, null !== (t = await this._getFile("", e)) && void 0 !== t ? t : "";
    }

    async _getFile(e, t = {}) {
      var n, r, i;
      const s = null === (n = this._viewer) || void 0 === n ? void 0 : n.canvas;

      if (s) {
        const n = this._viewer.renderer.displayCanvasScaling;
        void 0 !== t.displayPixelRatio && t.displayPixelRatio !== n && (this._viewer.renderer.displayCanvasScaling = t.displayPixelRatio);
        const o = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPlugin(co);
        if (t.waitForProgressive && o && void 0 === t.timeout) for (; !o.isConverged(!0);) await _c(64);else await _c(null !== (i = t.timeout) && void 0 !== i ? i : 200);
        t.displayPixelRatio = 1;
        const a = await Ic.GetFile(s, e, t);
        return t.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = n, a;
      }
    }

    async downloadSnapshot(e = "snapshot.png", t = {}) {
      const n = await this.getFile(e, t);
      n && xt(n);
    }

  };
  Nc.PluginType = "CanvasSnipper", Fc([Xe("Download .png", {
    limitedUi: !0
  })], Nc.prototype, "downloadSnapshot", null), Nc = Fc([Qe("Canvas Snipper")], Nc);

  var Uc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Bc = 1,
      jc = class {
    constructor(e, t, n, r, s) {
      this.position = new i.Pa4(), this.target = new i.Pa4(), this.quaternion = new i._fP(), this.up = new i.Pa4(), this.name = "Camera View", this.snap = "", this.focusView = () => {}, this.deleteView = () => {}, this.uiConfig = $e(this.name, this), e && (this.position = e), t && (this.target = t), n && (this.up = n), r && (this.quaternion = r), s && (this.snap = s), this.name = "Camera View" + Bc++;
    }

    _nameChanged() {
      var e, t;
      this.uiConfig && (this.uiConfig.label = this.name, null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
    }

  };
  Uc([xe(), We()], jc.prototype, "position", void 0), Uc([xe(), We()], jc.prototype, "target", void 0), Uc([xe(), We()], jc.prototype, "quaternion", void 0), Uc([xe(), We()], jc.prototype, "up", void 0), Uc([xe(), qe()], jc.prototype, "name", void 0), Uc([Ze()], jc.prototype, "snap", void 0), Uc([Xe()], jc.prototype, "focusView", void 0), Uc([Xe()], jc.prototype, "deleteView", void 0), jc = Uc([Ae("CameraView")], jc);

  class zc extends Gs {
    constructor() {
      super(), this.enabled = !0, this._cameraViews = [], this.viewLooping = !1, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = .25, this.interpolateMode = "spherical", this.animateOnScroll = !1, this.seekOnScroll = !1, this._animating = !1, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = !1, this._viewQueue = [], this._animationLooping = !1, this._infiniteLooping = !0, this._driver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.focusNext = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2) return;

        let t = this._cameraViews.findIndex(e => e === this._currentView);

        t < 0 && (t = -1), t += 1, e ? t %= this._cameraViews.length : t = Math.min(t, this._cameraViews.length - 1), this.focusView(this._cameraViews[t]);
      }, this.focusPrevious = (e = !0) => {
        if (this._animating) return;
        if (this._cameraViews.length < 2 || !this._currentView) return;

        let t = this._cameraViews.findIndex(e => e === this._currentView);

        t < 0 && (t = 0), t -= 1, t = e ? (t + this._cameraViews.length) % this._cameraViews.length : Math.max(t, 0), this.focusView(this._cameraViews[t]);
      }, this._popAnimations = [], this.uiConfig = {
        type: "folder",
        label: "Camera Views",
        children: [() => [...this._cameraViews.map(e => e.uiConfig)], ...Je(this)]
      }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this);
    }

    get camViews() {
      return this._cameraViews;
    }

    _wheel(e) {
      this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e.deltaY) > .001 && (this._scrollAnimationState = -1 * Math.sign(e.deltaY)));
    }

    _pointerMove(e) {
      var t;

      if (this.enabled && !this._animating && this.seekOnScroll) {
        const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera;
        if (!n) return;
        const r = new i.$V(),
              s = n.position,
              o = n.target,
              a = new i._fP().setFromUnitVectors(n.cameraObject.up, new i.Pa4(0, 1, 0)),
              l = a.clone().invert(),
              c = s.clone().sub(o);
        c.applyQuaternion(a), r.setFromVector3(c), r.theta += this.rotationOffset * e.movementX / this._viewer.canvas.clientWidth, r.phi += this.rotationOffset * e.movementY / this._viewer.canvas.clientHeight, r.makeSafe(), c.setFromSpherical(r), c.applyQuaternion(l), s.copy(o).add(c), n.positionUpdated(!1), n.targetUpdated();
      }
    }

    async onAdded(e) {
      await super.onAdded(e);
      let t = !1;
      e.addEventListener("preFrame", e => {
        this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.interactionsEnabled && (this._viewer.scene.activeCamera.interactionsEnabled = !1, t = !0) : t && (this._viewer.scene.activeCamera.interactionsEnabled = !0, t = !1);
      }), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove);
    }

    _postFrame() {
      var e, t;
      if (!this._viewer) return;
      if (!this.enabled || !this._animating) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(zc.PluginType), this._fadeDisabled = !1));
      const n = Ct() / 1e3;
      this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
      let r = n - this._lastFrameTime;
      this._lastFrameTime = n, r *= this.animateOnScroll ? this._scrollAnimationState : 1;
      const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

      if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= 0 || (this._updaters.forEach(e => {
        let t = r;
        e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
      }), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
        const e = this._viewer.getPluginByType("FrameFade");

        e && (e.disable(zc.PluginType), this._fadeDisabled = !0);
      }
    }

    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e);
    }

    async _animationLoop() {
      if (!this._animationLooping) {
        for (this._animationLooping = !0; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1);) {
          if (0 === this._viewQueue.length) {
            if (!this._infiniteLooping) break;

            this._viewQueue.push(...this._cameraViews);
          }

          await this.animateToView(this._viewQueue.shift()), await _c(2 + this.viewPauseTime);
        }

        this._animationLooping = !1;
      }
    }

    async animateAllViews() {
      if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
        for (; this._viewQueue.length > 0;) this._viewQueue.pop();

        this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = !1, await this._animationLoop(), this._infiniteLooping = !0;
      }
    }

    async resetToFirstView(e = 100) {
      this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e), await _c(2));
    }

    async recordAllViews(e) {
      var t;
      if (!this.enabled) return;
      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("CanvasRecorder");
      return n && n.enabled && (await this.resetToFirstView(), n.startRecording()) ? new Promise((t, r) => {
        const i = () => {
          n.removeEventListener("start", s), n.removeEventListener("stop", i), n.removeEventListener("error", o);
        },
              s = async () => {
          i(), null == e || e(), await this.animateAllViews();
          const r = await n.stopRecording();
          r && vt(r, "recording.mp4"), t();
        },
              o = async () => {
          i(), r();
        };

        n.addEventListener("start", s), n.addEventListener("stop", i), n.addEventListener("error", o);
      }) : void 0;
    }

    async addCurrentView() {
      var e, t, n, r, i;
      if (!this.enabled) return;
      const s = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera;
      if (!s) return;
      const o = this.getCurrentCameraView(s);
      o.snap = (await (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === n ? void 0 : n.getDataUrl({
        displayPixelRatio: .25,
        mimeType: "image/jpg"
      }))) || "", this._cameraViews.push(o), null === (i = (r = this.uiConfig).uiRefresh) || void 0 === i || i.call(r);
    }

    getCurrentCameraView(e) {
      const t = new i.Pa4(),
            n = e.cameraObject.matrixWorld;
      t.x = n.elements[4], t.y = n.elements[5], t.z = n.elements[6];
      const r = new jc(e.position.clone(), e.target.clone(), t.normalize(), e.cameraObject.quaternion.clone(), "");
      return r.focusView = async () => this.focusView(r), r.deleteView = () => this.deleteView(r), r;
    }

    async focusView(e) {
      return this.animateToView(e);
    }

    deleteView(e) {
      var t, n;

      const r = this._cameraViews.indexOf(e);

      r >= 0 && this._cameraViews.splice(r, 1), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t);
    }

    async animateToView(e, t, n) {
      var r;
      const s = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.activeCamera;
      if (!s) return;
      if (this._animating && (this._popAnimations.forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e);
      }), await _c(100), this._animating)) return void console.warn("todo: still animating?");
      this._currentView = e, this._animating = !0, this.dispatchEvent({
        type: "startViewChange",
        view: e
      }), void 0 === t && (t = this.animDuration);
      const o = "function" == typeof n ? n : fc[n || this.animEase],
            a = this._driver,
            l = [];
      this._popAnimations = [];
      const c = this._popAnimations;
      if ("spherical" === this.interpolateMode) l.push(async function (e, t, n, r, s, o) {
        const a = e.target.clone(),
              l = new i.Pa4(),
              c = new i.Pa4(),
              u = Gc(e.cameraObject, a),
              p = Gc(t, t.target),
              h = new i.$V();
        return Vc({
          from: 0,
          to: 1,
          duration: n,
          ease: r,
          driver: s,
          onUpdate: n => {
            h.phi = Hc(u.phi, p.phi, n), h.theta = Hc(u.theta, p.theta, n), h.radius = ee(u.radius, p.radius, n), l.copy(a).lerp(t.target, n), c.setFromSpherical(h), c.add(l), e.position = c, e.target = l, e.positionUpdated(!1), e.targetUpdated();
          },
          onComplete: () => {
            e.position = t.position, e.target = t.target, e.positionUpdated(!1), e.targetUpdated();
          }
        }, o);
      }(s, e, t, o, a, c));else if ("linear" === this.interpolateMode) {
        l.push(Vc({
          from: s.position.clone(),
          to: e.position.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => s.position = e,
          onComplete: () => s.position = e.position
        }, c)), l.push(Vc({
          from: s.target.clone(),
          to: e.target.clone(),
          duration: t,
          ease: o,
          driver: a,
          onUpdate: e => {
            s.target = e, s.targetUpdated();
          },
          onComplete: () => {
            s.target = e.target, s.targetUpdated();
          }
        }, c));
        const n = s.cameraObject.quaternion.clone(),
              r = new i._fP();
        l.push(Vc({
          from: 0,
          to: 1,
          duration: t,
          ease: o,
          driver: a,
          onUpdate: t => {
            r.copy(n).slerp(e.quaternion, t), s.cameraObject.quaternion.copy(r), s.cameraObject.updateProjectionMatrix();
          },
          onComplete: () => {
            s.cameraObject.quaternion.copy(e.quaternion), s.cameraObject.updateProjectionMatrix();
          }
        }, c));
      }
      await Promise.all(l), this._animating = !1, this.dispatchEvent({
        type: "viewChange",
        view: e
      }), await _c(10);
    }

    fromJSON(e, t) {
      var n, r;
      return super.fromJSON(e, t) ? (this._cameraViews.forEach(e => e.focusView = async () => this.focusView(e)), this._cameraViews.forEach(e => e.deleteView = () => this.deleteView(e)), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n), this) : null;
    }

  }

  async function Vc(e, t) {
    const n = e.onComplete,
          r = e.onStop;
    return e = { ...e
    }, new Promise((i, s) => {
      e.onComplete = () => {
        null == n || n(), i();
      }, e.onStop = () => {
        null == r || r(), i();
      };
      const o = dc(e);
      t.push(o);
    });
  }

  function Gc(e, t) {
    const n = e.position.clone();
    n.sub(t);
    const r = new i.$V().setFromVector3(n);
    return r.makeSafe(), r;
  }

  function Hc(e, t, n) {
    const r = t - e;
    return r >= Math.PI ? e + (r - 2 * Math.PI) * n : r <= -Math.PI ? e + (r + 2 * Math.PI) * n : e + r * n;
  }

  function Wc(e, t, n) {
    const r = (1 - n) * Math.cos(e) + n * Math.cos(t),
          i = (1 - n) * Math.sin(e) + n * Math.sin(t);
    return Math.atan2(i, r);
  }

  zc.PluginType = "CameraViews", Uc([xe("cameraViews")], zc.prototype, "_cameraViews", void 0), Uc([C(zc.prototype._animationLoop), xe(), Ve("Loop All Views", {
    limitedUi: !0
  })], zc.prototype, "viewLooping", void 0), Uc([xe(), qe("View Pause Time")], zc.prototype, "viewPauseTime", void 0), Uc([xe(), Ke("Ease", Object.keys(fc).map(e => ({
    label: e
  })))], zc.prototype, "animEase", void 0), Uc([xe(), He("Duration", [10, 1e4], 10, {
    limitedUi: !0
  })], zc.prototype, "animDuration", void 0), Uc([xe(), He("RotationOffset", [.2, .75], .01)], zc.prototype, "rotationOffset", void 0), Uc([xe(), Ke("Interpolation", ["spherical", "linear"].map(e => ({
    label: e
  })))], zc.prototype, "interpolateMode", void 0), Uc([Ve(), xe()], zc.prototype, "seekOnScroll", void 0), Uc([Xe("Animate All Views", {
    limitedUi: !0
  })], zc.prototype, "animateAllViews", null), Uc([Xe("Record All Views")], zc.prototype, "recordAllViews", null), Uc([Xe("Add Current View")], zc.prototype, "addCurrentView", null), Uc([Xe("Focus Next")], zc.prototype, "focusNext", void 0), Uc([Xe("Focus Previous")], zc.prototype, "focusPrevious", void 0);
  const Kc = new i.Pa4();

  function Xc(e, t, n) {
    let r = e.dot(t);
    r = Math.min(Math.max(r, -1), 1);
    const i = Math.acos(r) * n;
    return Kc.copy(e).multiplyScalar(r).sub(t).negate().normalize(), e.multiplyScalar(Math.cos(i)).add(Kc.multiplyScalar(Math.sin(i)));
  }

  var qc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Yc extends Is {
    constructor(e, t, n, r) {
      super(e, t), this._shadowParams = {
        enabled: !0,
        radius: 2,
        width: 1024,
        height: 1024,
        bias: -.001,
        normalBias: 0,
        near: 1.5,
        far: 4,
        frustumSize: 4
      }, this._randomParams = {
        focus: 1,
        spread: .01,
        distanceScale: 50,
        minDistanceScale: new i.Pa4(10, 10, 10),
        normalDirection: new i.Pa4(.01, .98, .01).normalize(),
        direction: new i.Pa4(-.9, .5, -1)
      }, this.isRandomizedDirectionalLight = !0, this.shadowParams = null != n ? n : {}, this.randomParams = null != r ? r : {}, this.updateShadowParams = this.updateShadowParams.bind(this);
    }

    get shadowParams() {
      return this._shadowParams;
    }

    set shadowParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), this._shadowParams = { ...this._shadowParams,
        ...e
      }, this.updateShadowParams();
    }

    get randomParams() {
      return this._randomParams;
    }

    set randomParams(e) {
      Object.keys(e).forEach(t => void 0 === e[t] && delete e[t]), Object.assign(this._randomParams, e);
    }

    updateShadowParams() {
      this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = !0;
    }

    randomizePosition(e = null, t = null) {
      const n = new i.FM8(Math.random() * Math.PI * 2, Math.asin(2 * Math.random() - 1));
      let r = new i.Pa4(Math.cos(n.x) * Math.cos(n.y), Math.sin(n.y), Math.sin(n.x) * Math.cos(n.y));

      for (let n = 0; n < 5; n++) {
        r = Zc(this._randomParams.normalDirection, .4), Math.random() < Math.sqrt(null != e ? e : this._randomParams.focus) && (r = Zc(this._randomParams.direction, Math.pow((null != t ? t : this._randomParams.spread) / 2, 2)));
        const n = r.dot(this._randomParams.normalDirection);
        if (n > 0 && n < .4) break;
      }

      r.normalize(), r.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(r.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld();
    }

    refreshShadowCamNearFar() {
      const e = new i.Pa4().subVectors(this.target.position, this.shadow.camera.position).length();
      this.shadow.camera.near = e - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e + this._shadowParams.far * this._shadowParams.frustumSize / 2;
    }

    dispose() {}

    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
    }

    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.updateShadowParams(), this) : null;
    }

  }

  function Zc(e, t) {
    e = e.clone().normalize();
    const n = new i.Pa4(0, -e.z, e.y).normalize(),
          r = new i.Pa4().crossVectors(e, n).normalize(),
          s = new i.FM8().random();
    s.x = 2 * s.x * Math.PI, s.y = 1 - s.y * t;
    const o = Math.sqrt(1 - s.y * s.y);
    return n.multiplyScalar(Math.cos(s.x) * o).add(r.multiplyScalar(Math.sin(s.x) * o)).add(e.multiplyScalar(s.y));
  }

  qc([xe("shadowParams")], Yc.prototype, "_shadowParams", void 0), qc([xe("randomParams")], Yc.prototype, "_randomParams", void 0);

  var Jc = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class $c extends Gs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.light = new Yc("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
        var e, t, n;
        this.enabled ? ((null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) && void 0 !== t ? t : 0) > 3 && this.light.randomizePosition(), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (n = this._cameraHelper) || void 0 === n || n.update()) : this.light.layers.mask = 0;
      }, this._setDirty = this._setDirty.bind(this), this.enabled = e;
    }

    get cameraHelper() {
      return this._cameraHelper;
    }

    async onAdded(e) {
      await super.onAdded(e), this._cameraHelper = new i.Rki(this.light.shadow.camera), this._cameraHelper.visible = !1, this._cameraHelper.userData.bboxVisible = !1, e.scene.add(this._cameraHelper), e.scene.addLight(this.light, {
        addToRoot: !0
      }), e.addEventListener("preRender", this._preRender);
    }

    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e);
    }

    _setDirty(e = !1) {
      var t, n;
      e ? null === (t = this._viewer) || void 0 === t || t.scene.setDirty() : null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Progressive Shadow",
        children: [{
          type: "checkbox",
          label: "Enabled",
          property: [this, "enabled"],
          onChange: this._setDirty
        }, {
          type: "folder",
          label: "Directional Light",
          children: [{
            type: "checkbox",
            label: "Visible",
            property: [this.light, "visible"],
            onChange: this._setDirty
          }, {
            type: "slider",
            label: "Intensity",
            bounds: [0, 10],
            property: [this.light, "intensity"],
            onChange: this._setDirty
          }, {
            type: "checkbox",
            label: "Shadow Enabled",
            property: [this.light.shadowParams, "enabled"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "focus"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [0, 1],
            property: [this.light.randomParams, "spread"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 60],
            property: [this.light.randomParams, "distanceScale"],
            onChange: this._setDirty
          }, {
            type: "vec3",
            bounds: [-5, 5],
            property: [this.light.randomParams, "direction"],
            onChange: this._setDirty
          }, {
            type: "slider",
            bounds: [.01, 10],
            property: [this.light.shadowParams, "radius"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [.01, 30],
            property: [this.light.shadowParams, "frustumSize"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }, {
            type: "slider",
            bounds: [-.01, .01],
            property: [this.light.shadowParams, "bias"],
            onChange: [this.light.updateShadowParams, this._setDirty]
          }]
        }]
      };
    }

  }

  $c.PluginType = "RandomizedDirectionalLight", Jc([xe()], $c.prototype, "enabled", void 0), Jc([xe("rdLight")], $c.prototype, "light", void 0), Jc([xe()], $c.prototype, "lightLayers", void 0);

  var Qc,
      eu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let tu = Qc = class extends Gs {
    constructor(e = !1) {
      super(), this.enabled = !1, this.worldRadius = 100, this.tripodHeight = 10, this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e;
    }

    _paramsChanged() {
      var e, t, n, r, s, o, a, l, c, u, p;
      const h = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0);
      if (this.enabled && h && h !== io) if (h.isDataTexture) h.mapping = i.dSO;else if (confirm("Background must be same as environment, do you want to change it?")) {
        const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SimpleBackgroundEnvUiPlugin1");
        e ? (e.envmapBg = !0, null === (r = (n = e.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0)) : null === (s = this._viewer) || void 0 === s || s.setBackground(io);
      } else this.enabled = !1;
      const d = null === (c = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.renderer) || void 0 === a ? void 0 : a.rendererObject) || void 0 === l ? void 0 : l.background.getBoxMesh2()) || void 0 === c ? void 0 : c.material,
            f = null !== (u = null == d ? void 0 : d.uniforms) && void 0 !== u ? u : i.Vj0.cube.uniforms;
      f.tripodHeight || (f.tripodHeight = {
        value: 1
      }), f.worldRadius || (f.worldRadius = {
        value: 1
      }), f.tripodHeight.value = this.tripodHeight, f.worldRadius.value = this.worldRadius, d && (!this.enabled && d.defines.HDRi_GROUND_PROJ ? delete d.defines.HDRi_GROUND_PROJ : this.enabled && (d.defines.HDRi_GROUND_PROJ = "1"), d.needsUpdate = !0), null === (p = this._viewer) || void 0 === p || p.setDirty();
    }

    async onAdded(e) {
      var t, n, r;
      await super.onAdded(e), (null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer) || void 0 === n ? void 0 : n.rendererObject) || void 0 === r ? void 0 : r.background.getBoxMesh()) && console.error("HDRi Ground Plugin must be added before setting any cube or env map"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("void main() {", "\n#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF 1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,vec3(0.,0.,0.),worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n\nvoid main() {"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n"), e.scene.addEventListener("environmentChanged", this._paramsChanged);
    }

  };
  tu.PluginType = "HDRiGroundPlugin", eu([xe(), C(Qc.prototype._paramsChanged), Ve("Enabled")], tu.prototype, "enabled", void 0), eu([xe(), C(Qc.prototype._paramsChanged), He("World Radius", [1, 1e3])], tu.prototype, "worldRadius", void 0), eu([xe(), C(Qc.prototype._paramsChanged), He("Tripod height", [0, 50])], tu.prototype, "tripodHeight", void 0), tu = Qc = eu([Qe("HDRi Ground")], tu);

  var nu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let ru = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
        thinBaseLayerFactors: {
          value: new i.Ltg()
        },
        thinNoiseLayerFactors: {
          value: new i.Ltg()
        },
        thinColorNoiseParams: {
          value: new i.Ltg()
        },
        thinFilmFactor: {
          value: .8
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? vo + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER\nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS\nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !(null === (r = t.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._thinFilmLayer;
          if (!(null == r ? void 0 : r.hasThinFilm)) return;
          this._uniforms.thinBaseLayerFactors.value.fromArray(r.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(r.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(r.colorNoiseParams), this._uniforms.thinFilmFactor.value = r.filmFactor;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i && (t.materialObject.defines.THIN_FILM_LAYER_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "ThinFilmLayer",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm) && (n ? iu(e.materialObject) || alert("Cannot add thin film.") : (e.materialObject.userData._thinFilmLayer.hasThinFilm = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "slider",
              bounds: [0, 1],
              label: "Intensity",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "filmFactor"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Base Layer",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "baseLayerFactors"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Noise Layer",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "noiseLayerFactors"],
              onChange: this.setDirty
            }), () => ({
              type: "vec4",
              label: "Noise Params",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm);
              },
              property: [e.materialObject.userData._thinFilmLayer, "colorNoiseParams"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addThinFilmLayer(e) {
      return iu(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new su(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(Vs);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(ou);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function iu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._thinFilmLayer || (t._thinFilmLayer = {});
    const n = t._thinFilmLayer;
    return n.hasThinFilm = !0, void 0 === n.baseLayerFactors && (n.baseLayerFactors = [.3, .6, 1, .9]), void 0 === n.noiseLayerFactors && (n.noiseLayerFactors = [.7, .5, .9, .7]), void 0 === n.colorNoiseParams && (n.colorNoiseParams = [.5, .5, .5, .7]), void 0 === n.filmFactor && (n.filmFactor = .3), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  ru.PluginType = "ThinFilmLayerPlugin", ru.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", nu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], ru.prototype, "enabled", void 0), ru = nu([Qe("ThinFilmLayer Materials")], ru);

  class su {
    constructor(e) {
      this.parser = e, this.name = ru.THIN_FILM_LAYER_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), iu(t), t.userData._thinFilmLayer = Te(r, t.userData._thinFilmLayer, !1, {}), Promise.resolve();
    }

  }

  const ou = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._thinFilmLayer) return;
      if (!t.userData._thinFilmLayer.hasThinFilm) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._thinFilmLayer, !1);
      n.extensions[ru.THIN_FILM_LAYER_GLTF_EXTENSION] = r, e.extensionsUsed[ru.THIN_FILM_LAYER_GLTF_EXTENSION] = !0;
    }
  });

  var au = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let lu = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
        ccTintColor: {
          value: new ve()
        },
        ccThickness: {
          value: 0
        },
        ccIor: {
          value: 0
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) && t.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!(this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && t.materialObject.clearcoat > 0)) return;
          const i = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
                s = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
          e.fragmentShader.includes(s) && e.fragmentShader.includes(i) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e.fragmentShader = e.fragmentShader.replace(s, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e.fragmentShader = e.fragmentShader.replace(i, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i), e.vertexUvs = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._clearcoatTint;
          if (!(null == r ? void 0 : r.enableTint)) return;
          this._uniforms.ccTintColor.value.set(r.tintColor), this._uniforms.ccThickness.value = r.thickness, this._uniforms.ccIor.value = r.ior;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i && (t.materialObject.defines.CLEARCOAT_TINT_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) ? "1" : "0") + (e.materialObject.clearcoat > 0 ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "ClearcoatTint",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && (n ? cu(e.materialObject) || alert("Cannot add clearcoat tint.") : (e.materialObject.userData._clearcoatTint.enableTint = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "color",
              label: "Tint color",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "tintColor"],
              onChange: this.setDirty
            }), () => ({
              type: "input",
              label: "Thickness",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "thickness"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              bounds: [.8, 2.5],
              label: "IOR",
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint);
              },
              property: [e.materialObject.userData._clearcoatTint, "ior"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addClearcoatTint(e) {
      return cu(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new uu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(Vs);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(pu);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function cu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._clearcoatTint || (t._clearcoatTint = {});
    const n = t._clearcoatTint;
    return n.enableTint = !0, void 0 === n.tintColor && (n.tintColor = 16777215), void 0 === n.thickness && (n.thickness = .1), void 0 === n.ior && (n.ior = 1.5), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  lu.PluginType = "ClearcoatTintPlugin", lu.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", au([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], lu.prototype, "enabled", void 0), lu = au([Qe("ClearcoatTint Materials")], lu);

  class uu {
    constructor(e) {
      this.parser = e, this.name = lu.CLEARCOAT_TINT_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), cu(t), t.userData._clearcoatTint = Te(r, t.userData._clearcoatTint, !1, {}), Promise.resolve();
    }

  }

  const pu = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._clearcoatTint) return;
      if (!t.userData._clearcoatTint.enableTint) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._clearcoatTint, !1);
      n.extensions[lu.CLEARCOAT_TINT_GLTF_EXTENSION] = r, e.extensionsUsed[lu.CLEARCOAT_TINT_GLTF_EXTENSION] = !0;
    }
  });

  var hu = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}",
      du = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const fu = {
    uniforms: {
      colorTexture: {
        value: null
      },
      tNormalDepth: {
        value: null
      },
      blurTexture: {
        value: null
      },
      cocTexture: {
        value: null
      },
      cocTextureSize: {
        value: new i.FM8()
      },
      cameraNearFar: {
        value: new i.FM8()
      }
    },
    vertexShader: _o,
    fragmentShader: jt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}"
  },
        _u = (It({
    uniforms: {
      cocTexture: {
        value: null
      },
      colorTexture: {
        value: null
      },
      colorTextureSize: {
        value: new i.FM8()
      },
      direction: {
        value: new i.FM8()
      }
    },
    vertexShader: _o,
    fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}"
  }, "colorTexture", "cocTexture"), It({
    uniforms: {
      colorTexture: {
        value: null
      },
      colorTextureSize: {
        value: new i.FM8()
      },
      direction: {
        value: new i.FM8()
      },
      frameCount: {
        value: 0
      },
      blurRadius: {
        value: 16
      }
    },
    vertexShader: _o,
    fragmentShader: vo + "\n" + hu + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(saturate(colorSum),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}",
    defines: {
      DOF_MODE: 1
    }
  }, "colorTexture"));

  class mu extends Ft {
    constructor() {
      super(fu, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = _u, this.nearFarBlurScale = new i.FM8(.25, .25), this.focalDepthRange = new i.FM8(.5, 1.5), this.crossCenter = new i.FM8(.5, .5), this.crossRadius = .04, this.crossAlpha = 1, this.crossColor = new ve(16750848), this.uiConfig = {
        type: "folder",
        label: "Depth of Field",
        children: [{
          type: "checkbox",
          label: "Enabled",
          limitedUi: !0,
          property: [this, "enabled"]
        }, {
          type: "slider",
          label: "Depth Range",
          bounds: [.5, 3],
          property: [this.focalDepthRange, "y"]
        }, {
          type: "slider",
          label: "Near Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "x"]
        }, {
          type: "slider",
          label: "Far Blur scale",
          bounds: [0, 1],
          property: [this.nearFarBlurScale, "y"]
        }]
      }, this.material.extensions.derivatives = !0, this.computeCocMaterial = It({
        uniforms: {
          colorTexture: {
            value: null
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          cameraNearFar: this.uniforms.cameraNearFar,
          nearFarBlurScale: this.uniforms.nearFarBlurScale,
          focalDepthRange: this.uniforms.focalDepthRange
        },
        vertexShader: _o,
        fragmentShader: jt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture"), this.expandCocMaterial = It({
        uniforms: {
          colorTexture: {
            value: null
          },
          colorTextureSize: {
            value: new i.FM8()
          },
          direction: {
            value: new i.FM8()
          },
          tNormalDepth: this.uniforms.tNormalDepth,
          nearFarBlurScale: this.uniforms.nearFarBlurScale
        },
        vertexShader: _o,
        fragmentShader: jt + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}"
      }, "colorTexture");
    }

    render(e, t, n, r, s) {
      if (!this.enabled) return;
      const o = e.baseRenderer,
            a = {
        minFilter: i.TyD,
        magFilter: i.TyD,
        type: i.cLu,
        encoding: i.rnI,
        sizeMultiplier: .5,
        isAntialiased: !1,
        format: i.wk1,
        depthBuffer: !1,
        generateMipmaps: !1
      },
            l = o.getTempTarget(a),
            c = o.getTempTarget(a);
      if (this.computeCocMaterial.uniforms.colorTexture.value = n.texture, o.blit(void 0, l, {
        material: this.computeCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = l.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, c, {
        material: this.expandCocMaterial
      }), this.expandCocMaterial.uniforms.colorTexture.value = c.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, l, {
        material: this.expandCocMaterial
      }), this.dofBlurMaterial.uniforms.frameCount) this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, o.blit(void 0, c, {
        material: this.dofBlurMaterial
      });else {
        const e = o.getTempTarget(a);
        this.dofBlurMaterial.uniforms.cocTexture.value = l.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, e, {
          material: this.dofBlurMaterial
        }), this.dofBlurMaterial.uniforms.colorTexture.value = e.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, c, {
          material: this.dofBlurMaterial
        }), o.releaseTempTarget(e);
      }
      this.material.uniforms.blurTexture.value = c.texture, this.material.uniforms.cocTexture.value = l.texture, super.render(e, t, n, r, s), o.releaseTempTarget(l), o.releaseTempTarget(c);
    }

  }

  du([xe(), V()], mu.prototype, "nearFarBlurScale", void 0), du([xe(), V()], mu.prototype, "focalDepthRange", void 0), du([V()], mu.prototype, "crossCenter", void 0), du([V()], mu.prototype, "crossRadius", void 0), du([V()], mu.prototype, "crossAlpha", void 0), du([V()], mu.prototype, "crossColor", void 0);

  var gu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class vu extends Ws {
    constructor(e = !0, t = !1) {
      super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [Ys], this.enableEdit = !1, this._focalPointHit = new i.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new i.Pa4(), this.enabled = e, this.enableEdit = t, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this);
    }

    passCtor(e) {
      return new mu();
    }

    get _frameFadeTime() {
      return 2.5 * this.crossFadeTime;
    }

    _onObjectHit(e) {
      var t, n;
      this._pass && e.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e.intersects.intersect.point), this._focalPointHitTime = e.time, e.intersects.selectedObject = null, null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Ea)) || void 0 === n || n.startTransition(this._frameFadeTime), this.setDirty());
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), e.getPluginByType("Picking") || console.warn("DepthOfFieldPlugin requires PickingPlugin for editing."), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("hitObject", this._onObjectHit);
    }

    async onRemove(e) {
      var t;
      return null === (t = e.getPluginByType("Picking")) || void 0 === t || t.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    _update(e) {
      var t, n;
      if (!super._update(e)) return !1;
      const r = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
      if (!r) return !1;
      const s = e.getPlugin(Ys);
      null == s || s.updateShaderProperties(r.material), r.dofBlurMaterial.uniforms.frameCount && (null === (n = e.renderer) || void 0 === n || n.updateShaderProperties(r.dofBlurMaterial));
      const o = e.scene.activeCamera;
      if (!o) return !1;
      o.cameraObject.updateMatrixWorld(!0), o.updateShaderProperties(r.material), this._tempVec.subVectors(this._focalPointHit, o.cameraObject.position), r.focalDepthRange.x = this._tempVec.length(), r.focalDepthRange.x *= o.cameraObject.getWorldDirection(new i.Pa4()).dot(this._tempVec.normalize());
      let a = (Ct() - this._focalPointHitTime) / this.crossFadeTime;

      if (a = 1 - Math.min(1, Math.max(0, a)), Math.abs(a - r.crossAlpha) > .01 && (r.crossAlpha = a, this.setDirty()), a > 0) {
        const e = this._tempVec.copy(this._focalPointHit).project(o.cameraObject).addScalar(1).divideScalar(2);

        r.crossCenter.set(e.x, e.y), r.computeCocMaterial.uniformsNeedUpdate = !0, r.expandCocMaterial.uniformsNeedUpdate = !0;
      }

      return !0;
    }

    get uiConfig() {
      var e, t, n, r, i;
      if (this._uiConfig) return this._uiConfig;
      const s = null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
      return s ? (null === (r = null === (n = s.children) || void 0 === n ? void 0 : n.map(e => x(e))) || void 0 === r || r.flat(2).forEach(e => e && (e.onChange = this.setDirty)), null === (i = s.children) || void 0 === i || i.push({
        type: "checkbox",
        label: "Enable Edit",
        limitedUi: !0,
        property: [this, "enableEdit"]
      }), this._uiConfig = s, s) : {};
    }

  }

  vu.PluginType = "DepthOfField", gu([xe()], vu.prototype, "enableEdit", void 0), gu([xe("focalPoint")], vu.prototype, "_focalPointHit", void 0), gu([xe()], vu.prototype, "crossFadeTime", void 0);

  var bu = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let xu = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
        noiseBumpParams: {
          value: new i.FM8()
        },
        noiseBumpScale: {
          value: .05
        },
        noiseBumpFlakeScale: {
          value: 1e3
        },
        noiseFlakeClamp: {
          value: 1
        },
        noiseFlakeRadius: {
          value: .5
        },
        noiseFlakeRoughnessMod: {
          value: 1
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => {
          var n;
          return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? vo + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER\nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform float noiseFlakeRoughnessMod;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : "";
        },
        shaderExtender: (e, t, n) => {
          var r;
          if (!this.enabled || !(null === (r = t.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump)) return;
          const i = "#glMarker beforeAccumulation";
          e.fragmentShader = e.fragmentShader.replace(i, "\n            vec3 outColor; \n            float voronoiDist = clamp(voronoi_f1_2d( noiseBumpFlakeScale * noiseBumpParams.xy * vUv, 1., noiseFlakeClamp, noiseFlakeRadius, outColor ), 0.0, 1.0);\n            normal = perturbNormalArb_nb( - vViewPosition, normal, (2. * outColor.xy - 1.) * noiseBumpScale, faceDirection ); \n            float avg = (outColor.r + outColor.g)*0.5; \n            diffuseColor *= (clamp(avg+0.5, 0.3, 1.));\n            float roughnessModifier = mix(1. - avg, 1., noiseFlakeRoughnessMod);\n            roughnessFactor *= roughnessModifier;\n            \n" + i), e.vertexUvs = !0, e.extensionDerivatives = !0;
        },
        onObjectRender: (e, t) => {
          var n;
          const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._noiseBumpMat;
          if (!(null == r ? void 0 : r.hasBump)) return;
          this._uniforms.noiseBumpParams.value.fromArray(r.bumpNoiseParams), this._uniforms.noiseBumpScale.value = r.bumpScale, this._uniforms.noiseBumpFlakeScale.value = r.flakeScale, this._uniforms.noiseFlakeClamp.value = r.flakeClamp, this._uniforms.noiseFlakeRadius.value = r.flakeRadius, this._uniforms.noiseFlakeRoughnessMod.value = r.flakeRoughnessMod;
          const i = this.enabled ? 1 : 0;
          t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i && (t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n;
          return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? "1" : "0");
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = {
            type: "folder",
            label: "NoiseBumpMaterial",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                var t;
                return (null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump) || !1;
              },

              set value(n) {
                var r, i;
                n !== (null === (r = e.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump) && (n ? yu(e.materialObject) || alert("Cannot add noise bump.") : (e.materialObject.userData._noiseBumpMat.hasBump = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0));
              },

              onChange: this.setDirty
            }, () => ({
              type: "vec4",
              label: "Bump Noise Params",
              bounds: [0, 1],
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "bumpNoiseParams"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Bump Scale",
              bounds: [0, .01],
              stepSize: 1e-5,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "bumpScale"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Scale",
              bounds: [100, 1e4],
              stepSize: 1e-4,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeScale"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Clamp",
              bounds: [0, 1],
              stepSize: 1,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeClamp"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Radius",
              bounds: [.1, 1],
              stepSize: .01,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeRadius"],
              onChange: this.setDirty
            }), () => ({
              type: "slider",
              label: "Flake Roughness Modifier",
              bounds: [0, 1],
              stepSize: 1,
              hidden: () => {
                var t;
                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump);
              },
              property: [e.materialObject.userData._noiseBumpMat, "flakeRoughnessMod"],
              onChange: this.setDirty
            })]
          };
          return t;
        }
      }, this.setDirty = () => {
        var e;
        null === (e = this._viewer) || void 0 === e || e.setDirty();
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    addNoiseBumpMaterial(e) {
      return yu(e.materialObject);
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new wu(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(Vs);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Su);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };

  function yu(e) {
    const t = null == e ? void 0 : e.userData;
    if (!t) return !1;
    t._noiseBumpMat || (t._noiseBumpMat = {});
    const n = t._noiseBumpMat;
    return n.hasBump = !0, void 0 === n.bumpNoiseParams && (n.bumpNoiseParams = [.5, .5]), void 0 === n.bumpScale && (n.bumpScale = .05), void 0 === n.flakeScale && (n.flakeScale = .05), void 0 === n.flakeClamp && (n.flakeClamp = 1), void 0 === n.flakeRadius && (n.flakeRadius = .3), void 0 === n.flakeRoughnessMod && (n.flakeRoughnessMod = 1), e.isMaterial && (e.needsUpdate = !0), !0;
  }

  xu.PluginType = "NoiseBumpMaterialPlugin", xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", bu([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], xu.prototype, "enabled", void 0), xu = bu([Qe("NoiseBumpMaterial Materials")], xu);

  class wu {
    constructor(e) {
      this.parser = e, this.name = xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      const n = this.parser.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = n.extensions[this.name];
      return t.userData || (t.userData = {}), yu(t), t.userData._noiseBumpMat = Te(r, t.userData._noiseBumpMat, !1, {}), Promise.resolve();
    }

  }

  const Su = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._noiseBumpMat) return;
      if (!t.userData._noiseBumpMat.hasBump) return;
      n.extensions = n.extensions || {};
      const r = Me(t.userData._noiseBumpMat, !1);
      n.extensions[xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = r, e.extensionsUsed[xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = !0;
    }
  });

  class Mu {
    constructor(e = 4) {
      this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }

    _initWorker(e) {
      if (!this.workers[e]) {
        const t = this.workerCreator();
        t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
      }
    }

    _getIdleWorker() {
      for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;

      return -1;
    }

    _onMessage(e, t) {
      const n = this.workersResolve[e];

      if (n && n(t), this.queue.length) {
        const {
          resolve: t,
          msg: n,
          transfer: r
        } = this.queue.shift();
        this.workersResolve[e] = t, this.workers[e].postMessage(n, r);
      } else this.workerStatus ^= 1 << e;
    }

    setWorkerCreator(e) {
      this.workerCreator = e;
    }

    setWorkerLimit(e) {
      this.pool = e;
    }

    postMessage(e, t) {
      return new Promise(n => {
        const r = this._getIdleWorker();

        -1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(e, t)) : this.queue.push({
          resolve: n,
          msg: e,
          transfer: t
        });
      });
    }

    dispose() {
      this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }

  }

  const Tu = 0,
        Eu = 1,
        Au = 2,
        Cu = 3,
        Ru = 0,
        ku = 0,
        Pu = 2,
        Du = 0,
        Ou = 1,
        Lu = 160,
        Iu = 161,
        Fu = 162,
        Nu = 163,
        Uu = 0,
        Bu = 1,
        ju = 0,
        zu = 1,
        Vu = 2,
        Gu = 3,
        Hu = 4,
        Wu = 5,
        Ku = 6,
        Xu = 7,
        qu = 8,
        Yu = 9,
        Zu = 10,
        Ju = 11,
        $u = 12,
        Qu = 13,
        ep = 14,
        tp = 15,
        np = 16,
        rp = 17,
        ip = 18,
        sp = 0,
        op = 1,
        ap = 2,
        lp = 3,
        cp = 4,
        up = 5,
        pp = 6,
        hp = 7,
        dp = 8,
        fp = 9,
        _p = 10,
        mp = 11,
        gp = 0,
        vp = 1,
        bp = 2,
        xp = 13,
        yp = 14,
        wp = 15,
        Sp = 128,
        Mp = 64,
        Tp = 32,
        Ep = 16,
        Ap = 0,
        Cp = 1,
        Rp = 2,
        kp = 3,
        Pp = 4,
        Dp = 5,
        Op = 6,
        Lp = 7,
        Ip = 8,
        Fp = 9,
        Np = 10,
        Up = 13,
        Bp = 14,
        jp = 15,
        zp = 16,
        Vp = 17,
        Gp = 20,
        Hp = 21,
        Wp = 22,
        Kp = 23,
        Xp = 24,
        qp = 27,
        Yp = 28,
        Zp = 29,
        Jp = 30,
        $p = 31,
        Qp = 34,
        eh = 35,
        th = 36,
        nh = 37,
        rh = 38,
        ih = 41,
        sh = 42,
        oh = 43,
        ah = 44,
        lh = 45,
        ch = 48,
        uh = 49,
        ph = 50,
        hh = 58,
        dh = 59,
        fh = 62,
        _h = 63,
        mh = 64,
        gh = 65,
        vh = 68,
        bh = 69,
        xh = 70,
        yh = 71,
        wh = 74,
        Sh = 75,
        Mh = 76,
        Th = 77,
        Eh = 78,
        Ah = 81,
        Ch = 82,
        Rh = 83,
        kh = 84,
        Ph = 85,
        Dh = 88,
        Oh = 89,
        Lh = 90,
        Ih = 91,
        Fh = 92,
        Nh = 95,
        Uh = 96,
        Bh = 97,
        jh = 98,
        zh = 99,
        Vh = 100,
        Gh = 101,
        Hh = 102,
        Wh = 103,
        Kh = 104,
        Xh = 105,
        qh = 106,
        Yh = 107,
        Zh = 108,
        Jh = 109,
        $h = 110,
        Qh = 111,
        ed = 112,
        td = 113,
        nd = 114,
        rd = 115,
        id = 116,
        sd = 117,
        od = 118,
        ad = 119,
        ld = 120,
        cd = 121,
        ud = 122,
        pd = 123,
        hd = 124,
        dd = 125,
        fd = 126,
        _d = 127,
        md = 128,
        gd = 129,
        vd = 130,
        bd = 131,
        xd = 132,
        yd = 133,
        wd = 134,
        Sd = 135,
        Md = 136,
        Td = 137,
        Ed = 138,
        Ad = 139,
        Cd = 140,
        Rd = 141,
        kd = 142,
        Pd = 143,
        Dd = 144,
        Od = 145,
        Ld = 146,
        Id = 147,
        Fd = 148,
        Nd = 149,
        Ud = 150,
        Bd = 151,
        jd = 152,
        zd = 153,
        Vd = 154,
        Gd = 155,
        Hd = 156,
        Wd = 157,
        Kd = 158,
        Xd = 159,
        qd = 160,
        Yd = 161,
        Zd = 162,
        Jd = 163,
        $d = 164,
        Qd = 165,
        ef = 166,
        tf = 167,
        nf = 168,
        rf = 169,
        sf = 170,
        of = 171,
        af = 172,
        lf = 173,
        cf = 174,
        uf = 175,
        pf = 176,
        hf = 177,
        df = 178,
        ff = 179,
        _f = 180,
        mf = 181,
        gf = 182,
        vf = 183,
        bf = 184,
        xf = 1000156007,
        yf = 1000156008,
        wf = 1000156009,
        Sf = 1000156010,
        Mf = 1000156011,
        Tf = 1000156017,
        Ef = 1000156018,
        Af = 1000156019,
        Cf = 1000156020,
        Rf = 1000156021,
        kf = 1000054e3,
        Pf = 1000054001,
        Df = 1000054002,
        Of = 1000054003,
        Lf = 1000054004,
        If = 1000054005,
        Ff = 1000054006,
        Nf = 1000054007,
        Uf = 1000066e3,
        Bf = 1000066001,
        jf = 1000066002,
        zf = 1000066003,
        Vf = 1000066004,
        Gf = 1000066005,
        Hf = 1000066006,
        Wf = 1000066007,
        Kf = 1000066008,
        Xf = 1000066009,
        qf = 1000066010,
        Yf = 1000066011,
        Zf = 1000066012,
        Jf = 1000066013,
        $f = 100034e4,
        Qf = 1000340001;

  class e_ {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }

  }

  class t_ {
    constructor(e, t, n, r) {
      this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0;
    }

    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);

      return this._offset += 1, e;
    }

    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);

      return this._offset += 2, e;
    }

    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);

      return this._offset += 8, e;
    }

    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _skip(e) {
      return this._offset += e, this;
    }

    _scan(e, t = 0) {
      const n = this._offset;
      let r = 0;

      for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;

      return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r);
    }

  }

  const n_ = new Uint8Array([0]),
        r_ = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

  function i_(e) {
    return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
  }

  function s_(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }

  function o_(e) {
    let t = 0;

    for (const n of e) t += n.byteLength;

    const n = new Uint8Array(t);
    let r = 0;

    for (const t of e) n.set(new Uint8Array(t), r), r += t.byteLength;

    return n;
  }

  function a_(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, r_.length);
    if (t[0] !== r_[0] || t[1] !== r_[1] || t[2] !== r_[2] || t[3] !== r_[3] || t[4] !== r_[4] || t[5] !== r_[5] || t[6] !== r_[6] || t[7] !== r_[7] || t[8] !== r_[8] || t[9] !== r_[9] || t[10] !== r_[10] || t[11] !== r_[11]) throw new Error("Missing KTX 2.0 identifier.");
    const n = new e_(),
          r = 17 * Uint32Array.BYTES_PER_ELEMENT,
          i = new t_(e, r_.length, r, !0);
    n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();

    const s = i._nextUint32();

    n.supercompressionScheme = i._nextUint32();

    const o = i._nextUint32(),
          a = i._nextUint32(),
          l = i._nextUint32(),
          c = i._nextUint32(),
          u = i._nextUint64(),
          p = i._nextUint64(),
          h = new t_(e, r_.length + r, 3 * s * 8, !0);

    for (let t = 0; t < s; t++) n.levels.push({
      levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
      uncompressedByteLength: h._nextUint64()
    });

    const d = new t_(e, o, a, !0),
          f = {
      vendorId: d._skip(4)._nextUint16(),
      descriptorType: d._nextUint16(),
      versionNumber: d._nextUint16(),
      descriptorBlockSize: d._nextUint16(),
      colorModel: d._nextUint8(),
      colorPrimaries: d._nextUint8(),
      transferFunction: d._nextUint8(),
      flags: d._nextUint8(),
      texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      samples: []
    },
          _ = (f.descriptorBlockSize / 4 - 6) / 4;

    for (let e = 0; e < _; e++) {
      const t = {
        bitOffset: d._nextUint16(),
        bitLength: d._nextUint8(),
        channelType: d._nextUint8(),
        samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        sampleLower: -1 / 0,
        sampleUpper: 1 / 0
      };
      64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
    }

    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
    const m = new t_(e, l, c, !0);

    for (; m._offset < c;) {
      const e = m._nextUint32(),
            t = m._scan(e),
            r = s_(t),
            i = m._scan(e - t.byteLength);

      n.keyValue[r] = r.match(/^ktx/i) ? s_(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4);
    }

    if (p <= 0) return n;

    const g = new t_(e, u, p, !0),
          v = g._nextUint16(),
          b = g._nextUint16(),
          x = g._nextUint32(),
          y = g._nextUint32(),
          w = g._nextUint32(),
          S = g._nextUint32(),
          M = [];

    for (let e = 0; e < s; e++) M.push({
      imageFlags: g._nextUint32(),
      rgbSliceByteOffset: g._nextUint32(),
      rgbSliceByteLength: g._nextUint32(),
      alphaSliceByteOffset: g._nextUint32(),
      alphaSliceByteLength: g._nextUint32()
    });

    const T = u + g._offset,
          E = T + x,
          A = E + y,
          C = A + w,
          R = new Uint8Array(e.buffer, e.byteOffset + T, x),
          k = new Uint8Array(e.buffer, e.byteOffset + E, y),
          P = new Uint8Array(e.buffer, e.byteOffset + A, w),
          D = new Uint8Array(e.buffer, e.byteOffset + C, S);
    return n.globalData = {
      endpointCount: v,
      selectorCount: b,
      imageDescs: M,
      endpointsData: R,
      selectorsData: k,
      tablesData: P,
      extendedData: D
    }, n;
  }

  function l_() {
    return (l_ = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  const c_ = {
    keepWriter: !1
  };

  function u_(e, t = {}) {
    t = l_({}, c_, t);
    let n = new ArrayBuffer(0);

    if (e.globalData) {
      const t = new ArrayBuffer(20 + 5 * e.globalData.imageDescs.length * 4),
            r = new DataView(t);
      r.setUint16(0, e.globalData.endpointCount, !0), r.setUint16(2, e.globalData.selectorCount, !0), r.setUint32(4, e.globalData.endpointsData.byteLength, !0), r.setUint32(8, e.globalData.selectorsData.byteLength, !0), r.setUint32(12, e.globalData.tablesData.byteLength, !0), r.setUint32(16, e.globalData.extendedData.byteLength, !0);

      for (let t = 0; t < e.globalData.imageDescs.length; t++) {
        const n = e.globalData.imageDescs[t];
        r.setUint32(20 + 5 * t * 4 + 0, n.imageFlags, !0), r.setUint32(20 + 5 * t * 4 + 4, n.rgbSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 8, n.rgbSliceByteLength, !0), r.setUint32(20 + 5 * t * 4 + 12, n.alphaSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 16, n.alphaSliceByteLength, !0);
      }

      n = o_([t, e.globalData.endpointsData, e.globalData.selectorsData, e.globalData.tablesData, e.globalData.extendedData]);
    }

    const r = [];
    let i = e.keyValue;
    t.keepWriter || (i = l_({}, e.keyValue, {
      KTXwriter: "KTX-Parse v0.3.1"
    }));

    for (const e in i) {
      const t = i[e],
            n = i_(e),
            s = "string" == typeof t ? i_(t) : t,
            o = n.byteLength + 1 + s.byteLength + 1,
            a = o % 4 ? 4 - o % 4 : 0;
      r.push(o_([new Uint32Array([o]), n, n_, s, n_, new Uint8Array(a).fill(0)]));
    }

    const s = o_(r);
    if (1 !== e.dataFormatDescriptor.length || 0 !== e.dataFormatDescriptor[0].descriptorType) throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
    const o = e.dataFormatDescriptor[0],
          a = new ArrayBuffer(28 + 16 * o.samples.length),
          l = new DataView(a),
          c = 24 + 16 * o.samples.length;
    if (l.setUint32(0, a.byteLength, !0), l.setUint16(4, o.vendorId, !0), l.setUint16(6, o.descriptorType, !0), l.setUint16(8, o.versionNumber, !0), l.setUint16(10, c, !0), l.setUint8(12, o.colorModel), l.setUint8(13, o.colorPrimaries), l.setUint8(14, o.transferFunction), l.setUint8(15, o.flags), !Array.isArray(o.texelBlockDimension)) throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
    l.setUint8(16, o.texelBlockDimension[0]), l.setUint8(17, o.texelBlockDimension[1]), l.setUint8(18, o.texelBlockDimension[2]), l.setUint8(19, o.texelBlockDimension[3]);

    for (let e = 0; e < 8; e++) l.setUint8(20 + e, o.bytesPlane[e]);

    for (let e = 0; e < o.samples.length; e++) {
      const t = o.samples[e],
            n = 28 + 16 * e;
      if (t.channelID) throw new Error("channelID has been renamed to channelType.");
      l.setUint16(n + 0, t.bitOffset, !0), l.setUint8(n + 2, t.bitLength), l.setUint8(n + 3, t.channelType), l.setUint8(n + 4, t.samplePosition[0]), l.setUint8(n + 5, t.samplePosition[1]), l.setUint8(n + 6, t.samplePosition[2]), l.setUint8(n + 7, t.samplePosition[3]), 64 & t.channelType ? (l.setInt32(n + 8, t.sampleLower, !0), l.setInt32(n + 12, t.sampleUpper, !0)) : (l.setUint32(n + 8, t.sampleLower, !0), l.setUint32(n + 12, t.sampleUpper, !0));
    }

    const u = r_.length + 68 + 3 * e.levels.length * 8,
          p = u + a.byteLength;
    let h = n.byteLength > 0 ? p + s.byteLength : 0;
    h % 8 && (h += 8 - h % 8);
    const d = [],
          f = new DataView(new ArrayBuffer(3 * e.levels.length * 8));

    let _ = (h || p + s.byteLength) + n.byteLength;

    for (let t = 0; t < e.levels.length; t++) {
      const n = e.levels[t];
      d.push(n.levelData), f.setBigUint64(24 * t + 0, BigInt(_), !0), f.setBigUint64(24 * t + 8, BigInt(n.levelData.byteLength), !0), f.setBigUint64(24 * t + 16, BigInt(n.uncompressedByteLength), !0), _ += n.levelData.byteLength;
    }

    const m = new ArrayBuffer(68),
          g = new DataView(m);
    return g.setUint32(0, e.vkFormat, !0), g.setUint32(4, e.typeSize, !0), g.setUint32(8, e.pixelWidth, !0), g.setUint32(12, e.pixelHeight, !0), g.setUint32(16, e.pixelDepth, !0), g.setUint32(20, e.layerCount, !0), g.setUint32(24, e.faceCount, !0), g.setUint32(28, e.levels.length, !0), g.setUint32(32, e.supercompressionScheme, !0), g.setUint32(36, u, !0), g.setUint32(40, a.byteLength, !0), g.setUint32(44, p, !0), g.setUint32(48, s.byteLength, !0), g.setBigUint64(52, BigInt(n.byteLength > 0 ? h : 0), !0), g.setBigUint64(60, BigInt(n.byteLength), !0), new Uint8Array(o_([new Uint8Array(r_).buffer, m, f.buffer, a, s, h > 0 ? new ArrayBuffer(h - (p + s.byteLength)) : new ArrayBuffer(0), n, ...d]));
  }

  const {
    read: p_,
    KHR_DF_FLAG_ALPHA_PREMULTIPLIED: h_,
    KHR_DF_TRANSFER_SRGB: d_,
    VK_FORMAT_UNDEFINED: f_,
    VK_FORMAT_R16_SFLOAT: __,
    VK_FORMAT_R16G16_SFLOAT: m_,
    VK_FORMAT_R16G16B16A16_SFLOAT: g_,
    VK_FORMAT_R32_SFLOAT: v_,
    VK_FORMAT_R32G32_SFLOAT: b_,
    VK_FORMAT_R32G32B32A32_SFLOAT: x_,
    VK_FORMAT_R8_SRGB: y_,
    VK_FORMAT_R8_UNORM: w_,
    VK_FORMAT_R8G8_SRGB: S_,
    VK_FORMAT_R8G8_UNORM: M_,
    VK_FORMAT_R8G8B8A8_SRGB: T_,
    VK_FORMAT_R8G8B8A8_UNORM: E_
  } = e,
        A_ = new WeakMap();
  let C_ = 0;

  class R_ extends i.aNw {
    constructor(e) {
      super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Mu(), this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }

    setTranscoderPath(e) {
      return this.transcoderPath = e, this;
    }

    setWorkerLimit(e) {
      return this.workerPool.setWorkerLimit(e), this;
    }

    detectSupport(e) {
      return this.workerConfig = {
        astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this;
    }

    init() {
      if (!this.transcoderPending) {
        const e = new i.hH6(this.manager);
        e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
        const t = e.loadAsync("basis_transcoder.js"),
              n = new i.hH6(this.manager);
        n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
        const r = n.loadAsync("basis_transcoder.wasm");
        this.transcoderPending = Promise.all([t, r]).then(([e, t]) => {
          const n = R_.BasisWorker.toString(),
                r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(R_.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(R_.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(R_.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r])), this.transcoderBinary = t, this.workerPool.setWorkerCreator(() => {
            const e = new Worker(this.workerSourceURL),
                  t = this.transcoderBinary.slice(0);
            return e.postMessage({
              type: "init",
              config: this.workerConfig,
              transcoderBinary: t
            }, [t]), e;
          });
        }), C_ > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), C_++;
      }

      return this.transcoderPending;
    }

    load(e, t, n, r) {
      if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
      const s = new i.hH6(this.manager);
      s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials), s.load(e, e => {
        if (A_.has(e)) return A_.get(e).promise.then(t).catch(r);
        this.createTexture(e).then(e => t ? t(e) : null).catch(r);
      }, n, r);
    }

    _createTextureFrom(e) {
      const {
        mipmaps: t,
        width: n,
        height: r,
        format: s,
        type: o,
        error: a,
        dfdTransferFn: l,
        dfdFlags: c
      } = e;
      if ("error" === o) return Promise.reject(a);
      const u = new i.EB7(t, n, r, s, i.ywz);
      return u.minFilter = 1 === t.length ? i.wem : i.D1R, u.magFilter = i.wem, u.generateMipmaps = !1, u.needsUpdate = !0, u.encoding = l === d_ ? i.knz : i.rnI, u.premultiplyAlpha = !!(c & h_), u;
    }

    createTexture(e, t = {}) {
      const n = p_(new Uint8Array(e));
      if (n.vkFormat !== f_) return function (e) {
        const {
          vkFormat: t,
          pixelWidth: n,
          pixelHeight: r,
          pixelDepth: s
        } = e;
        if (void 0 === k_[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        let o;
        const a = e.levels[0].levelData;
        o = P_[t] === i.VzW ? new Float32Array(a.buffer, a.byteOffset, a.byteLength / Float32Array.BYTES_PER_ELEMENT) : P_[t] === i.cLu ? new Uint16Array(a.buffer, a.byteOffset, a.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a;
        const l = 0 === s ? new i.IEO(o, n, r) : new i.JUT(o, n, r, s);
        return l.type = P_[t], l.format = k_[t], l.encoding = D_[t] || i.rnI, l.needsUpdate = !0, Promise.resolve(l);
      }(n);
      const r = t,
            s = this.init().then(() => this.workerPool.postMessage({
        type: "transcode",
        buffer: e,
        taskConfig: r
      }, [e])).then(e => this._createTextureFrom(e.data));
      return A_.set(e, {
        promise: s
      }), s;
    }

    dispose() {
      return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), C_--, this;
    }

  }

  R_.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
  }, R_.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
  }, R_.EngineFormat = {
    RGBAFormat: i.wk1,
    RGBA_ASTC_4x4_Format: i.ptH,
    RGBA_BPTC_Format: i.bsb,
    RGBA_ETC2_EAC_Format: i.ekQ,
    RGBA_PVRTC_4BPPV1_Format: i.eaV,
    RGBA_S3TC_DXT5_Format: i.ILR,
    RGB_ETC1_Format: i.fto,
    RGB_ETC2_Format: i.l0P,
    RGB_PVRTC_4BPPV1_Format: i._AM,
    RGB_S3TC_DXT1_Format: i.wuA
  }, R_.BasisWorker = function () {
    let e, t, n;
    const r = _EngineFormat,
          i = _TranscoderFormat,
          s = _BasisFormat;
    self.addEventListener("message", function (o) {
      const u = o.data;

      switch (u.type) {
        case "init":
          e = u.config, p = u.transcoderBinary, t = new Promise(e => {
            n = {
              wasmBinary: p,
              onRuntimeInitialized: e
            }, BASIS(n);
          }).then(() => {
            n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
          break;

        case "transcode":
          t.then(() => {
            try {
              const {
                width: t,
                height: o,
                hasAlpha: p,
                mipmaps: h,
                format: d,
                dfdTransferFn: f,
                dfdFlags: _
              } = function (t) {
                const o = new n.KTX2File(new Uint8Array(t));

                function u() {
                  o.close(), o.delete();
                }

                if (!o.isValid()) throw u(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");

                const p = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                      h = o.getWidth(),
                      d = o.getHeight(),
                      f = o.getLevels(),
                      _ = o.getHasAlpha(),
                      m = o.getDFDTransferFunc(),
                      g = o.getDFDFlags(),
                      {
                  transcoderFormat: v,
                  engineFormat: b
                } = function (t, n, o, u) {
                  let p, h;
                  const d = t === s.ETC1S ? a : l;

                  for (let r = 0; r < d.length; r++) {
                    const i = d[r];
                    if (e[i.if] && i.basisFormat.includes(t) && !(u && i.transcoderFormat.length < 2) && (!i.needsPowerOfTwo || c(n) && c(o))) return p = i.transcoderFormat[u ? 1 : 0], h = i.engineFormat[u ? 1 : 0], {
                      transcoderFormat: p,
                      engineFormat: h
                    };
                  }

                  return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), p = i.RGBA32, h = r.RGBAFormat, {
                    transcoderFormat: p,
                    engineFormat: h
                  };
                }(p, h, d, _);

                if (!h || !d || !f) throw u(), new Error("THREE.KTX2Loader:\tInvalid texture");
                if (!o.startTranscoding()) throw u(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                const x = [];

                for (let e = 0; e < f; e++) {
                  const t = o.getImageLevelInfo(e, 0, 0),
                        n = t.origWidth,
                        r = t.origHeight,
                        i = new Uint8Array(o.getImageTranscodedSizeInBytes(e, 0, 0, v));
                  if (!o.transcodeImage(i, e, 0, 0, v, 0, -1, -1)) throw u(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                  x.push({
                    data: i,
                    width: n,
                    height: r
                  });
                }

                return u(), {
                  width: h,
                  height: d,
                  hasAlpha: _,
                  mipmaps: x,
                  format: b,
                  dfdTransferFn: m,
                  dfdFlags: g
                };
              }(u.buffer),
                    m = [];

              for (let e = 0; e < h.length; ++e) m.push(h[e].data.buffer);

              self.postMessage({
                type: "transcode",
                id: u.id,
                width: t,
                height: o,
                hasAlpha: p,
                mipmaps: h,
                format: d,
                dfdTransferFn: f,
                dfdFlags: _
              }, m);
            } catch (e) {
              console.error(e), self.postMessage({
                type: "error",
                id: u.id,
                error: e.message
              });
            }
          });
      }

      var p;
    });
    const o = [{
      if: "astcSupported",
      basisFormat: [s.UASTC_4x4],
      transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
      engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    }, {
      if: "bptcSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.BC7_M5, i.BC7_M5],
      engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    }, {
      if: "dxtSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.BC1, i.BC3],
      engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    }, {
      if: "etc2Supported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.ETC1, i.ETC2],
      engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    }, {
      if: "etc1Supported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.ETC1],
      engineFormat: [r.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    }, {
      if: "pvrtcSupported",
      basisFormat: [s.ETC1S, s.UASTC_4x4],
      transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
      engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }],
          a = o.sort(function (e, t) {
      return e.priorityETC1S - t.priorityETC1S;
    }),
          l = o.sort(function (e, t) {
      return e.priorityUASTC - t.priorityUASTC;
    });

    function c(e) {
      return e <= 2 || 0 == (e & e - 1) && 0 !== e;
    }
  };
  const k_ = {
    [x_]: i.wk1,
    [g_]: i.wk1,
    [E_]: i.wk1,
    [T_]: i.wk1,
    [b_]: i.av9,
    [m_]: i.av9,
    [M_]: i.av9,
    [S_]: i.av9,
    [v_]: i.hEm,
    [__]: i.hEm,
    [y_]: i.hEm,
    [w_]: i.hEm
  },
        P_ = {
    [x_]: i.VzW,
    [g_]: i.cLu,
    [E_]: i.ywz,
    [T_]: i.ywz,
    [b_]: i.VzW,
    [m_]: i.cLu,
    [M_]: i.ywz,
    [S_]: i.ywz,
    [v_]: i.VzW,
    [__]: i.cLu,
    [y_]: i.ywz,
    [w_]: i.ywz
  },
        D_ = {
    [T_]: i.knz,
    [S_]: i.knz,
    [y_]: i.knz
  },
        O_ = "KHR_texture_basisu";

  class L_ extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs];
    }

    async onAdded(e) {
      var t, n, r, i;
      this._importer || (this._importer = new $t(class extends R_ {
        constructor(t) {
          super(t), this.setTranscoderPath("https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/").detectSupport(e.renderer.rendererObject);
        }

        async createTexture(e, t) {
          const n = e.map(e => new Uint8Array(e.slice(0))),
                r = await super.createTexture(e, t);
          return r.source._sourceImgBuffer = n, r.userData.mimeType = "image/ktx2", r;
        }

      }, ["ktx2"], !1)), Us.Importers.push(this._importer), null === (i = null === (r = null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === r ? void 0 : r.extensions) || void 0 === i || i.push(I_);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  L_.PluginType = "KTX2LoadPlugin";

  const I_ = e => ({
    writeTexture: (t, n) => {
      if (!e.options.embedImages) return;
      if ("image/ktx2" !== t.userData.mimeType) return;
      if (n.source) return void console.warn("source already set");
      const r = t.source._sourceImgBuffer;
      if (!r || !r.length) return void console.warn("no source buffer for ktx2");
      n.extensions = n.extensions || {};
      const i = {},
            s = new Blob(Array.isArray(r) ? r : [r], {
        type: "image/ktx2"
      });
      i.source = e.processImageBlob(s, t), n.extensions[O_] = i, e.extensionsUsed[O_] = !0;
    }
  });

  var F_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let N_ = class extends Nt {
    constructor(e, t, n) {
      super(e, t, null != n ? n : new U_(), new ve(0, 0, 0), 1), this.enabled = !0, this._firstCall = !0;
    }

    render(e, t, n, r, i) {
      if (!this.enabled) return;
      const s = this.overrideMaterial;
      s.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value), this._firstCall = !1), super.render(e, t, n, r, i), s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value);
    }

  };
  F_([Ve("Enabled")], N_.prototype, "enabled", void 0), N_ = F_([Qe("Velocity Buffer (TAA)")], N_);

  class U_ extends i.jyz {
    constructor() {
      super({
        vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
        fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}",
        uniforms: {
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: null
          },
          currentProjectionViewMatrix: {
            value: new i.yGw()
          },
          lastProjectionViewMatrix: {
            value: new i.yGw()
          }
        }
      }), this.extraUniformsToUpload = {
        modelMatrixPrevious: {
          value: new i.yGw().identity()
        }
      }, this._previousWorldMatrices = {};
    }

    onBeforeRender(e, t, n, r, s) {
      var o, a;
      const l = this._previousWorldMatrices[s.uuid];
      this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l ? l : s.matrixWorld), l ? l.copy(s.matrixWorld) : this._previousWorldMatrices[s.uuid] = s.matrixWorld.clone();
      let c = s.material;
      Array.isArray(c) && (c = c[0]), this.uniforms.alphaMap.value = null !== (o = null == c ? void 0 : c.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !c || !c.alphaTest || c.alphaTest < 1e-7 ? .001 : c.alphaTest;
      let u = this.uniforms.alphaMap.value ? 1 : void 0;
      u !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = u, this.needsUpdate = !0), u = c.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = u, this.needsUpdate = !0), this.side = null !== (a = c.side) && void 0 !== a ? a : i.ehD;
    }

  }

  class B_ extends Ws {
    constructor(e = !0) {
      super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e;
    }

    passCtor(e) {
      const t = e.renderer.createTarget({
        depthBuffer: !0,
        type: i.ywz
      });
      t.texture.name = "velocityBuffer", this._velocityBuffers.push(t);
      const n = e.getPluginByType("debug");
      n && n.addTexture("velocityBuffer", () => t.texture, [40, 50, 400, 200]);
      const r = new Set(),
            s = new Set();
      return new class extends N_ {
        render(n, i, o, a, l) {
          if (e.renderer.frameCount > 0) return;
          const c = n.getRenderTarget(),
                u = n.getActiveCubeFace(),
                p = n.getActiveMipmapLevel();
          this.scene.traverse(({
            material: e
          }) => {
            e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (r.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (s.add([e, e.transmission]), e.transmission = 0));
          }), K(n, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1,
            mainRenderPass: !1
          }, () => super.render(n, i, t, a, l)), r.forEach(e => e.transparent = !e.transparent), r.clear(), s.forEach(([e, t]) => e.transmission = t), s.clear(), n.setRenderTarget(c, u, p);
        }

      }();
    }

    _update(e) {
      if (!super._update(e)) return !1;
      if (e.renderer.frameCount > 0) return !1;
      const t = this.pass.passObject;
      return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0;
    }

    getVelocityBuffer() {
      return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0;
    }

    async onDispose(e) {}

    async onRemove(e) {
      return this._velocityBuffers.forEach(t => {
        var n;
        return e.renderer.disposeTarget(null === (n = null == t ? void 0 : t.dispose) || void 0 === n ? void 0 : n.call(t));
      }), super.onRemove(e);
    }

    updateShaderProperties(e) {
      var t, n;
      return e.uniforms.tVelocity ? e.uniforms.tVelocity.value = this.enabled && null !== (n = null === (t = this.getVelocityBuffer()) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : null : console.warn("BaseRenderer: no uniform: tVelocity"), this;
    }

    get uiConfig() {
      var e;
      return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig;
    }

  }

  B_.PluginType = "VelocityBuffer";

  class j_ extends r {
    constructor() {
      super(...arguments), this.dirty = !1, this.counters = {}, this._generators = new Map(), this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender");
    }

    async onAdded(e) {
      this._viewer = e, e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender);
    }

    addTexture(e, t, n, r, o, a = "postRender", l = !1) {
      var c;
      this._generators.has(a) || this._generators.set(a, []), null === (c = this._generators.get(a)) || void 0 === c || c.push({
        key: e,
        fn: t,
        rect: n ? [...n] : void 0,
        frag: o || r || l ? new i.jyz({
          vertexShader: s.vertexShader,
          uniforms: {
            tDiffuse: {
              value: null
            },
            opacity: {
              value: 1
            }
          },
          fragmentShader: null != o ? o : `\n        #include <common>\n        #include <packing>\n        uniform float opacity;\n\t\tuniform ${l ? "samplerCube" : "sampler2D"} tDiffuse;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvec4 texel = ${l ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};\n\t\t\t${null != r ? r : ""}\n\t\t\tgl_FragColor = opacity * texel;\n\t\t}\n            `
        }) : void 0
      });
    }

    removeTexture(e, t = "postRender") {
      var n, r;

      this._generators.set(t, null !== (r = null === (n = this._generators.get(t)) || void 0 === n ? void 0 : n.filter(t => t.key !== e)) && void 0 !== r ? r : []);
    }

    async onDispose(e) {
      return Promise.resolve(void 0);
    }

    async onRemove(e) {
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0);
    }

    _showDebug(e) {
      var t;
      const n = this._viewer,
            r = null == n ? void 0 : n.renderer;
      r && n && (null === (t = this._generators.get(e)) || void 0 === t || t.forEach(({
        key: e,
        fn: t,
        rect: i,
        frag: s
      }) => {
        const o = t(n);

        if (o) {
          if (o.image && i) {
            const e = o.image.width / o.image.height;
            i[2] < 1 && i[3] < 1 && (i[2] = 200), i[2] < 1 && (i[2] = i[3] * e), i[3] < 1 && (i[3] = i[2] / e);
          }

          r.blit(o, void 0, {
            viewport: i,
            clear: !1,
            material: s
          });
        }
      }));
    }

  }

  j_.PluginType = "debug";

  class z_ extends i.Tn7 {
    constructor() {
      super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null;
    }

    get materialObject() {
      return this;
    }

    onBeforeCompile(e, t) {
      e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e.vertexShader = e.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e.fragmentShader = e.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e.fragmentShader = e.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", M`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e.uniforms, this._uniforms), super.onBeforeCompile(e, t);
    }

    customProgramCacheKey() {
      return super.customProgramCacheKey();
    }

    toJSON(e) {
      throw new Error("Method not supported for this material.");
    }

    fromJSON(e, t) {
      throw new Error("Method not supported for this material.");
    }

    copyProps(e) {
      throw new Error("Method not supported for this material.");
    }

  }

  function V_(e, t, n, {
    replaceAll: r = !1,
    prepend: i = !1,
    append: s = !1
  } = {}) {
    if (!e.includes(t)) return console.error(`${t} not found in shader`), e;
    let o = n;
    return i ? o = n + t : s && (o = t + n), r ? e.replaceAll(t, o) : e.replace(t, o);
  }

  !function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([V({
    propKey: "tLastThis"
  })], z_.prototype, "lastFrameTexture", void 0);

  var G_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class H_ {
    constructor(e) {
      this.enabled = !0, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.groundMapMode = "aoMap", this.alphaVignette = !0, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = !0, this.materialExtension = {
        shaderExtender: (e, t, n) => {
          "aoMap" === this.groundMapMode ? e.fragmentShader = V_(e.fragmentShader, "#include <aomap_fragment>", V_(i.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( unpackRGBAToDepth(texture2D( aoMap, vUv2 ) ) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e.fragmentShader = V_(e.fragmentShader, "#include <map_fragment>", V_(i.WdD.map_fragment, "diffuseColor *= sampledDiffuseColor;", "float groundShadow = unpackRGBAToDepth(sampledDiffuseColor); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow);")) : "alphaMap" === this.groundMapMode && (e.fragmentShader = V_(e.fragmentShader, "#include <alphamap_fragment>", V_(i.WdD.alphamap_fragment, "texture2D( alphaMap, vUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vUv ) )", {
            replaceAll: !0
          }))), this.alphaVignette && n.capabilities.isWebGL2 && (e.fragmentShader = V_(e.fragmentShader, "#include <output_fragment>", M`#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vUv2.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `));
        },
        computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis,
        onObjectRender: (e, t) => {
          t.materialObject.userData.gMapMode !== this.groundMapMode && (t.materialObject.userData.gMapMode = this.groundMapMode, t.materialObject.needsUpdate = !0);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this._viewer = e;
      const t = new Yc(16777215, 10, {
        near: 1.5,
        far: 20,
        bias: 0,
        frustumSize: 4,
        width: 1024,
        height: 1024,
        enabled: !0,
        radius: 10,
        normalBias: 0
      }, {
        direction: new i.Pa4(.2, 1, .2).normalize(),
        spread: .9,
        focus: 1,
        distanceScale: 20,
        minDistanceScale: new i.Pa4(10, 10, 10),
        normalDirection: new i.Pa4(0, 1, 0)
      });
      t.shadow.camera.updateProjectionMatrix(), t.layers.disableAll(), t.layers.set(this._lightLayer), this._light = t, e.scene.addLight(this._light, {
        addToRoot: !0
      }), this._shadowMat = new z_({
        color: "#ffffff",
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        premultipliedAlpha: !1,
        opacity: 1,
        transparent: !1,
        blending: i.jFi
      });
    }

    get attachedMesh() {
      return this._attachedMesh;
    }

    set attachedMesh(e) {
      this._attachedMesh !== e && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e, this._attachedMesh && this._updateMaterial());
    }

    get target() {
      return this._target;
    }

    get light() {
      return this._light;
    }

    dispose() {
      this._shadowMat.dispose(), this._target = void 0, this.reset();
    }

    cleanupMaterial() {
      this._updateMaterial(!0);
    }

    _groundMapModeChanged() {
      this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = !0 : this._attachedMesh.material.transparent = !1), this.reset();
    }

    _alphaVignetteChanged() {
      var e, t, n;
      null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    fromJSON(e, t) {
      return Te(e, this, !0, t), this.reset(), this;
    }

    reset() {
      this._frameNumber = 0;
    }

    autoUpdateShadow() {
      this.shadowAutoUpdate && this.updateShadow();
    }

    updateShadow() {
      if (!this.enabled) return !1;
      const e = this._attachedMesh;
      if (++this._frameNumber > this.maxFrameNumber || !e) return !1;
      const t = 1024;
      this._target || (this._target = this._viewer.renderer.createTarget({
        isAntialiased: !1,
        type: i.ywz,
        depthBuffer: !1,
        size: new i.FM8(t, t),
        sizeMultiplier: void 0,
        encoding: i.rnI,
        format: i.wk1
      })), this._frameNumber < 3 ? this._light.randomizePosition(1, 0) : this._light.randomizePosition(), e.castShadow = !1;
      const n = this._viewer.renderer.rendererObject,
            r = n.shadowMap,
            s = r.type,
            o = r.needsUpdate,
            a = r.autoUpdate;
      r.type = i._MY, r.needsUpdate = !0, r.autoUpdate = !1;
      const l = this._viewer.scene,
            c = new i.S9g();
      c.disableAll(), l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.userData.__gp_layers = e.layers, e.layers = c);
      });
      const u = l.activeCamera.cameraObject;
      if (0 != (u.layers.mask & 1 << this._lightLayer)) throw "Camera can render pseudo directional light, check layers";
      u.layers.enable(this._lightLayer), e.layers.disable(this._lightLayer), K(n, {
        shadowMapRender: !0,
        backgroundRender: !1,
        sceneRender: !1
      }, () => this._viewer.renderer.renderScene(l)), u.layers.disable(this._lightLayer);
      const p = u.layers.mask;
      u.layers.set(this._lightLayer), e.layers.enable(this._lightLayer);

      const h = this._viewer.renderer.getTempTarget({
        isAntialiased: !1,
        type: i.ywz,
        depthBuffer: !1,
        size: new i.FM8(t, t),
        encoding: i.rnI,
        format: i.wk1
      }),
            d = h.texture.encoding;

      h.texture.encoding = i.rnI, this._viewer.renderer.blit(this._target.texture, h, {
        clear: !0
      });
      {
        const t = l.modelObject.environment,
              r = l.modelObject.background,
              i = e.material,
              s = e.frustumCulled,
              o = n.getRenderTarget(),
              a = n.getActiveCubeFace(),
              c = n.getActiveMipmapLevel();
        l.modelObject.background = null, l.modelObject.environment = null, e.material = this._shadowMat, e.frustumCulled = !1, n.setRenderTarget(this._target);
        const u = !1;
        this._shadowMat.opacity = u ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = h.texture, this._shadowMat.needsUpdate = !0, K(n, {
          shadowMapRender: !1,
          backgroundRender: !1,
          opaqueRender: !0,
          transparentRender: !1,
          transmissionRender: !1
        }, () => this._viewer.renderer.renderScene(l)), n.setRenderTarget(o, a, c), e.frustumCulled = s, e.material = i, l.modelObject.environment = t, l.modelObject.background = r;
      }
      return h.texture.encoding = d, this._viewer.renderer.releaseTempTarget(h), e.layers.disable(this._lightLayer), u.layers.mask = p, l.modelObject.traverse(e => {
        e.isLight && e !== this._light.lightObject && (e.layers = e.userData.__gp_layers, delete e.userData.__gp_layers);
      }), r.type = s, r.needsUpdate = o, r.autoUpdate = a, e.castShadow = !0, (this._frameNumber < 2 || this._frameNumber > Math.min(30, this.maxFrameNumber) && this._frameNumber % 150 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e.dispatchEvent({
        type: "materialUpdate"
      })), !0;
    }

    _updateMaterial(e = !1) {
      var t, n, r;
      this._attachedMesh && (e ? (this._attachedMesh.material.alphaMap === (null === (t = this._target) || void 0 === t ? void 0 : t.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (n = this._target) || void 0 === n ? void 0 : n.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (r = this._target) || void 0 === r ? void 0 : r.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e || "alphaMap" !== this.groundMapMode ? 0 : .001, this._attachedMesh.material.needsUpdate = !0));
    }

  }

  G_([xe("randomizedLight")], H_.prototype, "_light", void 0), G_([C(H_.prototype.reset), xe()], H_.prototype, "maxFrameNumber", void 0), G_([C(H_.prototype._groundMapModeChanged), xe()], H_.prototype, "groundMapMode", void 0), G_([xe(), C(H_.prototype._alphaVignetteChanged)], H_.prototype, "alphaVignette", void 0), G_([xe(), C(H_.prototype._alphaVignetteChanged)], H_.prototype, "alphaVignetteAxis", void 0);

  var W_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class K_ extends i.Kj0 {
    constructor(e, t, n = 0) {
      super(e), this.type = "Reflector", this.isReflector2 = !0, this.enabled = !0, this.reflectorModePhysical = !0, this.reflectionTargetNeedsUpdate = !0, this.transparentReflectionBackground = !0, this.materialExtension = {
        extraUniforms: {
          tRefDepth: {
            value: null
          },
          tRefDiffuse: {
            value: null
          },
          tRefDiffuseSize: {
            value: new i.FM8()
          },
          refTextureMatrix: {
            value: null
          },
          frameCount: {
            value: 0
          },
          sceneBoundingRadius: {
            value: 0
          }
        },
        updaters: [],
        shaderExtender: (e, t, n) => {
          if (this.enabled) {
            e.vertexShader = e.vertexShader.replace("void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
            const t = "#glMarker beforeModulation";
            e.fragmentShader = e.fragmentShader.replace(t, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t);
          }
        },
        parsVertexSnippet: () => this.enabled ? "\n\t\tuniform mat4 refTextureMatrix;\n\t\tvarying vec4 vRefUv;\n" : "",
        parsFragmentSnippet: () => this.enabled ? hu + "\n" + vo + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;uniform sampler2D tRefDepth;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*random3(vec3(vRefUv.xy,frameCount*0.1));vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "",
        computeCacheKey: e => this.enabled + " " + e.materialObject.transparent + " " + this.reflectorModePhysical + " ",
        onObjectRender: (e, {
          materialObject: t
        }) => {
          t.userData.__lastTransparent !== t.transparent && (t.needsUpdate = !0, t.userData.__lastTransparent = t.transparent);
        },
        isCompatible: e => e.isMeshStandardMaterial2
      }, this.material = void 0, this._renderTarget = t, this._renderTarget.depthTexture = new i.$YQ(t.width / 2, t.height / 2, i.ywz);

      const r = new i.JOQ(),
            s = new i.Pa4(),
            o = new i.Pa4(),
            a = new i.Pa4(),
            l = new i.yGw(),
            c = new i.Pa4(0, 0, -1),
            u = new i.Ltg(),
            p = new i.Pa4(),
            h = new i.Pa4(),
            d = new i.Ltg(),
            f = new i.yGw(),
            _ = new i.cPb();

      i.M8C.isPowerOfTwo(t.texture.image.width) && i.M8C.isPowerOfTwo(t.texture.image.height) || (this._renderTarget.texture.generateMipmaps = !1), this.onBeforeRender = (e, t, i) => {
        if (!this.enabled || !e.userData.mainRenderPass) return;
        if (!this.reflectionTargetNeedsUpdate) return;
        const m = i.view ? Object.assign({}, i.view) : null;
        if (m && i.clearViewOffset && i.clearViewOffset(), o.setFromMatrixPosition(this.matrixWorld), a.setFromMatrixPosition(i.matrixWorld), l.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(l), p.subVectors(o, a), p.dot(s) > 0) return;
        p.reflect(s).negate(), p.add(o), l.extractRotation(i.matrixWorld), c.set(0, 0, -1), c.applyMatrix4(l), c.add(a), h.subVectors(o, c), h.reflect(s).negate(), h.add(o), _.position.copy(p), _.up.set(0, 1, 0), _.up.applyMatrix4(l), _.up.reflect(s), _.lookAt(h), _.far = 2, _.near = 0, _.updateMatrixWorld(), _.projectionMatrix.copy(i.projectionMatrix), f.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), f.multiply(_.projectionMatrix), f.multiply(_.matrixWorldInverse), f.multiply(this.matrixWorld), r.setFromNormalAndCoplanarPoint(s, o), r.applyMatrix4(_.matrixWorldInverse), u.set(r.normal.x, r.normal.y, r.normal.z, r.constant);
        const g = _.projectionMatrix;
        d.x = (Math.sign(u.x) + g.elements[8]) / g.elements[0], d.y = (Math.sign(u.y) + g.elements[9]) / g.elements[5], d.z = -1, d.w = (1 + g.elements[10]) / g.elements[14], u.multiplyScalar(2 / u.dot(d)), g.elements[2] = u.x, g.elements[6] = u.y, g.elements[10] = u.z + 1 - n, g.elements[14] = u.w, this.visible = !1;
        const v = e.getRenderTarget(),
              b = e.xr.enabled,
              x = e.shadowMap.autoUpdate;
        e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(this._renderTarget), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear();
        const y = t.background;
        this.transparentReflectionBackground && (t.background = null);
        const w = !this.transparentReflectionBackground;
        y && w && (y.userData.flipX = !y.userData.flipX), K(e, {
          shadowMapRender: !1,
          backgroundRender: w,
          opaqueRender: !0,
          transparentRender: !0,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => e.render(t, _)), y && w && (y.userData.flipX = !y.userData.flipX || void 0), this.transparentReflectionBackground && (t.background = y), e.xr.enabled = b, e.shadowMap.autoUpdate = x, e.setRenderTarget(v), (null == m ? void 0 : m.enabled) && i.setViewOffset && i.setViewOffset(m.fullWidth, m.fullHeight, m.offsetX, m.offsetY, m.width, m.height);
        const S = i.viewport;
        void 0 !== S && e.state.viewport(S), this.visible = !0, this.reflectionTargetNeedsUpdate = !1;
      }, this.textureMatrix = f, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new i.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.tRefDepth.value = this._renderTarget.depthTexture, this.materialExtension.extraUniforms.refTextureMatrix.value = f;
    }

    _updateExtension() {
      var e, t;
      this.transparentReflectionBackground = this.reflectorModePhysical, null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e);
    }

    getRenderTarget() {
      return this._renderTarget;
    }

  }

  W_([C(K_.prototype._updateExtension)], K_.prototype, "enabled", void 0), W_([C(K_.prototype._updateExtension)], K_.prototype, "reflectorModePhysical", void 0), K_.prototype.isReflector = !0;

  var X_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class q_ extends Gs {
    constructor(e = {}) {
      super(), this._transformNeedRefresh = !0, this.dependencies = [Vs], this.visible = !0, this.size = 8, this.yOffset = 0, this.renderToDepth = !0, this.tonemapGround = !0, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new i.BKK(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0, this._options = {
        shape: "",
        up: [0, 100, 0],
        autoAdjustTransform: !0
      }, this.setOptions(e);
    }

    get enabled() {
      return this.visible;
    }

    set enabled(e) {
      this.visible = e;
    }

    get material() {
      return this._material;
    }

    get mesh() {
      return this._iMesh;
    }

    _createMesh() {
      return new i.Kj0(this._geometry);
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), e.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e.getPlugin(Vs);

      const r = this._createMesh();

      r.userData.physicsMass = 0, this._iMesh = await (null === (t = this._manager) || void 0 === t ? void 0 : t.addImportedSingle(r, {
        pseudoCenter: !1,
        autoScale: !1,
        addToRoot: !0
      })), this._mesh = null === (n = this._iMesh) || void 0 === n ? void 0 : n.modelObject, this._mesh && (this._mesh.userData.userSelectable = !1, this._mesh.castShadow = !0, this._mesh.receiveShadow = !0, this._mesh.name = "Ground Plane"), e.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e.scene.addEventListener("addSceneObject", this._onSceneUpdate), e.addEventListener("preRender", this._preRender), e.addEventListener("postFrame", this._postFrame), this.refreshOptions();
    }

    _postFrame() {
      this._transformNeedRefresh && this._refreshTransform(), this._viewer;
    }

    _preRender() {
      this._viewer;
    }

    async onDispose(e) {
      var t;
      return this._geometry.dispose(), null === (t = this._iMesh) || void 0 === t || t.dispose(), super.onDispose(e);
    }

    async onRemove(e) {
      return this._removeMaterial(), e.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e.removeEventListener("postFrame", this._postFrame), e.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e);
    }

    _removeMaterial() {
      var e, t;
      this._material && (null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t || t.unregisterMaterial(this._material), this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0);
    }

    _onSceneUpdate(e) {
      !1 !== e.geometryChanged && !1 !== e.updateGround && this.refreshTransform();
    }

    refreshTransform() {
      this._transformNeedRefresh = !0;
    }

    _refreshOptions2() {
      this.refreshOptions();
    }

    refreshOptions() {
      this._viewer && (this._refreshMaterial(), this.refreshTransform());
    }

    _refreshTransform() {
      var e;
      if (!this._mesh) return;
      if (!this._viewer) return;
      let t = !1;

      if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, t = !0), this.enabled) {
        if (this._options.autoAdjustTransform) {
          this._mesh.userData.bboxVisible = !1;

          const e = this._viewer.scene.getBounds(!0);

          this._mesh.userData.bboxVisible = !0;
          const n = e.getCenter(new i.Pa4()).sub(new i.Pa4(0, e.getSize(new i.Pa4()).y / 2 + this.yOffset, 0));
          t = t || n.clone().sub(this._mesh.position).length() > 1e-4, t && this._mesh.position.copy(n);
        }

        t = t || Math.abs(this._mesh.scale.x - this.size) > 1e-4, t && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new i.USm(-Math.PI / 2, 0, 0)), this._mesh.matrixWorldNeedsUpdate = !0, this._mesh.userData.setDirty()), this._transformNeedRefresh = !1;
      } else t && (null === (e = this._viewer) || void 0 === e || e.scene.setDirty());
    }

    _refreshMaterial() {
      var e, t, n, r, i, s, o, a, l;
      if (!this._viewer) return !1;
      if (!this.enabled) return !1;
      this._manager || console.error("GroundPlugin requires asset manager");
      const c = null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.findOrCreate(null !== (r = null === (n = this._material) || void 0 === n ? void 0 : n.uuid) && void 0 !== r ? r : "standard", {
        name: "BaseGroundMaterial",
        runtimeMaterial: !0,
        color: 16777215
      });
      let u = !1;
      return (null == c ? void 0 : c.uuid) !== (null === (i = this._material) || void 0 === i ? void 0 : i.uuid) && (this._removeMaterial(), c && (this._material = c), (null === (s = this._material) || void 0 === s ? void 0 : s.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material && (this._material.roughness = .2, this._material.metalness = .5, (null !== (l = null === (a = null === (o = this._mesh) || void 0 === o ? void 0 : o.userData) || void 0 === a ? void 0 : a.setMaterial) && void 0 !== l ? l : e => {
        this._mesh && (this._mesh.material = e.materialObject);
      })(this._material)), u = !0), this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth, this._viewer.setDirty()), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround, this._viewer.setDirty()), this._material.materialObject.userData.ssaoDisabled = !0, this._material.materialObject.userData.sscsDisabled = !0), u;
    }

    setOptions(e) {
      Object.assign(this._options, e), this.refreshOptions();
    }

    fromJSON(e, t) {
      return super.fromJSON(e, t) ? (this.refreshOptions(), this) : null;
    }

    _extraUiConfig() {
      return [() => {
        var e;
        return null === (e = this._material) || void 0 === e ? void 0 : e.uiConfig;
      }];
    }

    get uiConfig() {
      return this._uiConfig ? this._uiConfig : this._uiConfig = {
        type: "folder",
        label: "Ground",
        children: [{
          label: "Visible",
          type: "checkbox",
          property: [this, "visible"],
          limitedUi: !0
        }, {
          label: "Size",
          type: "input",
          property: [this, "size"],
          limitedUi: !0
        }, {
          label: "Render to Depth",
          type: "checkbox",
          property: [this, "renderToDepth"]
        }, {
          label: "Tonemap",
          type: "checkbox",
          property: [this, "tonemapGround"]
        }, {
          label: "Height",
          type: "slider",
          bounds: [-2, 2],
          property: [this, "yOffset"]
        }, ...this._extraUiConfig()]
      };
    }

  }

  X_([xe("material")], q_.prototype, "_material", void 0), X_([C(q_.prototype.refreshTransform), xe()], q_.prototype, "visible", void 0), X_([C(q_.prototype._onSceneUpdate), xe()], q_.prototype, "size", void 0), X_([C(q_.prototype._onSceneUpdate), xe()], q_.prototype, "yOffset", void 0), X_([C(q_.prototype._refreshOptions2), xe()], q_.prototype, "renderToDepth", void 0), X_([C(q_.prototype._refreshOptions2), xe()], q_.prototype, "tonemapGround", void 0);

  var Y_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class Z_ extends q_ {
    constructor(e = {}, t = !1) {
      super(e), this.bakedShadows = !0, this.groundReflection = !0, this.physicalReflections = !1, this._showDebug = t, t && this.dependencies.push(j_), this._onSceneUpdate = this._onSceneUpdate.bind(this);
    }

    get shadowBaker() {
      return this._shadowBaker;
    }

    _createMesh() {
      const e = new K_(this._geometry, this._viewer.renderer.createTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 1024,
          height: 1024
        },
        generateMipmaps: !0,
        depthBuffer: !0,
        minFilter: i.D1R,
        magFilter: i.wem,
        isAntialiased: !1
      })),
            t = e.onBeforeRender;
      return e.onBeforeRender = (...e) => {
        var n, r;
        let i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("SSReflection")) || void 0 === r ? void 0 : r.passes.ssr.passObject;
        i && !i.enabled && (i = void 0), i && (i.enabled = !1), t(...e), i && (i.enabled = !0);
      }, e;
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this._showDebug && (null === (t = e.getPlugin(j_)) || void 0 === t || t.addTexture("bake_ground_1", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light.shadow.map) || void 0 === t ? void 0 : t.texture;
      }, [100, 100, 200, 200]), null === (n = e.getPlugin(j_)) || void 0 === n || n.addTexture("bake_ground_2", () => {
        var e, t;
        return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.target) || void 0 === t ? void 0 : t.texture;
      }, [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"));
    }

    _postFrame() {
      var e;
      super._postFrame(), this._viewer && this.enabled && this.bakedShadows && (null === (e = this._shadowBaker) || void 0 === e || e.autoUpdateShadow());
    }

    _preRender() {
      super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1);
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    _removeMaterial() {
      var e, t, n, r;

      if (this._material) {
        if (this._shadowBaker && this._material.groundMatExtension && (null === (t = (e = this._material).unregisterMaterialExtensions) || void 0 === t || t.call(e, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
          const e = this._mesh.materialExtension;
          e || console.warn("unable to find the extension to unregister"), null === (r = (n = this._material).unregisterMaterialExtensions) || void 0 === r || r.call(n, [e]), delete this._material.reflectorMatExtension;
        }

        super._removeMaterial();
      }
    }

    _onSceneUpdate(e) {
      var t;
      super._onSceneUpdate(e), !1 !== e.geometryChanged && (null === (t = this._shadowBaker) || void 0 === t || t.reset());
    }

    refreshOptions() {
      if (!this._viewer) return;
      this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new H_(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
      const e = this._mesh;
      e.isReflector2 && (e.enabled = this.groundReflection, e.reflectorModePhysical = this.physicalReflections), super.refreshOptions();
    }

    _refreshMaterial() {
      var e, t, n, r;
      if (!this._viewer) return !1;

      const i = super._refreshMaterial();

      if (!this._material) return i;

      if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
        const n = this._mesh.materialExtension;
        n.updaters = [this._viewer.scene, this._viewer.renderer], null === (t = (e = this._material).registerMaterialExtensions) || void 0 === t || t.call(e, [n]), this._material.reflectorMatExtension = !0;
      }

      return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (r = (n = this._material).registerMaterialExtensions) || void 0 === r || r.call(n, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = !0), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, i;
    }

    _extraUiConfig() {
      var e, t, n, r, i, s, o, a, l, c, u, p, h, d, f, _, m, g, v, b, x, y, w, S, M, T, E, A, C, R;

      return [{
        label: "Baked Shadows",
        type: "checkbox",
        property: [this, "bakedShadows"]
      }, {
        label: "Shadow Frames",
        type: "input",
        hidden: () => !this._shadowBaker,
        stepSize: 1,
        bounds: [1, 1e3],
        property: [this._shadowBaker, "maxFrameNumber"]
      }, {
        label: "Alpha Vignette",
        type: "checkbox",
        hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent,
        property: [this._shadowBaker, "alphaVignette"],
        limitedUi: !0,
        onChange: () => {
          var e, t;
          return null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e, "postFrame", !0);
        }
      }, {
        label: "Alpha Vignette Axis",
        type: "dropdown",
        hidden: () => {
          var e;
          return !(null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent;
        },
        property: [this._shadowBaker, "alphaVignetteAxis"],
        children: ["x", "y", "xy"].map(e => ({
          label: e,
          value: e
        })),
        limitedUi: !0
      }, {
        label: "Planar Reflections",
        type: "checkbox",
        property: [this, "groundReflection"],
        limitedUi: !0
      }, {
        label: "Physical Reflections",
        type: "checkbox",
        property: [this, "physicalReflections"],
        limitedUi: !0
      }, {
        label: "Shadow type",
        type: "dropdown",
        hidden: () => !this._shadowBaker,
        property: [this._shadowBaker, "groundMapMode"],
        children: [{
          label: "aoMap"
        }, {
          label: "map"
        }, {
          label: "alphaMap"
        }],
        limitedUi: !0
      }, {
        type: "folder",
        label: "Randomized Light",
        hidden: () => !this._shadowBaker,
        limitedUi: !0,
        children: [{
          type: "color",
          label: "Color",
          property: [null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light, "color"]
        }, {
          type: "slider",
          label: "Intensity",
          bounds: [0, 100],
          property: [null === (t = this._shadowBaker) || void 0 === t ? void 0 : t.light, "intensity"]
        }, {
          type: "checkbox",
          label: "Shadow Enabled",
          property: [null === (r = null === (n = this._shadowBaker) || void 0 === n ? void 0 : n.light) || void 0 === r ? void 0 : r.shadowParams, "enabled"],
          onChange: [null === (s = null === (i = this._shadowBaker) || void 0 === i ? void 0 : i.light) || void 0 === s ? void 0 : s.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (a = null === (o = this._shadowBaker) || void 0 === o ? void 0 : o.light) || void 0 === a ? void 0 : a.randomParams, "focus"],
          onChange: [this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [0, 1],
          property: [null === (c = null === (l = this._shadowBaker) || void 0 === l ? void 0 : l.light) || void 0 === c ? void 0 : c.randomParams, "spread"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 60],
          property: [null === (p = null === (u = this._shadowBaker) || void 0 === u ? void 0 : u.light) || void 0 === p ? void 0 : p.randomParams, "distanceScale"],
          onChange: [null === (d = null === (h = this._shadowBaker) || void 0 === h ? void 0 : h.light) || void 0 === d ? void 0 : d.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (_ = null === (f = this._shadowBaker) || void 0 === f ? void 0 : f.light) || void 0 === _ ? void 0 : _.randomParams, "direction"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "vec3",
          bounds: [-1, 1],
          property: [null === (g = null === (m = this._shadowBaker) || void 0 === m ? void 0 : m.light) || void 0 === g ? void 0 : g.randomParams, "normalDirection"],
          onChange: [this._onSceneUpdate],
          limitedUi: !0
        }, {
          type: "slider",
          bounds: [.01, 10],
          property: [null === (b = null === (v = this._shadowBaker) || void 0 === v ? void 0 : v.light) || void 0 === b ? void 0 : b.shadowParams, "radius"],
          onChange: [null === (y = null === (x = this._shadowBaker) || void 0 === x ? void 0 : x.light) || void 0 === y ? void 0 : y.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "input",
          property: [null === (S = null === (w = this._shadowBaker) || void 0 === w ? void 0 : w.light) || void 0 === S ? void 0 : S.shadowParams, "frustumSize"],
          onChange: [null === (T = null === (M = this._shadowBaker) || void 0 === M ? void 0 : M.light) || void 0 === T ? void 0 : T.updateShadowParams, this._onSceneUpdate]
        }, {
          type: "slider",
          bounds: [-.1, .1],
          property: [null === (A = null === (E = this._shadowBaker) || void 0 === E ? void 0 : E.light) || void 0 === A ? void 0 : A.shadowParams, "bias"],
          onChange: [null === (R = null === (C = this._shadowBaker) || void 0 === C ? void 0 : C.light) || void 0 === R ? void 0 : R.updateShadowParams, this._onSceneUpdate]
        }]
      }, ...super._extraUiConfig()];
    }

  }

  Z_.PluginType = "Ground", Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "bakedShadows", void 0), Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "groundReflection", void 0), Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "physicalReflections", void 0), Y_([xe("shadowBaker")], Z_.prototype, "_shadowBaker", void 0);

  var J_ = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let $_ = class extends Gs {
    constructor() {
      super(), this.toJSON = void 0, this.enabled = !0, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = e => {
        var t;
        if (this.isFullScreen()) this.dispatchEvent({
          type: "enter"
        });else {
          const e = this._lastFsElement || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
          e && (e.style.width = this._lastSize[0], e.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1), this.dispatchEvent({
            type: "exit"
          });
        }
      }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this);
    }

    async enter(e) {
      var t;
      if (this.isFullScreen()) return;
      const n = e || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
      return n ? (this._lastFsElement = n, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("fullscreenchange", this._fsChangeHandler, !1), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)), this._lastSize = [n.style.width, n.style.height], n.style.width = "100%", n.style.height = "100%", n.requestFullscreen ? n.requestFullscreen() : n.mozRequestFullScreen ? n.mozRequestFullScreen() : n.webkitRequestFullscreen ? n.webkitRequestFullscreen() : n.msRequestFullscreen ? n.msRequestFullscreen() : void 0) : void 0;
    }

    async exit() {
      return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0;
    }

    async toggle(e) {
      return this.isFullScreen() ? this.exit() : this.enter(e);
    }

    isFullScreen() {
      return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement;
    }

  };
  $_.PluginType = "FullScreenPlugin", J_([Xe("Enter FullScreen")], $_.prototype, "enter", null), J_([Xe("Exit FullScreen")], $_.prototype, "exit", null), J_([Xe("Toggle FullScreen")], $_.prototype, "toggle", null), $_ = J_([Qe("Full Screen")], $_);

  var Q_,
      em = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let tm = Q_ = class extends Gs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.radius = .015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = !1, this.stepCount = 2, this.dependencies = [Ys, Vs], this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSCS_ENABLED) return;
          const r = M`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `,
                s = `\n#if SSCS_ENABLED\n\n    uniform float sscsIntensity;\n    uniform float sscsRadius;\n    uniform float sscsTolerance;\n\n    ${go}\n    \n    #define THREE_PACKING_INCLUDED\n    ${mo}\n    \n    ${jt}\n    ${vo}\n    \n    ${xo}\n\n#endif\n            \n            ` + i.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${r}\n`).replace("return shadow;", "return min(shadow, state.z);");
          e.fragmentShader = e.fragmentShader.replace("#include <shadowmap_pars_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;").replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ], directLight.direction ) : 1.0;");
        },
        onObjectRender: (e, t, n) => {
          var r;
          const i = t.materialObject;
          let s = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = i.userData) || void 0 === r ? void 0 : r.sscsDisabled) ? 1 : 0;
          i.defines.SSCS_ENABLED !== s && (i.defines.SSCS_ENABLED = s, i.needsUpdate = !0), s = this._defines.SSCS_STEP_COUNT, i.defines.SSCS_STEP_COUNT !== s && (i.defines.SSCS_STEP_COUNT = s, i.needsUpdate = !0), s = +this._defines.SSCS_DEBUG, i.defines.SSCS_DEBUG !== s && (i.defines.SSCS_DEBUG = s, i.needsUpdate = !0);
        },
        parsFragmentSnippet: () => "\n",
        extraUniforms: { ...Q_._uniforms
        },
        computeCacheKey: e => this.enabled ? "1" : "0",
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => {
          var e, t, n, r, i;
          return [null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ys), null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co), null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.activeCamera, null === (r = this._viewer) || void 0 === r ? void 0 : r.renderer, null === (i = this._viewer) || void 0 === i ? void 0 : i.scene];
        }
      }, this.enabled = e, this.userData = {
        setDirty: () => {
          var e;
          null === (e = this._viewer) || void 0 === e || e.setDirty();
        }
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this.materialExtension);
    }

    async onRemove(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), super.onRemove(e);
    }

  };
  tm.PluginType = "SSContactShadows", tm._uniforms = {
    tNormalDepth: {
      value: null
    },
    frameCount: {
      value: 0
    },
    projection: {
      value: new i.yGw()
    },
    cameraPositionWorld: {
      value: new i.Pa4()
    },
    cameraNearFar: {
      value: new i.FM8(.1, 1e3)
    },
    sceneBoundingRadius: {
      value: 0
    }
  }, em([Ve("Enabled"), xe()], tm.prototype, "enabled", void 0), em([V({
    uniforms: Q_._uniforms,
    propKey: "sscsRadius"
  }), He("Radius", [1e-4, .1], 1e-4), xe()], tm.prototype, "radius", void 0), em([V({
    uniforms: Q_._uniforms,
    propKey: "sscsIntensity"
  }), He("Intensity", [1e-4, 1], 1e-4), xe()], tm.prototype, "intensity", void 0), em([V({
    uniforms: Q_._uniforms,
    propKey: "sscsTolerance"
  }), He("Tolerance", [.1, 5]), xe()], tm.prototype, "tolerance", void 0), em([G("SSCS_DEBUG", void 0, !0), Ve("Debug only SSCS"), xe()], tm.prototype, "onlySSCSDebug", void 0), em([G("SSCS_STEP_COUNT", void 0, !0), He("Step count", [1, 8], 1), xe()], tm.prototype, "stepCount", void 0), tm = Q_ = em([Qe("Screen Space Contact Shadows")], tm);

  class nm {
    constructor(e) {
      this.presets = [], this.name = "", this.selected = void 0, e && (this.name = e);
    }

    async apply(e, t, n) {
      var r, i;
      if (!t) return void (this.selected = void 0);
      let s = this.presets.find(e => e.path === t.path);
      return s || (this.presets.push(t), s = t), this.selected = s, null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.importer) || void 0 === i ? void 0 : i.importAsset(s, n);
    }

  }

  class rm extends nm {
    constructor() {
      super(...arguments), this.name = "Background";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return r && (r.encoding = i.knz, await e.setBackground(r)), r;
    }

  }

  class im extends nm {
    constructor() {
      super(...arguments), this.name = "Environment";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return r && (await e.scene.setEnvironment(r)), r;
    }

  }

  class sm extends nm {
    constructor() {
      super(...arguments), this.name = "GemEnvironment";
    }

    async apply(e, t) {
      const n = await super.apply(e, t),
            r = null == n ? void 0 : n[0];
      return g(e.getPluginByType("Diamond"), "envMap", r), r;
    }

  }

  class om extends nm {
    async apply(e, t) {
      var n, r;
      const i = await super.apply(e, t, {
        processImported: !1
      });
      return i ? null === (r = null === (n = e.getManager()) || void 0 === n ? void 0 : n.importer) || void 0 === r ? void 0 : r.processImported(i) : void 0;
    }

  }

  class am extends om {
    constructor() {
      super(...arguments), this.name = "MaterialLibraries";
    }

    async apply(e, t) {
      const n = await super.apply(e, t);
      return n && alert("Material Library successfully imported."), n;
    }

  }

  class lm extends Gs {
    constructor() {
      super(...arguments), this.toJSON = null, this.enabled = !0, this.presetGroups = [], this.uiConfig = {
        type: "folder",
        label: "Presets",
        expanded: !0,
        limitedUi: !0,
        children: [() => this.presetGroups.map(e => ({
          type: "dropdown",
          label: e.name,
          limitedUi: !0,
          children: [{
            value: "",
            label: "none"
          }, ...e.presets.map(e => ({
            label: e.path.split("/").pop(),
            value: e.path
          }))],
          getValue: () => {
            var t;
            return (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || "";
          },
          setValue: t => {
            e.apply(this._viewer, e.presets.find(e => e.path === t));
          }
        })), {
          type: "button",
          label: "Download Selection",
          limitedUi: !0,
          value: () => {
            const e = this.exportPresets();
            xt(new File([JSON.stringify(e, null, 2)], "preset.template.json", {
              type: "application/json"
            }));
          }
        }, {
          type: "button",
          label: "Export Preset Groups",
          hidden: !0,
          limitedUi: !1,
          value: () => {
            const e = this.exportPresetGroups();
            xt(new File([JSON.stringify(e, null, 2)], "presetGroups.json", {
              type: "application/json"
            }));
          }
        }]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.presetGroups.push(new rm()), this.presetGroups.push(new im()), this.presetGroups.push(new sm()), this.presetGroups.push(new om("Ground")), this.presetGroups.push(new om("CameraViews")), this.presetGroups.push(new om("MaterialConfiguration")), this.presetGroups.push(new am()), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    exportPresets() {
      const e = Object.fromEntries(this.presetGroups.map(e => {
        var t;
        return [e.name, (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || void 0];
      }).filter(([, e]) => e));
      return e.type = lm.PluginType, e;
    }

    async fromJSON(e, t) {
      var n, r;
      if (!super.fromJSON(e, t)) return null;
      const i = { ...e
      };
      delete i.type;
      const s = [];

      for (const [e, t] of Object.entries(i)) {
        const n = this.presetGroups.find(t => t.name === e),
              r = null == n ? void 0 : n.presets;
        if (!n || !r) continue;
        const i = "string" == typeof t ? {
          path: t
        } : t;
        s.push(n.apply(this._viewer, i));
      }

      return await Promise.all(s), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0), this;
    }

    loadPresetGroups(e) {
      var t;

      for (const [n, r] of Object.entries(e)) {
        const e = null === (t = this.presetGroups.find(e => e.name === n)) || void 0 === t ? void 0 : t.presets;
        null == e || e.push(...r);
      }
    }

    exportPresetGroups() {
      return Object.fromEntries(this.presetGroups.map(e => [e.name, e.presets.map(e => e.path)]).filter(([, e]) => e.length > 0));
    }

  }

  lm.PluginType = "PresetLibraryPlugin";

  class cm {
    constructor(e, t, n) {
      this._el = e, this._inputEl = t, this._listeners = {
        drop: [],
        dropstart: [],
        droperror: []
      }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e || e.addEventListener("dragover", this._onDragover, !1), null == e || e.addEventListener("drop", this._onDrop, !1), null == t || t.addEventListener("change", this._onSelect), n && Object.entries(n).forEach(([e, t]) => t && this.on(e, t));
    }

    get inputEl() {
      return this._inputEl;
    }

    get el() {
      return this._el;
    }

    on(e, t) {
      return this._listeners[e].push(t), this;
    }

    _emit(e, t) {
      return this._listeners[e].forEach(e => e(t)), this;
    }

    destroy() {
      const e = this._el,
            t = this._inputEl;
      null == e || e.removeEventListener("dragover", this._onDragover), null == e || e.removeEventListener("drop", this._onDrop), null == t || t.removeEventListener("change", this._onSelect);
    }

    _onDrop(e) {
      var t, n;
      e.stopPropagation(), e.preventDefault(), this._emit("dropstart");
      const r = Array.from((null === (t = e.dataTransfer) || void 0 === t ? void 0 : t.files) || []),
            i = Array.from((null === (n = e.dataTransfer) || void 0 === n ? void 0 : n.items) || []);
      if (0 !== r.length || 0 !== i.length) {
        if (i.length > 0) {
          const e = i.map(e => e.webkitGetAsEntry());

          this._loadNextEntry(new Map(), e);
        } else this._emit("drop", {
          files: new Map(r.map(e => (e.filePath = e.name, [e.filePath, e])))
        });
      } else this._fail("Required drag-and-drop APIs are not supported in this browser.");
    }

    _onDragover(e) {
      e.stopPropagation(), e.preventDefault(), e.dataTransfer && (e.dataTransfer.dropEffect = "copy");
    }

    _onSelect(e) {
      var t;
      if (!this._inputEl) return void console.warn("Invalid Dropzone event ", e);

      this._emit("dropstart");

      const n = [].slice.call(null !== (t = this._inputEl.files) && void 0 !== t ? t : new FileList()),
            r = new Map();
      n.forEach(e => {
        e.filePath = e.webkitRelativePath || e.name, r.set(e.filePath, e);
      }), this._emit("drop", {
        files: r
      });
    }

    _loadNextEntry(e, t) {
      const n = t.pop();
      if (n) {
        if (n.isFile) n.file(r => {
          r.filePath = n.fullPath, e.set(n.fullPath, r), this._loadNextEntry(e, t);
        }, () => console.error("Could not load file: %s", n.fullPath));else if (n.isDirectory) {
          const r = n.createReader(),
                i = n => {
            n.length ? (t = t.concat(n), r.readEntries(i)) : this._loadNextEntry(e, t);
          };

          r.readEntries(i);
        } else console.warn("Unknown asset type: " + n.fullPath), this._loadNextEntry(e, t);
      } else this._emit("drop", {
        files: e
      });
    }

    _fail(e) {
      this._emit("droperror", {
        message: e
      });
    }

  }

  class um extends r {
    constructor(e) {
      super(), this._domElement = e, this._allowedExtensions = void 0, this.importerParams = {
        autoScale: !0,
        autoScaleRadius: 2,
        pseudoCenter: !0,
        autoImport: !0,
        autoAdd: !0,
        centerOffset: new i.Pa4(.5, .5, 3)
      }, this.dependencies = [Vs], this.uiConfig = {
        type: "folder",
        label: "Drop Options",
        children: [{
          label: "Auto Center",
          type: "checkbox",
          property: [this.importerParams, "pseudoCenter"],
          limitedUi: !0
        }, {
          label: "Auto Scale",
          type: "checkbox",
          property: [this.importerParams, "autoScale"],
          limitedUi: !0
        }, {
          label: "Auto scale radius",
          type: "slider",
          bounds: [.5, 100],
          property: [this.importerParams, "autoScaleRadius"]
        }]
      };
    }

    async onAdded(e) {
      this._inputEl = document.createElement("input"), this._viewer = e, this._inputEl.type = "file", this._dropzone = new cm(this._domElement || e.canvas, this._inputEl, {
        drop: this._onFileDrop.bind(this)
      });
    }

    async _onFileDrop({
      files: e
    }) {
      var t, n, r, i, s, o;
      if (!e) return;
      const a = this._viewer;
      if (!a) return;
      if (void 0 !== this._allowedExtensions) for (const r of e.keys()) this._allowedExtensions.includes(null !== (n = null === (t = r.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase()) && void 0 !== n ? n : "") || e.delete(r);
      if (e.size < 1) return;
      const l = a.getPlugin(Vs),
            c = {
        type: "drop",
        files: e
      };

      if (this.importerParams.autoImport) {
        const t = {
          allowedExtensions: this.allowedExtensions,
          ...this.importerParams
        };

        if (c.imported = await (null === (r = l.importer) || void 0 === r ? void 0 : r.importFiles(e, void 0, t)), this.importerParams.autoAdd) {
          const e = null !== (o = [...(null !== (s = null === (i = c.imported) || void 0 === i ? void 0 : i.values()) && void 0 !== s ? s : [])].flat(2).filter(e => !!e)) && void 0 !== o ? o : [];
          c.assets = l.addProcessedAssets(e, { ...this.importerParams
          }), t.rootSceneImported || a.resetCamera(this.importerParams);
        }
      }

      this.dispatchEvent(c);
    }

    promptForFile() {
      var e;
      null === (e = this._inputEl) || void 0 === e || e.click();
    }

    async onDispose(e) {}

    async onRemove(e) {
      var t;
      null === (t = this._dropzone) || void 0 === t || t.destroy(), this._dropzone = void 0, this._viewer = void 0;
    }

    get allowedExtensions() {
      return this._allowedExtensions;
    }

    set allowedExtensions(e) {
      this._allowedExtensions = e, this._inputEl && (this._inputEl.accept = e ? e.map(e => "." + e).join(", ") : "");
    }

  }

  um.PluginType = "Dropzone";

  var pm,
      hm = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let dm = pm = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this.bicubicFiltering = !0, this._defines = {
        CUSTOM_BUMP_MAP_DEBUG: !1,
        CUSTOM_BUMP_MAP_BICUBIC: !0
      }, this._uniforms = {
        customBumpUvTransform: {
          value: new i.Vkp()
        },
        customBumpScale: {
          value: .001
        },
        customBumpMap: {
          value: null
        }
      }, this.materialExtension = {
        parsFragmentSnippet: (e, t) => this.enabled && (null == t ? void 0 : t.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "",
        shaderExtender: (e, t, n) => {
          var r;
          this.enabled && t.materialObject.userData._hasCustomBump && (null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._customBumpMap) && (e.fragmentShader = V_(e.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = V_(e.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", {
            prepend: !0
          }), e.vertexShader = V_(e.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", {
            prepend: !0
          }), e.vertexUvs = !0);
        },
        onObjectRender: (e, t) => {
          var n;
          const r = t.materialObject.userData;
          if (!(null == r ? void 0 : r._hasCustomBump)) return;
          const i = e;
          if (!i.isMesh || !i.geometry) return;
          const s = (null === (n = r._customBumpMap) || void 0 === n ? void 0 : n.isTexture) ? r._customBumpMap : null;
          this._uniforms.customBumpMap.value = s, this._uniforms.customBumpScale.value = s ? r._customBumpScale : 0, s && (s.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s.matrix));
          let o = this.enabled && s ? 1 : 0;
          t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o, t.materialObject.needsUpdate = !0);
        },
        extraUniforms: { ...this._uniforms
        },
        computeCacheKey: e => {
          var t, n, r;
          return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._hasCustomBump) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._customBumpMap) || void 0 === r ? void 0 : r.uuid);
        },
        isCompatible: e => e.isMeshStandardMaterial2,
        updaters: () => [],
        getUiConfig: e => {
          const t = this.enableCustomBump,
                n = {
            type: "folder",
            label: "CustomBumpMap",
            children: [{
              type: "checkbox",
              label: "Enabled",

              get value() {
                return e.materialObject.userData._hasCustomBump || !1;
              },

              set value(r) {
                var i;
                r !== e.materialObject.userData._hasCustomBump && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._hasCustomBump = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0));
              },

              onChange: this.setDirty
            }, {
              type: "slider",
              label: "Bump Scale",
              hidden: () => !e.materialObject.userData._hasCustomBump,
              property: [e.materialObject.userData, "_customBumpScale"],
              onChange: this.setDirty
            }, {
              type: "image",
              label: "Bump Map",
              hidden: () => !e.materialObject.userData._hasCustomBump,
              property: [e.materialObject.userData, "_customBumpMap"],
              onChange: () => {
                e.materialObject.needsUpdate = !0, this.setDirty();
              }
            }]
          };
          return n;
        }
      }, this.setDirty = () => {
        var e, t, n;
        null === (t = (e = this.materialExtension).setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
      }, this.enableCustomBumpSelected = () => {
        var e, t, n;
        const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
        return "material" === (null == r ? void 0 : r.assetType) && this.enableCustomBump(r);
      }, this._loaderCreate = this._loaderCreate.bind(this);
    }

    enableCustomBump(e, t, n) {
      var r, i;
      const s = null === (r = e.materialObject) || void 0 === r ? void 0 : r.userData;
      if (!s) return !1;

      if (void 0 === s._hasCustomBump) {
        const e = s.appliedMeshes;
        let t = !0;
        if (e) for (const {
          geometry: n
        } of e) !n || n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1);
        if (!t) return !1;
      }

      return s._hasCustomBump = !0, s._customBumpScale = null !== (i = null != n ? n : s._customBumpScale) && void 0 !== i ? i : .001, s._customBumpMap = null != t ? t : s._customBumpMap, e.materialObject.needsUpdate = !0, !0;
    }

    _loaderCreate({
      loader: e
    }) {
      e.isGLTFLoader2 && e.register(e => new fm(e));
    }

    async onAdded(e) {
      var t, n, r, i, s;
      await super.onAdded(e);
      const o = e.getPlugin(Vs);
      null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(_m);
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e);
    }

  };
  dm.PluginType = "CustomBumpMapPlugin", dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", hm([Ve("Enabled", e => ({
    onChange: e.setDirty
  })), xe()], dm.prototype, "enabled", void 0), hm([Ve("Bicubic", e => ({
    onChange: e.setDirty
  })), G("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, pm.prototype.setDirty), xe()], dm.prototype, "bicubicFiltering", void 0), hm([Xe("Enable CustomBumpMap", e => ({
    hidden: () => {
      var t;
      return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca));
    }
  }))], dm.prototype, "enableCustomBumpSelected", void 0), dm = pm = hm([Qe("CustomBumpMap Materials")], dm);

  class fm {
    constructor(e) {
      this.parser = e, this.name = dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    }

    async extendMaterialParams(e, t) {
      var n;
      const r = this.parser,
            s = r.json.materials[e];
      if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
      const o = [],
            a = s.extensions[this.name];
      t.userData || (t.userData = {}), t.userData._hasCustomBump = !0, t.userData._customBumpScale = null !== (n = a.customBumpScale) && void 0 !== n ? n : 0;
      const l = a.customBumpMap;
      return l && o.push(r.assignTexture(t.userData, "_customBumpMap", l).then(e => {
        e.encoding = i.knz;
      })), Promise.all(o);
    }

  }

  const _m = e => ({
    writeMaterial: (t, n) => {
      if (!t.isMeshStandardMaterial || !t.userData._hasCustomBump) return;
      if ((t.userData._customBumpScale || 0) < .001) return;
      n.extensions = n.extensions || {};
      const r = {};

      if (r.customBumpScale = t.userData._customBumpScale || 1, t.userData._customBumpMap) {
        const n = {
          index: e.processTexture(t.userData._customBumpMap)
        };
        e.applyTextureTransform(n, t.userData._customBumpMap), r.customBumpMap = n;
      }

      n.extensions[dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = r, e.extensionsUsed[dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = !0;
    }
  });

  var mm = __webpackgi_require__(701),
      gm = __webpackgi_require__.n(mm),
      vm = __webpackgi_require__(236),
      bm = __webpackgi_require__.n(vm),
      xm = __webpackgi_require__(80),
      ym = __webpackgi_require__.n(xm),
      wm = __webpackgi_require__(850),
      Sm = __webpackgi_require__.n(wm),
      Mm = __webpackgi_require__(182),
      Tm = __webpackgi_require__.n(Mm),
      Em = __webpackgi_require__(213),
      Am = __webpackgi_require__.n(Em),
      Cm = __webpackgi_require__(987),
      Rm = {};

  Rm.styleTagTransform = Am(), Rm.setAttributes = Sm(), Rm.insert = ym().bind(null, "head"), Rm.domAPI = bm(), Rm.insertStyleElement = Tm(), gm()(Cm.Z, Rm), Cm.Z && Cm.Z.locals && Cm.Z.locals;

  var km,
      Pm = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let Dm = km = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.dependencies = [Vs], this._popupDiv = wt({
        id: "assetManagerPopup",
        addToBody: !1,
        innerHTML: ""
      });
      const e = wt({
        id: "assetManagerPopupClose",
        addToBody: !1,
        innerHTML: "&#10005"
      });
      e.addEventListener("click", () => {
        this._popupDiv.style.display = "none";
      }), this._popupContent = wt({
        id: "assetManagerPopupContent",
        addToBody: !1,
        innerHTML: ""
      }), this.enabled || (this._popupDiv.style.display = "none"), this._popupDiv.appendChild(e), this._popupDiv.appendChild(this._popupContent);
    }

    _onEnabledChange() {
      this.enabled || (this._popupDiv.style.display = "none");
    }

    _updatePopupDiv(e) {
      if (!this._popupContent) return;
      if (!this.enabled) return void (this._popupDiv.style.display = "none");
      let t = "";
      e.forEach((e, n) => {
        t += `<span class="processState">${e}</span>: ${n.split("/").pop()}<br>`;
      }), this._popupContent.innerHTML = t, 0 === e.size ? this._popupDiv.style.display = "none" : this._popupDiv.style.display = "block";
    }

    async onAdded(e) {
      var t, n, r, i;
      await super.onAdded(e), e.container.appendChild(this._popupDiv);
      const s = new Map();
      null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("importFile", e => {
        "done" !== e.state ? s.set(e.path, e.state) : s.delete(e.path), this._updatePopupDiv(s);
      }), null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.exporter) || void 0 === i || i.addEventListener("exportFile", e => {
        "done" !== e.state ? s.set(e.obj.name, e.state) : s.delete(e.obj.name), this._updatePopupDiv(s);
      });
    }

  };

  async function Om(e, {
    ground: t = !0,
    bloom: n = !0,
    depthTonemap: r = !1
  } = {}) {
    await e.addPlugin(Ys), await e.addPlugin($_), await e.addPlugin(new co(32)), await e.addPlugin(new fo(r || !e.useRgbm)), await e.addPlugin(To), await e.addPlugin(ko), await e.addPlugin(Pa), await e.addPlugin(Ea), await e.addPlugin(wc), t && (await e.addPlugin(Z_)), n && (await e.addPlugin(Cc)), await e.addPlugin(kc), await e.addPlugin(ru), await e.addPlugin(xu), await e.addPlugin(dm), await e.addPlugin(lu), await e.addPlugin(B_, !1), await e.addPlugin(Lc), await e.addPlugin(zc), await e.addPlugin($c, !1), await e.addPlugin(tu, !1), await e.addPlugin(vu, !1), await e.addPlugin(tm, !1), await e.addPlugin(L_), await e.addPlugin(lm);
  }

  async function Lm(e, {
    debug: t = !1,
    ground: n = !0,
    bloom: r = !0,
    depthTonemap: i = !1,
    importPopup: s = !0
  } = {}) {
    var o;
    const a = new ro(e);
    t && (await a.addPlugin(j_));
    const l = await a.addPlugin(Vs, void 0, void 0, {
      storage: caches ? await caches.open("webgi-cache-storage") : void 0
    });
    return s && (await a.addPlugin(Dm)), await Om(a, {
      ground: n,
      bloom: r,
      depthTonemap: i
    }), a.renderer.refreshPipeline(), null === (o = l.importer) || void 0 === o || o.processors.add("model", {
      forAssetType: "model",
      process: (e, t) => e
    }), a;
  }

  Dm.PluginType = "AssetImportPopupPluginBasic", Pm([Ve("Enabled"), C(km.prototype._onEnabledChange), xe()], Dm.prototype, "enabled", void 0), Dm = km = Pm([Qe("Asset import popup")], Dm);
  let Im = 0;

  class Fm extends HTMLElement {
    constructor() {
      super(), this._initialized = !1, this._state = {
        src: "",
        environment: ""
      }, this._models = {}, this._refreshingModels = !1, this._refreshingEnvironment = !1, this.viewerIndex = Im++, this.canvasId = "webgi-viewer-" + this.viewerIndex, this.attachShadow({
        mode: "open"
      }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block", this.canvas = mt(), this.canvas.setAttribute("id", this.canvasId);
      const e = document.createElement("style");
      e.textContent = T`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
        `, this.wrapper.append(this.canvas), this.shadowRoot.append(e, this.wrapper), this._initialize().then(async () => this.refreshAll());
    }

    async refreshAll() {
      await Promise.all([this.refreshModelSource(), this.refreshEnvironment()]);
    }

    async _initialize() {
      this._initialized || (this.viewer = await Lm({
        canvas: this.canvas,
        useRgbm: "true" === this._getAttr("rgbm", "true"),
        useGBufferDepth: "true" === this._getAttr("depth-prepass", "true")
      }, {
        debug: "true" === this._getAttr("debug", "false"),
        ground: "baked" === this._getAttr("ground", "baked"),
        bloom: "true" === this._getAttr("bloom", "true"),
        depthTonemap: !0
      }), this._initialized = !0, this.dispatchEvent(new Event("initialized")));
    }

    connectedCallback() {
      console.log("WebGiViewerElement added to page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }

    disconnectedCallback() {
      console.log("WebGiViewerElement removed from page."), this.viewer && (this.viewer.enabled = !1);
    }

    adoptedCallback() {
      console.log("WebGiViewerElement moved to new page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0);
    }

    static get observedAttributes() {
      return ["src", "environment"];
    }

    attributeChangedCallback(e, t, n) {
      console.log("WebGiViewerElement attributes changed.", e, t, n), this.refreshAll();
    }

    clearModels() {}

    async refreshModelSource() {
      if (!this.viewer) return;

      const e = this._getAttr("src", "");

      if (e === this._state.src) return;
      if (this._refreshingModels) return;
      this._refreshingModels = !0;
      const t = [e],
            n = [],
            r = [];

      for (const e of t) !this._models[e] && e && (this._models[e] = this.viewer.getManager().importer.importPath(e, {
        autoScale: this._getAttr("auto-scale", "true"),
        autoCenter: this._getAttr("auto-center", "true"),
        processImported: !1
      }));

      for (const [e, i] of Object.entries(this._models)) t.includes(e) ? n.push(i) : r.push(i);

      await Promise.all([Promise.all(n).then(async e => Promise.all(e.map(async e => this.viewer.getManager().importer.processImported(e)))).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && this.viewer.scene.addSceneObject(e);
      }), Promise.all(r).then(e => {
        for (const t of e) for (const e of t) e && "model" === e.assetType && e.modelObject.removeFromParent();
      })]), this._state.src = e, this._refreshingModels = !1;
    }

    async refreshEnvironment() {
      if (!this.viewer) return;
      if (!this.hasAttribute("environment")) return void (this._state.environment = null);

      const e = this._getAttr("environment", "");

      if (e === this._state.src) return;
      if (this._refreshingEnvironment) return;
      this._refreshingEnvironment = !0;
      const t = this.viewer.scene.getEnvironment(),
            n = e ? await this.viewer.getManager().importer.importSinglePath(e) : void 0;
      n && "texture" !== n.assetType || (await this.viewer.scene.setEnvironment(n)), null == t || t.dispose(), this._state.environment = e, this._refreshingEnvironment = !1;
    }

    _getAttr(e, t) {
      return this.hasAttribute(e) ? this.getAttribute(e) : t;
    }

  }

  window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", Fm);

  class Nm {
    constructor(e) {
      var t, n, r;
      this._basePath = null !== (t = null == e ? void 0 : e.basePath) && void 0 !== t ? t : "", this._assets = null !== (r = null === (n = null == e ? void 0 : e.assets) || void 0 === n ? void 0 : n.map(e => this._resolveAsset(e))) && void 0 !== r ? r : [];
    }

    get basePath() {
      return this._basePath;
    }

    get assets() {
      return this._assets;
    }

    find(e) {
      const t = this._assets.find(e);

      return null != t ? t : void 0;
    }

    _resolveAsset(e) {
      return { ...e,
        path: gt([this._basePath, e.path])
      };
    }

  }

  class Um extends r {
    constructor(...e) {
      super(), this._assets = e;
    }

    addAssetList(e) {
      this._assets.push(e);
    }

    removeAssetList(e) {
      const t = this._assets.indexOf(e);

      t >= 0 && this._assets.splice(t, 1);
    }

    async findAssetRegex(e) {
      for (const t of this._assets) {
        const n = t.find(t => {
          var n, r;
          return t && (e.test(t.path) || e.test(null !== (r = null === (n = t.file) || void 0 === n ? void 0 : n.name) && void 0 !== r ? r : ""));
        });
        if (n) return n;
      }

      console.warn("Asset not found:", e);
    }

    async findAsset(e) {
      return this.findAssetRegex(e.query);
    }

    async findAssetSimple(e, t = !1) {
      return this.findAssetRegex(new RegExp(e, t ? "i" : ""));
    }

  }

  var Bm = {},
      jm = function (e) {
    return URL.createObjectURL(new Blob([e], {
      type: "text/javascript"
    }));
  },
      zm = function (e) {
    return new Worker(e);
  };

  try {
    URL.revokeObjectURL(jm(""));
  } catch (Eu) {
    jm = function (e) {
      return "data:application/javascript;charset=UTF-8," + encodeURI(e);
    }, zm = function (e) {
      return new Worker(e, {
        type: "module"
      });
    };
  }

  var Vm = Uint8Array,
      Gm = Uint16Array,
      Hm = Uint32Array,
      Wm = new Vm([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
      Km = new Vm([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
      Xm = new Vm([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
      qm = function (e, t) {
    for (var n = new Gm(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];

    var i = new Hm(n[30]);

    for (r = 1; r < 30; ++r) for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;

    return [n, i];
  },
      Ym = qm(Wm, 2),
      Zm = Ym[0],
      Jm = Ym[1];

  Zm[28] = 258, Jm[258] = 28;

  for (var $m = qm(Km, 0), Qm = $m[0], eg = $m[1], tg = new Gm(32768), ng = 0; ng < 32768; ++ng) {
    var rg = (43690 & ng) >>> 1 | (21845 & ng) << 1;
    rg = (61680 & (rg = (52428 & rg) >>> 2 | (13107 & rg) << 2)) >>> 4 | (3855 & rg) << 4, tg[ng] = ((65280 & rg) >>> 8 | (255 & rg) << 8) >>> 1;
  }

  var ig = function (e, t, n) {
    for (var r = e.length, i = 0, s = new Gm(t); i < r; ++i) ++s[e[i] - 1];

    var o,
        a = new Gm(t);

    for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;

    if (n) {
      o = new Gm(1 << t);
      var l = 15 - t;

      for (i = 0; i < r; ++i) if (e[i]) for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[tg[p] >>> l] = c;
    } else for (o = new Gm(r), i = 0; i < r; ++i) e[i] && (o[i] = tg[a[e[i] - 1]++] >>> 15 - e[i]);

    return o;
  },
      sg = new Vm(288);

  for (ng = 0; ng < 144; ++ng) sg[ng] = 8;

  for (ng = 144; ng < 256; ++ng) sg[ng] = 9;

  for (ng = 256; ng < 280; ++ng) sg[ng] = 7;

  for (ng = 280; ng < 288; ++ng) sg[ng] = 8;

  var og = new Vm(32);

  for (ng = 0; ng < 32; ++ng) og[ng] = 5;

  var ag = ig(sg, 9, 0),
      lg = ig(sg, 9, 1),
      cg = ig(og, 5, 0),
      ug = ig(og, 5, 1),
      pg = function (e) {
    for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);

    return t;
  },
      hg = function (e, t, n) {
    var r = t / 8 | 0;
    return (e[r] | e[r + 1] << 8) >> (7 & t) & n;
  },
      dg = function (e, t) {
    var n = t / 8 | 0;
    return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t);
  },
      fg = function (e) {
    return (e / 8 | 0) + (7 & e && 1);
  },
      _g = function (e, t, n) {
    (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
    var r = new (e instanceof Gm ? Gm : e instanceof Hm ? Hm : Vm)(n - t);
    return r.set(e.subarray(t, n)), r;
  },
      mg = function (e, t, n) {
    var r = e.length;
    if (!r || n && !n.l && r < 5) return t || new Vm(0);
    var i = !t || n,
        s = !n || n.i;
    n || (n = {}), t || (t = new Vm(3 * r));

    var o = function (e) {
      var n = t.length;

      if (e > n) {
        var r = new Vm(Math.max(2 * n, e));
        r.set(t), t = r;
      }
    },
        a = n.f || 0,
        l = n.p || 0,
        c = n.b || 0,
        u = n.l,
        p = n.d,
        h = n.m,
        d = n.n,
        f = 8 * r;

    do {
      if (!u) {
        n.f = a = hg(e, l, 1);

        var _ = hg(e, l + 1, 3);

        if (l += 3, !_) {
          var m = e[(A = fg(l) + 4) - 4] | e[A - 3] << 8,
              g = A + m;

          if (g > r) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
          continue;
        }

        if (1 == _) u = lg, p = ug, h = 9, d = 5;else {
          if (2 != _) throw "invalid block type";
          var v = hg(e, l, 31) + 257,
              b = hg(e, l + 10, 15) + 4,
              x = v + hg(e, l + 5, 31) + 1;
          l += 14;

          for (var y = new Vm(x), w = new Vm(19), S = 0; S < b; ++S) w[Xm[S]] = hg(e, l + 3 * S, 7);

          l += 3 * b;
          var M = pg(w),
              T = (1 << M) - 1,
              E = ig(w, M, 1);

          for (S = 0; S < x;) {
            var A,
                C = E[hg(e, l, T)];
            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;else {
              var R = 0,
                  k = 0;

              for (16 == A ? (k = 3 + hg(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + hg(e, l, 7), l += 3) : 18 == A && (k = 11 + hg(e, l, 127), l += 7); k--;) y[S++] = R;
            }
          }

          var P = y.subarray(0, v),
              D = y.subarray(v);
          h = pg(P), d = pg(D), u = ig(P, h, 1), p = ig(D, d, 1);
        }

        if (l > f) {
          if (s) throw "unexpected EOF";
          break;
        }
      }

      i && o(c + 131072);

      for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
        var F = (R = u[dg(e, l) & O]) >>> 4;

        if ((l += 15 & R) > f) {
          if (s) throw "unexpected EOF";
          break;
        }

        if (!R) throw "invalid length/literal";
        if (F < 256) t[c++] = F;else {
          if (256 == F) {
            I = l, u = null;
            break;
          }

          var N = F - 254;

          if (F > 264) {
            var U = Wm[S = F - 257];
            N = hg(e, l, (1 << U) - 1) + Zm[S], l += U;
          }

          var B = p[dg(e, l) & L],
              j = B >>> 4;
          if (!B) throw "invalid distance";

          if (l += 15 & B, D = Qm[j], j > 3 && (U = Km[j], D += dg(e, l) & (1 << U) - 1, l += U), l > f) {
            if (s) throw "unexpected EOF";
            break;
          }

          i && o(c + 131072);

          for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];

          c = z;
        }
      }

      n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d);
    } while (!a);

    return c == t.length ? t : _g(t, 0, c);
  },
      gg = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8;
  },
      vg = function (e, t, n) {
    n <<= 7 & t;
    var r = t / 8 | 0;
    e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16;
  },
      bg = function (e, t) {
    for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
      s: r,
      f: e[r]
    });

    var i = n.length,
        s = n.slice();
    if (!i) return [Eg, 0];

    if (1 == i) {
      var o = new Vm(n[0].s + 1);
      return o[n[0].s] = 1, [o, 1];
    }

    n.sort(function (e, t) {
      return e.f - t.f;
    }), n.push({
      s: -1,
      f: 25001
    });
    var a = n[0],
        l = n[1],
        c = 0,
        u = 1,
        p = 2;

    for (n[0] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
      s: -1,
      f: a.f + l.f,
      l: a,
      r: l
    };

    var h = s[0].s;

    for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);

    var d = new Gm(h + 1),
        f = xg(n[u - 1], d, 0);

    if (f > t) {
      r = 0;
      var _ = 0,
          m = f - t,
          g = 1 << m;

      for (s.sort(function (e, t) {
        return d[t.s] - d[e.s] || e.f - t.f;
      }); r < i; ++r) {
        var v = s[r].s;
        if (!(d[v] > t)) break;
        _ += g - (1 << f - d[v]), d[v] = t;
      }

      for (_ >>>= m; _ > 0;) {
        var b = s[r].s;
        d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r;
      }

      for (; r >= 0 && _; --r) {
        var x = s[r].s;
        d[x] == t && (--d[x], ++_);
      }

      f = t;
    }

    return [new Vm(d), f];
  },
      xg = function (e, t, n) {
    return -1 == e.s ? Math.max(xg(e.l, t, n + 1), xg(e.r, t, n + 1)) : t[e.s] = n;
  },
      yg = function (e) {
    for (var t = e.length; t && !e[--t];);

    for (var n = new Gm(++t), r = 0, i = e[0], s = 1, o = function (e) {
      n[r++] = e;
    }, a = 1; a <= t; ++a) if (e[a] == i && a != t) ++s;else {
      if (!i && s > 2) {
        for (; s > 138; s -= 138) o(32754);

        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(i), --s; s > 6; s -= 6) o(8304);

        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }

      for (; s--;) o(i);

      s = 1, i = e[a];
    }

    return [n.subarray(0, r), t];
  },
      wg = function (e, t) {
    for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];

    return n;
  },
      Sg = function (e, t, n) {
    var r = n.length,
        i = fg(t + 2);
    e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];

    for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];

    return 8 * (i + 4 + r);
  },
      Mg = function (e, t, n, r, i, s, o, a, l, c, u) {
    gg(t, u++, n), ++i[256];

    for (var p = bg(i, 15), h = p[0], d = p[1], f = bg(s, 15), _ = f[0], m = f[1], g = yg(h), v = g[0], b = g[1], x = yg(_), y = x[0], w = x[1], S = new Gm(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;

    for (M = 0; M < y.length; ++M) S[31 & y[M]]++;

    for (var T = bg(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[Xm[C - 1]]; --C);

    var R,
        k,
        P,
        D,
        O = c + 5 << 3,
        L = wg(i, sg) + wg(s, og) + o,
        I = wg(i, h) + wg(s, _) + o + 14 + 3 * C + wg(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
    if (O <= L && O <= I) return Sg(t, u, e.subarray(l, l + c));

    if (gg(t, u, 1 + (I < L)), u += 2, I < L) {
      R = ig(h, d, 0), k = h, P = ig(_, m, 0), D = _;
      var F = ig(E, A, 0);

      for (gg(t, u, b - 257), gg(t, u + 5, w - 1), gg(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) gg(t, u + 3 * M, E[Xm[M]]);

      u += 3 * C;

      for (var N = [v, y], U = 0; U < 2; ++U) {
        var B = N[U];

        for (M = 0; M < B.length; ++M) {
          var j = 31 & B[M];
          gg(t, u, F[j]), u += E[j], j > 15 && (gg(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12);
        }
      }
    } else R = ag, k = sg, P = cg, D = og;

    for (M = 0; M < a; ++M) if (r[M] > 255) {
      j = r[M] >>> 18 & 31, vg(t, u, R[j + 257]), u += k[j + 257], j > 7 && (gg(t, u, r[M] >>> 23 & 31), u += Wm[j]);
      var z = 31 & r[M];
      vg(t, u, P[z]), u += D[z], z > 3 && (vg(t, u, r[M] >>> 5 & 8191), u += Km[z]);
    } else vg(t, u, R[r[M]]), u += k[r[M]];

    return vg(t, u, R[256]), u + k[256];
  },
      Tg = new Hm([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
      Eg = new Vm(0),
      Ag = function (e, t, n, r, i, s) {
    var o = e.length,
        a = new Vm(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
        l = a.subarray(r, a.length - i),
        c = 0;
    if (!t || o < 8) for (var u = 0; u <= o; u += 65535) {
      var p = u + 65535;
      p < o ? c = Sg(l, c, e.subarray(u, p)) : (l[u] = s, c = Sg(l, c, e.subarray(u, o)));
    } else {
      for (var h = Tg[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new Gm(32768), g = new Gm(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function (t) {
        return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _;
      }, y = new Hm(25e3), w = new Gm(288), S = new Gm(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
        var R = x(u),
            k = 32767 & u,
            P = g[R];

        if (m[k] = P, g[R] = k, A <= u) {
          var D = o - u;

          if ((M > 7e3 || E > 24576) && D > 423) {
            c = Mg(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;

            for (var O = 0; O < 286; ++O) w[O] = 0;

            for (O = 0; O < 30; ++O) S[O] = 0;
          }

          var L = 2,
              I = 0,
              F = f,
              N = k - P & 32767;
          if (D > 2 && R == x(u - N)) for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
            if (e[u + L] == e[u + L - N]) {
              for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);

              if (z > L) {
                if (L = z, I = N, z > U) break;
                var V = Math.min(N, z - 2),
                    G = 0;

                for (O = 0; O < V; ++O) {
                  var H = u - N + O + 32768 & 32767,
                      W = H - m[H] + 32768 & 32767;
                  W > G && (G = W, P = H);
                }
              }
            }

            N += (k = P) - (P = m[k]) + 32768 & 32767;
          }

          if (I) {
            y[E++] = 268435456 | Jm[L] << 18 | eg[I];
            var K = 31 & Jm[L],
                X = 31 & eg[I];
            T += Wm[K] + Km[X], ++w[257 + K], ++S[X], A = u + L, ++M;
          } else y[E++] = e[u], ++w[e[u]];
        }
      }

      c = Mg(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = Sg(l, c + 1, Eg));
    }
    return _g(a, 0, r + fg(c) + i);
  },
      Cg = function () {
    for (var e = new Hm(256), t = 0; t < 256; ++t) {
      for (var n = t, r = 9; --r;) n = (1 & n && 3988292384) ^ n >>> 1;

      e[t] = n;
    }

    return e;
  }(),
      Rg = function () {
    var e = -1;
    return {
      p: function (t) {
        for (var n = e, r = 0; r < t.length; ++r) n = Cg[255 & n ^ t[r]] ^ n >>> 8;

        e = n;
      },
      d: function () {
        return ~e;
      }
    };
  },
      kg = function () {
    var e = 1,
        t = 0;
    return {
      p: function (n) {
        for (var r = e, i = t, s = n.length, o = 0; o != s;) {
          for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];

          r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16);
        }

        e = r, t = i;
      },
      d: function () {
        return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8;
      }
    };
  },
      Pg = function (e, t, n, r, i) {
    return Ag(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i);
  },
      Dg = function (e, t) {
    var n = {};

    for (var r in e) n[r] = e[r];

    for (var r in t) n[r] = t[r];

    return n;
  },
      Og = function (e, t, n) {
    for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
      var a = r[o],
          l = s[o];

      if ("function" == typeof a) {
        t += ";" + l + "=";
        var c = a.toString();
        if (a.prototype) {
          if (-1 != c.indexOf("[native code]")) {
            var u = c.indexOf(" ", 8) + 1;
            t += c.slice(u, c.indexOf("(", u));
          } else for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
        } else t += c;
      } else n[l] = a;
    }

    return [t, n];
  },
      Lg = [],
      Ig = function (e, t, n, r) {
    var i;

    if (!Lg[n]) {
      for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = Og(e[l], s, o))[0], o = i[1];

      Lg[n] = Og(e[a], s, o);
    }

    var c = Dg({}, Lg[n][1]);
    return function (e, t, n, r, i) {
      var s = zm(Bm[t] || (Bm[t] = jm(e)));
      return s.onerror = function (e) {
        return i(e.error, null);
      }, s.onmessage = function (e) {
        return i(null, e.data);
      }, s.postMessage(n, r), s;
    }(Lg[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function (e) {
      var t = [];

      for (var n in e) (e[n] instanceof Vm || e[n] instanceof Gm || e[n] instanceof Hm) && t.push((e[n] = new e[n].constructor(e[n])).buffer);

      return t;
    }(c), r);
  },
      Fg = function () {
    return [Vm, Gm, Hm, Wm, Km, Xm, Zm, Qm, lg, ug, tg, ig, pg, hg, dg, fg, _g, mg, pv, Vg, Gg];
  },
      Ng = function () {
    return [Vm, Gm, Hm, Wm, Km, Xm, Jm, eg, ag, sg, cg, og, tg, Tg, Eg, ig, gg, vg, bg, xg, yg, wg, Sg, Mg, fg, _g, Ag, Pg, av, Vg];
  },
      Ug = function () {
    return [Jg, ev, Zg, Rg, Cg];
  },
      Bg = function () {
    return [$g, Qg];
  },
      jg = function () {
    return [tv, Zg, kg];
  },
      zg = function () {
    return [nv];
  },
      Vg = function (e) {
    return postMessage(e, [e.buffer]);
  },
      Gg = function (e) {
    return e && e.size && new Vm(e.size);
  },
      Hg = function (e, t, n, r, i, s) {
    var o = Ig(n, r, i, function (e, t) {
      o.terminate(), s(e, t);
    });
    return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () {
      o.terminate();
    };
  },
      Wg = function (e) {
    return e.ondata = function (e, t) {
      return postMessage([e, t], [e.buffer]);
    }, function (t) {
      return e.push(t.data[0], t.data[1]);
    };
  },
      Kg = function (e, t, n, r, i) {
    var s,
        o = Ig(e, r, i, function (e, n) {
      e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]));
    });
    o.postMessage(n), t.push = function (e, n) {
      if (s) throw "stream finished";
      if (!t.ondata) throw "no stream handler";
      o.postMessage([e, s = n], [e.buffer]);
    }, t.terminate = function () {
      o.terminate();
    };
  },
      Xg = function (e, t) {
    return e[t] | e[t + 1] << 8;
  },
      qg = function (e, t) {
    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
  },
      Yg = function (e, t) {
    return qg(e, t) + 4294967296 * qg(e, t + 4);
  },
      Zg = function (e, t, n) {
    for (; n; ++t) e[t] = n, n >>>= 8;
  },
      Jg = function (e, t) {
    var n = t.filename;

    if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Zg(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
      e[3] = 8;

      for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r);
    }
  },
      $g = function (e) {
    if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
    var t = e[3],
        n = 10;
    4 & t && (n += e[10] | 2 + (e[11] << 8));

    for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);

    return n + (2 & t);
  },
      Qg = function (e) {
    var t = e.length;
    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
  },
      ev = function (e) {
    return 10 + (e.filename && e.filename.length + 1 || 0);
  },
      tv = function (e, t) {
    var n = t.level,
        r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
    e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1);
  },
      nv = function (e) {
    if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
    if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported";
  };

  function rv(e, t) {
    return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e;
  }

  var iv = function () {
    function e(e, t) {
      t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {};
    }

    return e.prototype.p = function (e, t) {
      this.ondata(Pg(e, this.o, 0, 0, !t), t);
    }, e.prototype.push = function (e, t) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      this.d = t, this.p(e, t || !1);
    }, e;
  }(),
      sv = function () {
    return function (e, t) {
      Kg([Ng, function () {
        return [Wg, iv];
      }], this, rv.call(this, e, t), function (e) {
        var t = new iv(e.data);
        onmessage = Wg(t);
      }, 6);
    };
  }();

  function ov(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Ng], function (e) {
      return Vg(av(e.data[0], e.data[1]));
    }, 0, n);
  }

  function av(e, t) {
    return Pg(e, t || {}, 0, 0);
  }

  var lv = function () {
    function e(e) {
      this.s = {}, this.p = new Vm(0), this.ondata = e;
    }

    return e.prototype.e = function (e) {
      if (this.d) throw "stream finished";
      if (!this.ondata) throw "no stream handler";
      var t = this.p.length,
          n = new Vm(t + e.length);
      n.set(this.p), n.set(e, t), this.p = n;
    }, e.prototype.c = function (e) {
      this.d = this.s.i = e || !1;
      var t = this.s.b,
          n = mg(this.p, this.o, this.s);
      this.ondata(_g(n, t, this.s.b), this.d), this.o = _g(n, this.s.b - 32768), this.s.b = this.o.length, this.p = _g(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, e.prototype.push = function (e, t) {
      this.e(e), this.c(t);
    }, e;
  }(),
      cv = function () {
    return function (e) {
      this.ondata = e, Kg([Fg, function () {
        return [Wg, lv];
      }], this, 0, function () {
        var e = new lv();
        onmessage = Wg(e);
      }, 7);
    };
  }();

  function uv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Fg], function (e) {
      return Vg(pv(e.data[0], Gg(e.data[1])));
    }, 1, n);
  }

  function pv(e, t) {
    return mg(e, t);
  }

  var hv = function () {
    function e(e, t) {
      this.c = Rg(), this.l = 0, this.v = 1, iv.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      iv.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e), this.l += e.length;
      var n = Pg(e, this.o, this.v && ev(this.o), t && 8, !t);
      this.v && (Jg(n, this.o), this.v = 0), t && (Zg(n, n.length - 8, this.c.d()), Zg(n, n.length - 4, this.l)), this.ondata(n, t);
    }, e;
  }(),
      dv = function () {
    return function (e, t) {
      Kg([Ng, Ug, function () {
        return [Wg, iv, hv];
      }], this, rv.call(this, e, t), function (e) {
        var t = new hv(e.data);
        onmessage = Wg(t);
      }, 8);
    };
  }();

  function fv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Ng, Ug, function () {
      return [_v];
    }], function (e) {
      return Vg(_v(e.data[0], e.data[1]));
    }, 2, n);
  }

  function _v(e, t) {
    t || (t = {});
    var n = Rg(),
        r = e.length;
    n.p(e);
    var i = Pg(e, t, ev(t), 8),
        s = i.length;
    return Jg(i, t), Zg(i, s - 8, n.d()), Zg(i, s - 4, r), i;
  }

  var mv = function () {
    function e(e) {
      this.v = 1, lv.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (lv.prototype.e.call(this, e), this.v) {
        var n = this.p.length > 3 ? $g(this.p) : 4;
        if (n >= this.p.length && !t) return;
        this.p = this.p.subarray(n), this.v = 0;
      }

      if (t) {
        if (this.p.length < 8) throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }

      lv.prototype.c.call(this, t);
    }, e;
  }(),
      gv = function () {
    return function (e) {
      this.ondata = e, Kg([Fg, Bg, function () {
        return [Wg, lv, mv];
      }], this, 0, function () {
        var e = new mv();
        onmessage = Wg(e);
      }, 9);
    };
  }();

  function vv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Fg, Bg, function () {
      return [bv];
    }], function (e) {
      return Vg(bv(e.data[0]));
    }, 3, n);
  }

  function bv(e, t) {
    return mg(e.subarray($g(e), -8), t || new Vm(Qg(e)));
  }

  var xv = function () {
    function e(e, t) {
      this.c = kg(), this.v = 1, iv.call(this, e, t);
    }

    return e.prototype.push = function (e, t) {
      iv.prototype.push.call(this, e, t);
    }, e.prototype.p = function (e, t) {
      this.c.p(e);
      var n = Pg(e, this.o, this.v && 2, t && 4, !t);
      this.v && (tv(n, this.o), this.v = 0), t && Zg(n, n.length - 4, this.c.d()), this.ondata(n, t);
    }, e;
  }(),
      yv = function () {
    return function (e, t) {
      Kg([Ng, jg, function () {
        return [Wg, iv, xv];
      }], this, rv.call(this, e, t), function (e) {
        var t = new xv(e.data);
        onmessage = Wg(t);
      }, 10);
    };
  }();

  function wv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Ng, jg, function () {
      return [Sv];
    }], function (e) {
      return Vg(Sv(e.data[0], e.data[1]));
    }, 4, n);
  }

  function Sv(e, t) {
    t || (t = {});
    var n = kg();
    n.p(e);
    var r = Pg(e, t, 2, 4);
    return tv(r, t), Zg(r, r.length - 4, n.d()), r;
  }

  var Mv = function () {
    function e(e) {
      this.v = 1, lv.call(this, e);
    }

    return e.prototype.push = function (e, t) {
      if (lv.prototype.e.call(this, e), this.v) {
        if (this.p.length < 2 && !t) return;
        this.p = this.p.subarray(2), this.v = 0;
      }

      if (t) {
        if (this.p.length < 4) throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }

      lv.prototype.c.call(this, t);
    }, e;
  }(),
      Tv = function () {
    return function (e) {
      this.ondata = e, Kg([Fg, zg, function () {
        return [Wg, lv, Mv];
      }], this, 0, function () {
        var e = new Mv();
        onmessage = Wg(e);
      }, 11);
    };
  }();

  function Ev(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return Hg(e, t, [Fg, zg, function () {
      return [Av];
    }], function (e) {
      return Vg(Av(e.data[0], Gg(e.data[1])));
    }, 5, n);
  }

  function Av(e, t) {
    return mg((nv(e), e.subarray(2, -4)), t);
  }

  var Cv = function () {
    function e(e) {
      this.G = mv, this.I = lv, this.Z = Mv, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no stream handler";
      if (this.s) this.s.push(e, t);else {
        if (this.p && this.p.length) {
          var n = new Vm(this.p.length + e.length);
          n.set(this.p), n.set(e, this.p.length);
        } else this.p = e;

        if (this.p.length > 2) {
          var r = this,
              i = function () {
            r.ondata.apply(r, arguments);
          };

          this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null;
        }
      }
    }, e;
  }(),
      Rv = function () {
    function e(e) {
      this.G = gv, this.I = cv, this.Z = Tv, this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      Cv.prototype.push.call(this, e, t);
    }, e;
  }();

  function kv(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? vv(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? uv(e, t, n) : Ev(e, t, n);
  }

  function Pv(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2] ? bv(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? pv(e, t) : Av(e, t);
  }

  var Dv = function (e, t, n, r) {
    for (var i in e) {
      var s = e[i],
          o = t + i;
      s instanceof Vm ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], Dg(r, s[1])] : Dv(s, o + "/", n, r);
    }
  },
      Ov = "undefined" != typeof TextEncoder && new TextEncoder(),
      Lv = "undefined" != typeof TextDecoder && new TextDecoder(),
      Iv = 0;

  try {
    Lv.decode(Eg, {
      stream: !0
    }), Iv = 1;
  } catch (Eu) {}

  var Fv = function (e) {
    for (var t = "", n = 0;;) {
      var r = e[n++],
          i = (r > 127) + (r > 223) + (r > 239);
      if (n + i > e.length) return [t, _g(e, n - 1)];
      i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r);
    }
  },
      Nv = function () {
    function e(e) {
      this.ondata = e, Iv ? this.t = new TextDecoder() : this.p = Eg;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";

      if (t = !!t, this.t) {
        if (this.ondata(this.t.decode(e, {
          stream: !0
        }), t), t) {
          if (this.t.decode().length) throw "invalid utf-8 data";
          this.t = null;
        }
      } else {
        if (!this.p) throw "stream finished";
        var n = new Vm(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length);
        var r = Fv(n),
            i = r[0],
            s = r[1];

        if (t) {
          if (s.length) throw "invalid utf-8 data";
          this.p = null;
        } else this.p = s;

        this.ondata(i, t);
      }
    }, e;
  }(),
      Uv = function () {
    function e(e) {
      this.ondata = e;
    }

    return e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback";
      if (this.d) throw "stream finished";
      this.ondata(Bv(e), this.d = t || !1);
    }, e;
  }();

  function Bv(e, t) {
    if (t) {
      for (var n = new Vm(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);

      return n;
    }

    if (Ov) return Ov.encode(e);

    var i = e.length,
        s = new Vm(e.length + (e.length >> 1)),
        o = 0,
        a = function (e) {
      s[o++] = e;
    };

    for (r = 0; r < i; ++r) {
      if (o + 5 > s.length) {
        var l = new Vm(o + 8 + (i - r << 1));
        l.set(s), s = l;
      }

      var c = e.charCodeAt(r);
      c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c));
    }

    return _g(s, 0, o);
  }

  function jv(e, t) {
    if (t) {
      for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));

      return n;
    }

    if (Lv) return Lv.decode(e);
    var i = Fv(e),
        s = i[0];
    if (i[1].length) throw "invalid utf-8 data";
    return s;
  }

  var zv = function (e) {
    return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0;
  },
      Vv = function (e, t) {
    return t + 30 + Xg(e, t + 26) + Xg(e, t + 28);
  },
      Gv = function (e, t, n) {
    var r = Xg(e, t + 28),
        i = jv(e.subarray(t + 46, t + 46 + r), !(2048 & Xg(e, t + 8))),
        s = t + 46 + r,
        o = qg(e, t + 20),
        a = n && 4294967295 == o ? Hv(e, s) : [o, qg(e, t + 24), qg(e, t + 42)],
        l = a[0],
        c = a[1],
        u = a[2];
    return [Xg(e, t + 10), l, c, i, s + Xg(e, t + 30) + Xg(e, t + 32), u];
  },
      Hv = function (e, t) {
    for (; 1 != Xg(e, t); t += 4 + Xg(e, t + 2));

    return [Yg(e, t + 12), Yg(e, t + 4), Yg(e, t + 20)];
  },
      Wv = function (e) {
    var t = 0;
    if (e) for (var n in e) {
      var r = e[n].length;
      if (r > 65535) throw "extra field too long";
      t += r + 4;
    }
    return t;
  },
      Kv = function (e, t, n, r, i, s, o, a) {
    var l = r.length,
        c = n.extra,
        u = a && a.length,
        p = Wv(c);
    Zg(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
    var h = new Date(null == n.mtime ? Date.now() : n.mtime),
        d = h.getFullYear() - 1980;
    if (d < 0 || d > 119) throw "date not in range 1980-2099";
    if (Zg(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (Zg(e, t, n.crc), Zg(e, t + 4, s), Zg(e, t + 8, n.size)), Zg(e, t + 12, l), Zg(e, t + 14, p), t += 16, null != o && (Zg(e, t, u), Zg(e, t + 6, n.attrs), Zg(e, t + 10, o), t += 14), e.set(r, t), t += l, p) for (var f in c) {
      var _ = c[f],
          m = _.length;
      Zg(e, t, +f), Zg(e, t + 2, m), e.set(_, t + 4), t += 4 + m;
    }
    return u && (e.set(a, t), t += u), t;
  },
      Xv = function (e, t, n, r, i) {
    Zg(e, t, 101010256), Zg(e, t + 8, n), Zg(e, t + 10, n), Zg(e, t + 12, r), Zg(e, t + 16, i);
  },
      qv = function () {
    function e(e) {
      this.filename = e, this.c = Rg(), this.size = 0, this.compression = 0;
    }

    return e.prototype.process = function (e, t) {
      this.ondata(null, e, t);
    }, e.prototype.push = function (e, t) {
      if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
      this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1);
    }, e;
  }(),
      Yv = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), qv.call(this, e), this.d = new iv(t, function (e, t) {
        n.ondata(null, e, t);
      }), this.compression = 8, this.flag = zv(t.level);
    }

    return e.prototype.process = function (e, t) {
      try {
        this.d.push(e, t);
      } catch (e) {
        this.ondata(e, null, t);
      }
    }, e.prototype.push = function (e, t) {
      qv.prototype.push.call(this, e, t);
    }, e;
  }(),
      Zv = function () {
    function e(e, t) {
      var n = this;
      t || (t = {}), qv.call(this, e), this.d = new sv(t, function (e, t, r) {
        n.ondata(e, t, r);
      }), this.compression = 8, this.flag = zv(t.level), this.terminate = this.d.terminate;
    }

    return e.prototype.process = function (e, t) {
      this.d.push(e, t);
    }, e.prototype.push = function (e, t) {
      qv.prototype.push.call(this, e, t);
    }, e;
  }(),
      Jv = function () {
    function e(e) {
      this.ondata = e, this.u = [], this.d = 1;
    }

    return e.prototype.add = function (e) {
      var t = this;
      if (2 & this.d) throw "stream finished";
      var n = Bv(e.filename),
          r = n.length,
          i = e.comment,
          s = i && Bv(i),
          o = r != e.filename.length || s && i.length != s.length,
          a = r + Wv(e.extra) + 30;
      if (r > 65535) throw "filename too long";
      var l = new Vm(a);
      Kv(l, 0, e, n, o);

      var c = [l],
          u = function () {
        for (var e = 0, n = c; e < n.length; e++) {
          var r = n[e];
          t.ondata(null, r, !1);
        }

        c = [];
      },
          p = this.d;

      this.d = 0;
      var h = this.u.length,
          d = Dg(e, {
        f: n,
        u: o,
        o: s,
        t: function () {
          e.terminate && e.terminate();
        },
        r: function () {
          if (u(), p) {
            var e = t.u[h + 1];
            e ? e.r() : t.d = 1;
          }

          p = 1;
        }
      }),
          f = 0;
      e.ondata = function (n, r, i) {
        if (n) t.ondata(n, r, i), t.terminate();else if (f += r.length, c.push(r), i) {
          var s = new Vm(16);
          Zg(s, 0, 134695760), Zg(s, 4, e.crc), Zg(s, 8, f), Zg(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1;
        } else p && u();
      }, this.u.push(d);
    }, e.prototype.end = function () {
      var e = this;

      if (2 & this.d) {
        if (1 & this.d) throw "stream finishing";
        throw "stream finished";
      }

      this.d ? this.e() : this.u.push({
        r: function () {
          1 & e.d && (e.u.splice(-1, 1), e.e());
        },
        t: function () {}
      }), this.d = 3;
    }, e.prototype.e = function () {
      for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + Wv(l.extra) + (l.o ? l.o.length : 0);

      for (var s = new Vm(n + 22), o = 0, a = this.u; o < a.length; o++) {
        var l = a[o];
        Kv(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + Wv(l.extra) + (l.o ? l.o.length : 0), t += l.b;
      }

      Xv(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2;
    }, e.prototype.terminate = function () {
      for (var e = 0, t = this.u; e < t.length; e++) t[e].t();

      this.d = 2;
    }, e;
  }();

  function $v(e, t, n) {
    if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
    var r = {};
    Dv(e, "", r, t);

    var i = Object.keys(r),
        s = i.length,
        o = 0,
        a = 0,
        l = s,
        c = new Array(s),
        u = [],
        p = function () {
      for (var e = 0; e < u.length; ++e) u[e]();
    },
        h = function () {
      var e = new Vm(a + 22),
          t = o,
          r = a - o;
      a = 0;

      for (var i = 0; i < l; ++i) {
        var s = c[i];

        try {
          var u = s.c.length;
          Kv(e, a, s, s.f, s.u, u);
          var p = 30 + s.f.length + Wv(s.extra),
              h = a + p;
          e.set(s.c, h), Kv(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u;
        } catch (e) {
          return n(e, null);
        }
      }

      Xv(e, o, c.length, r, t), n(null, e);
    };

    s || h();

    for (var d = function (e) {
      var t = i[e],
          l = r[t],
          d = l[0],
          f = l[1],
          _ = Rg(),
          m = d.length;

      _.p(d);

      var g = Bv(t),
          v = g.length,
          b = f.comment,
          x = b && Bv(b),
          y = x && x.length,
          w = Wv(f.extra),
          S = 0 == f.level ? 0 : 8,
          M = function (r, i) {
        if (r) p(), n(r, null);else {
          var l = i.length;
          c[e] = Dg(f, {
            size: m,
            crc: _.d(),
            c: i,
            f: g,
            m: x,
            u: v != t.length || x && b.length != y,
            compression: S
          }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h();
        }
      };

      if (v > 65535 && M("filename too long", null), S) {
        if (m < 16e4) try {
          M(null, av(d, f));
        } catch (e) {
          M(e, null);
        } else u.push(ov(d, f, M));
      } else M(null, d);
    }, f = 0; f < l; ++f) d(f);

    return p;
  }

  function Qv(e, t) {
    t || (t = {});
    var n = {},
        r = [];
    Dv(e, "", n, t);
    var i = 0,
        s = 0;

    for (var o in n) {
      var a = n[o],
          l = a[0],
          c = a[1],
          u = 0 == c.level ? 0 : 8,
          p = (S = Bv(o)).length,
          h = c.comment,
          d = h && Bv(h),
          f = d && d.length,
          _ = Wv(c.extra);

      if (p > 65535) throw "filename too long";
      var m = u ? av(l, c) : l,
          g = m.length,
          v = Rg();
      v.p(l), r.push(Dg(c, {
        size: l.length,
        crc: v.d(),
        c: m,
        f: S,
        m: d,
        u: p != o.length || d && h.length != f,
        o: i,
        compression: u
      })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g;
    }

    for (var b = new Vm(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
      var S = r[w];
      Kv(b, S.o, S, S.f, S.u, S.c.length);
      var M = 30 + S.f.length + Wv(S.extra);
      b.set(S.c, S.o + M), Kv(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0);
    }

    return Xv(b, i, r.length, y, x), b;
  }

  var eb = function () {
    function e() {}

    return e.prototype.push = function (e, t) {
      this.ondata(null, e, t);
    }, e.compression = 0, e;
  }(),
      tb = function () {
    function e() {
      var e = this;
      this.i = new lv(function (t, n) {
        e.ondata(null, t, n);
      });
    }

    return e.prototype.push = function (e, t) {
      try {
        this.i.push(e, t);
      } catch (n) {
        this.ondata(n, e, t);
      }
    }, e.compression = 8, e;
  }(),
      nb = function () {
    function e(e, t) {
      var n = this;
      t < 32e4 ? this.i = new lv(function (e, t) {
        n.ondata(null, e, t);
      }) : (this.i = new cv(function (e, t, r) {
        n.ondata(e, t, r);
      }), this.terminate = this.i.terminate);
    }

    return e.prototype.push = function (e, t) {
      this.i.terminate && (e = _g(e, 0)), this.i.push(e, t);
    }, e.compression = 8, e;
  }(),
      rb = function () {
    function e(e) {
      this.onfile = e, this.k = [], this.o = {
        0: eb
      }, this.p = Eg;
    }

    return e.prototype.push = function (e, t) {
      var n = this;
      if (!this.onfile) throw "no callback";
      if (!this.p) throw "stream finished";

      if (this.c > 0) {
        var r = Math.min(this.c, e.length),
            i = e.subarray(0, r);
        if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t);
      } else {
        var s = 0,
            o = 0,
            a = void 0,
            l = void 0;
        this.p.length ? e.length ? ((l = new Vm(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;

        for (var c = l.length, u = this.c, p = u && this.d, h = function () {
          var e,
              t = qg(l, o);

          if (67324752 == t) {
            s = 1, a = o, d.d = null, d.c = 0;

            var r = Xg(l, o + 6),
                i = Xg(l, o + 8),
                p = 2048 & r,
                h = 8 & r,
                f = Xg(l, o + 26),
                _ = Xg(l, o + 28);

            if (c > o + 30 + f + _) {
              var m = [];
              d.k.unshift(m), s = 2;
              var g,
                  v = qg(l, o + 18),
                  b = qg(l, o + 22),
                  x = jv(l.subarray(o + 30, o += 30 + f), !p);
              4294967295 == v ? (e = h ? [-2] : Hv(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
              var y = {
                name: x,
                compression: i,
                start: function () {
                  if (!y.ondata) throw "no callback";

                  if (v) {
                    var e = n.o[i];
                    if (!e) throw "unknown compression type " + i;

                    (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function (e, t, n) {
                      y.ondata(e, t, n);
                    };

                    for (var t = 0, r = m; t < r.length; t++) {
                      var s = r[t];
                      g.push(s, !1);
                    }

                    n.k[0] == m && n.c ? n.d = g : g.push(Eg, !0);
                  } else y.ondata(null, Eg, !0);
                },
                terminate: function () {
                  g && g.terminate && g.terminate();
                }
              };
              v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y);
            }

            return "break";
          }

          if (u) {
            if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
            if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break";
          }
        }, d = this; o < c - 4 && "break" !== h(); ++o);

        if (this.p = Eg, u < 0) {
          var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == qg(l, a - 16) && 4)) : l.subarray(0, o);
          p ? p.push(f, !!s) : this.k[+(2 == s)].push(f);
        }

        if (2 & s) return this.push(l.subarray(o), t);
        this.p = l.subarray(o);
      }

      if (t) {
        if (this.c) throw "invalid zip file";
        this.p = null;
      }
    }, e.prototype.register = function (e) {
      this.o[e.compression] = e;
    }, e;
  }();

  function ib(e, t) {
    if ("function" != typeof t) throw "no callback";

    for (var n = [], r = function () {
      for (var e = 0; e < n.length; ++e) n[e]();
    }, i = {}, s = e.length - 22; 101010256 != qg(e, s); --s) if (!s || e.length - s > 65558) return void t("invalid zip file", null);

    var o = Xg(e, s + 8);
    o || t(null, {});
    var a = o,
        l = qg(e, s + 16),
        c = 4294967295 == l;

    if (c) {
      if (s = qg(e, s - 12), 101075792 != qg(e, s)) return void t("invalid zip file", null);
      a = o = qg(e, s + 32), l = qg(e, s + 48);
    }

    for (var u = function (s) {
      var a = Gv(e, l, c),
          u = a[0],
          p = a[1],
          h = a[2],
          d = a[3],
          f = a[4],
          _ = a[5],
          m = Vv(e, _);
      l = f;

      var g = function (e, n) {
        e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i));
      };

      if (u) {
        if (8 == u) {
          var v = e.subarray(m, m + p);
          if (p < 32e4) try {
            g(null, pv(v, new Vm(h)));
          } catch (e) {
            g(e, null);
          } else n.push(uv(v, {
            size: h
          }, g));
        } else g("unknown compression type " + u, null);
      } else g(null, _g(e, m, m + p));
    }, p = 0; p < a; ++p) u();

    return r;
  }

  function sb(e) {
    for (var t = {}, n = e.length - 22; 101010256 != qg(e, n); --n) if (!n || e.length - n > 65558) throw "invalid zip file";

    var r = Xg(e, n + 8);
    if (!r) return {};
    var i = qg(e, n + 16),
        s = 4294967295 == i;

    if (s) {
      if (n = qg(e, n - 12), 101075792 != qg(e, n)) throw "invalid zip file";
      r = qg(e, n + 32), i = qg(e, n + 48);
    }

    for (var o = 0; o < r; ++o) {
      var a = Gv(e, i, s),
          l = a[0],
          c = a[1],
          u = a[2],
          p = a[3],
          h = a[4],
          d = a[5],
          f = Vv(e, d);

      if (i = h, l) {
        if (8 != l) throw "unknown compression type " + l;
        t[p] = pv(e.subarray(f, f + c), new Vm(u));
      } else t[p] = _g(e, f, f + c);
    }

    return t;
  }

  class ob extends i.yxD {
    constructor(e) {
      super(e), this.type = i.cLu;
    }

    parse(e) {
      const t = 65536,
            r = 14,
            s = 65537,
            o = Math.pow(2.7182818, 2.2),
            a = {
        l: 0,
        c: 0,
        lc: 0
      };

      function l(e, t, n, r, i) {
        for (; n < e;) t = t << 8 | B(r, i), n += 8;

        n -= e, a.l = t >> n & (1 << e) - 1, a.c = t, a.lc = n;
      }

      const c = new Array(59);

      function u(e) {
        return 63 & e;
      }

      function p(e) {
        return e >> 6;
      }

      const h = {
        c: 0,
        lc: 0
      };

      function d(e, t, n, r) {
        e = e << 8 | B(n, r), t += 8, h.c = e, h.lc = t;
      }

      const f = {
        c: 0,
        lc: 0
      };

      function _(e, t, n, r, i, s, o, a, l) {
        if (e == t) {
          r < 8 && (d(n, r, i, s), n = h.c, r = h.lc);
          let e = n >> (r -= 8);
          if (e = new Uint8Array([e])[0], a.value + e > l) return !1;
          const t = o[a.value - 1];

          for (; e-- > 0;) o[a.value++] = t;
        } else {
          if (!(a.value < l)) return !1;
          o[a.value++] = e;
        }

        f.c = n, f.lc = r;
      }

      function m(e) {
        return 65535 & e;
      }

      function g(e) {
        const t = m(e);
        return t > 32767 ? t - 65536 : t;
      }

      const v = {
        a: 0,
        b: 0
      };

      function b(e, t) {
        const n = g(e),
              r = g(t),
              i = n + (1 & r) + (r >> 1),
              s = i,
              o = i - r;
        v.a = s, v.b = o;
      }

      function x(e, t) {
        const n = m(e),
              r = m(t),
              i = n - (r >> 1) & 65535,
              s = r + i - 32768 & 65535;
        v.a = s, v.b = i;
      }

      function y(e, t, n, r, i, s, o) {
        const a = o < 16384,
              l = n > i ? i : n;
        let c,
            u,
            p = 1;

        for (; p <= l;) p <<= 1;

        for (p >>= 1, c = p, p >>= 1; p >= 1;) {
          u = 0;
          const o = u + s * (i - c),
                l = s * p,
                h = s * c,
                d = r * p,
                f = r * c;

          let _, m, g, y;

          for (; u <= o; u += h) {
            let i = u;
            const s = u + r * (n - c);

            for (; i <= s; i += f) {
              const n = i + d,
                    r = i + l,
                    s = r + d;
              a ? (b(e[i + t], e[r + t]), _ = v.a, g = v.b, b(e[n + t], e[s + t]), m = v.a, y = v.b, b(_, m), e[i + t] = v.a, e[n + t] = v.b, b(g, y), e[r + t] = v.a, e[s + t] = v.b) : (x(e[i + t], e[r + t]), _ = v.a, g = v.b, x(e[n + t], e[s + t]), m = v.a, y = v.b, x(_, m), e[i + t] = v.a, e[n + t] = v.b, x(g, y), e[r + t] = v.a, e[s + t] = v.b);
            }

            if (n & p) {
              const n = i + l;
              a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _;
            }
          }

          if (i & p) {
            let i = u;
            const s = u + r * (n - c);

            for (; i <= s; i += f) {
              const n = i + d;
              a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _;
            }
          }

          c = p, p >>= 1;
        }

        return u;
      }

      function w(e, t, n, i, o, m) {
        const g = n.value,
              v = U(t, n),
              b = U(t, n);
        n.value += 4;
        const x = U(t, n);
        if (n.value += 4, v < 0 || v >= s || b < 0 || b >= s) throw new Error("Something wrong with HUF_ENCSIZE");
        const y = new Array(s),
              w = new Array(16384);
        if (function (e) {
          for (let t = 0; t < 16384; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null;
        }(w), function (e, t, n, r, i, o) {
          const u = t;
          let p = 0,
              h = 0;

          for (; r <= i; r++) {
            if (u.value - t.value > n) return !1;
            l(6, p, h, e, u);
            const s = a.l;

            if (p = a.c, h = a.lc, o[r] = s, 63 == s) {
              if (u.value - t.value > n) throw new Error("Something wrong with hufUnpackEncTable");
              l(8, p, h, e, u);
              let s = a.l + 6;
              if (p = a.c, h = a.lc, r + s > i + 1) throw new Error("Something wrong with hufUnpackEncTable");

              for (; s--;) o[r++] = 0;

              r--;
            } else if (s >= 59) {
              let e = s - 59 + 2;
              if (r + e > i + 1) throw new Error("Something wrong with hufUnpackEncTable");

              for (; e--;) o[r++] = 0;

              r--;
            }
          }

          !function (e) {
            for (let e = 0; e <= 58; ++e) c[e] = 0;

            for (let t = 0; t < s; ++t) c[e[t]] += 1;

            let t = 0;

            for (let e = 58; e > 0; --e) {
              const n = t + c[e] >> 1;
              c[e] = t, t = n;
            }

            for (let t = 0; t < s; ++t) {
              const n = e[t];
              n > 0 && (e[t] = n | c[n]++ << 6);
            }
          }(o);
        }(e, n, i - (n.value - g), v, b, y), x > 8 * (i - (n.value - g))) throw new Error("Something wrong with hufUncompress");
        !function (e, t, n, i) {
          for (; t <= n; t++) {
            const n = p(e[t]),
                  s = u(e[t]);
            if (n >> s) throw new Error("Invalid table entry");

            if (s > r) {
              const e = i[n >> s - r];
              if (e.len) throw new Error("Invalid table entry");

              if (e.lit++, e.p) {
                const t = e.p;
                e.p = new Array(e.lit);

                for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n];
              } else e.p = new Array(1);

              e.p[e.lit - 1] = t;
            } else if (s) {
              let e = 0;

              for (let o = 1 << r - s; o > 0; o--) {
                const o = i[(n << r - s) + e];
                if (o.len || o.p) throw new Error("Invalid table entry");
                o.len = s, o.lit = t, e++;
              }
            }
          }
        }(y, v, b, w), function (e, t, n, i, s, o, a, l, c) {
          let m = 0,
              g = 0;
          const v = a,
                b = Math.trunc(i.value + (s + 7) / 8);

          for (; i.value < b;) for (d(m, g, n, i), m = h.c, g = h.lc; g >= r;) {
            const s = t[m >> g - r & 16383];
            if (s.len) g -= s.len, _(s.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc;else {
              if (!s.p) throw new Error("hufDecode issues");
              let t;

              for (t = 0; t < s.lit; t++) {
                const r = u(e[s.p[t]]);

                for (; g < r && i.value < b;) d(m, g, n, i), m = h.c, g = h.lc;

                if (g >= r && p(e[s.p[t]]) == (m >> g - r & (1 << r) - 1)) {
                  g -= r, _(s.p[t], o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
                  break;
                }
              }

              if (t == s.lit) throw new Error("hufDecode issues");
            }
          }

          const x = 8 - s & 7;

          for (m >>= x, g -= x; g > 0;) {
            const e = t[m << r - g & 16383];
            if (!e.len) throw new Error("hufDecode issues");
            g -= e.len, _(e.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
          }
        }(y, w, e, n, x, b, m, o, {
          value: 0
        });
      }

      function S(e) {
        for (let t = 1; t < e.length; t++) {
          const n = e[t - 1] + e[t] - 128;
          e[t] = n;
        }
      }

      function M(e, t) {
        let n = 0,
            r = Math.floor((e.length + 1) / 2),
            i = 0;
        const s = e.length - 1;

        for (; !(i > s || (t[i++] = e[n++], i > s));) t[i++] = e[r++];
      }

      function T(e) {
        let t = e.byteLength;
        const n = new Array();
        let r = 0;
        const i = new DataView(e);

        for (; t > 0;) {
          const e = i.getInt8(r++);

          if (e < 0) {
            const s = -e;
            t -= s + 1;

            for (let e = 0; e < s; e++) n.push(i.getUint8(r++));
          } else {
            const s = e;
            t -= 2;
            const o = i.getUint8(r++);

            for (let e = 0; e < s + 1; e++) n.push(o);
          }
        }

        return n;
      }

      function E(e, t, n) {
        let r,
            i = 1;

        for (; i < 64;) r = t[e.value], 65280 == r ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r, i++), e.value++;
      }

      function A(e) {
        const t = .5 * Math.cos(.7853975),
              n = .5 * Math.cos(3.14159 / 16),
              r = .5 * Math.cos(3.14159 / 8),
              i = .5 * Math.cos(3 * 3.14159 / 16),
              s = .5 * Math.cos(.981746875),
              o = .5 * Math.cos(3 * 3.14159 / 8),
              a = .5 * Math.cos(1.374445625),
              l = new Array(4),
              c = new Array(4),
              u = new Array(4),
              p = new Array(4);

        for (let h = 0; h < 8; ++h) {
          const d = 8 * h;
          l[0] = r * e[d + 2], l[1] = o * e[d + 2], l[2] = r * e[d + 6], l[3] = o * e[d + 6], c[0] = n * e[d + 1] + i * e[d + 3] + s * e[d + 5] + a * e[d + 7], c[1] = i * e[d + 1] - a * e[d + 3] - n * e[d + 5] - s * e[d + 7], c[2] = s * e[d + 1] - n * e[d + 3] + a * e[d + 5] + i * e[d + 7], c[3] = a * e[d + 1] - s * e[d + 3] + i * e[d + 5] - n * e[d + 7], u[0] = t * (e[d + 0] + e[d + 4]), u[3] = t * (e[d + 0] - e[d + 4]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[d + 0] = p[0] + c[0], e[d + 1] = p[1] + c[1], e[d + 2] = p[2] + c[2], e[d + 3] = p[3] + c[3], e[d + 4] = p[3] - c[3], e[d + 5] = p[2] - c[2], e[d + 6] = p[1] - c[1], e[d + 7] = p[0] - c[0];
        }

        for (let h = 0; h < 8; ++h) l[0] = r * e[16 + h], l[1] = o * e[16 + h], l[2] = r * e[48 + h], l[3] = o * e[48 + h], c[0] = n * e[8 + h] + i * e[24 + h] + s * e[40 + h] + a * e[56 + h], c[1] = i * e[8 + h] - a * e[24 + h] - n * e[40 + h] - s * e[56 + h], c[2] = s * e[8 + h] - n * e[24 + h] + a * e[40 + h] + i * e[56 + h], c[3] = a * e[8 + h] - s * e[24 + h] + i * e[40 + h] - n * e[56 + h], u[0] = t * (e[h] + e[32 + h]), u[3] = t * (e[h] - e[32 + h]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[0 + h] = p[0] + c[0], e[8 + h] = p[1] + c[1], e[16 + h] = p[2] + c[2], e[24 + h] = p[3] + c[3], e[32 + h] = p[3] - c[3], e[40 + h] = p[2] - c[2], e[48 + h] = p[1] - c[1], e[56 + h] = p[0] - c[0];
      }

      function C(e) {
        for (let t = 0; t < 64; ++t) {
          const n = e[0][t],
                r = e[1][t],
                i = e[2][t];
          e[0][t] = n + 1.5747 * i, e[1][t] = n - .1873 * r - .4682 * i, e[2][t] = n + 1.8556 * r;
        }
      }

      function R(e, t, n) {
        for (let s = 0; s < 64; ++s) t[n + s] = i.A5E.toHalfFloat((r = e[s]) <= 1 ? Math.sign(r) * Math.pow(Math.abs(r), 2.2) : Math.sign(r) * Math.pow(o, Math.abs(r) - 1));

        var r;
      }

      function k(e) {
        return new DataView(e.array.buffer, e.offset.value, e.size);
      }

      function P(e) {
        const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
              n = new Uint8Array(T(t)),
              r = new Uint8Array(n.length);
        return S(n), M(n, r), new DataView(r.buffer);
      }

      function D(e) {
        const t = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const r = Av(t),
              i = new Uint8Array(r.length);
        return S(r), M(r, i), new DataView(i.buffer);
      }

      function O(e) {
        const n = e.viewer,
              r = {
          value: e.offset.value
        },
              i = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)),
              s = new Uint8Array(8192);
        let o = 0;
        const a = new Array(e.channels);

        for (let t = 0; t < e.channels; t++) a[t] = {}, a[t].start = o, a[t].end = a[t].start, a[t].nx = e.width, a[t].ny = e.lines, a[t].size = e.type, o += a[t].nx * a[t].ny * a[t].size;

        const l = W(n, r),
              c = W(n, r);
        if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
        if (l <= c) for (let e = 0; e < c - l + 1; e++) s[e + l] = j(n, r);

        const u = new Uint16Array(t),
              p = function (e, n) {
          let r = 0;

          for (let i = 0; i < t; ++i) (0 == i || e[i >> 3] & 1 << (7 & i)) && (n[r++] = i);

          const i = r - 1;

          for (; r < t;) n[r++] = 0;

          return i;
        }(s, u),
              h = U(n, r);

        w(e.array, n, r, h, i, o);

        for (let t = 0; t < e.channels; ++t) {
          const e = a[t];

          for (let n = 0; n < a[t].size; ++n) y(i, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, p);
        }

        !function (e, t, n) {
          for (let r = 0; r < n; ++r) t[r] = e[t[r]];
        }(u, i, o);
        let d = 0;
        const f = new Uint8Array(i.buffer.byteLength);

        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          const e = a[t],
                n = e.nx * e.size,
                r = new Uint8Array(i.buffer, 2 * e.end, 2 * n);
          f.set(r, d), d += 2 * n, e.end += n;
        }

        return new DataView(f.buffer);
      }

      function L(e) {
        const t = e.array.slice(e.offset.value, e.offset.value + e.size);
        void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
        const r = Av(t),
              i = e.lines * e.channels * e.width,
              s = 1 == e.type ? new Uint16Array(i) : new Uint32Array(i);
        let o = 0,
            a = 0;
        const l = new Array(4);

        for (let t = 0; t < e.lines; t++) for (let t = 0; t < e.channels; t++) {
          let t = 0;

          switch (e.type) {
            case 1:
              l[0] = o, l[1] = l[0] + e.width, o = l[1] + e.width;

              for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 8 | r[l[1]++], s[a] = t, a++;

              break;

            case 2:
              l[0] = o, l[1] = l[0] + e.width, l[2] = l[1] + e.width, o = l[2] + e.width;

              for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 24 | r[l[1]++] << 16 | r[l[2]++] << 8, s[a] = t, a++;

          }
        }

        return new DataView(s.buffer);
      }

      function I(e) {
        const t = e.viewer,
              n = {
          value: e.offset.value
        },
              r = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
              i = {
          version: z(t, n),
          unknownUncompressedSize: z(t, n),
          unknownCompressedSize: z(t, n),
          acCompressedSize: z(t, n),
          dcCompressedSize: z(t, n),
          rleCompressedSize: z(t, n),
          rleUncompressedSize: z(t, n),
          rleRawSize: z(t, n),
          totalAcUncompressedCount: z(t, n),
          totalDcUncompressedCount: z(t, n),
          acCompression: z(t, n)
        };
        if (i.version < 2) throw new Error("EXRLoader.parse: " + J.compression + " version " + i.version + " is unsupported");
        const s = new Array();
        let o = W(t, n) - 2;

        for (; o > 0;) {
          const e = F(t.buffer, n),
                r = j(t, n),
                i = r >> 2 & 3,
                a = new Int8Array([(r >> 4) - 1])[0],
                l = j(t, n);
          s.push({
            name: e,
            index: a,
            type: l,
            compression: i
          }), o -= e.length + 3;
        }

        const a = J.channels,
              l = new Array(e.channels);

        for (let t = 0; t < e.channels; ++t) {
          const n = l[t] = {},
                r = a[t];
          n.name = r.name, n.compression = 0, n.decoded = !1, n.type = r.pixelType, n.pLinear = r.pLinear, n.width = e.width, n.height = e.lines;
        }

        const c = {
          idx: new Array(3)
        };

        for (let t = 0; t < e.channels; ++t) {
          const e = l[t];

          for (let n = 0; n < s.length; ++n) {
            const r = s[n];
            e.name == r.name && (e.compression = r.compression, r.index >= 0 && (c.idx[r.index] = t), e.offset = t);
          }
        }

        let u, p, h;
        if (i.acCompressedSize > 0) switch (i.acCompression) {
          case 0:
            u = new Uint16Array(i.totalAcUncompressedCount), w(e.array, t, n, i.acCompressedSize, u, i.totalAcUncompressedCount);
            break;

          case 1:
            const r = Av(e.array.slice(n.value, n.value + i.totalAcUncompressedCount));
            u = new Uint16Array(r.buffer), n.value += i.totalAcUncompressedCount;
        }

        if (i.dcCompressedSize > 0) {
          const t = {
            array: e.array,
            offset: n,
            size: i.dcCompressedSize
          };
          p = new Uint16Array(D(t).buffer), n.value += i.dcCompressedSize;
        }

        i.rleRawSize > 0 && (h = T(Av(e.array.slice(n.value, n.value + i.rleCompressedSize)).buffer), n.value += i.rleCompressedSize);
        let d = 0;
        const f = new Array(l.length);

        for (let e = 0; e < f.length; ++e) f[e] = new Array();

        for (let t = 0; t < e.lines; ++t) for (let t = 0; t < l.length; ++t) f[t].push(d), d += l[t].width * e.type * 2;

        !function (e, t, n, r, i, s) {
          let o = new DataView(s.buffer);

          const a = n[e.idx[0]].width,
                l = n[e.idx[0]].height,
                c = Math.floor(a / 8),
                u = Math.ceil(a / 8),
                p = Math.ceil(l / 8),
                h = a - 8 * (u - 1),
                d = l - 8 * (p - 1),
                f = {
            value: 0
          },
                _ = new Array(3),
                m = new Array(3),
                g = new Array(3),
                v = new Array(3),
                b = new Array(3);

          for (let n = 0; n < 3; ++n) b[n] = t[e.idx[n]], _[n] = n < 1 ? 0 : _[n - 1] + u * p, m[n] = new Float32Array(64), g[n] = new Uint16Array(64), v[n] = new Uint16Array(64 * u);

          for (let t = 0; t < p; ++t) {
            let s = 8;
            t == p - 1 && (s = d);
            let a = 8;

            for (let e = 0; e < u; ++e) {
              e == u - 1 && (a = h);

              for (let e = 0; e < 3; ++e) g[e].fill(0), g[e][0] = i[_[e]++], E(f, r, g[e]), x = g[e], (y = m[e])[0] = H(x[0]), y[1] = H(x[1]), y[2] = H(x[5]), y[3] = H(x[6]), y[4] = H(x[14]), y[5] = H(x[15]), y[6] = H(x[27]), y[7] = H(x[28]), y[8] = H(x[2]), y[9] = H(x[4]), y[10] = H(x[7]), y[11] = H(x[13]), y[12] = H(x[16]), y[13] = H(x[26]), y[14] = H(x[29]), y[15] = H(x[42]), y[16] = H(x[3]), y[17] = H(x[8]), y[18] = H(x[12]), y[19] = H(x[17]), y[20] = H(x[25]), y[21] = H(x[30]), y[22] = H(x[41]), y[23] = H(x[43]), y[24] = H(x[9]), y[25] = H(x[11]), y[26] = H(x[18]), y[27] = H(x[24]), y[28] = H(x[31]), y[29] = H(x[40]), y[30] = H(x[44]), y[31] = H(x[53]), y[32] = H(x[10]), y[33] = H(x[19]), y[34] = H(x[23]), y[35] = H(x[32]), y[36] = H(x[39]), y[37] = H(x[45]), y[38] = H(x[52]), y[39] = H(x[54]), y[40] = H(x[20]), y[41] = H(x[22]), y[42] = H(x[33]), y[43] = H(x[38]), y[44] = H(x[46]), y[45] = H(x[51]), y[46] = H(x[55]), y[47] = H(x[60]), y[48] = H(x[21]), y[49] = H(x[34]), y[50] = H(x[37]), y[51] = H(x[47]), y[52] = H(x[50]), y[53] = H(x[56]), y[54] = H(x[59]), y[55] = H(x[61]), y[56] = H(x[35]), y[57] = H(x[36]), y[58] = H(x[48]), y[59] = H(x[49]), y[60] = H(x[57]), y[61] = H(x[58]), y[62] = H(x[62]), y[63] = H(x[63]), A(m[e]);

              C(m);

              for (let t = 0; t < 3; ++t) R(m[t], v[t], 64 * e);
            }

            let l = 0;

            for (let r = 0; r < 3; ++r) {
              const i = n[e.idx[r]].type;

              for (let e = 8 * t; e < 8 * t + s; ++e) {
                l = b[r][e];

                for (let t = 0; t < c; ++t) {
                  const n = 64 * t + 8 * (7 & e);
                  o.setUint16(l + 0 * i, v[r][n + 0], !0), o.setUint16(l + 2 * i, v[r][n + 1], !0), o.setUint16(l + 4 * i, v[r][n + 2], !0), o.setUint16(l + 6 * i, v[r][n + 3], !0), o.setUint16(l + 8 * i, v[r][n + 4], !0), o.setUint16(l + 10 * i, v[r][n + 5], !0), o.setUint16(l + 12 * i, v[r][n + 6], !0), o.setUint16(l + 14 * i, v[r][n + 7], !0), l += 16 * i;
                }
              }

              if (c != u) for (let e = 8 * t; e < 8 * t + s; ++e) {
                const t = b[r][e] + 8 * c * 2 * i,
                      n = 64 * c + 8 * (7 & e);

                for (let e = 0; e < a; ++e) o.setUint16(t + 2 * e * i, v[r][n + e], !0);
              }
            }
          }

          var x, y;
          const w = new Uint16Array(a);
          o = new DataView(s.buffer);

          for (let t = 0; t < 3; ++t) {
            n[e.idx[t]].decoded = !0;
            const r = n[e.idx[t]].type;
            if (2 == n[t].type) for (let e = 0; e < l; ++e) {
              const n = b[t][e];

              for (let e = 0; e < a; ++e) w[e] = o.getUint16(n + 2 * e * r, !0);

              for (let e = 0; e < a; ++e) o.setFloat32(n + 2 * e * r, H(w[e]), !0);
            }
          }
        }(c, f, l, u, p, r);

        for (let t = 0; t < l.length; ++t) {
          const n = l[t];
          if (!n.decoded) switch (n.compression) {
            case 2:
              let i = 0,
                  s = 0;

              for (let o = 0; o < e.lines; ++o) {
                let e = f[t][i];

                for (let t = 0; t < n.width; ++t) {
                  for (let t = 0; t < 2 * n.type; ++t) r[e++] = h[s + t * n.width * n.height];

                  s++;
                }

                i++;
              }

              break;

            case 1:
            default:
              throw new Error("EXRLoader.parse: unsupported channel compression");
          }
        }

        return new DataView(r.buffer);
      }

      function F(e, t) {
        const n = new Uint8Array(e);
        let r = 0;

        for (; 0 != n[t.value + r];) r += 1;

        const i = new TextDecoder().decode(n.slice(t.value, t.value + r));
        return t.value = t.value + r + 1, i;
      }

      function N(e, t) {
        const n = e.getInt32(t.value, !0);
        return t.value = t.value + 4, n;
      }

      function U(e, t) {
        const n = e.getUint32(t.value, !0);
        return t.value = t.value + 4, n;
      }

      function B(e, t) {
        const n = e[t.value];
        return t.value = t.value + 1, n;
      }

      function j(e, t) {
        const n = e.getUint8(t.value);
        return t.value = t.value + 1, n;
      }

      const z = function (e, t) {
        const n = Number(e.getBigInt64(t.value, !0));
        return t.value += 8, n;
      };

      function V(e, t) {
        const n = e.getFloat32(t.value, !0);
        return t.value += 4, n;
      }

      function G(e, t) {
        return i.A5E.toHalfFloat(V(e, t));
      }

      function H(e) {
        const t = (31744 & e) >> 10,
              n = 1023 & e;
        return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14);
      }

      function W(e, t) {
        const n = e.getUint16(t.value, !0);
        return t.value += 2, n;
      }

      function K(e, t) {
        return H(W(e, t));
      }

      function X(e, t, n, r, i) {
        return "string" === r || "stringvector" === r || "iccProfile" === r ? function (e, t, n) {
          const r = new TextDecoder().decode(new Uint8Array(e).slice(t.value, t.value + n));
          return t.value = t.value + n, r;
        }(t, n, i) : "chlist" === r ? function (e, t, n, r) {
          const i = n.value,
                s = [];

          for (; n.value < i + r - 1;) {
            const r = F(t, n),
                  i = N(e, n),
                  o = j(e, n);
            n.value += 3;
            const a = N(e, n),
                  l = N(e, n);
            s.push({
              name: r,
              pixelType: i,
              pLinear: o,
              xSampling: a,
              ySampling: l
            });
          }

          return n.value += 1, s;
        }(e, t, n, i) : "chromaticities" === r ? function (e, t) {
          return {
            redX: V(e, t),
            redY: V(e, t),
            greenX: V(e, t),
            greenY: V(e, t),
            blueX: V(e, t),
            blueY: V(e, t),
            whiteX: V(e, t),
            whiteY: V(e, t)
          };
        }(e, n) : "compression" === r ? function (e, t) {
          return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j(e, t)];
        }(e, n) : "box2i" === r ? function (e, t) {
          return {
            xMin: U(e, t),
            yMin: U(e, t),
            xMax: U(e, t),
            yMax: U(e, t)
          };
        }(e, n) : "lineOrder" === r ? function (e, t) {
          return ["INCREASING_Y"][j(e, t)];
        }(e, n) : "float" === r ? V(e, n) : "v2f" === r ? function (e, t) {
          return [V(e, t), V(e, t)];
        }(e, n) : "v3f" === r ? function (e, t) {
          return [V(e, t), V(e, t), V(e, t)];
        }(e, n) : "int" === r ? N(e, n) : "rational" === r ? function (e, t) {
          return [N(e, t), U(e, t)];
        }(e, n) : "timecode" === r ? function (e, t) {
          return [U(e, t), U(e, t)];
        }(e, n) : "preview" === r ? (n.value += i, "skipped") : void (n.value += i);
      }

      const q = new DataView(e),
            Y = new Uint8Array(e),
            Z = {
        value: 0
      },
            J = function (e, t, n) {
        const r = {};
        if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
        r.version = e.getUint8(4);
        const i = e.getUint8(5);
        r.spec = {
          singleTile: !!(2 & i),
          longName: !!(4 & i),
          deepFormat: !!(8 & i),
          multiPart: !!(16 & i)
        }, n.value = 8;
        let s = !0;

        for (; s;) {
          const i = F(t, n);
          if (0 == i) s = !1;else {
            const s = F(t, n),
                  o = X(e, t, n, s, U(e, n));
            void 0 === o ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`) : r[i] = o;
          }
        }

        if (0 != (-5 & i)) throw console.error("EXRHeader:", r), new Error("THREE.EXRLoader: provided file is currently unsupported.");
        return r;
      }(q, e, Z),
            $ = function (e, t, n, r, s) {
        const o = {
          size: 0,
          viewer: t,
          array: n,
          offset: r,
          width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
          height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
          channels: e.channels.length,
          bytesPerLine: null,
          lines: null,
          inputSize: null,
          type: e.channels[0].pixelType,
          uncompress: null,
          getter: null,
          format: null,
          encoding: null
        };

        switch (e.compression) {
          case "NO_COMPRESSION":
            o.lines = 1, o.uncompress = k;
            break;

          case "RLE_COMPRESSION":
            o.lines = 1, o.uncompress = P;
            break;

          case "ZIPS_COMPRESSION":
            o.lines = 1, o.uncompress = D;
            break;

          case "ZIP_COMPRESSION":
            o.lines = 16, o.uncompress = D;
            break;

          case "PIZ_COMPRESSION":
            o.lines = 32, o.uncompress = O;
            break;

          case "PXR24_COMPRESSION":
            o.lines = 16, o.uncompress = L;
            break;

          case "DWAA_COMPRESSION":
            o.lines = 32, o.uncompress = I;
            break;

          case "DWAB_COMPRESSION":
            o.lines = 256, o.uncompress = I;
            break;

          default:
            throw new Error("EXRLoader.parse: " + e.compression + " is unsupported");
        }

        if (o.scanlineBlockSize = o.lines, 1 == o.type) switch (s) {
          case i.VzW:
            o.getter = K, o.inputSize = 2;
            break;

          case i.cLu:
            o.getter = W, o.inputSize = 2;
        } else {
          if (2 != o.type) throw new Error("EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".");

          switch (s) {
            case i.VzW:
              o.getter = V, o.inputSize = 4;
              break;

            case i.cLu:
              o.getter = G, o.inputSize = 4;
          }
        }
        o.blockCount = (e.dataWindow.yMax + 1) / o.scanlineBlockSize;

        for (let e = 0; e < o.blockCount; e++) z(t, r);

        o.outputChannels = 3 == o.channels ? 4 : o.channels;
        const a = o.width * o.height * o.outputChannels;

        switch (s) {
          case i.VzW:
            o.byteArray = new Float32Array(a), o.channels < o.outputChannels && o.byteArray.fill(1, 0, a);
            break;

          case i.cLu:
            o.byteArray = new Uint16Array(a), o.channels < o.outputChannels && o.byteArray.fill(15360, 0, a);
            break;

          default:
            console.error("THREE.EXRLoader: unsupported type: ", s);
        }

        return o.bytesPerLine = o.width * o.inputSize * o.channels, 4 == o.outputChannels ? (o.format = i.wk1, o.encoding = i.rnI) : (o.format = i.hEm, o.encoding = i.rnI), o;
      }(J, q, Y, Z, this.type),
            Q = {
        value: 0
      },
            ee = {
        R: 0,
        G: 1,
        B: 2,
        A: 3,
        Y: 0
      };

      for (let e = 0; e < $.height / $.scanlineBlockSize; e++) {
        const t = U(q, Z);
        $.size = U(q, Z), $.lines = t + $.scanlineBlockSize > $.height ? $.height - t : $.scanlineBlockSize;
        const n = $.size < $.lines * $.bytesPerLine ? $.uncompress($) : k($);
        Z.value += $.size;

        for (let t = 0; t < $.scanlineBlockSize; t++) {
          const r = t + e * $.scanlineBlockSize;
          if (r >= $.height) break;

          for (let e = 0; e < $.channels; e++) {
            const i = ee[J.channels[e].name];

            for (let s = 0; s < $.width; s++) {
              Q.value = (t * ($.channels * $.width) + e * $.width + s) * $.inputSize;
              const o = ($.height - 1 - r) * ($.width * $.outputChannels) + s * $.outputChannels + i;
              $.byteArray[o] = $.getter(n, Q);
            }
          }
        }
      }

      return {
        header: J,
        width: $.width,
        height: $.height,
        data: $.byteArray,
        format: $.format,
        encoding: $.encoding,
        type: this.type
      };
    }

    setDataType(e) {
      return this.type = e, this;
    }

    load(e, t, n, r) {
      return super.load(e, function (e, n) {
        e.encoding = n.encoding, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n);
      }, n, r);
    }

  }

  class ab extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs];
    }

    async onAdded(e) {
      this._importer || (this._importer = new $t(class extends ob {
        constructor(t) {
          super(t), this.setDataType(Bs(e.renderer.rendererObject));
        }

      }, ["exr"], !1)), Us.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  function lb(e, t, n) {
    const r = n.length - e - 1;
    if (t >= n[r]) return r - 1;
    if (t <= n[e]) return e;
    let i = e,
        s = r,
        o = Math.floor((i + s) / 2);

    for (; t < n[o] || t >= n[o + 1];) t < n[o] ? s = o : i = o, o = Math.floor((i + s) / 2);

    return o;
  }

  function cb(e, t) {
    let n = 1;

    for (let t = 2; t <= e; ++t) n *= t;

    let r = 1;

    for (let e = 2; e <= t; ++e) r *= e;

    for (let n = 2; n <= e - t; ++n) r *= n;

    return n / r;
  }

  ab.PluginType = "EXRLoadPlugin";

  class ub extends i.Hyl {
    constructor(e, t, n, r, s) {
      super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = s || this.knots.length - 1;

      for (let e = 0; e < n.length; ++e) {
        const t = n[e];
        this.controlPoints[e] = new i.Ltg(t.x, t.y, t.z, t.w);
      }
    }

    getPoint(e, t = new i.Pa4()) {
      const n = t,
            r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
            s = function (e, t, n, r) {
        const s = lb(e, r, t),
              o = function (e, t, n, r) {
          const i = [],
                s = [],
                o = [];
          i[0] = 1;

          for (let a = 1; a <= n; ++a) {
            s[a] = t - r[e + 1 - a], o[a] = r[e + a] - t;
            let n = 0;

            for (let e = 0; e < a; ++e) {
              const t = o[e + 1],
                    r = s[a - e],
                    l = i[e] / (t + r);
              i[e] = n + t * l, n = r * l;
            }

            i[a] = n;
          }

          return i;
        }(s, r, e, t),
              a = new i.Ltg(0, 0, 0, 0);

        for (let t = 0; t <= e; ++t) {
          const r = n[s - e + t],
                i = o[t],
                l = r.w * i;
          a.x += r.x * l, a.y += r.y * l, a.z += r.z * l, a.w += r.w * i;
        }

        return a;
      }(this.degree, this.knots, this.controlPoints, r);

      return 1 !== s.w && s.divideScalar(s.w), n.set(s.x, s.y, s.z);
    }

    getTangent(e, t = new i.Pa4()) {
      const n = t,
            r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
            s = function (e, t, n, r, s) {
        return function (e) {
          const t = e.length,
                n = [],
                r = [];

          for (let s = 0; s < t; ++s) {
            const t = e[s];
            n[s] = new i.Pa4(t.x, t.y, t.z), r[s] = t.w;
          }

          const s = [];

          for (let e = 0; e < t; ++e) {
            const t = n[e].clone();

            for (let n = 1; n <= e; ++n) t.sub(s[e - n].clone().multiplyScalar(cb(e, n) * r[n]));

            s[e] = t.divideScalar(r[0]);
          }

          return s;
        }(function (e, t, n, r, s) {
          const o = s < e ? s : e,
                a = [],
                l = lb(e, r, t),
                c = function (e, t, n, r, i) {
            const s = [];

            for (let e = 0; e <= n; ++e) s[e] = 0;

            const o = [];

            for (let e = 0; e <= r; ++e) o[e] = s.slice(0);

            const a = [];

            for (let e = 0; e <= n; ++e) a[e] = s.slice(0);

            a[0][0] = 1;
            const l = s.slice(0),
                  c = s.slice(0);

            for (let r = 1; r <= n; ++r) {
              l[r] = t - i[e + 1 - r], c[r] = i[e + r] - t;
              let n = 0;

              for (let e = 0; e < r; ++e) {
                const t = c[e + 1],
                      i = l[r - e];
                a[r][e] = t + i;
                const s = a[e][r - 1] / a[r][e];
                a[e][r] = n + t * s, n = i * s;
              }

              a[r][r] = n;
            }

            for (let e = 0; e <= n; ++e) o[0][e] = a[e][n];

            for (let e = 0; e <= n; ++e) {
              let t = 0,
                  i = 1;
              const l = [];

              for (let e = 0; e <= n; ++e) l[e] = s.slice(0);

              l[0][0] = 1;

              for (let s = 1; s <= r; ++s) {
                let r = 0;
                const c = e - s,
                      u = n - s;
                e >= s && (l[i][0] = l[t][0] / a[u + 1][c], r = l[i][0] * a[c][u]);
                const p = e - 1 <= u ? s - 1 : n - e;

                for (let e = c >= -1 ? 1 : -c; e <= p; ++e) l[i][e] = (l[t][e] - l[t][e - 1]) / a[u + 1][c + e], r += l[i][e] * a[c + e][u];

                e <= u && (l[i][s] = -l[t][s - 1] / a[u + 1][e], r += l[i][s] * a[e][u]), o[s][e] = r;
                const h = t;
                t = i, i = h;
              }
            }

            let u = n;

            for (let e = 1; e <= r; ++e) {
              for (let t = 0; t <= n; ++t) o[e][t] *= u;

              u *= n - e;
            }

            return o;
          }(l, r, e, o, t),
                u = [];

          for (let e = 0; e < n.length; ++e) {
            const t = n[e].clone(),
                  r = t.w;
            t.x *= r, t.y *= r, t.z *= r, u[e] = t;
          }

          for (let t = 0; t <= o; ++t) {
            const n = u[l - e].clone().multiplyScalar(c[t][0]);

            for (let r = 1; r <= e; ++r) n.add(u[l - e + r].clone().multiplyScalar(c[t][r]));

            a[t] = n;
          }

          for (let e = o + 1; e <= s + 1; ++e) a[e] = new i.Ltg(0, 0, 0);

          return a;
        }(e, t, n, r, s));
      }(this.degree, this.knots, this.controlPoints, r, 1);

      return n.copy(s[1]).normalize(), n;
    }

  }

  let pb, hb, db;

  class fb extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = "" === s.path ? i.Zp0.extractUrlBase(e) : s.path,
            a = new i.hH6(this.manager);
      a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function (n) {
        try {
          t(s.parse(n, o));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    parse(e, t) {
      if (function (e) {
        const t = "Kaydara FBX Binary  \0";
        return e.byteLength >= t.length && t === Pb(e, 0, t.length);
      }(e)) pb = new bb().parse(e);else {
        const t = Pb(e);
        if (!function (e) {
          const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
          let n = 0;

          function r(t) {
            const r = e[t - 1];
            return e = e.slice(n + t), n++, r;
          }

          for (let e = 0; e < t.length; ++e) if (r(1) === t[e]) return !1;

          return !0;
        }(t)) throw new Error("THREE.FBXLoader: Unknown format.");
        if (wb(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + wb(t));
        pb = new vb().parse(t);
      }
      const n = new i.dpR(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
      return new _b(n, this.manager).parse(pb);
    }

  }

  class _b {
    constructor(e, t) {
      this.textureLoader = e, this.manager = t;
    }

    parse() {
      hb = this.parseConnections();
      const e = this.parseImages(),
            t = this.parseTextures(e),
            n = this.parseMaterials(t),
            r = this.parseDeformers(),
            i = new mb().parse(r);
      return this.parseScene(r, i, n), db;
    }

    parseConnections() {
      const e = new Map();
      return "Connections" in pb && pb.Connections.connections.forEach(function (t) {
        const n = t[0],
              r = t[1],
              i = t[2];
        e.has(n) || e.set(n, {
          parents: [],
          children: []
        });
        const s = {
          ID: r,
          relationship: i
        };
        e.get(n).parents.push(s), e.has(r) || e.set(r, {
          parents: [],
          children: []
        });
        const o = {
          ID: n,
          relationship: i
        };
        e.get(r).children.push(o);
      }), e;
    }

    parseImages() {
      const e = {},
            t = {};

      if ("Video" in pb.Objects) {
        const n = pb.Objects.Video;

        for (const r in n) {
          const i = n[r];

          if (e[parseInt(r)] = i.RelativeFilename || i.Filename, "Content" in i) {
            const e = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0,
                  s = "string" == typeof i.Content && "" !== i.Content;

            if (e || s) {
              const e = this.parseImage(n[r]);
              t[i.RelativeFilename || i.Filename] = e;
            }
          }
        }
      }

      for (const n in e) {
        const r = e[n];
        void 0 !== t[r] ? e[n] = t[r] : e[n] = e[n].split("\\").pop();
      }

      return e;
    }

    parseImage(e) {
      const t = e.Content,
            n = e.RelativeFilename || e.Filename,
            r = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
      let i;

      switch (r) {
        case "bmp":
          i = "image/bmp";
          break;

        case "jpg":
        case "jpeg":
          i = "image/jpeg";
          break;

        case "png":
          i = "image/png";
          break;

        case "tif":
          i = "image/tiff";
          break;

        case "tga":
          null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
          break;

        default:
          return void console.warn('FBXLoader: Image type "' + r + '" is not supported.');
      }

      if ("string" == typeof t) return "data:" + i + ";base64," + t;
      {
        const e = new Uint8Array(t);
        return window.URL.createObjectURL(new Blob([e], {
          type: i
        }));
      }
    }

    parseTextures(e) {
      const t = new Map();

      if ("Texture" in pb.Objects) {
        const n = pb.Objects.Texture;

        for (const r in n) {
          const i = this.parseTexture(n[r], e);
          t.set(parseInt(r), i);
        }
      }

      return t;
    }

    parseTexture(e, t) {
      const n = this.loadTexture(e, t);
      n.ID = e.id, n.name = e.attrName;
      const r = e.WrapModeU,
            s = e.WrapModeV,
            o = void 0 !== r ? r.value : 0,
            a = void 0 !== s ? s.value : 0;

      if (n.wrapS = 0 === o ? i.rpg : i.uWy, n.wrapT = 0 === a ? i.rpg : i.uWy, "Scaling" in e) {
        const t = e.Scaling.value;
        n.repeat.x = t[0], n.repeat.y = t[1];
      }

      if ("Translation" in e) {
        const t = e.Translation.value;
        n.offset.x = t[0], n.offset.y = t[1];
      }

      return n;
    }

    loadTexture(e, t) {
      let n;
      const r = this.textureLoader.path,
            s = hb.get(e.id).children;
      let o;
      void 0 !== s && s.length > 0 && void 0 !== t[s[0].ID] && (n = t[s[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0));
      const a = e.FileName.slice(-3).toLowerCase();

      if ("tga" === a) {
        const t = this.manager.getHandler(".tga");
        null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ()) : (t.setPath(this.textureLoader.path), o = t.load(n));
      } else "psd" === a ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ()) : o = this.textureLoader.load(n);

      return this.textureLoader.setPath(r), o;
    }

    parseMaterials(e) {
      const t = new Map();

      if ("Material" in pb.Objects) {
        const n = pb.Objects.Material;

        for (const r in n) {
          const i = this.parseMaterial(n[r], e);
          null !== i && t.set(parseInt(r), i);
        }
      }

      return t;
    }

    parseMaterial(e, t) {
      const n = e.id,
            r = e.attrName;
      let s = e.ShadingModel;
      if ("object" == typeof s && (s = s.value), !hb.has(n)) return null;
      const o = this.parseParameters(e, t, n);
      let a;

      switch (s.toLowerCase()) {
        case "phong":
          a = new i.xoR();
          break;

        case "lambert":
          a = new i.YBo();
          break;

        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new i.xoR();
      }

      return a.setValues(o), a.name = r, a;
    }

    parseParameters(e, t, n) {
      const r = {};
      e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = new i.Ilk().fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (r.color = new i.Ilk().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = new i.Ilk().fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (r.emissive = new i.Ilk().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = new i.Ilk().fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (r.specular = new i.Ilk().fromArray(e.SpecularColor.value));
      const s = this;
      return hb.get(n).children.forEach(function (e) {
        const n = e.relationship;

        switch (n) {
          case "Bump":
            r.bumpMap = s.getTexture(t, e.ID);
            break;

          case "Maya|TEX_ao_map":
            r.aoMap = s.getTexture(t, e.ID);
            break;

          case "DiffuseColor":
          case "Maya|TEX_color_map":
            r.map = s.getTexture(t, e.ID), void 0 !== r.map && (r.map.encoding = i.knz);
            break;

          case "DisplacementColor":
            r.displacementMap = s.getTexture(t, e.ID);
            break;

          case "EmissiveColor":
            r.emissiveMap = s.getTexture(t, e.ID), void 0 !== r.emissiveMap && (r.emissiveMap.encoding = i.knz);
            break;

          case "NormalMap":
          case "Maya|TEX_normal_map":
            r.normalMap = s.getTexture(t, e.ID);
            break;

          case "ReflectionColor":
            r.envMap = s.getTexture(t, e.ID), void 0 !== r.envMap && (r.envMap.mapping = i.dSO, r.envMap.encoding = i.knz);
            break;

          case "SpecularColor":
            r.specularMap = s.getTexture(t, e.ID), void 0 !== r.specularMap && (r.specularMap.encoding = i.knz);
            break;

          case "TransparentColor":
          case "TransparencyFactor":
            r.alphaMap = s.getTexture(t, e.ID), r.transparent = !0;
            break;

          case "AmbientColor":
          case "ShininessExponent":
          case "SpecularFactor":
          case "VectorDisplacementColor":
          default:
            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n);
        }
      }), r;
    }

    getTexture(e, t) {
      return "LayeredTexture" in pb.Objects && t in pb.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = hb.get(t).children[0].ID), e.get(t);
    }

    parseDeformers() {
      const e = {},
            t = {};

      if ("Deformer" in pb.Objects) {
        const n = pb.Objects.Deformer;

        for (const r in n) {
          const i = n[r],
                s = hb.get(parseInt(r));

          if ("Skin" === i.attrType) {
            const t = this.parseSkeleton(s, n);
            t.ID = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = s.parents[0].ID, e[r] = t;
          } else if ("BlendShape" === i.attrType) {
            const e = {
              id: r
            };
            e.rawTargets = this.parseMorphTargets(s, n), e.id = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[r] = e;
          }
        }
      }

      return {
        skeletons: e,
        morphTargets: t
      };
    }

    parseSkeleton(e, t) {
      const n = [];
      return e.children.forEach(function (e) {
        const r = t[e.ID];
        if ("Cluster" !== r.attrType) return;
        const s = {
          ID: e.ID,
          indices: [],
          weights: [],
          transformLink: new i.yGw().fromArray(r.TransformLink.a)
        };
        "Indexes" in r && (s.indices = r.Indexes.a, s.weights = r.Weights.a), n.push(s);
      }), {
        rawBones: n,
        bones: []
      };
    }

    parseMorphTargets(e, t) {
      const n = [];

      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r],
              s = t[i.ID],
              o = {
          name: s.attrName,
          initialWeight: s.DeformPercent,
          id: s.id,
          fullWeights: s.FullWeights.a
        };
        if ("BlendShapeChannel" !== s.attrType) return;
        o.geoID = hb.get(parseInt(i.ID)).children.filter(function (e) {
          return void 0 === e.relationship;
        })[0].ID, n.push(o);
      }

      return n;
    }

    parseScene(e, t, n) {
      db = new i.ZAu();
      const r = this.parseModels(e.skeletons, t, n),
            s = pb.Objects.Model,
            o = this;
      r.forEach(function (e) {
        const t = s[e.ID];
        o.setLookAtProperties(e, t), hb.get(e.ID).parents.forEach(function (t) {
          const n = r.get(t.ID);
          void 0 !== n && n.add(e);
        }), null === e.parent && db.add(e);
      }), this.bindSkeleton(e.skeletons, t, r), this.createAmbientLight(), db.traverse(function (e) {
        if (e.userData.transformData) {
          e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
          const t = Cb(e.userData.transformData);
          e.applyMatrix4(t), e.updateWorldMatrix();
        }
      });
      const a = new gb().parse();
      1 === db.children.length && db.children[0].isGroup && (db.children[0].animations = a, db = db.children[0]), db.animations = a;
    }

    parseModels(e, t, n) {
      const r = new Map(),
            s = pb.Objects.Model;

      for (const o in s) {
        const a = parseInt(o),
              l = s[o],
              c = hb.get(a);
        let u = this.buildSkeleton(c, e, a, l.attrName);

        if (!u) {
          switch (l.attrType) {
            case "Camera":
              u = this.createCamera(c);
              break;

            case "Light":
              u = this.createLight(c);
              break;

            case "Mesh":
              u = this.createMesh(c, t, n);
              break;

            case "NurbsCurve":
              u = this.createCurve(c, t);
              break;

            case "LimbNode":
            case "Root":
              u = new i.N$j();
              break;

            case "Null":
            default:
              u = new i.ZAu();
          }

          u.name = l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "", u.ID = a;
        }

        this.getTransformData(u, l), r.set(a, u);
      }

      return r;
    }

    buildSkeleton(e, t, n, r) {
      let s = null;
      return e.parents.forEach(function (e) {
        for (const o in t) {
          const a = t[o];
          a.rawBones.forEach(function (t, o) {
            if (t.ID === e.ID) {
              const e = s;
              s = new i.N$j(), s.matrixWorld.copy(t.transformLink), s.name = r ? i.iUV.sanitizeNodeName(r) : "", s.ID = n, a.bones[o] = s, null !== e && s.add(e);
            }
          });
        }
      }), s;
    }

    createCamera(e) {
      let t, n;
      if (e.children.forEach(function (e) {
        const t = pb.Objects.NodeAttribute[e.ID];
        void 0 !== t && (n = t);
      }), void 0 === n) t = new i.Tme();else {
        let e = 0;
        void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1);
        let r = 1;
        void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
        let s = 1e3;
        void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3);
        let o = window.innerWidth,
            a = window.innerHeight;
        void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (o = n.AspectWidth.value, a = n.AspectHeight.value);
        const l = o / a;
        let c = 45;
        void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
        const u = n.FocalLength ? n.FocalLength.value : null;

        switch (e) {
          case 0:
            t = new i.cPb(c, l, r, s), null !== u && t.setFocalLength(u);
            break;

          case 1:
            t = new i.iKG(-o / 2, o / 2, a / 2, -a / 2, r, s);
            break;

          default:
            console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new i.Tme();
        }
      }
      return t;
    }

    createLight(e) {
      let t, n;
      if (e.children.forEach(function (e) {
        const t = pb.Objects.NodeAttribute[e.ID];
        void 0 !== t && (n = t);
      }), void 0 === n) t = new i.Tme();else {
        let e;
        e = void 0 === n.LightType ? 0 : n.LightType.value;
        let r = 16777215;
        void 0 !== n.Color && (r = new i.Ilk().fromArray(n.Color.value));
        let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
        void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (s = 0);
        let o = 0;
        void 0 !== n.FarAttenuationEnd && (o = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
        const a = 1;

        switch (e) {
          case 0:
            t = new i.cek(r, s, o, a);
            break;

          case 1:
            t = new i.Ox3(r, s);
            break;

          case 2:
            let e = Math.PI / 3;
            void 0 !== n.InnerAngle && (e = i.M8C.degToRad(n.InnerAngle.value));
            let l = 0;
            void 0 !== n.OuterAngle && (l = i.M8C.degToRad(n.OuterAngle.value), l = Math.max(l, 1)), t = new i.PMe(r, s, o, e, l, a);
            break;

          default:
            console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new i.cek(r, s);
        }

        void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0);
      }
      return t;
    }

    createMesh(e, t, n) {
      let r,
          s = null,
          o = null;
      const a = [];
      return e.children.forEach(function (e) {
        t.has(e.ID) && (s = t.get(e.ID)), n.has(e.ID) && a.push(n.get(e.ID));
      }), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new i.xoR({
        color: 13421772
      }), a.push(o)), "color" in s.attributes && a.forEach(function (e) {
        e.vertexColors = !0;
      }), s.FBX_Deformer ? (r = new i.TUv(s, o), r.normalizeSkinWeights()) : r = new i.Kj0(s, o), r;
    }

    createCurve(e, t) {
      const n = e.children.reduce(function (e, n) {
        return t.has(n.ID) && (e = t.get(n.ID)), e;
      }, null),
            r = new i.nls({
        color: 3342591,
        linewidth: 1
      });
      return new i.x12(n, r);
    }

    getTransformData(e, t) {
      const n = {};
      "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? Rb(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
    }

    setLookAtProperties(e, t) {
      "LookAtProperty" in t && hb.get(e.ID).children.forEach(function (t) {
        if ("LookAtProperty" === t.relationship) {
          const n = pb.Objects.Model[t.ID];

          if ("Lcl_Translation" in n) {
            const t = n.Lcl_Translation.value;
            void 0 !== e.target ? (e.target.position.fromArray(t), db.add(e.target)) : e.lookAt(new i.Pa4().fromArray(t));
          }
        }
      });
    }

    bindSkeleton(e, t, n) {
      const r = this.parsePoseNodes();

      for (const s in e) {
        const o = e[s];
        hb.get(parseInt(o.ID)).parents.forEach(function (e) {
          if (t.has(e.ID)) {
            const t = e.ID;
            hb.get(t).parents.forEach(function (e) {
              n.has(e.ID) && n.get(e.ID).bind(new i.OdW(o.bones), r[e.ID]);
            });
          }
        });
      }
    }

    parsePoseNodes() {
      const e = {};

      if ("Pose" in pb.Objects) {
        const t = pb.Objects.Pose;

        for (const n in t) if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
          const r = t[n].PoseNode;
          Array.isArray(r) ? r.forEach(function (t) {
            e[t.Node] = new i.yGw().fromArray(t.Matrix.a);
          }) : e[r.Node] = new i.yGw().fromArray(r.Matrix.a);
        }
      }

      return e;
    }

    createAmbientLight() {
      if ("GlobalSettings" in pb && "AmbientColor" in pb.GlobalSettings) {
        const e = pb.GlobalSettings.AmbientColor.value,
              t = e[0],
              n = e[1],
              r = e[2];

        if (0 !== t || 0 !== n || 0 !== r) {
          const e = new i.Ilk(t, n, r);
          db.add(new i.Mig(e, 1));
        }
      }
    }

  }

  class mb {
    parse(e) {
      const t = new Map();

      if ("Geometry" in pb.Objects) {
        const n = pb.Objects.Geometry;

        for (const r in n) {
          const i = hb.get(parseInt(r)),
                s = this.parseGeometry(i, n[r], e);
          t.set(parseInt(r), s);
        }
      }

      return t;
    }

    parseGeometry(e, t, n) {
      switch (t.attrType) {
        case "Mesh":
          return this.parseMeshGeometry(e, t, n);

        case "NurbsCurve":
          return this.parseNurbsGeometry(t);
      }
    }

    parseMeshGeometry(e, t, n) {
      const r = n.skeletons,
            i = [],
            s = e.parents.map(function (e) {
        return pb.Objects.Model[e.ID];
      });
      if (0 === s.length) return;
      const o = e.children.reduce(function (e, t) {
        return void 0 !== r[t.ID] && (e = r[t.ID]), e;
      }, null);
      e.children.forEach(function (e) {
        void 0 !== n.morphTargets[e.ID] && i.push(n.morphTargets[e.ID]);
      });
      const a = s[0],
            l = {};
      "RotationOrder" in a && (l.eulerOrder = Rb(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
      const c = Cb(l);
      return this.genGeometry(t, o, i, c);
    }

    genGeometry(e, t, n, r) {
      const s = new i.u9r();
      e.attrName && (s.name = e.attrName);
      const o = this.parseGeoNode(e, t),
            a = this.genBuffers(o),
            l = new i.a$l(a.vertex, 3);

      if (l.applyMatrix4(r), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new i.a$l(a.colors, 3)), t && (s.setAttribute("skinIndex", new i.qlB(a.weightsIndices, 4)), s.setAttribute("skinWeight", new i.a$l(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
        const e = new i.Vkp().getNormalMatrix(r),
              t = new i.a$l(a.normal, 3);
        t.applyNormalMatrix(e), s.setAttribute("normal", t);
      }

      if (a.uvs.forEach(function (e, t) {
        let n = "uv" + (t + 1).toString();
        0 === t && (n = "uv"), s.setAttribute(n, new i.a$l(a.uvs[t], 2));
      }), o.material && "AllSame" !== o.material.mappingType) {
        let e = a.materialIndex[0],
            t = 0;

        if (a.materialIndex.forEach(function (n, r) {
          n !== e && (s.addGroup(t, r - t, e), e = n, t = r);
        }), s.groups.length > 0) {
          const t = s.groups[s.groups.length - 1],
                n = t.start + t.count;
          n !== a.materialIndex.length && s.addGroup(n, a.materialIndex.length - n, e);
        }

        0 === s.groups.length && s.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
      }

      return this.addMorphTargets(s, e, n, r), s;
    }

    parseGeoNode(e, t) {
      const n = {};

      if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
        n.uv = [];
        let t = 0;

        for (; e.LayerElementUV[t];) e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])), t++;
      }

      return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach(function (e, t) {
        e.indices.forEach(function (r, i) {
          void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({
            id: t,
            weight: e.weights[i]
          });
        });
      })), n;
    }

    genBuffers(e) {
      const t = {
        vertex: [],
        normal: [],
        colors: [],
        uvs: [],
        materialIndex: [],
        vertexWeights: [],
        weightsIndices: []
      };
      let n = 0,
          r = 0,
          i = !1,
          s = [],
          o = [],
          a = [],
          l = [],
          c = [],
          u = [];
      const p = this;
      return e.vertexIndices.forEach(function (h, d) {
        let f,
            _ = !1;

        h < 0 && (h ^= -1, _ = !0);
        let m = [],
            g = [];

        if (s.push(3 * h, 3 * h + 1, 3 * h + 2), e.color) {
          const t = Tb(d, n, h, e.color);
          a.push(t[0], t[1], t[2]);
        }

        if (e.skeleton) {
          if (void 0 !== e.weightTable[h] && e.weightTable[h].forEach(function (e) {
            g.push(e.weight), m.push(e.id);
          }), g.length > 4) {
            i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
            const e = [0, 0, 0, 0],
                  t = [0, 0, 0, 0];
            g.forEach(function (n, r) {
              let i = n,
                  s = m[r];
              t.forEach(function (t, n, r) {
                if (i > t) {
                  r[n] = i, i = t;
                  const o = e[n];
                  e[n] = s, s = o;
                }
              });
            }), m = e, g = t;
          }

          for (; g.length < 4;) g.push(0), m.push(0);

          for (let e = 0; e < 4; ++e) c.push(g[e]), u.push(m[e]);
        }

        if (e.normal) {
          const t = Tb(d, n, h, e.normal);
          o.push(t[0], t[1], t[2]);
        }

        e.material && "AllSame" !== e.material.mappingType && (f = Tb(d, n, h, e.material)[0]), e.uv && e.uv.forEach(function (e, t) {
          const r = Tb(d, n, h, e);
          void 0 === l[t] && (l[t] = []), l[t].push(r[0]), l[t].push(r[1]);
        }), r++, _ && (p.genFace(t, e, s, f, o, a, l, c, u, r), n++, r = 0, s = [], o = [], a = [], l = [], c = [], u = []);
      }), t;
    }

    genFace(e, t, n, r, i, s, o, a, l, c) {
      for (let u = 2; u < c; u++) e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1)]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 1]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 2]]), e.vertex.push(t.vertexPositions[n[3 * u]]), e.vertex.push(t.vertexPositions[n[3 * u + 1]]), e.vertex.push(t.vertexPositions[n[3 * u + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[4 * (u - 1)]), e.vertexWeights.push(a[4 * (u - 1) + 1]), e.vertexWeights.push(a[4 * (u - 1) + 2]), e.vertexWeights.push(a[4 * (u - 1) + 3]), e.vertexWeights.push(a[4 * u]), e.vertexWeights.push(a[4 * u + 1]), e.vertexWeights.push(a[4 * u + 2]), e.vertexWeights.push(a[4 * u + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (u - 1)]), e.weightsIndices.push(l[4 * (u - 1) + 1]), e.weightsIndices.push(l[4 * (u - 1) + 2]), e.weightsIndices.push(l[4 * (u - 1) + 3]), e.weightsIndices.push(l[4 * u]), e.weightsIndices.push(l[4 * u + 1]), e.weightsIndices.push(l[4 * u + 2]), e.weightsIndices.push(l[4 * u + 3])), t.color && (e.colors.push(s[0]), e.colors.push(s[1]), e.colors.push(s[2]), e.colors.push(s[3 * (u - 1)]), e.colors.push(s[3 * (u - 1) + 1]), e.colors.push(s[3 * (u - 1) + 2]), e.colors.push(s[3 * u]), e.colors.push(s[3 * u + 1]), e.colors.push(s[3 * u + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[3 * (u - 1)]), e.normal.push(i[3 * (u - 1) + 1]), e.normal.push(i[3 * (u - 1) + 2]), e.normal.push(i[3 * u]), e.normal.push(i[3 * u + 1]), e.normal.push(i[3 * u + 2])), t.uv && t.uv.forEach(function (t, n) {
        void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(o[n][0]), e.uvs[n].push(o[n][1]), e.uvs[n].push(o[n][2 * (u - 1)]), e.uvs[n].push(o[n][2 * (u - 1) + 1]), e.uvs[n].push(o[n][2 * u]), e.uvs[n].push(o[n][2 * u + 1]);
      });
    }

    addMorphTargets(e, t, n, r) {
      if (0 === n.length) return;
      e.morphTargetsRelative = !0, e.morphAttributes.position = [];
      const i = this;
      n.forEach(function (n) {
        n.rawTargets.forEach(function (n) {
          const s = pb.Objects.Geometry[n.geoID];
          void 0 !== s && i.genMorphGeometry(e, t, s, r, n.name);
        });
      });
    }

    genMorphGeometry(e, t, n, r, s) {
      const o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
            a = void 0 !== n.Vertices ? n.Vertices.a : [],
            l = void 0 !== n.Indexes ? n.Indexes.a : [],
            c = 3 * e.attributes.position.count,
            u = new Float32Array(c);

      for (let e = 0; e < l.length; e++) {
        const t = 3 * l[e];
        u[t] = a[3 * e], u[t + 1] = a[3 * e + 1], u[t + 2] = a[3 * e + 2];
      }

      const p = {
        vertexIndices: o,
        vertexPositions: u
      },
            h = this.genBuffers(p),
            d = new i.a$l(h.vertex, 3);
      d.name = s || n.attrName, d.applyMatrix4(r), e.morphAttributes.position.push(d);
    }

    parseNormals(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.Normals.a;
      let i = [];
      return "IndexToDirect" === n && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
        dataSize: 3,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseUVs(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.UV.a;
      let i = [];
      return "IndexToDirect" === n && (i = e.UVIndex.a), {
        dataSize: 2,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseVertexColors(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.Colors.a;
      let i = [];
      return "IndexToDirect" === n && (i = e.ColorIndex.a), {
        dataSize: 4,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseMaterialIndices(e) {
      const t = e.MappingInformationType,
            n = e.ReferenceInformationType;
      if ("NoMappingInformation" === t) return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
      const r = e.Materials.a,
            i = [];

      for (let e = 0; e < r.length; ++e) i.push(e);

      return {
        dataSize: 1,
        buffer: r,
        indices: i,
        mappingType: t,
        referenceType: n
      };
    }

    parseNurbsGeometry(e) {
      if (void 0 === ub) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new i.u9r();
      const t = parseInt(e.Order);
      if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new i.u9r();
      const n = t - 1,
            r = e.KnotVector.a,
            s = [],
            o = e.Points.a;

      for (let e = 0, t = o.length; e < t; e += 4) s.push(new i.Ltg().fromArray(o, e));

      let a, l;
      if ("Closed" === e.Form) s.push(s[0]);else if ("Periodic" === e.Form) {
        a = n, l = r.length - 1 - a;

        for (let e = 0; e < n; ++e) s.push(s[e]);
      }
      const c = new ub(n, r, s, a, l).getPoints(12 * s.length);
      return new i.u9r().setFromPoints(c);
    }

  }

  class gb {
    parse() {
      const e = [],
            t = this.parseClips();
      if (void 0 !== t) for (const n in t) {
        const r = t[n],
              i = this.addClip(r);
        e.push(i);
      }
      return e;
    }

    parseClips() {
      if (void 0 === pb.Objects.AnimationCurve) return;
      const e = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(e);
      const t = this.parseAnimationLayers(e);
      return this.parseAnimStacks(t);
    }

    parseAnimationCurveNodes() {
      const e = pb.Objects.AnimationCurveNode,
            t = new Map();

      for (const n in e) {
        const r = e[n];

        if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
          const e = {
            id: r.id,
            attr: r.attrName,
            curves: {}
          };
          t.set(e.id, e);
        }
      }

      return t;
    }

    parseAnimationCurves(e) {
      const t = pb.Objects.AnimationCurve;

      for (const n in t) {
        const r = {
          id: t[n].id,
          times: t[n].KeyTime.a.map(Sb),
          values: t[n].KeyValueFloat.a
        },
              i = hb.get(r.id);

        if (void 0 !== i) {
          const t = i.parents[0].ID,
                n = i.parents[0].relationship;
          n.match(/X/) ? e.get(t).curves.x = r : n.match(/Y/) ? e.get(t).curves.y = r : n.match(/Z/) ? e.get(t).curves.z = r : n.match(/d|DeformPercent/) && e.has(t) && (e.get(t).curves.morph = r);
        }
      }
    }

    parseAnimationLayers(e) {
      const t = pb.Objects.AnimationLayer,
            n = new Map();

      for (const r in t) {
        const t = [],
              s = hb.get(parseInt(r));
        void 0 !== s && (s.children.forEach(function (n, r) {
          if (e.has(n.ID)) {
            const s = e.get(n.ID);

            if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
              if (void 0 === t[r]) {
                const e = hb.get(n.ID).parents.filter(function (e) {
                  return void 0 !== e.relationship;
                })[0].ID;

                if (void 0 !== e) {
                  const s = pb.Objects.Model[e.toString()];
                  if (void 0 === s) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                  const o = {
                    modelName: s.attrName ? i.iUV.sanitizeNodeName(s.attrName) : "",
                    ID: s.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  db.traverse(function (e) {
                    e.ID === s.id && (o.transform = e.matrix, e.userData.transformData && (o.eulerOrder = e.userData.transformData.eulerOrder));
                  }), o.transform || (o.transform = new i.yGw()), "PreRotation" in s && (o.preRotation = s.PreRotation.value), "PostRotation" in s && (o.postRotation = s.PostRotation.value), t[r] = o;
                }
              }

              t[r] && (t[r][s.attr] = s);
            } else if (void 0 !== s.curves.morph) {
              if (void 0 === t[r]) {
                const e = hb.get(n.ID).parents.filter(function (e) {
                  return void 0 !== e.relationship;
                })[0].ID,
                      s = hb.get(e).parents[0].ID,
                      o = hb.get(s).parents[0].ID,
                      a = hb.get(o).parents[0].ID,
                      l = pb.Objects.Model[a],
                      c = {
                  modelName: l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "",
                  morphName: pb.Objects.Deformer[e].attrName
                };
                t[r] = c;
              }

              t[r][s.attr] = s;
            }
          }
        }), n.set(parseInt(r), t));
      }

      return n;
    }

    parseAnimStacks(e) {
      const t = pb.Objects.AnimationStack,
            n = {};

      for (const r in t) {
        const i = hb.get(parseInt(r)).children;
        i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
        const s = e.get(i[0].ID);
        n[r] = {
          name: t[r].attrName,
          layer: s
        };
      }

      return n;
    }

    addClip(e) {
      let t = [];
      const n = this;
      return e.layer.forEach(function (e) {
        t = t.concat(n.generateTracks(e));
      }), new i.m7l(e.name, -1, t);
    }

    generateTracks(e) {
      const t = [];
      let n = new i.Pa4(),
          r = new i._fP(),
          s = new i.Pa4();

      if (e.transform && e.transform.decompose(n, r, s), n = n.toArray(), r = new i.USm().setFromQuaternion(r, e.eulerOrder).toArray(), s = s.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
        const r = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
        void 0 !== r && t.push(r);
      }

      if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
        const n = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
        void 0 !== n && t.push(n);
      }

      if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
        const n = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
        void 0 !== n && t.push(n);
      }

      if (void 0 !== e.DeformPercent) {
        const n = this.generateMorphTrack(e);
        void 0 !== n && t.push(n);
      }

      return t;
    }

    generateVectorTrack(e, t, n, r) {
      const s = this.getTimesForAllAxes(t),
            o = this.getKeyframeTrackValues(s, t, n);
      return new i.yC1(e + "." + r, s, o);
    }

    generateRotationTrack(e, t, n, r, s, o) {
      void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(i.M8C.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(i.M8C.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(i.M8C.degToRad));
      const a = this.getTimesForAllAxes(t),
            l = this.getKeyframeTrackValues(a, t, n);
      void 0 !== r && ((r = r.map(i.M8C.degToRad)).push(o), r = new i.USm().fromArray(r), r = new i._fP().setFromEuler(r)), void 0 !== s && ((s = s.map(i.M8C.degToRad)).push(o), s = new i.USm().fromArray(s), s = new i._fP().setFromEuler(s).invert());
      const c = new i._fP(),
            u = new i.USm(),
            p = [];

      for (let e = 0; e < l.length; e += 3) u.set(l[e], l[e + 1], l[e + 2], o), c.setFromEuler(u), void 0 !== r && c.premultiply(r), void 0 !== s && c.multiply(s), c.toArray(p, e / 3 * 4);

      return new i.iLg(e + ".quaternion", a, p);
    }

    generateMorphTrack(e) {
      const t = e.DeformPercent.curves.morph,
            n = t.values.map(function (e) {
        return e / 100;
      }),
            r = db.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
      return new i.dUE(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, n);
    }

    getTimesForAllAxes(e) {
      let t = [];

      if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort(function (e, t) {
        return e - t;
      }), t.length > 1) {
        let e = 1,
            n = t[0];

        for (let r = 1; r < t.length; r++) {
          const i = t[r];
          i !== n && (t[e] = i, n = i, e++);
        }

        t = t.slice(0, e);
      }

      return t;
    }

    getKeyframeTrackValues(e, t, n) {
      const r = n,
            i = [];
      let s = -1,
          o = -1,
          a = -1;
      return e.forEach(function (e) {
        if (t.x && (s = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (a = t.z.times.indexOf(e)), -1 !== s) {
          const e = t.x.values[s];
          i.push(e), r[0] = e;
        } else i.push(r[0]);

        if (-1 !== o) {
          const e = t.y.values[o];
          i.push(e), r[1] = e;
        } else i.push(r[1]);

        if (-1 !== a) {
          const e = t.z.values[a];
          i.push(e), r[2] = e;
        } else i.push(r[2]);
      }), i;
    }

    interpolateRotations(e) {
      for (let t = 1; t < e.values.length; t++) {
        const n = e.values[t - 1],
              r = e.values[t] - n,
              i = Math.abs(r);

        if (i >= 180) {
          const s = i / 180,
                o = r / s;
          let a = n + o;
          const l = e.times[t - 1],
                c = (e.times[t] - l) / s;
          let u = l + c;
          const p = [],
                h = [];

          for (; u < e.times[t];) p.push(u), u += c, h.push(a), a += o;

          e.times = Db(e.times, t, p), e.values = Db(e.values, t, h);
        }
      }
    }

  }

  class vb {
    getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }

    getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }

    getCurrentProp() {
      return this.currentProp;
    }

    pushStack(e) {
      this.nodeStack.push(e), this.currentIndent += 1;
    }

    popStack() {
      this.nodeStack.pop(), this.currentIndent -= 1;
    }

    setCurrentProp(e, t) {
      this.currentProp = e, this.currentPropName = t;
    }

    parse(e) {
      this.currentIndent = 0, this.allNodes = new yb(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
      const t = this,
            n = e.split(/[\r\n]+/);
      return n.forEach(function (e, r) {
        const i = e.match(/^[\s\t]*;/),
              s = e.match(/^[\s\t]*$/);
        if (i || s) return;
        const o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
              a = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
              l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
        o ? t.parseNodeBegin(e, o) : a ? t.parseNodeProperty(e, a, n[++r]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
      }), this.allNodes;
    }

    parseNodeBegin(e, t) {
      const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            r = t[2].split(",").map(function (e) {
        return e.trim().replace(/^"/, "").replace(/"$/, "");
      }),
            i = {
        name: n
      },
            s = this.parseNodeAttr(r),
            o = this.getCurrentNode();
      0 === this.currentIndent ? this.allNodes.add(n, i) : n in o ? ("PoseNode" === n ? o.PoseNode.push(i) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== s.id && (o[n][s.id] = i)) : "number" == typeof s.id ? (o[n] = {}, o[n][s.id] = i) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i);
    }

    parseNodeAttr(e) {
      let t = e[0];
      "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
      let n = "",
          r = "";
      return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), r = e[2]), {
        id: t,
        name: n,
        type: r
      };
    }

    parseNodeProperty(e, t, n) {
      let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
          i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
      "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
      const s = this.getCurrentNode();

      if ("Properties70" !== s.name) {
        if ("C" === r) {
          const e = i.split(",").slice(1),
                t = parseInt(e[0]),
                n = parseInt(e[1]);
          let o = i.split(",").slice(3);
          o = o.map(function (e) {
            return e.trim().replace(/^"/, "");
          }), r = "connections", i = [t, n], function (e, t) {
            for (let n = 0, r = e.length, i = t.length; n < i; n++, r++) e[r] = t[n];
          }(i, o), void 0 === s[r] && (s[r] = []);
        }

        "Node" === r && (s.id = i), r in s && Array.isArray(s[r]) ? s[r].push(i) : "a" !== r ? s[r] = i : s.a = i, this.setCurrentProp(s, r), "a" === r && "," !== i.slice(-1) && (s.a = kb(i));
      } else this.parseNodeSpecialProperty(e, r, i);
    }

    parseNodePropertyContinued(e) {
      const t = this.getCurrentNode();
      t.a += e, "," !== e.slice(-1) && (t.a = kb(t.a));
    }

    parseNodeSpecialProperty(e, t, n) {
      const r = n.split('",').map(function (e) {
        return e.trim().replace(/^\"/, "").replace(/\s/, "_");
      }),
            i = r[0],
            s = r[1],
            o = r[2],
            a = r[3];
      let l = r[4];

      switch (s) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
          l = parseFloat(l);
          break;

        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
          l = kb(l);
      }

      this.getPrevNode()[i] = {
        type: s,
        type2: o,
        flag: a,
        value: l
      }, this.setCurrentProp(this.getPrevNode(), i);
    }

  }

  class bb {
    parse(e) {
      const t = new xb(e);
      t.skip(23);
      const n = t.getUint32();
      if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
      const r = new yb();

      for (; !this.endOfContent(t);) {
        const e = this.parseNode(t, n);
        null !== e && r.add(e.name, e);
      }

      return r;
    }

    endOfContent(e) {
      return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
    }

    parseNode(e, t) {
      const n = {},
            r = t >= 7500 ? e.getUint64() : e.getUint32(),
            i = t >= 7500 ? e.getUint64() : e.getUint32();
      t >= 7500 ? e.getUint64() : e.getUint32();
      const s = e.getUint8(),
            o = e.getString(s);
      if (0 === r) return null;
      const a = [];

      for (let t = 0; t < i; t++) a.push(this.parseProperty(e));

      const l = a.length > 0 ? a[0] : "",
            c = a.length > 1 ? a[1] : "",
            u = a.length > 2 ? a[2] : "";

      for (n.singleProperty = 1 === i && e.getOffset() === r; r > e.getOffset();) {
        const r = this.parseNode(e, t);
        null !== r && this.parseSubNode(o, n, r);
      }

      return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== u && (n.attrType = u), "" !== o && (n.name = o), n;
    }

    parseSubNode(e, t, n) {
      if (!0 === n.singleProperty) {
        const e = n.propertyList[0];
        Array.isArray(e) ? (t[n.name] = n, n.a = e) : t[n.name] = e;
      } else if ("Connections" === e && "C" === n.name) {
        const e = [];
        n.propertyList.forEach(function (t, n) {
          0 !== n && e.push(t);
        }), void 0 === t.connections && (t.connections = []), t.connections.push(e);
      } else if ("Properties70" === n.name) Object.keys(n).forEach(function (e) {
        t[e] = n[e];
      });else if ("Properties70" === e && "P" === n.name) {
        let e = n.propertyList[0],
            r = n.propertyList[1];
        const i = n.propertyList[2],
              s = n.propertyList[3];
        let o;
        0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")), o = "Color" === r || "ColorRGB" === r || "Vector" === r || "Vector3D" === r || 0 === r.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[e] = {
          type: r,
          type2: i,
          flag: s,
          value: o
        };
      } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n);
    }

    parseProperty(e) {
      const t = e.getString(1);
      let r;

      switch (t) {
        case "C":
          return e.getBoolean();

        case "D":
          return e.getFloat64();

        case "F":
          return e.getFloat32();

        case "I":
          return e.getInt32();

        case "L":
          return e.getInt64();

        case "R":
          return r = e.getUint32(), e.getArrayBuffer(r);

        case "S":
          return r = e.getUint32(), e.getString(r);

        case "Y":
          return e.getInt16();

        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
          const i = e.getUint32(),
                s = e.getUint32(),
                o = e.getUint32();
          if (0 === s) switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(i);

            case "d":
              return e.getFloat64Array(i);

            case "f":
              return e.getFloat32Array(i);

            case "i":
              return e.getInt32Array(i);

            case "l":
              return e.getInt64Array(i);
          }
          void 0 === n && console.error("THREE.FBXLoader: External library fflate.min.js required.");
          const a = Av(new Uint8Array(e.getArrayBuffer(o))),
                l = new xb(a.buffer);

          switch (t) {
            case "b":
            case "c":
              return l.getBooleanArray(i);

            case "d":
              return l.getFloat64Array(i);

            case "f":
              return l.getFloat32Array(i);

            case "i":
              return l.getInt32Array(i);

            case "l":
              return l.getInt64Array(i);
          }

          break;

        default:
          throw new Error("THREE.FBXLoader: Unknown property type " + t);
      }
    }

  }

  class xb {
    constructor(e, t) {
      this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t;
    }

    getOffset() {
      return this.offset;
    }

    size() {
      return this.dv.buffer.byteLength;
    }

    skip(e) {
      this.offset += e;
    }

    getBoolean() {
      return 1 == (1 & this.getUint8());
    }

    getBooleanArray(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getBoolean());

      return t;
    }

    getUint8() {
      const e = this.dv.getUint8(this.offset);
      return this.offset += 1, e;
    }

    getInt16() {
      const e = this.dv.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, e;
    }

    getInt32() {
      const e = this.dv.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getInt32Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getInt32());

      return t;
    }

    getUint32() {
      const e = this.dv.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getInt64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, 4294967295 === e && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e;
    }

    getInt64Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getInt64());

      return t;
    }

    getUint64() {
      let e, t;
      return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e;
    }

    getFloat32() {
      const e = this.dv.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, e;
    }

    getFloat32Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getFloat32());

      return t;
    }

    getFloat64() {
      const e = this.dv.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, e;
    }

    getFloat64Array(e) {
      const t = [];

      for (let n = 0; n < e; n++) t.push(this.getFloat64());

      return t;
    }

    getArrayBuffer(e) {
      const t = this.dv.buffer.slice(this.offset, this.offset + e);
      return this.offset += e, t;
    }

    getString(e) {
      let t = [];

      for (let n = 0; n < e; n++) t[n] = this.getUint8();

      const n = t.indexOf(0);
      return n >= 0 && (t = t.slice(0, n)), i.Zp0.decodeText(new Uint8Array(t));
    }

  }

  class yb {
    add(e, t) {
      this[e] = t;
    }

  }

  function wb(e) {
    const t = e.match(/FBXVersion: (\d+)/);
    if (t) return parseInt(t[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
  }

  function Sb(e) {
    return e / 46186158e3;
  }

  const Mb = [];

  function Tb(e, t, n, r) {
    let i;

    switch (r.mappingType) {
      case "ByPolygonVertex":
        i = e;
        break;

      case "ByPolygon":
        i = t;
        break;

      case "ByVertice":
        i = n;
        break;

      case "AllSame":
        i = r.indices[0];
        break;

      default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType);
    }

    "IndexToDirect" === r.referenceType && (i = r.indices[i]);
    const s = i * r.dataSize,
          o = s + r.dataSize;
    return function (e, t, n, r) {
      for (let i = n, s = 0; i < r; i++, s++) e[s] = t[i];

      return e;
    }(Mb, r.buffer, s, o);
  }

  const Eb = new i.USm(),
        Ab = new i.Pa4();

  function Cb(e) {
    const t = new i.yGw(),
          n = new i.yGw(),
          r = new i.yGw(),
          s = new i.yGw(),
          o = new i.yGw(),
          a = new i.yGw(),
          l = new i.yGw(),
          c = new i.yGw(),
          u = new i.yGw(),
          p = new i.yGw(),
          h = new i.yGw(),
          d = new i.yGw(),
          f = e.inheritType ? e.inheritType : 0;

    if (e.translation && t.setPosition(Ab.fromArray(e.translation)), e.preRotation) {
      const t = e.preRotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), n.makeRotationFromEuler(Eb.fromArray(t));
    }

    if (e.rotation) {
      const t = e.rotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), r.makeRotationFromEuler(Eb.fromArray(t));
    }

    if (e.postRotation) {
      const t = e.postRotation.map(i.M8C.degToRad);
      t.push(e.eulerOrder), s.makeRotationFromEuler(Eb.fromArray(t)), s.invert();
    }

    e.scale && o.scale(Ab.fromArray(e.scale)), e.scalingOffset && l.setPosition(Ab.fromArray(e.scalingOffset)), e.scalingPivot && a.setPosition(Ab.fromArray(e.scalingPivot)), e.rotationOffset && c.setPosition(Ab.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(Ab.fromArray(e.rotationPivot)), e.parentMatrixWorld && (h.copy(e.parentMatrix), p.copy(e.parentMatrixWorld));

    const _ = n.clone().multiply(r).multiply(s),
          m = new i.yGw();

    m.extractRotation(p);
    const g = new i.yGw();
    g.copyPosition(p);
    const v = g.clone().invert().multiply(p),
          b = m.clone().invert().multiply(v),
          x = o,
          y = new i.yGw();
    if (0 === f) y.copy(m).multiply(_).multiply(b).multiply(x);else if (1 === f) y.copy(m).multiply(b).multiply(_).multiply(x);else {
      const e = new i.yGw().scale(new i.Pa4().setFromMatrixScale(h)).clone().invert(),
            t = b.clone().multiply(e);
      y.copy(m).multiply(_).multiply(t).multiply(x);
    }
    const w = u.clone().invert(),
          S = a.clone().invert();
    let M = t.clone().multiply(c).multiply(u).multiply(n).multiply(r).multiply(s).multiply(w).multiply(l).multiply(a).multiply(o).multiply(S);
    const T = new i.yGw().copyPosition(M),
          E = p.clone().multiply(T);
    return d.copyPosition(E), M = d.clone().multiply(y), M.premultiply(p.invert()), M;
  }

  function Rb(e) {
    const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e];
  }

  function kb(e) {
    return e.split(",").map(function (e) {
      return parseFloat(e);
    });
  }

  function Pb(e, t, n) {
    return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), i.Zp0.decodeText(new Uint8Array(e, t, n));
  }

  function Db(e, t, n) {
    return e.slice(0, t).concat(n).concat(e.slice(t));
  }

  class Ob extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs], this._importer = new $t(fb, ["fbx"], !0);
    }

    async onAdded(e) {
      Us.Importers.push(this._importer);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Us.Importers.splice(Us.Importers.indexOf(this._importer), 1);
    }

  }

  Ob.PluginType = "FBXLoadPlugin";
  const Lb = new WeakMap();

  class Ib extends i.aNw {
    constructor(e) {
      super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = [];
    }

    setLibraryPath(e) {
      return this.libraryPath = e, this;
    }

    setWorkerLimit(e) {
      return this.workerLimit = e, this;
    }

    load(e, t, n, r) {
      const s = new i.hH6(this.manager);
      s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), this.url = e, s.load(e, n => {
        if (Lb.has(n)) return Lb.get(n).promise.then(t).catch(r);
        this.decodeObjects(n, e).then(e => {
          e.userData.warnings = this.warnings, t(e);
        }).catch(e => r(e));
      }, n, r);
    }

    debug() {
      console.log("Task load: ", this.workerPool.map(e => e._taskLoad));
    }

    decodeObjects(e, t) {
      let n, r;

      const i = e.byteLength,
            s = this._getWorker(i).then(t => (n = t, r = this.workerNextTaskID++, new Promise((t, i) => {
        n._callbacks[r] = {
          resolve: t,
          reject: i
        }, n.postMessage({
          type: "decode",
          id: r,
          buffer: e
        }, [e]);
      }))).then(e => this._createGeometry(e.data)).catch(e => {
        throw e;
      });

      return s.catch(() => !0).then(() => {
        n && r && this._releaseTask(n, r);
      }), Lb.set(e, {
        url: t,
        promise: s
      }), s;
    }

    parse(e, t, n) {
      this.decodeObjects(e, "").then(e => {
        e.userData.warnings = this.warnings, t(e);
      }).catch(e => n(e));
    }

    _compareMaterials(e) {
      const t = {};
      t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type;

      for (let e = 0; e < this.materials.length; e++) {
        const n = this.materials[e],
              r = {};
        if (r.name = n.name, r.color = {}, r.color.r = n.color.r, r.color.g = n.color.g, r.color.b = n.color.b, r.type = n.type, JSON.stringify(t) === JSON.stringify(r)) return n;
      }

      return this.materials.push(e), e;
    }

    _createMaterial(e) {
      if (void 0 === e) return new i.Wid({
        color: new i.Ilk(1, 1, 1),
        metalness: .8,
        name: "default",
        side: 2
      });
      const t = e.diffuseColor,
            n = new i.Ilk(t.r / 255, t.g / 255, t.b / 255);
      0 === t.r && 0 === t.g && 0 === t.b && (n.r = 1, n.g = 1, n.b = 1);
      const r = new i.Wid({
        color: n,
        name: e.name,
        side: 2,
        transparent: e.transparency > 0,
        opacity: 1 - e.transparency
      }),
            s = new i.dpR();

      for (let t = 0; t < e.textures.length; t++) {
        const n = e.textures[t];

        if (null !== n.image) {
          const e = s.load(n.image);

          switch (n.type) {
            case "Diffuse":
              r.map = e;
              break;

            case "Bump":
              r.bumpMap = e;
              break;

            case "Transparency":
              r.alphaMap = e, r.transparent = !0;
              break;

            case "Emap":
              r.envMap = e;
          }

          e.wrapS = 0 === n.wrapU ? i.rpg : i.uWy, e.wrapT = 0 === n.wrapV ? i.rpg : i.uWy, e.repeat.set(n.repeat[0], n.repeat[1]);
        }
      }

      return r;
    }

    _createGeometry(e) {
      const t = new i.Tme(),
            n = [],
            r = [],
            s = [];
      t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url;
      let o = e.objects;
      const a = e.materials;

      for (let i = 0; i < o.length; i++) {
        const l = o[i],
              c = l.attributes;

        switch (l.objectType) {
          case "InstanceDefinition":
            r.push(l);
            break;

          case "InstanceReference":
            s.push(l);
            break;

          default:
            let i;

            if (c.materialIndex >= 0) {
              const e = a[c.materialIndex];

              let t = this._createMaterial(e);

              t = this._compareMaterials(t), i = this._createObject(l, t);
            } else {
              const e = this._createMaterial();

              i = this._createObject(l, e);
            }

            if (void 0 === i) continue;
            const o = e.layers[c.layerIndex];
            i.visible = !o || e.layers[c.layerIndex].visible, c.isInstanceDefinitionObject ? n.push(i) : t.add(i);
        }
      }

      for (let e = 0; e < r.length; e++) {
        const a = r[e];
        o = [];

        for (let e = 0; e < a.attributes.objectIds.length; e++) {
          const t = a.attributes.objectIds[e];

          for (let e = 0; e < n.length; e++) t === n[e].userData.attributes.id && o.push(n[e]);
        }

        for (let e = 0; e < s.length; e++) {
          const n = s[e];

          if (n.geometry.parentIdefId === a.attributes.id) {
            const e = new i.Tme(),
                  r = n.geometry.xform.array,
                  s = new i.yGw();
            s.set(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]), e.applyMatrix4(s);

            for (let t = 0; t < o.length; t++) e.add(o[t].clone(!0));

            t.add(e);
          }
        }
      }

      return t.userData.materials = this.materials, t;
    }

    _createObject(e, t) {
      const n = new i.s4_(),
            r = e.attributes;
      let s, o, a, l;

      switch (e.objectType) {
        case "Point":
        case "PointSet":
          s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") ? o = new i.UY4({
            vertexColors: !0,
            sizeAttenuation: !1,
            size: 2
          }) : (a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.UY4({
            color: l,
            sizeAttenuation: !1,
            size: 2
          })), o = this._compareMaterials(o);
          const c = new i.woe(s, o);
          return c.userData.attributes = r, c.userData.objectType = e.objectType, r.name && (c.name = r.name), c;

        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
          if (null === e.geometry) return;
          s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") && (t.vertexColors = !0), null === t && (t = this._createMaterial(), t = this._compareMaterials(t));
          const u = new i.Kj0(s, t);
          return u.castShadow = r.castsShadows, u.receiveShadow = r.receivesShadows, u.userData.attributes = r, u.userData.objectType = e.objectType, r.name && (u.name = r.name), u;

        case "Curve":
          s = n.parse(e.geometry), a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.nls({
            color: l
          }), o = this._compareMaterials(o);
          const p = new i.x12(s, o);
          return p.userData.attributes = r, p.userData.objectType = e.objectType, r.name && (p.name = r.name), p;

        case "TextDot":
          s = e.geometry;
          const h = document.createElement("canvas").getContext("2d"),
                d = `${s.fontHeight}px ${s.fontFace}`;
          h.font = d;

          const f = h.measureText(s.text).width + 10,
                _ = s.fontHeight + 10,
                m = window.devicePixelRatio;

          h.canvas.width = f * m, h.canvas.height = _ * m, h.canvas.style.width = f + "px", h.canvas.style.height = _ + "px", h.setTransform(m, 0, 0, m, 0, 0), h.font = d, h.textBaseline = "middle", h.textAlign = "center", l = r.drawColor, h.fillStyle = `rgba(${l.r},${l.g},${l.b},${l.a})`, h.fillRect(0, 0, f, _), h.fillStyle = "white", h.fillText(s.text, f / 2, _ / 2);
          const g = new i.ROQ(h.canvas);
          g.minFilter = i.wem, g.wrapS = i.uWy, g.wrapT = i.uWy, o = new i.xeV({
            map: g,
            depthTest: !1
          });
          const v = new i.jyi(o);
          return v.position.set(s.point[0], s.point[1], s.point[2]), v.scale.set(f / 10, _ / 10, 1), v.userData.attributes = r, v.userData.objectType = e.objectType, r.name && (v.name = r.name), v;

        case "Light":
          let b;

          switch (s = e.geometry, s.lightStyle.name) {
            case "LightStyle_WorldPoint":
              b = new i.cek(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.shadow.normalBias = .1;
              break;

            case "LightStyle_WorldSpot":
              b = new i.PMe(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.angle = s.spotAngleRadians, b.shadow.normalBias = .1;
              break;

            case "LightStyle_WorldRectangular":
              b = new i.T_f();
              const e = Math.abs(s.width[2]),
                    t = Math.abs(s.length[0]);
              b.position.set(s.location[0] - t / 2, s.location[1], s.location[2] - e / 2), b.height = t, b.width = e, b.lookAt(new i.Pa4(s.direction[0], s.direction[1], s.direction[2]));
              break;

            case "LightStyle_WorldDirectional":
              b = new i.Ox3(), b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.shadow.normalBias = .1;
          }

          return b && (b.intensity = s.intensity, a = s.diffuse, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), b.color = l, b.userData.attributes = r, b.userData.objectType = e.objectType), b;
      }
    }

    _initLibrary() {
      if (!this.libraryPending) {
        const e = new i.hH6(this.manager);
        e.setPath(this.libraryPath);
        const t = new Promise((t, n) => {
          e.load("rhino3dm.js", t, void 0, n);
        }),
              n = new i.hH6(this.manager);
        n.setPath(this.libraryPath), n.setResponseType("arraybuffer");
        const r = new Promise((e, t) => {
          n.load("rhino3dm.wasm", e, void 0, t);
        });
        this.libraryPending = Promise.all([t, r]).then(([e, t]) => {
          this.libraryConfig.wasmBinary = t;
          const n = Fb.toString(),
                r = ["/* rhino3dm.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
          this.workerSourceURL = URL.createObjectURL(new Blob([r]));
        });
      }

      return this.libraryPending;
    }

    _getWorker(e) {
      return this._initLibrary().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const e = new Worker(this.workerSourceURL);
          e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
            type: "init",
            libraryConfig: this.libraryConfig
          }), e.onmessage = t => {
            const n = t.data;

            switch (n.type) {
              case "warning":
                this.warnings.push(n.data), console.warn(n.data);
                break;

              case "decode":
                e._callbacks[n.id].resolve(n);

                break;

              case "error":
                e._callbacks[n.id].reject(n);

                break;

              default:
                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + n.type + '"');
            }
          }, this.workerPool.push(e);
        } else this.workerPool.sort(function (e, t) {
          return e._taskLoad > t._taskLoad ? -1 : 1;
        });

        const t = this.workerPool[this.workerPool.length - 1];
        return t._taskLoad += e, t;
      });
    }

    _releaseTask(e, t) {
      e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
    }

    dispose() {
      for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();

      return this.workerPool.length = 0, this;
    }

  }

  function Fb() {
    let e, t, n, r;

    function i(e, t) {
      const i = e.geometry(),
            a = e.attributes();
      let l,
          c,
          u,
          p,
          h,
          d = i.objectType;

      switch (d) {
        case n.ObjectType.Curve:
          const e = o(i, 100);
          u = {}, c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [];

          for (let t = 0; t < e.length; t++) u.array.push(e[t][0]), u.array.push(e[t][1]), u.array.push(e[t][2]);

          c.position = u, p.attributes = c, l = {
            data: p
          };
          break;

        case n.ObjectType.Point:
          const f = i.location;
          u = {};
          const _ = {};
          c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [f[0], f[1], f[2]];
          const m = a.drawColor(t);
          _.itemSize = 3, _.type = "Float32Array", _.array = [m.r / 255, m.g / 255, m.b / 255], c.position = u, c.color = _, p.attributes = c, l = {
            data: p
          };
          break;

        case n.ObjectType.PointSet:
        case n.ObjectType.Mesh:
          l = i.toThreejsJSON();
          break;

        case n.ObjectType.Brep:
          const g = i.faces();
          h = new n.Mesh();

          for (let e = 0; e < g.count; e++) {
            const t = g.get(e),
                  r = t.getMesh(n.MeshType.Any);
            r && (h.append(r), r.delete()), t.delete();
          }

          h.faces().count > 0 && (h.compact(), l = h.toThreejsJSON(), g.delete()), h.delete();
          break;

        case n.ObjectType.Extrusion:
          h = i.getMesh(n.MeshType.Any), h && (l = h.toThreejsJSON(), h.delete());
          break;

        case n.ObjectType.TextDot:
          l = s(i);
          break;

        case n.ObjectType.Light:
          l = s(i), "LightStyle_WorldLinear" === l.lightStyle.name && self.postMessage({
            type: "warning",
            id: r,
            data: {
              message: `THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${l.lightStyle.name}`,
              type: "no conversion",
              guid: a.id
            }
          });
          break;

        case n.ObjectType.InstanceReference:
          l = s(i), l.xform = s(i.xform), l.xform.array = i.xform.toFloatArray(!0);
          break;

        case n.ObjectType.SubD:
          i.subdivide(3), h = n.Mesh.createFromSubDControlNet(i), h && (l = h.toThreejsJSON(), h.delete());
          break;

        default:
          self.postMessage({
            type: "warning",
            id: r,
            data: {
              message: `THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`,
              type: "not implemented",
              guid: a.id
            }
          });
      }

      if (l) return c = s(a), c.geometry = s(i), a.groupCount > 0 && (c.groupIds = a.getGroupList()), a.userStringCount > 0 && (c.userStrings = a.getUserStrings()), i.userStringCount > 0 && (c.geometry.userStrings = i.getUserStrings()), c.drawColor = a.drawColor(t), d = d.constructor.name, d = d.substring(11, d.length), {
        geometry: l,
        attributes: c,
        objectType: d
      };
      self.postMessage({
        type: "warning",
        id: r,
        data: {
          message: `THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`,
          type: "missing mesh",
          guid: a.id
        }
      });
    }

    function s(e) {
      const t = {};

      for (const n in e) {
        const r = e[n];
        "function" != typeof r && ("object" == typeof r && null !== r && r.hasOwnProperty("constructor") ? t[n] = {
          name: r.constructor.name,
          value: r.value
        } : t[n] = r);
      }

      return t;
    }

    function o(e, t) {
      let r = t,
          i = [];
      const s = [];
      if (e instanceof n.LineCurve) return [e.pointAtStart, e.pointAtEnd];

      if (e instanceof n.PolylineCurve) {
        r = e.pointCount;

        for (let t = 0; t < r; t++) i.push(e.point(t));

        return i;
      }

      if (e instanceof n.PolyCurve) {
        const t = e.segmentCount;

        for (let n = 0; n < t; n++) {
          const t = e.segmentCurve(n),
                s = o(t, r);
          i = i.concat(s), t.delete();
        }

        return i;
      }

      if (e instanceof n.ArcCurve && (r = Math.floor(e.angleDegrees / 5), r = r < 2 ? 2 : r), e instanceof n.NurbsCurve && 1 === e.degree) {
        const t = e.tryGetPolyline();

        for (let e = 0; e < t.count; e++) i.push(t.get(e));

        return t.delete(), i;
      }

      const a = e.domain,
            l = r - 1;

      for (let t = 0; t < r; t++) {
        const n = a[0] + t / l * (a[1] - a[0]);

        if (n === a[0] || n === a[1]) {
          s.push(n);
          continue;
        }

        const r = e.tangentAt(n),
              i = e.tangentAt(s.slice(-1)[0]),
              o = r[0] * r[0] + r[1] * r[1] + r[2] * r[2],
              c = i[0] * i[0] + i[1] * i[1] + i[2] * i[2],
              u = Math.sqrt(o * c);
        let p;
        if (0 === u) p = Math.PI / 2;else {
          const e = (r.x * i.x + r.y * i.y + r.z * i.z) / u;
          p = Math.acos(Math.max(-1, Math.min(1, e)));
        }
        p < .1 || s.push(n);
      }

      return i = s.map(t => e.pointAt(t)), i;
    }

    onmessage = function (o) {
      const a = o.data;

      switch (a.type) {
        case "init":
          t = a.libraryConfig;
          const o = t.wasmBinary;
          let l;
          e = new Promise(function (e) {
            l = {
              wasmBinary: o,
              onRuntimeInitialized: e
            }, rhino3dm(l);
          }).then(() => {
            n = l;
          });
          break;

        case "decode":
          r = a.id;
          const c = a.buffer;
          e.then(() => {
            try {
              const e = function (e, t) {
                const n = new Uint8Array(t),
                      o = e.File3dm.fromByteArray(n),
                      a = [],
                      l = [],
                      c = [],
                      u = [],
                      p = [],
                      h = [],
                      d = [],
                      f = o.objects(),
                      _ = f.count;

                for (let e = 0; e < _; e++) {
                  const t = f.get(e),
                        n = i(t, o);
                  t.delete(), n && a.push(n);
                }

                for (let e = 0; e < o.instanceDefinitions().count(); e++) {
                  const t = o.instanceDefinitions().get(e),
                        n = s(t);
                  n.objectIds = t.getObjectIds(), a.push({
                    geometry: null,
                    attributes: n,
                    objectType: "InstanceDefinition"
                  });
                }

                const m = [e.TextureType.Diffuse, e.TextureType.Bump, e.TextureType.Transparency, e.TextureType.Opacity, e.TextureType.Emap],
                      g = [e.TextureType.PBR_BaseColor, e.TextureType.PBR_Subsurface, e.TextureType.PBR_SubsurfaceScattering, e.TextureType.PBR_SubsurfaceScatteringRadius, e.TextureType.PBR_Metallic, e.TextureType.PBR_Specular, e.TextureType.PBR_SpecularTint, e.TextureType.PBR_Roughness, e.TextureType.PBR_Anisotropic, e.TextureType.PBR_Anisotropic_Rotation, e.TextureType.PBR_Sheen, e.TextureType.PBR_SheenTint, e.TextureType.PBR_Clearcoat, e.TextureType.PBR_ClearcoatBump, e.TextureType.PBR_ClearcoatRoughness, e.TextureType.PBR_OpacityIor, e.TextureType.PBR_OpacityRoughness, e.TextureType.PBR_Emission, e.TextureType.PBR_AmbientOcclusion, e.TextureType.PBR_Displacement];

                for (let e = 0; e < o.materials().count(); e++) {
                  const t = o.materials().get(e),
                        n = t.physicallyBased();
                  let i = s(t);
                  const a = [];

                  for (let e = 0; e < m.length; e++) {
                    const n = t.getTexture(m[e]);

                    if (n) {
                      let t = m[e].constructor.name;
                      t = t.substring(12, t.length);
                      const i = {
                        type: t
                      },
                            s = o.getEmbeddedFileAsBase64(n.fileName);
                      i.wrapU = n.wrapU, i.wrapV = n.wrapV, i.wrapW = n.wrapW;
                      const l = n.uvwTransform.toFloatArray(!0);
                      i.repeat = [l[0], l[5]], s ? i.image = "data:image/png;base64," + s : (self.postMessage({
                        type: "warning",
                        id: r,
                        data: {
                          message: `THREE.3DMLoader: Image for ${t} texture not embedded in file.`,
                          type: "missing resource"
                        }
                      }), i.image = null), a.push(i), n.delete();
                    }
                  }

                  if (i.textures = a, n.supported) {
                    for (let e = 0; e < g.length; e++) {
                      const n = t.getTexture(g[e]);

                      if (n) {
                        const t = o.getEmbeddedFileAsBase64(n.fileName);
                        let r = g[e].constructor.name;
                        r = r.substring(12, r.length);
                        const i = {
                          type: r,
                          image: "data:image/png;base64," + t
                        };
                        a.push(i), n.delete();
                      }
                    }

                    const e = s(t.physicallyBased());
                    i = Object.assign(e, i);
                  }

                  l.push(i), t.delete(), n.delete();
                }

                for (let e = 0; e < o.layers().count(); e++) {
                  const t = o.layers().get(e),
                        n = s(t);
                  c.push(n), t.delete();
                }

                for (let e = 0; e < o.views().count(); e++) {
                  const t = o.views().get(e),
                        n = s(t);
                  u.push(n), t.delete();
                }

                for (let e = 0; e < o.namedViews().count(); e++) {
                  const t = o.namedViews().get(e),
                        n = s(t);
                  p.push(n), t.delete();
                }

                for (let e = 0; e < o.groups().count(); e++) {
                  const t = o.groups().get(e),
                        n = s(t);
                  h.push(n), t.delete();
                }

                const v = s(o.settings()),
                      b = o.strings().count();

                for (let e = 0; e < b; e++) d.push(o.strings().get(e));

                return o.delete(), {
                  objects: a,
                  materials: l,
                  layers: c,
                  views: u,
                  namedViews: p,
                  groups: h,
                  strings: d,
                  settings: v
                };
              }(n, c);

              self.postMessage({
                type: "decode",
                id: a.id,
                data: e
              });
            } catch (e) {
              self.postMessage({
                type: "error",
                id: a.id,
                error: e
              });
            }
          });
      }
    };
  }

  class Nb extends Ib {
    constructor(e) {
      super(e), this.setLibraryPath("https://cdn.jsdelivr.net/npm/rhino3dm@7.11.1/");
    }

    async loadAsync(e, t) {
      return await super.loadAsync(e, t);
    }

  }

  class Ub extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs], this._importer = new $t(Nb, ["3dm"], !0);
    }

    async onAdded(e) {
      Us.Importers.push(this._importer);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Us.Importers.splice(Us.Importers.indexOf(this._importer), 1);
    }

  }

  Ub.PluginType = "Rhino3dmLoadPlugin";

  class Bb extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs];
    }

    async onAdded(e) {
      const t = document.createElement("script");
      t.type = "module", t.innerHTML = "\nimport { MeshoptDecoder } from 'https://cdn.jsdelivr.net/gh/zeux/meshoptimizer@master/js/meshopt_decoder.module.js'\nwindow.MeshoptDecoder = MeshoptDecoder\n", document.head.appendChild(t), this._script = t;
    }

    async onDispose(e) {}

    async onRemove(e) {
      this._script && (document.head.removeChild(this._script), this._script = void 0);
    }

  }

  Bb.PluginType = "GLTFMeshOptPlugin";

  class jb extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = new i.hH6(this.manager);
      o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (n) {
        try {
          t(s.parse(n));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    parse(e) {
      function t(e, t, n) {
        for (let r = 0, i = e.length; r < i; r++) if (e[r] !== t.getUint8(n + r)) return !1;

        return !0;
      }

      const n = function (e) {
        if ("string" == typeof e) {
          const t = new Uint8Array(e.length);

          for (let n = 0; n < e.length; n++) t[n] = 255 & e.charCodeAt(n);

          return t.buffer || t;
        }

        return e;
      }(e);

      return function (e) {
        const n = new DataView(e);
        if (84 + 50 * n.getUint32(80, !0) === n.byteLength) return !0;
        const r = [115, 111, 108, 105, 100];

        for (let e = 0; e < 5; e++) if (t(r, n, e)) return !1;

        return !0;
      }(n) ? function (e) {
        const t = new DataView(e),
              n = t.getUint32(80, !0);
        let r,
            s,
            o,
            a,
            l,
            c,
            u,
            p,
            h = !1;

        for (let e = 0; e < 70; e++) 1129270351 == t.getUint32(e, !1) && 82 == t.getUint8(e + 4) && 61 == t.getUint8(e + 5) && (h = !0, a = new Float32Array(3 * n * 3), l = t.getUint8(e + 6) / 255, c = t.getUint8(e + 7) / 255, u = t.getUint8(e + 8) / 255, p = t.getUint8(e + 9) / 255);

        const d = new i.u9r(),
              f = new Float32Array(3 * n * 3),
              _ = new Float32Array(3 * n * 3);

        for (let e = 0; e < n; e++) {
          const n = 84 + 50 * e,
                i = t.getFloat32(n, !0),
                p = t.getFloat32(n + 4, !0),
                d = t.getFloat32(n + 8, !0);

          if (h) {
            const e = t.getUint16(n + 48, !0);
            0 == (32768 & e) ? (r = (31 & e) / 31, s = (e >> 5 & 31) / 31, o = (e >> 10 & 31) / 31) : (r = l, s = c, o = u);
          }

          for (let l = 1; l <= 3; l++) {
            const c = n + 12 * l,
                  u = 3 * e * 3 + 3 * (l - 1);
            f[u] = t.getFloat32(c, !0), f[u + 1] = t.getFloat32(c + 4, !0), f[u + 2] = t.getFloat32(c + 8, !0), _[u] = i, _[u + 1] = p, _[u + 2] = d, h && (a[u] = r, a[u + 1] = s, a[u + 2] = o);
          }
        }

        return d.setAttribute("position", new i.TlE(f, 3)), d.setAttribute("normal", new i.TlE(_, 3)), h && (d.setAttribute("color", new i.TlE(a, 3)), d.hasColors = !0, d.alpha = p), d;
      }(n) : function (e) {
        const t = new i.u9r(),
              n = /solid([\s\S]*?)endsolid/g,
              r = /facet([\s\S]*?)endfacet/g;
        let s = 0;
        const o = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
              a = new RegExp("vertex" + o + o + o, "g"),
              l = new RegExp("normal" + o + o + o, "g"),
              c = [],
              u = [],
              p = new i.Pa4();
        let h,
            d = 0,
            f = 0,
            _ = 0;

        for (; null !== (h = n.exec(e));) {
          f = _;
          const e = h[0];

          for (; null !== (h = r.exec(e));) {
            let e = 0,
                t = 0;
            const n = h[0];

            for (; null !== (h = l.exec(n));) p.x = parseFloat(h[1]), p.y = parseFloat(h[2]), p.z = parseFloat(h[3]), t++;

            for (; null !== (h = a.exec(n));) c.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), u.push(p.x, p.y, p.z), e++, _++;

            1 !== t && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s), 3 !== e && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s), s++;
          }

          const n = f,
                i = _ - f;
          t.addGroup(n, i, d), d++;
        }

        return t.setAttribute("position", new i.a$l(c, 3)), t.setAttribute("normal", new i.a$l(u, 3)), t;
      }("string" != typeof (r = e) ? i.Zp0.decodeText(new Uint8Array(r)) : r);
      var r;
    }

  }

  class zb extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs];
    }

    async onAdded(e) {
      this._importer || (this._importer = new $t(jb, ["stl"], !0)), Us.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  zb.PluginType = "STLLoadPlugin";

  class Vb extends i.aNw {
    constructor(e) {
      super(e);
    }

    load(e, t, n, r) {
      const s = this,
            o = "" === this.path ? i.Zp0.extractUrlBase(e) : this.path,
            a = new i.hH6(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (n) {
        try {
          t(s.parse(n, o));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    setMaterialOptions(e) {
      return this.materialOptions = e, this;
    }

    parse(e, t) {
      const n = e.split("\n");
      let r = {};
      const i = /\s+/,
            s = {};

      for (let e = 0; e < n.length; e++) {
        let t = n[e];
        if (t = t.trim(), 0 === t.length || "#" === t.charAt(0)) continue;
        const o = t.indexOf(" ");
        let a = o >= 0 ? t.substring(0, o) : t;
        a = a.toLowerCase();
        let l = o >= 0 ? t.substring(o + 1) : "";
        if (l = l.trim(), "newmtl" === a) r = {
          name: l
        }, s[l] = r;else if ("ka" === a || "kd" === a || "ks" === a || "ke" === a) {
          const e = l.split(i, 3);
          r[a] = [parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2])];
        } else r[a] = l;
      }

      const o = new Gb(this.resourcePath || t, this.materialOptions);
      return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(s), o;
    }

  }

  class Gb {
    constructor(e = "", t = {}) {
      this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : i.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : i.rpg;
    }

    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }

    setManager(e) {
      this.manager = e;
    }

    setMaterials(e) {
      this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
    }

    convert(e) {
      if (!this.options) return e;
      const t = {};

      for (const n in e) {
        const r = e[n],
              i = {};
        t[n] = i;

        for (const e in r) {
          let t = !0,
              n = r[e];
          const s = e.toLowerCase();

          switch (s) {
            case "kd":
            case "ka":
            case "ks":
              this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (t = !1);
          }

          t && (i[s] = n);
        }
      }

      return t;
    }

    async preload() {
      for (const e in this.materialsInfo) await this.create(e);
    }

    getIndex(e) {
      return this.nameLookup[e];
    }

    async getAsArray() {
      let e = 0;

      for (const t in this.materialsInfo) this.materialsArray[e] = await this.create(t), this.nameLookup[t] = e, e++;

      return this.materialsArray;
    }

    async create(e) {
      return void 0 === this.materials[e] && (await this.createMaterial_(e)), this.materials[e];
    }

    async createMaterial_(e) {
      const t = this,
            n = this.materialsInfo[e],
            r = {
        name: e,
        side: this.side
      };

      async function s(e, n) {
        if (r[e]) return;
        const i = t.getTextureParams(n, r);
        return new Promise((n, s) => {
          let o = !1,
              a = () => !o && (o = !0) && n();

          const l = t.loadTexture((c = t.baseUrl, "string" != typeof (u = i.url) || "" === u ? "" : /^https?:\/\//i.test(u) ? u : c + u), void 0, t => {
            r[e] = t, a();
          }, void 0, a);
          var c, u;
          setTimeout(a, 50), l.repeat.copy(i.scale), l.offset.copy(i.offset), l.wrapS = t.wrap, l.wrapT = t.wrap;
        });
      }

      const o = Array.from(Object.keys(n || {}));
      let a = o.includes("d") || o.includes("D");

      for (const e of o) {
        const t = n[e];
        let o;
        if ("" !== t) switch (e.toLowerCase()) {
          case "kd":
            r.color = new i.Ilk().fromArray(t);
            break;

          case "ks":
            r.specular = new i.Ilk().fromArray(t);
            break;

          case "ke":
            r.emissive = new i.Ilk().fromArray(t);
            break;

          case "map_kd":
            await s("map", t);
            break;

          case "map_ks":
            await s("specularMap", t);
            break;

          case "map_ke":
            await s("emissiveMap", t);
            break;

          case "norm":
            await s("normalMap", t);
            break;

          case "map_bump":
          case "bump":
            await s("bumpMap", t);
            break;

          case "map_d":
            await s("alphaMap", t), r.transparent = !0;
            break;

          case "ns":
            r.shininess = parseFloat(t);
            break;

          case "d":
            o = parseFloat(t), o < 1 && (r.opacity = o, r.transparent = !0);
            break;

          case "tr":
            if (a) break;
            o = parseFloat(t), this.options && this.options.invertTrProperty && (o = 1 - o), o > 0 && (r.opacity = 1 - o, r.transparent = !0);
        }
      }

      return this.materials[e] = new i.xoR(r), this.materials[e];
    }

    getTextureParams(e, t) {
      const n = {
        scale: new i.FM8(1, 1),
        offset: new i.FM8(0, 0)
      },
            r = e.split(/\s+/);
      let s;
      return s = r.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(r[s + 1]), r.splice(s, 2)), s = r.indexOf("-s"), s >= 0 && (n.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), s = r.indexOf("-o"), s >= 0 && (n.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), n.url = r.join(" ").trim(), n;
    }

    loadTexture(e, t, n, r, s) {
      const o = void 0 !== this.manager ? this.manager : i.tEQ;
      let a = o.getHandler(e);
      null === a && (a = new i.dpR(o)), a.setCrossOrigin && a.setCrossOrigin(this.crossOrigin);
      const l = a.load(e, n, r, s);
      return void 0 !== t && (l.mapping = t), l;
    }

  }

  const Hb = /^[og]\s*(.+)?/,
        Wb = /^mtllib /,
        Kb = /^usemtl /,
        Xb = /^usemap /,
        qb = new i.Pa4(),
        Yb = new i.Pa4(),
        Zb = new i.Pa4(),
        Jb = new i.Pa4(),
        $b = new i.Pa4();

  function Qb() {
    const e = {
      objects: [],
      object: {},
      vertices: [],
      normals: [],
      colors: [],
      uvs: [],
      materials: {},
      materialLibraries: [],
      startObject: function (e, t) {
        if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void (this.object.fromDeclaration = !1 !== t);
        const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;

        if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
          name: e || "",
          fromDeclaration: !1 !== t,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: !1
          },
          materials: [],
          smooth: !0,
          startMaterial: function (e, t) {
            const n = this._finalize(!1);

            n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
            const r = {
              index: this.materials.length,
              name: e || "",
              mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
              smooth: void 0 !== n ? n.smooth : this.smooth,
              groupStart: void 0 !== n ? n.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: !1,
              clone: function (e) {
                const t = {
                  index: "number" == typeof e ? e : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1
                };
                return t.clone = this.clone.bind(t), t;
              }
            };
            return this.materials.push(r), r;
          },
          currentMaterial: function () {
            if (this.materials.length > 0) return this.materials[this.materials.length - 1];
          },
          _finalize: function (e) {
            const t = this.currentMaterial();
            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1) for (let e = this.materials.length - 1; e >= 0; e--) this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
            return e && 0 === this.materials.length && this.materials.push({
              name: "",
              smooth: this.smooth
            }), t;
          }
        }, n && n.name && "function" == typeof n.clone) {
          const e = n.clone(0);
          e.inherited = !0, this.object.materials.push(e);
        }

        this.objects.push(this.object);
      },
      finalize: function () {
        this.object && "function" == typeof this.object._finalize && this.object._finalize(!0);
      },
      parseVertexIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 3 * (n >= 0 ? n - 1 : n + t / 3);
      },
      parseNormalIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 3 * (n >= 0 ? n - 1 : n + t / 3);
      },
      parseUVIndex: function (e, t) {
        const n = parseInt(e, 10);
        return 2 * (n >= 0 ? n - 1 : n + t / 2);
      },
      addVertex: function (e, t, n) {
        const r = this.vertices,
              i = this.object.geometry.vertices;
        i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addVertexPoint: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addVertexLine: function (e) {
        const t = this.vertices;
        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
      },
      addNormal: function (e, t, n) {
        const r = this.normals,
              i = this.object.geometry.normals;
        i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addFaceNormal: function (e, t, n) {
        const r = this.vertices,
              i = this.object.geometry.normals;
        qb.fromArray(r, e), Yb.fromArray(r, t), Zb.fromArray(r, n), $b.subVectors(Zb, Yb), Jb.subVectors(qb, Yb), $b.cross(Jb), $b.normalize(), i.push($b.x, $b.y, $b.z), i.push($b.x, $b.y, $b.z), i.push($b.x, $b.y, $b.z);
      },
      addColor: function (e, t, n) {
        const r = this.colors,
              i = this.object.geometry.colors;
        void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]), void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]), void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2]);
      },
      addUV: function (e, t, n) {
        const r = this.uvs,
              i = this.object.geometry.uvs;
        i.push(r[e + 0], r[e + 1]), i.push(r[t + 0], r[t + 1]), i.push(r[n + 0], r[n + 1]);
      },
      addDefaultUV: function () {
        const e = this.object.geometry.uvs;
        e.push(0, 0), e.push(0, 0), e.push(0, 0);
      },
      addUVLine: function (e) {
        const t = this.uvs;
        this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
      },
      addFace: function (e, t, n, r, i, s, o, a, l) {
        const c = this.vertices.length;
        let u = this.parseVertexIndex(e, c),
            p = this.parseVertexIndex(t, c),
            h = this.parseVertexIndex(n, c);

        if (this.addVertex(u, p, h), this.addColor(u, p, h), void 0 !== o && "" !== o) {
          const e = this.normals.length;
          u = this.parseNormalIndex(o, e), p = this.parseNormalIndex(a, e), h = this.parseNormalIndex(l, e), this.addNormal(u, p, h);
        } else this.addFaceNormal(u, p, h);

        if (void 0 !== r && "" !== r) {
          const e = this.uvs.length;
          u = this.parseUVIndex(r, e), p = this.parseUVIndex(i, e), h = this.parseUVIndex(s, e), this.addUV(u, p, h), this.object.geometry.hasUVIndices = !0;
        } else this.addDefaultUV();
      },
      addPointGeometry: function (e) {
        this.object.geometry.type = "Points";
        const t = this.vertices.length;

        for (let n = 0, r = e.length; n < r; n++) {
          const r = this.parseVertexIndex(e[n], t);
          this.addVertexPoint(r), this.addColor(r);
        }
      },
      addLineGeometry: function (e, t) {
        this.object.geometry.type = "Line";
        const n = this.vertices.length,
              r = this.uvs.length;

        for (let t = 0, r = e.length; t < r; t++) this.addVertexLine(this.parseVertexIndex(e[t], n));

        for (let e = 0, n = t.length; e < n; e++) this.addUVLine(this.parseUVIndex(t[e], r));
      }
    };
    return e.startObject("", !1), e;
  }

  class ex extends i.aNw {
    constructor(e) {
      super(e), this.materials = null;
    }

    load(e, t, n, r) {
      const s = this,
            o = new i.hH6(this.manager);
      o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, async function (n) {
        try {
          t(await s.parse(n));
        } catch (t) {
          r ? r(t) : console.error(t), s.manager.itemError(e);
        }
      }, n, r);
    }

    setMaterials(e) {
      return this.materials = e, this;
    }

    async parse(e) {
      const t = new Qb();
      -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
      const n = e.split("\n");
      let r = "",
          s = "",
          o = 0,
          a = [];
      const l = "function" == typeof "".trimLeft;

      for (let e = 0, i = n.length; e < i; e++) if (r = n[e], r = l ? r.trimLeft() : r.trim(), o = r.length, 0 !== o && (s = r.charAt(0), "#" !== s)) if ("v" === s) {
        const e = r.split(/\s+/);

        switch (e[0]) {
          case "v":
            t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])), e.length >= 7 ? t.colors.push(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6])) : t.colors.push(void 0, void 0, void 0);
            break;

          case "vn":
            t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
            break;

          case "vt":
            t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
        }
      } else if ("f" === s) {
        const e = r.substr(1).trim().split(/\s+/),
              n = [];

        for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t];

          if (r.length > 0) {
            const e = r.split("/");
            n.push(e);
          }
        }

        const i = n[0];

        for (let e = 1, r = n.length - 1; e < r; e++) {
          const r = n[e],
                s = n[e + 1];
          t.addFace(i[0], r[0], s[0], i[1], r[1], s[1], i[2], r[2], s[2]);
        }
      } else if ("l" === s) {
        const e = r.substring(1).trim().split(" ");
        let n = [];
        const i = [];
        if (-1 === r.indexOf("/")) n = e;else for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t].split("/");
          "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1]);
        }
        t.addLineGeometry(n, i);
      } else if ("p" === s) {
        const e = r.substr(1).trim().split(" ");
        t.addPointGeometry(e);
      } else if (null !== (a = Hb.exec(r))) {
        const e = (" " + a[0].substr(1).trim()).substr(1);
        t.startObject(e);
      } else if (Kb.test(r)) t.object.startMaterial(r.substring(7).trim(), t.materialLibraries);else if (Wb.test(r)) {
        t.materialLibraries.push(r.substring(7).trim());
        const e = r.substring(7).trim(),
              n = this.manager.getHandler(e);

        if (n) {
          const t = await n.loadAsync(e).catch(e => {
            console.warn(e);
          });
          t && this.setMaterials(t);
        } else console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.");
      } else if (Xb.test(r)) console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if ("s" === s) {
        if (a = r.split(" "), a.length > 1) {
          const e = a[1].trim().toLowerCase();
          t.object.smooth = "0" !== e && "off" !== e;
        } else t.object.smooth = !0;

        const e = t.object.currentMaterial();
        e && (e.smooth = t.object.smooth);
      } else {
        if ("\0" === r) continue;
        console.warn('THREE.OBJLoader: Unexpected line: "' + r + '"');
      }

      t.finalize();
      const c = new i.ZAu();
      if (c.materialLibraries = [].concat(t.materialLibraries), !0 == !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length)) for (let e = 0, n = t.objects.length; e < n; e++) {
        const n = t.objects[e],
              r = n.geometry,
              s = n.materials,
              o = "Line" === r.type,
              a = "Points" === r.type;
        let l = !1;
        if (0 === r.vertices.length) continue;
        const u = new i.u9r();
        u.setAttribute("position", new i.a$l(r.vertices, 3)), r.normals.length > 0 && u.setAttribute("normal", new i.a$l(r.normals, 3)), r.colors.length > 0 && (l = !0, u.setAttribute("color", new i.a$l(r.colors, 3))), !0 === r.hasUVIndices && u.setAttribute("uv", new i.a$l(r.uvs, 2));
        const p = [];

        for (let e = 0, n = s.length; e < n; e++) {
          const n = s[e],
                r = n.name + "_" + n.smooth + "_" + l;
          let c = t.materials[r];
          if (null !== this.materials) if (c = await this.materials.create(n.name), !o || !c || c instanceof i.nls) {
            if (a && c && !(c instanceof i.UY4)) {
              const e = new i.UY4({
                size: 10,
                sizeAttenuation: !1
              });
              i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), e.map = c.map, c = e;
            }
          } else {
            const e = new i.nls();
            i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), c = e;
          }
          void 0 === c && (c = o ? new i.nls() : a ? new i.UY4({
            size: 1,
            sizeAttenuation: !1
          }) : new i.xoR(), c.name = n.name, c.flatShading = !n.smooth, c.vertexColors = l, t.materials[r] = c), p.push(c);
        }

        let h;

        if (p.length > 1) {
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            u.addGroup(t.groupStart, t.groupCount, e);
          }

          h = o ? new i.ejS(u, p) : a ? new i.woe(u, p) : new i.Kj0(u, p);
        } else h = o ? new i.ejS(u, p[0]) : a ? new i.woe(u, p[0]) : new i.Kj0(u, p[0]);

        h.name = n.name, c.add(h);
      } else if (t.vertices.length > 0) {
        const e = new i.UY4({
          size: 1,
          sizeAttenuation: !1
        }),
              n = new i.u9r();
        n.setAttribute("position", new i.a$l(t.vertices, 3)), t.colors.length > 0 && void 0 !== t.colors[0] && (n.setAttribute("color", new i.a$l(t.colors, 3)), e.vertexColors = !0);
        const r = new i.woe(n, e);
        c.add(r);
      }
      return c;
    }

  }

  class tx extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs], this._importer1 = new $t(ex, ["obj"], !0), this._importer2 = new $t(Vb, ["mtl"], !1);
    }

    async onAdded(e) {
      Us.Importers.push(this._importer1), Us.Importers.push(this._importer2);
    }

    async onDispose(e) {}

    async onRemove(e) {
      Us.Importers.splice(Us.Importers.indexOf(this._importer1), 1), Us.Importers.splice(Us.Importers.indexOf(this._importer2), 1);
    }

  }

  tx.PluginType = "ObjMtlLoadPlugin";

  class nx extends i.DqL {
    constructor(e) {
      super(e);
    }

    parse(e, t) {
      const n = new rx(e, 1);
      return {
        mipmaps: n.mipmaps(t),
        width: n.pixelWidth,
        height: n.pixelHeight,
        format: n.glInternalFormat,
        isCubemap: 6 === n.numberOfFaces,
        mipmapCount: n.numberOfMipmapLevels
      };
    }

  }

  class rx {
    constructor(e, t) {
      this.arrayBuffer = e;
      const n = new Uint8Array(this.arrayBuffer, 0, 12);
      if (171 !== n[0] || 75 !== n[1] || 84 !== n[2] || 88 !== n[3] || 32 !== n[4] || 49 !== n[5] || 49 !== n[6] || 187 !== n[7] || 13 !== n[8] || 10 !== n[9] || 26 !== n[10] || 10 !== n[11]) return void console.error("texture missing KTX identifier");
      const r = Uint32Array.BYTES_PER_ELEMENT,
            i = new DataView(this.arrayBuffer, 12, 13 * r),
            s = 67305985 === i.getUint32(0, !0);
      this.glType = i.getUint32(1 * r, s), this.glTypeSize = i.getUint32(2 * r, s), this.glFormat = i.getUint32(3 * r, s), this.glInternalFormat = i.getUint32(4 * r, s), this.glBaseInternalFormat = i.getUint32(5 * r, s), this.pixelWidth = i.getUint32(6 * r, s), this.pixelHeight = i.getUint32(7 * r, s), this.pixelDepth = i.getUint32(8 * r, s), this.numberOfArrayElements = i.getUint32(9 * r, s), this.numberOfFaces = i.getUint32(10 * r, s), this.numberOfMipmapLevels = i.getUint32(11 * r, s), this.bytesOfKeyValueData = i.getUint32(12 * r, s), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t ? this.loadType = 0 : console.warn("number of faces expected" + t + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported");
    }

    mipmaps(e) {
      const t = [];
      let n = 64 + this.bytesOfKeyValueData,
          r = this.pixelWidth,
          i = this.pixelHeight;
      const s = e ? this.numberOfMipmapLevels : 1;

      for (let e = 0; e < s; e++) {
        const e = new Int32Array(this.arrayBuffer, n, 1)[0];
        n += 4;

        for (let s = 0; s < this.numberOfFaces; s++) {
          const s = new Uint8Array(this.arrayBuffer, n, e);
          t.push({
            data: s,
            width: r,
            height: i
          }), n += e, n += 3 - (e + 3) % 4;
        }

        r = Math.max(1, .5 * r), i = Math.max(1, .5 * i);
      }

      return t;
    }

  }

  class ix extends r {
    constructor() {
      super(...arguments), this.dependencies = [Vs];
    }

    async onAdded(e) {
      this._importer || (this._importer = new $t(nx, ["ktx"], !1)), Us.Importers.push(this._importer);
    }

    async onDispose(e) {
      this._importer = void 0;
    }

    async onRemove(e) {
      this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0;
    }

  }

  ix.PluginType = "KTXLoadPlugin";

  class sx extends i.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }

  }

  class ox extends i.hH6 {
    constructor(e) {
      super(e), this.responseType = "blob";
    }

    load(e, t, n, r) {
      return super.load(e, e => {
        try {
          null == t || t(bt(e));
        } catch (e) {
          null == r || r(e);
        }
      }, n, r);
    }

  }

  class ax {
    async parseAsync(e, t) {
      var n;
      return new Blob([JSON.stringify(e, null, null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
        type: "application/json"
      });
    }

  }

  class lx {
    async parseAsync(e, t) {
      return new Blob([e], {
        type: "text/plain"
      });
    }

  }

  function cx(e, t) {
    const n = e.getPlugin(Vs).exportViewerConfig(),
          r = [];
    Object.values(n.resources).forEach(e => {
      Object.values(e).forEach(e => {
        e.url && ("Uint16Array" === e.url.type && e.url.data && (e.url.data = new Uint16Array(e.url.data), r.push(e.url)), "Uint8Array" === e.url.type && e.url.data && (e.url.data = new Uint8Array(e.url.data), r.push(e.url)));
      });
    });

    for (const e of r) {
      let n = "application/octet-stream";

      if ("Uint16Array" === e.type) {
        const t = ux(e.data, 4),
              r = new ImageData(t, e.width, e.height),
              s = i.PpQ.getDataURL(r).split(",")[1];
        n = "image/png", e.data = atob(s), e.encoding = "rgbe";
      }

      const r = new Blob([e.data], {
        type: n
      });
      t.json.images || (t.json.images = []);
      const s = {
        mimeType: n
      },
            o = t.json.images.push(s) - 1;
      e.data = {
        image: o
      }, t.pending.push(t.processBufferViewImage(r).then(e => {
        s.bufferView = e;
      }));
    }

    return n;
  }

  function ux(e, t = 3, n) {
    let r, i, s, o, a;
    const l = e.byteLength / (2 * t) | 0;
    n = n || new Uint8ClampedArray(4 * l);

    for (let c = 0; c < l; c++) {
      r = e[c * t], i = e[c * t + 1], s = e[c * t + 2], o = Math.max(Math.max(r, i), s);
      const l = Math.ceil(Math.log2(o));
      a = Math.pow(2, l - 8), n[4 * c] = r / a | 0, n[4 * c + 1] = i / a | 0, n[4 * c + 2] = s / a | 0, n[4 * c + 3] = l + 128;
    }

    return n;
  }

  class px {
    constructor() {
      this.pluginCallbacks = [], this.register(function (e) {
        return new yx(e);
      }), this.register(function (e) {
        return new wx(e);
      }), this.register(function (e) {
        return new Sx(e);
      }), this.register(function (e) {
        return new Ex(e);
      }), this.register(function (e) {
        return new Ax(e);
      }), this.register(function (e) {
        return new Mx(e);
      }), this.register(function (e) {
        return new Cx(e);
      }), this.register(function (e) {
        return new Tx(e);
      }), this.register(function (e) {
        return new Rx(e);
      });
    }

    register(e) {
      return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this;
    }

    unregister(e) {
      return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }

    parse(e, t, n, r, i) {
      "object" == typeof n && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), r = n);
      const s = i || new xx(),
            o = [];

      for (let e = 0, t = this.pluginCallbacks.length; e < t; e++) o.push(this.pluginCallbacks[e](s));

      s.setPlugins(o), s.write(e, t, r).catch(n);
    }

    parseAsync(e, t) {
      const n = this;
      return new Promise(function (r, i) {
        n.parse(e, r, i, t);
      });
    }

  }

  const hx = 5121,
        dx = 5123,
        fx = {};
  fx[i.TyD] = 9728, fx[i.YLQ] = 9984, fx[i.aH4] = 9986, fx[i.wem] = 9729, fx[i.qyh] = 9985, fx[i.D1R] = 9987, fx[i.uWy] = 33071, fx[i.rpg] = 10497, fx[i.OoA] = 33648;
  const _x = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
  };

  function mx(e, t) {
    return e.length === t.length && e.every(function (e, n) {
      return e === t[n];
    });
  }

  function gx(e) {
    return 4 * Math.ceil(e / 4);
  }

  function vx(e, t = 0) {
    const n = gx(e.byteLength);

    if (n !== e.byteLength) {
      const r = new Uint8Array(n);
      if (r.set(new Uint8Array(e)), 0 !== t) for (let i = e.byteLength; i < n; i++) r[i] = t;
      return r.buffer;
    }

    return e;
  }

  function bx(e, t) {
    if (void 0 !== e.toBlob) return new Promise(n => e.toBlob(n, t));
    let n;
    return "image/jpeg" === t ? n = .92 : "image/webp" === t && (n = .8), e.convertToBlob({
      type: t,
      quality: n
    });
  }

  class xx {
    constructor() {
      this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map(), this.skins = [], this.extensionsUsed = {}, this.uids = new Map(), this.uid = 0, this.json = {
        asset: {
          version: "2.0",
          generator: "THREE.GLTFExporter"
        }
      }, this.cache = {
        meshes: new Map(),
        attributes: new Map(),
        attributesNormalized: new Map(),
        materials: new Map(),
        textures: new Map(),
        images: new Map()
      };
    }

    setPlugins(e) {
      this.plugins = e;
    }

    async write(e, t, n) {
      this.options = Object.assign({}, {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      }, n), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
      const r = this,
            i = r.buffers,
            s = r.json;
      n = r.options;
      const o = r.extensionsUsed,
            a = new Blob(i, {
        type: "application/octet-stream"
      }),
            l = Object.keys(o);

      if (l.length > 0 && (s.extensionsUsed = l), s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = a.size), !0 === n.binary) {
        const e = new FileReader();
        e.readAsArrayBuffer(a), e.onloadend = function () {
          const n = vx(e.result),
                r = new DataView(new ArrayBuffer(8));
          r.setUint32(0, n.byteLength, !0), r.setUint32(4, 5130562, !0);
          const i = vx((o = JSON.stringify(s), new TextEncoder().encode(o).buffer), 32);
          var o;
          const a = new DataView(new ArrayBuffer(8));
          a.setUint32(0, i.byteLength, !0), a.setUint32(4, 1313821514, !0);
          const l = new ArrayBuffer(12),
                c = new DataView(l);
          c.setUint32(0, 1179937895, !0), c.setUint32(4, 2, !0);
          const u = 12 + a.byteLength + i.byteLength + r.byteLength + n.byteLength;
          c.setUint32(8, u, !0);
          const p = new Blob([l, a, i, r, n], {
            type: "application/octet-stream"
          }),
                h = new FileReader();
          h.readAsArrayBuffer(p), h.onloadend = function () {
            t(h.result);
          };
        };
      } else if (s.buffers && s.buffers.length > 0) {
        const e = new FileReader();
        e.readAsDataURL(a), e.onloadend = function () {
          const n = e.result;
          s.buffers[0].uri = n, t(s);
        };
      } else t(s);
    }

    serializeUserData(e, t) {
      if (0 === Object.keys(e.userData).length) return;
      const n = this.options,
            r = this.extensionsUsed;

      try {
        const i = JSON.parse(JSON.stringify(e.userData));

        if (n.includeCustomExtensions && i.gltfExtensions) {
          void 0 === t.extensions && (t.extensions = {});

          for (const e in i.gltfExtensions) t.extensions[e] = i.gltfExtensions[e], r[e] = !0;

          delete i.gltfExtensions;
        }

        Object.keys(i).length > 0 && (t.extras = i);
      } catch (t) {
        console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message), console.warn({ ...e.userData
        });
      }
    }

    getUID(e, t = !1) {
      if (!1 === this.uids.has(e)) {
        const t = new Map();
        t.set(!0, this.uid++), t.set(!1, this.uid++), this.uids.set(e, t);
      }

      return this.uids.get(e).get(t);
    }

    isNormalizedNormalAttribute(e) {
      if (this.cache.attributesNormalized.has(e)) return !1;
      const t = new i.Pa4();

      for (let n = 0, r = e.count; n < r; n++) if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;

      return !0;
    }

    createNormalizedNormalAttribute(e) {
      const t = this.cache;
      if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
      const n = e.clone(),
            r = new i.Pa4();

      for (let e = 0, t = n.count; e < t; e++) r.fromBufferAttribute(n, e), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), n.setXYZ(e, r.x, r.y, r.z);

      return t.attributesNormalized.set(e, n), n;
    }

    applyTextureTransform(e, t) {
      let n = !1;
      const r = {};
      0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0);
    }

    buildMetalRoughTexture(e, t) {
      if (e === t) return e;

      function n(e) {
        return e.encoding === i.knz ? function (e) {
          return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4);
        } : function (e) {
          return e;
        };
      }

      console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
      const r = e ? e.image : void 0,
            s = t ? t.image : void 0,
            o = Math.max(r ? r.width : 0, s ? s.width : 0),
            a = Math.max(r ? r.height : 0, s ? s.height : 0),
            l = document.createElement("canvas");
      l.width = o, l.height = a;
      const c = l.getContext("2d");
      c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
      const u = c.getImageData(0, 0, o, a);

      if (r) {
        c.drawImage(r, 0, 0, o, a);
        const t = n(e),
              i = c.getImageData(0, 0, o, a).data;

        for (let e = 2; e < i.length; e += 4) u.data[e] = 256 * t(i[e] / 256);
      }

      if (s) {
        c.drawImage(s, 0, 0, o, a);
        const e = n(t),
              r = c.getImageData(0, 0, o, a).data;

        for (let t = 1; t < r.length; t += 4) u.data[t] = 256 * e(r[t] / 256);
      }

      c.putImageData(u, 0, 0);
      const p = (e || t).clone();
      return p.source = new i.Hw6(l), p.encoding = i.rnI, p;
    }

    processBuffer(e) {
      const t = this.json,
            n = this.buffers;
      return t.buffers || (t.buffers = [{
        byteLength: 0
      }]), n.push(e), 0;
    }

    processBufferView(e, t, n, r, i) {
      const s = this.json;
      let o;
      s.bufferViews || (s.bufferViews = []), o = t === hx ? 1 : t === dx ? 2 : 4;
      const a = gx(r * e.itemSize * o),
            l = new DataView(new ArrayBuffer(a));
      let c = 0;

      for (let i = n; i < n + r; i++) for (let n = 0; n < e.itemSize; n++) {
        let r;
        e.itemSize > 4 ? r = e.array[i * e.itemSize + n] : 0 === n ? r = e.getX(i) : 1 === n ? r = e.getY(i) : 2 === n ? r = e.getZ(i) : 3 === n && (r = e.getW(i)), 5126 === t ? l.setFloat32(c, r, !0) : 5125 === t ? l.setUint32(c, r, !0) : t === dx ? l.setUint16(c, r, !0) : t === hx && l.setUint8(c, r), c += o;
      }

      const u = {
        buffer: this.processBuffer(l.buffer),
        byteOffset: this.byteOffset,
        byteLength: a
      };
      return void 0 !== i && (u.target = i), 34962 === i && (u.byteStride = e.itemSize * o), this.byteOffset += a, s.bufferViews.push(u), {
        id: s.bufferViews.length - 1,
        byteLength: 0
      };
    }

    processBufferViewImage(e) {
      const t = this,
            n = t.json;
      return n.bufferViews || (n.bufferViews = []), new Promise(function (r) {
        const i = new FileReader();
        i.readAsArrayBuffer(e), i.onloadend = function () {
          const e = vx(i.result),
                s = {
            buffer: t.processBuffer(e),
            byteOffset: t.byteOffset,
            byteLength: e.byteLength
          };
          t.byteOffset += e.byteLength, r(n.bufferViews.push(s) - 1);
        };
      });
    }

    processAccessor(e, t, n, r) {
      const i = this.options,
            s = this.json;
      let o;
      if (e.array.constructor === Float32Array) o = 5126;else if (e.array.constructor === Uint32Array) o = 5125;else if (e.array.constructor === Uint16Array) o = dx;else {
        if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
        o = hx;
      }

      if (void 0 === n && (n = 0), void 0 === r && (r = e.count), i.truncateDrawRange && void 0 !== t && null === t.index) {
        const i = n + r,
              s = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
        n = Math.max(n, t.drawRange.start), (r = Math.min(i, s) - n) < 0 && (r = 0);
      }

      if (0 === r) return null;

      const a = function (e, t, n) {
        const r = {
          min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
          max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
        };

        for (let i = t; i < t + n; i++) for (let t = 0; t < e.itemSize; t++) {
          let n;
          e.itemSize > 4 ? n = e.array[i * e.itemSize + t] : 0 === t ? n = e.getX(i) : 1 === t ? n = e.getY(i) : 2 === t ? n = e.getZ(i) : 3 === t && (n = e.getW(i)), r.min[t] = Math.min(r.min[t], n), r.max[t] = Math.max(r.max[t], n);
        }

        return r;
      }(e, n, r);

      let l;
      void 0 !== t && (l = e === t.index ? 34963 : 34962);
      const c = this.processBufferView(e, o, n, r, l),
            u = {
        bufferView: c.id,
        byteOffset: c.byteOffset,
        componentType: o,
        count: r,
        max: a.max,
        min: a.min,
        type: {
          1: "SCALAR",
          2: "VEC2",
          3: "VEC3",
          4: "VEC4",
          16: "MAT4"
        }[e.itemSize]
      };
      return !0 === e.normalized && (u.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(u) - 1;
    }

    processImage(e, t, n, r = "image/png") {
      const s = this,
            o = s.cache,
            a = s.json,
            l = s.options,
            c = s.pending;
      o.images.has(e) || o.images.set(e, {});
      const u = o.images.get(e),
            p = r + ":flipY/" + n.toString();
      if (void 0 !== u[p]) return u[p];
      a.images || (a.images = []);
      const h = {
        mimeType: r
      },
            d = "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
      d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
      const f = d.getContext("2d");

      if (!0 === n && (f.translate(0, d.height), f.scale(1, -1)), void 0 !== e.data) {
        t !== i.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported."), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const n = new Uint8ClampedArray(e.height * e.width * 4);

        for (let t = 0; t < n.length; t += 4) n[t + 0] = e.data[t + 0], n[t + 1] = e.data[t + 1], n[t + 2] = e.data[t + 2], n[t + 3] = e.data[t + 3];

        f.putImageData(new ImageData(n, e.width, e.height), 0, 0);
      } else f.drawImage(e, 0, 0, d.width, d.height);

      !0 === l.binary ? c.push(bx(d, r).then(e => s.processBufferViewImage(e)).then(e => {
        h.bufferView = e;
      })) : void 0 !== d.toDataURL ? h.uri = d.toDataURL(r) : c.push(bx(d, r).then(e => new FileReader().readAsDataURL(e)).then(e => {
        h.uri = e;
      }));

      const _ = a.images.push(h) - 1;

      return u[p] = _, _;
    }

    processSampler(e) {
      const t = this.json;
      t.samplers || (t.samplers = []);
      const n = {
        magFilter: fx[e.magFilter],
        minFilter: fx[e.minFilter],
        wrapS: fx[e.wrapS],
        wrapT: fx[e.wrapT]
      };
      return t.samplers.push(n) - 1;
    }

    processTexture(e) {
      const t = this.cache,
            n = this.json;
      if (t.textures.has(e)) return t.textures.get(e);
      n.textures || (n.textures = []);
      let r = e.userData.mimeType;
      "image/webp" === r && (r = "image/png"), "image/jpg" === r && (r = "image/jpeg");
      const i = ["image/jpeg", "image/png"];
      r && !i.includes(r) && console.error("GLTFExporter: Unsupported mime type: " + r + ". Cannot export texture.", e);
      const s = {
        sampler: this.processSampler(e),
        source: !r || i.includes(r) ? this.processImage(e.image, e.format, e.flipY, r) : null
      };
      e.name && (s.name = e.name), this._invokeAll(function (t) {
        t.writeTexture && t.writeTexture(e, s);
      });
      const o = n.textures.push(s) - 1;
      return t.textures.set(e, o), o;
    }

    processMaterial(e) {
      const t = this.cache,
            n = this.json;
      if (t.materials.has(e)) return t.materials.get(e);
      if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
      n.materials || (n.materials = []);
      const r = {
        pbrMetallicRoughness: {}
      };
      !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
      const s = e.color.toArray().concat([e.opacity]);

      if (mx(s, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
        const t = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap),
              n = {
          index: this.processTexture(t)
        };
        this.applyTextureTransform(n, t), r.pbrMetallicRoughness.metallicRoughnessTexture = n;
      }

      if (e.map) {
        const t = {
          index: this.processTexture(e.map)
        };
        this.applyTextureTransform(t, e.map), r.pbrMetallicRoughness.baseColorTexture = t;
      }

      if (e.emissive) {
        const t = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
              n = Math.max(t.r, t.g, t.b);

        if (n > 1 && (t.multiplyScalar(1 / n), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n > 0 && (r.emissiveFactor = t.toArray()), e.emissiveMap) {
          const t = {
            index: this.processTexture(e.emissiveMap)
          };
          this.applyTextureTransform(t, e.emissiveMap), r.emissiveTexture = t;
        }
      }

      if (e.normalMap) {
        const t = {
          index: this.processTexture(e.normalMap)
        };
        e.normalScale && 1 !== e.normalScale.x && (t.scale = e.normalScale.x), this.applyTextureTransform(t, e.normalMap), r.normalTexture = t;
      }

      if (e.aoMap) {
        const t = {
          index: this.processTexture(e.aoMap),
          texCoord: 1
        };
        1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity), this.applyTextureTransform(t, e.aoMap), r.occlusionTexture = t;
      }

      e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === i.ehD && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll(function (t) {
        t.writeMaterial && t.writeMaterial(e, r);
      });
      const o = n.materials.push(r) - 1;
      return t.materials.set(e, o), o;
    }

    processMesh(e) {
      const t = this.cache,
            n = this.json,
            r = [e.geometry.uuid];
      if (Array.isArray(e.material)) for (let t = 0, n = e.material.length; t < n; t++) r.push(e.material[t].uuid);else r.push(e.material.uuid);
      const s = r.join(":");
      if (t.meshes.has(s)) return t.meshes.get(s);
      const o = e.geometry;
      let a;
      if (a = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4, !0 !== o.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
      const l = {},
            c = {},
            u = [],
            p = [],
            h = {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1",
        color: "COLOR_0",
        skinWeight: "WEIGHTS_0",
        skinIndex: "JOINTS_0"
      },
            d = o.getAttribute("normal");
      void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
      let f = null;

      for (let e in o.attributes) {
        if ("morph" === e.slice(0, 5)) continue;
        const n = o.attributes[e];

        if (e = h[e] || e.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e) || (e = "_" + e), t.attributes.has(this.getUID(n))) {
          c[e] = t.attributes.get(this.getUID(n));
          continue;
        }

        f = null;
        const r = n.array;
        "JOINTS_0" !== e || r instanceof Uint16Array || r instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new i.TlE(new Uint16Array(r), n.itemSize, n.normalized));
        const s = this.processAccessor(f || n, o);
        null !== s && (c[e] = s, t.attributes.set(this.getUID(n), s));
      }

      if (void 0 !== d && o.setAttribute("normal", d), 0 === Object.keys(c).length) return null;

      if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
        const n = [],
              r = [],
              i = {};
        if (void 0 !== e.morphTargetDictionary) for (const t in e.morphTargetDictionary) i[e.morphTargetDictionary[t]] = t;

        for (let s = 0; s < e.morphTargetInfluences.length; ++s) {
          const a = {};
          let l = !1;

          for (const e in o.morphAttributes) {
            if ("position" !== e && "normal" !== e) {
              l || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l = !0);
              continue;
            }

            const n = o.morphAttributes[e][s],
                  r = e.toUpperCase(),
                  i = o.attributes[e];

            if (t.attributes.has(this.getUID(n, !0))) {
              a[r] = t.attributes.get(this.getUID(n, !0));
              continue;
            }

            const c = n.clone();
            if (!o.morphTargetsRelative) for (let e = 0, t = n.count; e < t; e++) c.setXYZ(e, n.getX(e) - i.getX(e), n.getY(e) - i.getY(e), n.getZ(e) - i.getZ(e));
            a[r] = this.processAccessor(c, o), t.attributes.set(this.getUID(i, !0), a[r]);
          }

          p.push(a), n.push(e.morphTargetInfluences[s]), void 0 !== e.morphTargetDictionary && r.push(i[s]);
        }

        l.weights = n, r.length > 0 && (l.extras = {}, l.extras.targetNames = r);
      }

      const _ = Array.isArray(e.material);

      if (_ && 0 === o.groups.length) return null;
      const m = _ ? e.material : [e.material],
            g = _ ? o.groups : [{
        materialIndex: 0,
        start: void 0,
        count: void 0
      }];

      for (let e = 0, n = g.length; e < n; e++) {
        const n = {
          mode: a,
          attributes: c
        };

        if (this.serializeUserData(o, n), p.length > 0 && (n.targets = p), null !== o.index) {
          let r = this.getUID(o.index);
          void 0 === g[e].start && void 0 === g[e].count || (r += ":" + g[e].start + ":" + g[e].count), t.attributes.has(r) ? n.indices = t.attributes.get(r) : (n.indices = this.processAccessor(o.index, o, g[e].start, g[e].count), t.attributes.set(r, n.indices)), null === n.indices && delete n.indices;
        }

        const r = this.processMaterial(m[g[e].materialIndex]);
        null !== r && (n.material = r), u.push(n);
      }

      l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function (t) {
        t.writeMesh && t.writeMesh(e, l);
      });
      const v = n.meshes.push(l) - 1;
      return t.meshes.set(s, v), v;
    }

    processCamera(e) {
      const t = this.json;
      t.cameras || (t.cameras = []);
      const n = e.isOrthographicCamera,
            r = {
        type: n ? "orthographic" : "perspective"
      };
      return n ? r.orthographic = {
        xmag: 2 * e.right,
        ymag: 2 * e.top,
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      } : r.perspective = {
        aspectRatio: e.aspect,
        yfov: i.M8C.degToRad(e.fov),
        zfar: e.far <= 0 ? .001 : e.far,
        znear: e.near < 0 ? 0 : e.near
      }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1;
    }

    processAnimation(e, t) {
      const n = this.json,
            r = this.nodeMap;
      n.animations || (n.animations = []);
      const s = (e = px.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks,
            o = [],
            a = [];

      for (let e = 0; e < s.length; ++e) {
        const n = s[e],
              l = i.iUV.parseTrackName(n.name);
        let c = i.iUV.findNode(t, l.nodeName);
        const u = _x[l.propertyName];
        if ("bones" === l.objectName && (c = !0 === c.isSkinnedMesh ? c.skeleton.getBoneByName(l.objectIndex) : void 0), !c || !u) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n.name), null;
        const p = 1;
        let h,
            d = n.values.length / n.times.length;
        u === _x.morphTargetInfluences && (d /= c.morphTargetInfluences.length), !0 === n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (h = "CUBICSPLINE", d /= 3) : h = n.getInterpolation() === i.Syv ? "STEP" : "LINEAR", a.push({
          input: this.processAccessor(new i.TlE(n.times, p)),
          output: this.processAccessor(new i.TlE(n.values, d)),
          interpolation: h
        }), o.push({
          sampler: a.length - 1,
          target: {
            node: r.get(c),
            path: u
          }
        });
      }

      return n.animations.push({
        name: e.name || "clip_" + n.animations.length,
        samplers: a,
        channels: o
      }), n.animations.length - 1;
    }

    processSkin(e) {
      const t = this.json,
            n = this.nodeMap,
            r = t.nodes[n.get(e)],
            s = e.skeleton;
      if (void 0 === s) return null;
      const o = e.skeleton.bones[0];
      if (void 0 === o) return null;
      const a = [],
            l = new Float32Array(16 * s.bones.length),
            c = new i.yGw();

      for (let t = 0; t < s.bones.length; ++t) a.push(n.get(s.bones[t])), c.copy(s.boneInverses[t]), c.multiply(e.bindMatrix).toArray(l, 16 * t);

      return void 0 === t.skins && (t.skins = []), t.skins.push({
        inverseBindMatrices: this.processAccessor(new i.TlE(l, 16)),
        joints: a,
        skeleton: n.get(o)
      }), r.skin = t.skins.length - 1;
    }

    processNode(e) {
      const t = this.json,
            n = this.options,
            r = this.nodeMap;
      t.nodes || (t.nodes = []);
      const i = {};

      if (n.trs) {
        const t = e.quaternion.toArray(),
              n = e.position.toArray(),
              r = e.scale.toArray();
        mx(t, [0, 0, 0, 1]) || (i.rotation = t), mx(n, [0, 0, 0]) || (i.translation = n), mx(r, [1, 1, 1]) || (i.scale = r);
      } else e.matrixAutoUpdate && e.updateMatrix(), !1 === mx(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i.matrix = e.matrix.elements);

      if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
        const t = this.processMesh(e);
        null !== t && (i.mesh = t);
      } else e.isCamera && (i.camera = this.processCamera(e));

      if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
        const t = [];

        for (let r = 0, i = e.children.length; r < i; r++) {
          const i = e.children[r];

          if (i.visible || !1 === n.onlyVisible) {
            const e = this.processNode(i);
            null !== e && t.push(e);
          }
        }

        t.length > 0 && (i.children = t);
      }

      this._invokeAll(function (t) {
        t.writeNode && t.writeNode(e, i);
      });

      const s = t.nodes.push(i) - 1;
      return r.set(e, s), s;
    }

    processScene(e) {
      const t = this.json,
            n = this.options;
      t.scenes || (t.scenes = [], t.scene = 0);
      const r = {};
      "" !== e.name && (r.name = e.name), t.scenes.push(r);
      const i = [];

      for (let t = 0, r = e.children.length; t < r; t++) {
        const r = e.children[t];

        if (r.visible || !1 === n.onlyVisible) {
          const e = this.processNode(r);
          null !== e && i.push(e);
        }
      }

      i.length > 0 && (r.nodes = i), this.serializeUserData(e, r);
    }

    processObjects(e) {
      const t = new i.xsS();
      t.name = "AuxScene";

      for (let n = 0; n < e.length; n++) t.children.push(e[n]);

      this.processScene(t);
    }

    processInput(e) {
      const t = this.options;
      e = e instanceof Array ? e : [e], this._invokeAll(function (t) {
        t.beforeParse && t.beforeParse(e);
      });
      const n = [];

      for (let t = 0; t < e.length; t++) e[t] instanceof i.xsS ? this.processScene(e[t]) : n.push(e[t]);

      n.length > 0 && this.processObjects(n);

      for (let e = 0; e < this.skins.length; ++e) this.processSkin(this.skins[e]);

      for (let n = 0; n < t.animations.length; ++n) this.processAnimation(t.animations[n], e[0]);

      this._invokeAll(function (t) {
        t.afterParse && t.afterParse(e);
      });
    }

    _invokeAll(e) {
      for (let t = 0, n = this.plugins.length; t < n; t++) e(this.plugins[t]);
    }

  }

  class yx {
    constructor(e) {
      this.writer = e, this.name = "KHR_lights_punctual";
    }

    writeNode(e, t) {
      if (!e.isLight) return;
      if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      const n = this.writer,
            r = n.json,
            i = n.extensionsUsed,
            s = {};
      e.name && (s.name = e.name), s.color = e.color.toArray(), s.intensity = e.intensity, e.isDirectionalLight ? s.type = "directional" : e.isPointLight ? (s.type = "point", e.distance > 0 && (s.range = e.distance)) : e.isSpotLight && (s.type = "spot", e.distance > 0 && (s.range = e.distance), s.spot = {}, s.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, s.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
        lights: []
      }, i[this.name] = !0);
      const o = r.extensions[this.name].lights;
      o.push(s), t.extensions = t.extensions || {}, t.extensions[this.name] = {
        light: o.length - 1
      };
    }

  }

  class wx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_unlit";
    }

    writeMaterial(e, t) {
      if (!e.isMeshBasicMaterial) return;
      const n = this.writer.extensionsUsed;
      t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9;
    }

  }

  class Sx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness";
    }

    writeMaterial(e, t) {
      if (!e.isGLTFSpecularGlossinessMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};
      t.pbrMetallicRoughness.baseColorFactor && (i.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
      const s = [1, 1, 1];

      if (e.specular.toArray(s, 0), i.specularFactor = s, i.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (i.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
        const t = {
          index: n.processTexture(e.specularMap)
        };
        n.applyTextureTransform(t, e.specularMap), i.specularGlossinessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Mx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_clearcoat";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
        const t = {
          index: n.processTexture(e.clearcoatMap)
        };
        n.applyTextureTransform(t, e.clearcoatMap), i.clearcoatTexture = t;
      }

      if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
        const t = {
          index: n.processTexture(e.clearcoatRoughnessMap)
        };
        n.applyTextureTransform(t, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = t;
      }

      if (e.clearcoatNormalMap) {
        const t = {
          index: n.processTexture(e.clearcoatNormalMap)
        };
        n.applyTextureTransform(t, e.clearcoatNormalMap), i.clearcoatNormalTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Tx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_iridescence";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
        const t = {
          index: n.processTexture(e.iridescenceMap)
        };
        n.applyTextureTransform(t, e.iridescenceMap), i.iridescenceTexture = t;
      }

      if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
        const t = {
          index: n.processTexture(e.iridescenceThicknessMap)
        };
        n.applyTextureTransform(t, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Ex {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_transmission";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.transmissionFactor = e.transmission, e.transmissionMap) {
        const t = {
          index: n.processTexture(e.transmissionMap)
        };
        n.applyTextureTransform(t, e.transmissionMap), i.transmissionTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Ax {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_volume";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.thicknessFactor = e.thickness, e.thicknessMap) {
        const t = {
          index: n.processTexture(e.thicknessMap)
        };
        n.applyTextureTransform(t, e.thicknessMap), i.thicknessTexture = t;
      }

      i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Cx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_sheen";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial || e.sheen < .01) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.sheenColorFactor = e.sheenColor.toArray(), e.sheenColorMap) {
        const t = {
          index: n.processTexture(e.sheenColorMap)
        };
        n.applyTextureTransform(t, e.sheenColorMap), i.sheenColorTexture = t;
      }

      if (i.sheenRoughnessFactor = e.sheenRoughness, e.sheenRoughnessMap) {
        const t = {
          index: n.processTexture(e.sheenRoughnessMap)
        };
        n.applyTextureTransform(t, e.sheenRoughnessMap), i.sheenRoughnessTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, t.extras = t.extras || {}, t.extras.sheenFactor = e.sheen, r[this.name] = !0;
    }

  }

  class Rx {
    constructor(e) {
      this.writer = e, this.name = "KHR_materials_ior";
    }

    writeMaterial(e, t) {
      if (!e.isMeshPhysicalMaterial) return;
      const n = this.writer.extensionsUsed,
            r = {};
      r.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0;
    }

  }

  px.Utils = {
    GLTFWriter: xx,
    insertKeyframe: function (e, t) {
      const n = .001,
            r = e.getValueSize(),
            i = new e.TimeBufferType(e.times.length + 1),
            s = new e.ValueBufferType(e.values.length + r),
            o = e.createInterpolant(new e.ValueBufferType(r));
      let a;

      if (0 === e.times.length) {
        i[0] = t;

        for (let e = 0; e < r; e++) s[e] = 0;

        a = 0;
      } else if (t < e.times[0]) {
        if (Math.abs(e.times[0] - t) < n) return 0;
        i[0] = t, i.set(e.times, 1), s.set(o.evaluate(t), 0), s.set(e.values, r), a = 0;
      } else if (t > e.times[e.times.length - 1]) {
        if (Math.abs(e.times[e.times.length - 1] - t) < n) return e.times.length - 1;
        i[i.length - 1] = t, i.set(e.times, 0), s.set(e.values, 0), s.set(o.evaluate(t), e.values.length), a = i.length - 1;
      } else for (let l = 0; l < e.times.length; l++) {
        if (Math.abs(e.times[l] - t) < n) return l;

        if (e.times[l] < t && e.times[l + 1] > t) {
          i.set(e.times.slice(0, l + 1), 0), i[l + 1] = t, i.set(e.times.slice(l + 1), l + 2), s.set(e.values.slice(0, (l + 1) * r), 0), s.set(o.evaluate(t), (l + 1) * r), s.set(e.values.slice((l + 1) * r), (l + 2) * r), a = l + 1;
          break;
        }
      }

      return e.times = i, e.values = s, a;
    },
    mergeMorphTargetTracks: function (e, t) {
      const n = [],
            r = {},
            s = e.tracks;

      for (let e = 0; e < s.length; ++e) {
        let o = s[e];
        const a = i.iUV.parseTrackName(o.name),
              l = i.iUV.findNode(t, a.nodeName);

        if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
          n.push(o);
          continue;
        }

        if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
          if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
          console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(i.NMF);
        }

        const c = l.morphTargetInfluences.length,
              u = l.morphTargetDictionary[a.propertyIndex];
        if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
        let p;

        if (void 0 === r[l.uuid]) {
          p = o.clone();
          const e = new p.ValueBufferType(c * p.times.length);

          for (let t = 0; t < p.times.length; t++) e[t * c + u] = p.values[t];

          p.name = (a.nodeName || "") + ".morphTargetInfluences", p.values = e, r[l.uuid] = p, n.push(p);
          continue;
        }

        const h = o.createInterpolant(new o.ValueBufferType(1));
        p = r[l.uuid];

        for (let e = 0; e < p.times.length; e++) p.values[e * c + u] = h.evaluate(p.times[e]);

        for (let e = 0; e < o.times.length; e++) {
          const t = this.insertKeyframe(p, o.times[e]);
          p.values[t * c + u] = o.values[e];
        }
      }

      return e.tracks = n, e;
    }
  };

  class kx extends px.Utils.GLTFWriter {
    constructor() {
      super(...arguments), this._defaultMaterial = new i.Wid();
    }

    serializeUserData(e, t) {
      const n = e.userData,
            r = {};
      n.__disposed && console.error("Serializing a disposed object", e), Object.entries(n).forEach(([e, t]) => {
        (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("_") || "uuid" !== e && (ct.includes(e) || ut.includes(e) || Xt.includes(e))) && (r[e] = t, delete n[e]);
      }), super.serializeUserData(e, t), Object.entries(r).forEach(([e, t]) => {
        n[e] = t, delete r[e];
      });
    }

    processObjects(e) {
      var t;
      1 === e.length && (null === (t = e[0]) || void 0 === t ? void 0 : t.userData.rootSceneModelRoot) ? this.processScene(e[0]) : super.processObjects(e);
    }

    processMaterial(e) {
      if (this.cache.materials.has(e)) return this.cache.materials.get(e);
      let t = e;
      t.isShaderMaterial && (t = this._defaultMaterial);
      const n = super.processMaterial(t),
            r = JSON.stringify(this.json.materials[n]),
            i = JSON.parse(r);
      if (this.serializeUserData(e, i), this._invokeAll(t => {
        t.writeMaterial && t.writeMaterial(e, i);
      }), JSON.stringify(i) === r) return n;
      const s = this.json.materials.push(i) - 1;
      return this.cache.materials.set(e, s), s;
    }

    processImageBlob(e, t) {
      const n = this.cache,
            r = this.options,
            i = this.pending,
            s = this.json,
            o = t.image;
      n.images.has(o) || n.images.set(o, {});
      const a = n.images.get(o),
            l = e.type + ":flipY/" + t.flipY.toString();
      if (void 0 !== a[l]) return a[l];
      s.images || (s.images = []);
      const c = {
        mimeType: e.type
      };
      !0 === r.binary ? i.push(new Promise(t => {
        this.processBufferViewImage(e).then(e => {
          c.bufferView = e, t();
        });
      })) : i.push(bt(e).then(e => {
        c.uri = e;
      }));
      const u = s.images.push(c) - 1;
      return a[l] = u, u;
    }

  }

  class Px extends px {
    register(e) {
      return super.register(e);
    }

    async parseAsync(e, t) {
      var n;
      if (!e) throw new Error("No object to export");
      const r = e.__isGLTFOutput || !Array.isArray(e) && !e.isObject3D ? e : await new Promise((n, r) => this.parse(e, n, r, t));
      if (r && "object" == typeof r && !r.byteLength) return new Blob([JSON.stringify(r, (e, t) => e.startsWith("__") ? void 0 : t, null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
        type: "model/gltf+json"
      });
      if (r) return new Blob([r], {
        type: "model/gltf+binary"
      });
      throw new Error("GLTFExporter2.parse() failed");
    }

    parse(e, t, n, r) {
      const i = {
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        truncateDrawRange: !0,
        embedImages: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !0
      };
      return "glb" === r.exportExt && (i.binary = !0), !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        e.uuid && (e.userData.gltfUUID = e.uuid);
      })), (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
        if (e.animations) for (const t of e.animations) !1 === t.__gltfExport || i.animations.includes(t) || i.animations.push(...e.animations);
      })), super.parse(e, n => {
        !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach(e => e.traverse(e => {
          delete e.userData.gltfUUID;
        })), t(Object.assign(n, {
          __isGLTFOutput: !0
        }));
      }, n, i, new kx());
    }

  }

  class Dx extends r {
    constructor(e, t = {}) {
      super(), this._processors = new rt(), this._cachedParsers = [], Ox(e);
    }

    get processors() {
      return this._processors;
    }

    getExporter(...e) {
      return Dx.Exporters.find(t => t.ext.some(t => e.includes(t)));
    }

    async exportObject(e, t = {}) {
      var n, r, i, s;
      if (!(null == e ? void 0 : e.assetType)) return void console.error("Object has no asset type");
      (null === (r = null === (n = e) || void 0 === n ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) && !1 === t.viewerConfig && (e.userData.__exportViewerConfig = !1);
      const o = await this._exportFile(e, t);
      return (null === (s = null === (i = e) || void 0 === i ? void 0 : i.userData) || void 0 === s ? void 0 : s.rootSceneModelRoot) && !1 === t.viewerConfig && delete e.userData.__exportViewerConfig, o;
    }

    async _exportFile(e, t = {}) {
      var n, r, i;
      let s;
      this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "processing"
      });

      try {
        const o = await this.processBeforeExport(e, t),
              a = null !== (r = null !== (n = t.exportExt) && void 0 !== n ? n : null == o ? void 0 : o.typeExt) && void 0 !== r ? r : null == o ? void 0 : o.ext;
        if (!o || !a) throw new Error(`Unable to preprocess before export ${a}`);

        const l = this._getParser(a);

        this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "exporting"
        });
        const c = await l.parseAsync(o.obj, {
          exportExt: null !== (i = o.ext) && void 0 !== i ? i : a,
          ...t
        });
        c.ext = o.ext, s = c;
      } catch (t) {
        return console.error("AssetExporter: Unable to Export file", e), console.error(t), void this.dispatchEvent({
          type: "exportFile",
          obj: e,
          state: "error",
          error: t
        });
      }

      return this.dispatchEvent({
        type: "exportFile",
        obj: e,
        state: "done"
      }), s;
    }

    _createParser(e) {
      const t = Dx.Exporters.find(t => t.ext.includes(e));
      if (!t) throw new Error(`No exporter found for extension ${e}`);
      const n = null == t ? void 0 : t.ctor(this);
      if (!n) throw new Error(`Unable to create parser for extension ${e}`);
      return this._cachedParsers.push({
        ext: t.ext,
        parser: n
      }), this.dispatchEvent({
        type: "exporterCreate",
        exporter: t,
        parser: n
      }), n;
    }

    _getParser(e) {
      var t, n;
      return null !== (n = null === (t = this._cachedParsers.find(t => t.ext.includes(e))) || void 0 === t ? void 0 : t.parser) && void 0 !== n ? n : this._createParser(e);
    }

    async processBeforeExport(e, t = {}) {
      switch (null != e.assetType && (e = await this._processors.process(e.assetType, e, t)), e.assetType) {
        case "light":
          return void console.error("AssetExporter: light export not implemented");

        case "model":
          return {
            obj: e,
            ext: "glb"
          };

        case "material":
          return {
            obj: e.toJSON(),
            ext: e.typeSlug || "json",
            typeExt: "json"
          };

        case "texture":
          return {
            obj: e.toJSON(),
            ext: "json"
          };

        default:
          console.error("AssetExporter: unknown asset type", e.assetType);
      }
    }

    dispose() {
      var e;
      null === (e = this._processors) || void 0 === e || e.dispose();
    }

  }

  function Ox(e, t = Px, n) {
    var r;
    if (!e) return;
    const i = Dx.Exporters.findIndex(e => e.ext.includes("gltf") || e.ext.includes("glb")),
          s = [];
    if (i >= 0) s.push(...(null !== (r = Dx.Exporters[i].extensions) && void 0 !== r ? r : [])), Dx.Exporters.splice(i, 1);else {
      const t = t => ({
        afterParse: n => {
          var r, i;
          if (!(null === (r = null == (n = Array.isArray(n) ? n[0] : n) ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) || !1 === (null === (i = null == n ? void 0 : n.userData) || void 0 === i ? void 0 : i.__exportViewerConfig)) return;
          const s = t.json.scenes[t.json.scene || 0];
          s.extensions || (s.extensions = {}), s.extensions[Jn] = cx(e, t), t.extensionsUsed[Jn] = !0;
        }
      });

      s.push(Fx), s.push(Ix), s.push(Lx), s.push(t), s.push(e => new Nx(e)), s.push(e => new Ux(e)), s.push(e => new Bx(e));
    }
    Dx.Exporters.push({
      ctor: () => {
        const e = new t();
        return s.forEach(t => e.register(t)), null == n || n(e), e;
      },
      ext: ["gltf", "glb"],
      extensions: s
    });
  }

  Dx.Exporters = [{
    ctor: () => new ax(),
    ext: ["json"]
  }, {
    ctor: () => new lx(),
    ext: ["txt", "text"]
  }];

  const Lx = e => ({
    writeNode: (t, n) => {
      if (!(null == t ? void 0 : t.isLight)) return;
      n.extensions || (n.extensions = {});
      const r = {};
      t.shadow && (r.shadow = t.shadow.toJSON()), Object.keys(r).length > 0 && (n.extensions[Qn] = r, e.extensionsUsed[Qn] = !0);
    }
  }),
        Ix = e => ({
    writeNode: (t, n) => {
      if (!(null == t ? void 0 : t.isObject3D)) return;
      n.extensions || (n.extensions = {});
      const r = {};
      void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), !1 === t.visible && (r.visible = !1), !1 === t.frustumCulled && (r.frustumCulled = !1), 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), 1 !== t.layers.mask && (r.layers = t.layers.mask), !1 === t.matrixAutoUpdate && (r.matrixAutoUpdate = !1), Object.keys(r).length > 0 && (n.extensions[er] = r, e.extensionsUsed[er] = !0);
    }
  }),
        Fx = e => ({
    writeMaterial: (t, n) => {
      var r;
      if (!(null == t ? void 0 : t.isMaterial)) return;
      n.extensions || (n.extensions = {});
      const i = {};

      if (void 0 !== t.emissiveIntensity && (null === (r = t.emissive) || void 0 === r ? void 0 : r.isColor)) {
        const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
              n = Math.max(e.r, e.g, e.b);
        n > 1 && (i.emissiveIntensity = n);
      }

      void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), Object.keys(i).length > 0 && (n.extensions[tr] = i, e.extensionsUsed[tr] = !0);
    }
  });

  class Nx {
    constructor(e) {
      this.writer = e, this.name = or;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.bumpScale) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.bumpScale = e.bumpScale, e.bumpMap) {
        const t = {
          index: n.processTexture(e.bumpMap)
        };
        n.applyTextureTransform(t, e.bumpMap), i.bumpTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Ux {
    constructor(e) {
      this.writer = e, this.name = lr;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || 0 === e.lightMapIntensity) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (i.lightMapIntensity = e.lightMapIntensity, e.bumpMap) {
        const t = {
          index: n.processTexture(e.bumpMap)
        };
        n.applyTextureTransform(t, e.bumpMap), i.lightMapTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class Bx {
    constructor(e) {
      this.writer = e, this.name = ar;
    }

    writeMaterial(e, t) {
      if (!e.isMeshStandardMaterial || !e.alphaMap) return;
      const n = this.writer,
            r = n.extensionsUsed,
            i = {};

      if (e.alphaMap) {
        const t = {
          index: n.processTexture(e.alphaMap)
        };
        n.applyTextureTransform(t, e.alphaMap), i.alphaTexture = t;
      }

      t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0;
    }

  }

  class jx extends Gs {
    constructor(e) {
      super(), this.enabled = !0, this.exportOptions = {
        compress: !1,
        name: "scene",
        viewerConfig: !0,
        convertMeshToIndexed: !1
      }, this.exporter = e, this.exportScene = this.exportScene.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), this.exporter || (this.exporter = new Dx(e)), this.exporter.processors.add("model", {
        forAssetType: "model",
        processAsync: async (e, t) => {
          var n;
          return t.convertMeshToIndexed && (null === (n = e.modelObject) || void 0 === n || n.traverse(e => {
            e.geometry && (e.geometry.attributes.index || e.userData.setGeometry(q(e.geometry)));
          })), e;
        }
      });
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    async exportScene(e) {
      var t, n;
      return null === (t = this.exporter) || void 0 === t ? void 0 : t.exportObject(null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.modelRoot, e || { ...this.exportOptions
      });
    }

    get uiConfig() {
      if (this._uiConfig) return this._uiConfig;
      const e = this._viewer;
      e.addEventListener("addPlugin", e => {
        var t;
        "function" == typeof (null === (t = e.plugin) || void 0 === t ? void 0 : t.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ");
      });
      const t = Object.entries(e.plugins).filter(([e, t]) => "function" == typeof (null == t ? void 0 : t.toJSON)).map(([e, t]) => ({
        label: e,
        type: "checkbox",
        value: !0
      }));
      return this._uiConfig = {
        type: "folder",
        label: "Asset Exporter",
        limitedUi: !0,
        children: [{
          type: "input",
          property: [this.exportOptions, "name"],
          limitedUi: !0
        }, {
          type: "folder",
          label: "GLB Export",
          limitedUi: !0,
          children: [{
            type: "checkbox",
            label: "DRACO Compress",
            property: [this.exportOptions, "compress"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Scene Settings",
            property: [this.exportOptions, "viewerConfig"],
            limitedUi: !0
          }, {
            type: "checkbox",
            label: "Indexed meshes only",
            property: [this.exportOptions, "convertMeshToIndexed"]
          }, {
            type: "button",
            label: "Export GLB",
            limitedUi: !0,
            value: async () => {
              const e = await this.exportScene(this.exportOptions);
              e && vt(e, this.exportOptions.name + "." + e.ext);
            }
          }]
        }, {
          type: "folder",
          label: "Preset/Config export",
          children: [{
            type: "folder",
            label: "Plugins",
            children: t
          }, {
            type: "button",
            label: "Select none",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !1, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Select all",
            value: () => {
              t.forEach(e => {
                var t;
                e.value = !0, null === (t = e.uiRefresh) || void 0 === t || t.call(e);
              });
            }
          }, {
            type: "button",
            label: "Export Plugins",
            limitedUi: !0,
            value: async () => {
              const n = new Blob([JSON.stringify(e.getPlugin(Vs).exportPluginPresets(t.filter(e => !!e.value).map(e => x(e.label) || "")), null, 2)], {
                type: "application/json"
              });
              n && vt(n, this.exportOptions.name + "." + Vs.ViewerTypeSlug);
            }
          }, {
            type: "button",
            label: "Export All Viewer Config",
            limitedUi: !0,
            value: async () => {
              const t = new Blob([JSON.stringify(e.getPlugin(Vs).exportViewerConfig(), null, 2)], {
                type: "application/json"
              });
              t && vt(t, this.exportOptions.name + "." + Vs.ViewerTypeSlug);
            }
          }]
        }]
      };
    }

  }

  jx.PluginType = "AssetExporterPlugin";

  class zx {
    constructor() {
      this._listeners = {};
    }

    addEventListener(e, t) {
      const n = this._listeners;
      return void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t), this;
    }

    removeEventListener(e, t) {
      if (void 0 === this._listeners) return this;
      const n = this._listeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }

      return this;
    }

    dispatchEvent(e) {
      if (void 0 === this._listeners) return this;
      const t = this._listeners[e.type];

      if (void 0 !== t) {
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
      }

      return this;
    }

    dispose() {
      for (const e in this._listeners) delete this._listeners[e];
    }

  }

  class Vx extends zx {
    constructor(e, t, n, r = {}) {
      if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = !1, this._name = e, this._parent = t, this._child = n, this._attributes = r, !t.isOnGraph(n)) throw new Error("Cannot connect disconnected graphs.");
    }

    getName() {
      return this._name;
    }

    getParent() {
      return this._parent;
    }

    getChild() {
      return this._child;
    }

    setChild(e) {
      return this._child = e, this;
    }

    getAttributes() {
      return this._attributes;
    }

    dispose() {
      this._disposed || (this._disposed = !0, this.dispatchEvent({
        type: "dispose",
        target: this
      }), super.dispose());
    }

    isDisposed() {
      return this._disposed;
    }

  }

  class Gx extends zx {
    constructor(...e) {
      super(...e), this._emptySet = new Set(), this._edges = new Set(), this._parentEdges = new Map(), this._childEdges = new Map();
    }

    listEdges() {
      return Array.from(this._edges);
    }

    listParentEdges(e) {
      return Array.from(this._childEdges.get(e) || this._emptySet);
    }

    listParents(e) {
      return this.listParentEdges(e).map(e => e.getParent());
    }

    listChildEdges(e) {
      return Array.from(this._parentEdges.get(e) || this._emptySet);
    }

    listChildren(e) {
      return this.listChildEdges(e).map(e => e.getChild());
    }

    disconnectParents(e, t) {
      let n = this.listParentEdges(e);
      return t && (n = n.filter(e => t(e.getParent()))), n.forEach(e => e.dispose()), this;
    }

    createEdge(e, t, n, r) {
      return this._registerEdge(new Vx(e, t, n, r));
    }

    _registerEdge(e) {
      this._edges.add(e);

      const t = e.getParent();
      this._parentEdges.has(t) || this._parentEdges.set(t, new Set()), this._parentEdges.get(t).add(e);
      const n = e.getChild();
      return this._childEdges.has(n) || this._childEdges.set(n, new Set()), this._childEdges.get(n).add(e), e.addEventListener("dispose", () => this._removeEdge(e)), e;
    }

    _removeEdge(e) {
      return this._edges.delete(e), this._parentEdges.get(e.getParent()).delete(e), this._childEdges.get(e.getChild()).delete(e), this;
    }

  }

  function Hx() {
    return (Hx = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  function Wx(e) {
    return e instanceof Vx;
  }

  function Kx(e) {
    return Array.isArray(e) && e[0] instanceof Vx;
  }

  function Xx(e) {
    return !!(e && "object" == typeof e && Object.values(e)[0] instanceof Vx);
  }

  const qx = Symbol("attributes"),
        Yx = Symbol("immutableKeys");

  class Zx extends zx {
    constructor(e) {
      super(), this._disposed = !1, this.graph = void 0, this[qx] = void 0, this[Yx] = void 0, this.graph = e, this[Yx] = new Set(), this[qx] = this._createAttributes();
    }

    getDefaults() {
      return {};
    }

    _createAttributes() {
      const e = this.getDefaults(),
            t = {};

      for (const n in e) {
        const r = e[n];

        if (r instanceof Zx) {
          const e = this.graph.createEdge(n, this, r);
          e.addEventListener("dispose", () => r.dispose()), this[Yx].add(n), t[n] = e;
        } else t[n] = r;
      }

      return t;
    }

    isOnGraph(e) {
      return this.graph === e.graph;
    }

    isDisposed() {
      return this._disposed;
    }

    dispose() {
      this._disposed || (this.graph.listChildEdges(this).forEach(e => e.dispose()), this.graph.disconnectParents(this), this._disposed = !0, this.dispatchEvent({
        type: "dispose"
      }));
    }

    detach() {
      return this.graph.disconnectParents(this), this;
    }

    swap(e, t) {
      for (const n in this[qx]) {
        const r = this[qx][n];

        if (Wx(r)) {
          const i = r;
          i.getChild() === e && this.setRef(n, t, i.getAttributes());
        } else if (Kx(r)) {
          const i = r.find(t => t.getChild() === e);

          if (i) {
            const r = i.getAttributes();
            this.removeRef(n, e).addRef(n, t, r);
          }
        } else if (Xx(r)) {
          const i = r;

          for (const r in i) {
            const s = i[r];
            s.getChild() === e && this.setRefMap(n, r, t, s.getAttributes());
          }
        }
      }

      return this;
    }

    get(e) {
      return this[qx][e];
    }

    set(e, t) {
      return this[qx][e] = t, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    getRef(e) {
      const t = this[qx][e];
      return t ? t.getChild() : null;
    }

    setRef(e, t, n) {
      if (this[Yx].has(e)) throw new Error(`Cannot overwrite immutable attribute, "${e}".`);
      const r = this[qx][e];
      if (r && r.dispose(), !t) return this;
      const i = this.graph.createEdge(e, this, t, n);
      return i.addEventListener("dispose", () => {
        delete this[qx][e], this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this[qx][e] = i, this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    listRefs(e) {
      return this[qx][e].map(e => e.getChild());
    }

    addRef(e, t, n) {
      const r = this.graph.createEdge(e, this, t, n),
            i = this[qx][e];
      return i.push(r), r.addEventListener("dispose", () => {
        const t = i.filter(e => e !== r);
        i.length = 0;

        for (const e of t) i.push(e);

        this.dispatchEvent({
          type: "change",
          attribute: e
        });
      }), this.dispatchEvent({
        type: "change",
        attribute: e
      });
    }

    removeRef(e, t) {
      return this[qx][e].filter(e => e.getChild() === t).forEach(e => e.dispose()), this;
    }

    listRefMapKeys(e) {
      return Object.keys(this[qx][e]);
    }

    listRefMapValues(e) {
      return Object.values(this[qx][e]).map(e => e.getChild());
    }

    getRefMap(e, t) {
      const n = this[qx][e];
      return n[t] ? n[t].getChild() : null;
    }

    setRefMap(e, t, n, r) {
      const i = this[qx][e],
            s = i[t];
      if (s && s.dispose(), !n) return this;
      r = Object.assign(r || {}, {
        key: t
      });
      const o = this.graph.createEdge(e, this, n, Hx({}, r, {
        key: t
      }));
      return o.addEventListener("dispose", () => {
        delete i[t], this.dispatchEvent({
          type: "change",
          attribute: e,
          key: t
        });
      }), i[t] = o, this.dispatchEvent({
        type: "change",
        attribute: e,
        key: t
      });
    }

    dispatchEvent(e) {
      return super.dispatchEvent(Hx({}, e, {
        target: this
      })), this.graph.dispatchEvent(Hx({}, e, {
        target: this,
        type: `node:${e.type}`
      })), this;
    }

  }

  var Jx,
      $x,
      Qx,
      ey,
      ty,
      ny,
      ry = "undefined" != typeof Float32Array ? Float32Array : Array;

  function iy(e) {
    var t = e[0],
        n = e[1],
        r = e[2];
    return Math.hypot(t, n, r);
  }

  function sy(e, t, n) {
    var r = t[0],
        i = t[1],
        s = t[2],
        o = n[3] * r + n[7] * i + n[11] * s + n[15];
    return o = o || 1, e[0] = (n[0] * r + n[4] * i + n[8] * s + n[12]) / o, e[1] = (n[1] * r + n[5] * i + n[9] * s + n[13]) / o, e[2] = (n[2] * r + n[6] * i + n[10] * s + n[14]) / o, e;
  }

  function oy(e, t, n) {
    var r = t[0],
        i = t[1],
        s = t[2],
        o = t[3],
        a = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        p = t[8],
        h = t[9],
        d = t[10],
        f = t[11],
        _ = t[12],
        m = t[13],
        g = t[14],
        v = t[15],
        b = n[0],
        x = n[1],
        y = n[2],
        w = n[3];
    return e[0] = b * r + x * a + y * p + w * _, e[1] = b * i + x * l + y * h + w * m, e[2] = b * s + x * c + y * d + w * g, e[3] = b * o + x * u + y * f + w * v, b = n[4], x = n[5], y = n[6], w = n[7], e[4] = b * r + x * a + y * p + w * _, e[5] = b * i + x * l + y * h + w * m, e[6] = b * s + x * c + y * d + w * g, e[7] = b * o + x * u + y * f + w * v, b = n[8], x = n[9], y = n[10], w = n[11], e[8] = b * r + x * a + y * p + w * _, e[9] = b * i + x * l + y * h + w * m, e[10] = b * s + x * c + y * d + w * g, e[11] = b * o + x * u + y * f + w * v, b = n[12], x = n[13], y = n[14], w = n[15], e[12] = b * r + x * a + y * p + w * _, e[13] = b * i + x * l + y * h + w * m, e[14] = b * s + x * c + y * d + w * g, e[15] = b * o + x * u + y * f + w * v, e;
  }

  function ay(e, t) {
    const n = {
      min: [1 / 0, 1 / 0, 1 / 0],
      max: [-1 / 0, -1 / 0, -1 / 0]
    };

    for (const r of e.listPrimitives()) {
      const e = r.getAttribute("POSITION");
      if (!e) continue;
      let i = [0, 0, 0],
          s = [0, 0, 0];

      for (let r = 0; r < e.getCount(); r++) i = e.getElement(r, i), s = sy(s, i, t), ly(s, n);
    }

    return n;
  }

  function ly(e, t) {
    for (let n = 0; n < 3; n++) t.min[n] = Math.min(e[n], t.min[n]), t.max[n] = Math.max(e[n], t.max[n]);
  }

  Math.random, Math.PI, Math.hypot || (Math.hypot = function () {
    for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];

    return Math.sqrt(e);
  }), Jx = new ry(3), ry != Float32Array && (Jx[0] = 0, Jx[1] = 0, Jx[2] = 0), function (e) {
    e.ACCESSOR = "Accessor", e.ANIMATION = "Animation", e.ANIMATION_CHANNEL = "AnimationChannel", e.ANIMATION_SAMPLER = "AnimationSampler", e.BUFFER = "Buffer", e.CAMERA = "Camera", e.MATERIAL = "Material", e.MESH = "Mesh", e.PRIMITIVE = "Primitive", e.PRIMITIVE_TARGET = "PrimitiveTarget", e.NODE = "Node", e.ROOT = "Root", e.SCENE = "Scene", e.SKIN = "Skin", e.TEXTURE = "Texture", e.TEXTURE_INFO = "TextureInfo";
  }($x || ($x = {})), function (e) {
    e.INTERLEAVED = "interleaved", e.SEPARATE = "separate";
  }(Qx || (Qx = {})), function (e) {
    e.ARRAY_BUFFER = "ARRAY_BUFFER", e.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e.OTHER = "OTHER";
  }(ey || (ey = {})), function (e) {
    e[e.R = 4096] = "R", e[e.G = 256] = "G", e[e.B = 16] = "B", e[e.A = 1] = "A";
  }(ty || (ty = {})), function (e) {
    e.GLTF = "GLTF", e.GLB = "GLB";
  }(ny || (ny = {}));

  class cy {
    static createBufferFromDataURI(e) {
      if ("undefined" == typeof Buffer) {
        const t = atob(e.split(",")[1]),
              n = new Uint8Array(t.length);

        for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);

        return n;
      }

      {
        const t = e.split(",")[1],
              n = e.indexOf("base64") >= 0;
        return Buffer.from(t, n ? "base64" : "utf8");
      }
    }

    static encodeText(e) {
      return "undefined" != typeof TextEncoder ? new TextEncoder().encode(e) : Buffer.from(e);
    }

    static decodeText(e) {
      return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
    }

    static concat(e) {
      let t = 0;

      for (const n of e) t += n.byteLength;

      const n = new Uint8Array(t);
      let r = 0;

      for (const t of e) n.set(t, r), r += t.byteLength;

      return n;
    }

    static pad(e, t = 0) {
      const n = this.padNumber(e.byteLength);
      if (n === e.byteLength) return e;
      const r = new Uint8Array(n);
      if (r.set(e), 0 !== t) for (let i = e.byteLength; i < n; i++) r[i] = t;
      return r;
    }

    static padNumber(e) {
      return 4 * Math.ceil(e / 4);
    }

    static equals(e, t) {
      if (e === t) return !0;
      if (e.byteLength !== t.byteLength) return !1;
      let n = e.byteLength;

      for (; n--;) if (e[n] !== t[n]) return !1;

      return !0;
    }

    static toView(e, t = 0, n = 1 / 0) {
      return new Uint8Array(e.buffer, e.byteOffset + t, Math.min(e.byteLength, n));
    }

    static assertView(e) {
      if (e && !ArrayBuffer.isView(e)) throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);
      return e;
    }

  }

  class uy {
    static hexToFactor(e, t) {
      e = Math.floor(e);
      const n = t;
      return n[0] = (e >> 16 & 255) / 255, n[1] = (e >> 8 & 255) / 255, n[2] = (255 & e) / 255, this.convertSRGBToLinear(t, t);
    }

    static factorToHex(e) {
      const t = [...e],
            [n, r, i] = this.convertLinearToSRGB(e, t);
      return 255 * n << 16 ^ 255 * r << 8 ^ 255 * i << 0;
    }

    static convertSRGBToLinear(e, t) {
      const n = e,
            r = t;

      for (let e = 0; e < 3; e++) r[e] = n[e] < .04045 ? .0773993808 * n[e] : Math.pow(.9478672986 * n[e] + .0521327014, 2.4);

      return t;
    }

    static convertLinearToSRGB(e, t) {
      const n = e,
            r = t;

      for (let e = 0; e < 3; e++) r[e] = n[e] < .0031308 ? 12.92 * n[e] : 1.055 * Math.pow(n[e], .41666) - .055;

      return t;
    }

  }

  class py {
    match(e) {
      return e.length >= 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7];
    }

    getSize(e) {
      const t = new DataView(e.buffer, e.byteOffset);
      return cy.decodeText(e.slice(12, 16)) === py.PNG_FRIED_CHUNK_NAME ? [t.getUint32(32, !1), t.getUint32(36, !1)] : [t.getUint32(16, !1), t.getUint32(20, !1)];
    }

    getChannels(e) {
      return 4;
    }

  }

  py.PNG_FRIED_CHUNK_NAME = "CgBI";

  class hy {
    static registerFormat(e, t) {
      this.impls[e] = t;
    }

    static getMimeType(e) {
      for (const t in this.impls) if (this.impls[t].match(e)) return t;

      return null;
    }

    static getSize(e, t) {
      return this.impls[t] ? this.impls[t].getSize(e) : null;
    }

    static getChannels(e, t) {
      return this.impls[t] ? this.impls[t].getChannels(e) : null;
    }

    static getMemSize(e, t) {
      if (!this.impls[t]) return null;
      if (this.impls[t].getGPUByteLength) return this.impls[t].getGPUByteLength(e);
      let n = 0;
      const r = this.getSize(e, t);
      if (!r) return null;

      for (; r[0] > 1 || r[1] > 1;) n += r[0] * r[1] * 4, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);

      return n += 4, n;
    }

    static mimeTypeToExtension(e) {
      return "image/jpeg" === e ? "jpg" : e.split("/").pop();
    }

    static extensionToMimeType(e) {
      return "jpg" === e ? "image/jpeg" : `image/${e}`;
    }

  }

  function dy(e, t) {
    if (t > e.byteLength) throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e.getUint8(t)) throw new TypeError("Invalid JPG, marker table corrupted");
    return e;
  }

  hy.impls = {
    "image/jpeg": new class {
      match(e) {
        return e.length >= 3 && 255 === e[0] && 216 === e[1] && 255 === e[2];
      }

      getSize(e) {
        let t,
            n,
            r = new DataView(e.buffer, e.byteOffset + 4);

        for (; r.byteLength;) {
          if (t = r.getUint16(0, !1), dy(r, t), n = r.getUint8(t + 1), 192 === n || 193 === n || 194 === n) return [r.getUint16(t + 7, !1), r.getUint16(t + 5, !1)];
          r = new DataView(e.buffer, r.byteOffset + t + 2);
        }

        throw new TypeError("Invalid JPG, no size found");
      }

      getChannels(e) {
        return 3;
      }

    }(),
    "image/png": new py()
  };

  class fy {
    static basename(e) {
      const t = e.split(/[\\/]/).pop();
      return t.substring(0, t.lastIndexOf("."));
    }

    static extension(e) {
      if (e.startsWith("data:image/")) {
        const t = e.match(/data:(image\/\w+)/)[1];
        return hy.mimeTypeToExtension(t);
      }

      return e.startsWith("data:model/gltf+json") ? "gltf" : e.startsWith("data:model/gltf-binary") ? "glb" : e.startsWith("data:application/") ? "bin" : e.split(/[\\/]/).pop().split(/[.]/).pop();
    }

  }

  function _y(e) {
    return "[object Object]" === Object.prototype.toString.call(e);
  }

  function my(e) {
    if (!1 === _y(e)) return !1;
    const t = e.constructor;
    if (void 0 === t) return !0;
    const n = t.prototype;
    return !1 !== _y(n) && !1 !== Object.prototype.hasOwnProperty.call(n, "isPrototypeOf");
  }

  class gy {
    constructor(e) {
      this.verbosity = void 0, this.verbosity = e;
    }

    debug(e) {
      this.verbosity <= gy.Verbosity.DEBUG && console.debug(e);
    }

    info(e) {
      this.verbosity <= gy.Verbosity.INFO && console.info(e);
    }

    warn(e) {
      this.verbosity <= gy.Verbosity.WARN && console.warn(e);
    }

    error(e) {
      this.verbosity <= gy.Verbosity.ERROR && console.error(e);
    }

  }

  gy.Verbosity = {
    SILENT: 4,
    ERROR: 3,
    WARN: 2,
    INFO: 1,
    DEBUG: 0
  }, gy.DEFAULT_INSTANCE = new gy(gy.Verbosity.INFO);

  class vy {
    static identity(e) {
      return e;
    }

    static eq(e, t) {
      if (e.length !== t.length) return !1;

      for (let n = 0; n < e.length; n++) if (Math.abs(e[n] - t[n]) > 1e-5) return !1;

      return !0;
    }

    static denormalize(e, t) {
      switch (t) {
        case 5126:
          return e;

        case 5123:
          return e / 65535;

        case 5121:
          return e / 255;

        case 5122:
          return Math.max(e / 32767, -1);

        case 5120:
          return Math.max(e / 127, -1);

        default:
          throw new Error("Invalid component type.");
      }
    }

    static normalize(e, t) {
      switch (t) {
        case 5126:
          return e;

        case 5123:
          return Math.round(65535 * e);

        case 5121:
          return Math.round(255 * e);

        case 5122:
          return Math.round(32767 * e);

        case 5120:
          return Math.round(127 * e);

        default:
          throw new Error("Invalid component type.");
      }
    }

    static decompose(e, t, n, r) {
      let i = iy([e[0], e[1], e[2]]);
      const s = iy([e[4], e[5], e[6]]),
            o = iy([e[8], e[9], e[10]]);
      (function (e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            p = e[10],
            h = e[11],
            d = e[12],
            f = e[13],
            _ = e[14],
            m = e[15];
        return (t * o - n * s) * (p * m - h * _) - (t * a - r * s) * (u * m - h * f) + (t * l - i * s) * (u * _ - p * f) + (n * a - r * o) * (c * m - h * d) - (n * l - i * o) * (c * _ - p * d) + (r * l - i * a) * (c * f - u * d);
      })(e) < 0 && (i = -i), t[0] = e[12], t[1] = e[13], t[2] = e[14];
      const a = e.slice(),
            l = 1 / i,
            c = 1 / s,
            u = 1 / o;
      a[0] *= l, a[1] *= l, a[2] *= l, a[4] *= c, a[5] *= c, a[6] *= c, a[8] *= u, a[9] *= u, a[10] *= u, function (e, t) {
        var n = new ry(3);
        !function (e, t) {
          var n = t[0],
              r = t[1],
              i = t[2],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[8],
              c = t[9],
              u = t[10];
          e[0] = Math.hypot(n, r, i), e[1] = Math.hypot(s, o, a), e[2] = Math.hypot(l, c, u);
        }(n, t);

        var r = 1 / n[0],
            i = 1 / n[1],
            s = 1 / n[2],
            o = t[0] * r,
            a = t[1] * i,
            l = t[2] * s,
            c = t[4] * r,
            u = t[5] * i,
            p = t[6] * s,
            h = t[8] * r,
            d = t[9] * i,
            f = t[10] * s,
            _ = o + u + f,
            m = 0;

        _ > 0 ? (m = 2 * Math.sqrt(_ + 1), e[3] = .25 * m, e[0] = (p - d) / m, e[1] = (h - l) / m, e[2] = (a - c) / m) : o > u && o > f ? (m = 2 * Math.sqrt(1 + o - u - f), e[3] = (p - d) / m, e[0] = .25 * m, e[1] = (a + c) / m, e[2] = (h + l) / m) : u > f ? (m = 2 * Math.sqrt(1 + u - o - f), e[3] = (h - l) / m, e[0] = (a + c) / m, e[1] = .25 * m, e[2] = (p + d) / m) : (m = 2 * Math.sqrt(1 + f - o - u), e[3] = (a - c) / m, e[0] = (h + l) / m, e[1] = (p + d) / m, e[2] = .25 * m);
      }(n, a), r[0] = i, r[1] = s, r[2] = o;
    }

    static compose(e, t, n, r) {
      const i = r,
            s = t[0],
            o = t[1],
            a = t[2],
            l = t[3],
            c = s + s,
            u = o + o,
            p = a + a,
            h = s * c,
            d = s * u,
            f = s * p,
            _ = o * u,
            m = o * p,
            g = a * p,
            v = l * c,
            b = l * u,
            x = l * p,
            y = n[0],
            w = n[1],
            S = n[2];

      return i[0] = (1 - (_ + g)) * y, i[1] = (d + x) * y, i[2] = (f - b) * y, i[3] = 0, i[4] = (d - x) * w, i[5] = (1 - (h + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (f + b) * S, i[9] = (m - v) * S, i[10] = (1 - (h + _)) * S, i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i;
    }

  }

  function by(e, t) {
    if (!!e != !!t) return !1;
    const n = e.getChild(),
          r = t.getChild();
    return n === r || n.equals(r);
  }

  function xy(e, t) {
    if (!!e != !!t) return !1;
    if (e.length !== t.length) return !1;

    for (let n = 0; n < e.length; n++) {
      const r = e[n],
            i = t[n];
      if (r.getChild() !== i.getChild() && !r.getChild().equals(i.getChild())) return !1;
    }

    return !0;
  }

  function yy(e, t) {
    if (!!e != !!t) return !1;
    const n = Object.keys(e),
          r = Object.keys(t);
    if (n.length !== r.length) return !1;

    for (const n in e) {
      const r = e[n],
            i = t[n];
      if (!!r != !!i) return !1;
      const s = r.getChild(),
            o = i.getChild();
      if (s !== o && !s.equals(o)) return !1;
    }

    return !0;
  }

  function wy(e, t) {
    if (e === t) return !0;
    if (!!e != !!t || !e || !t) return !1;
    if (e.length !== t.length) return !1;

    for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;

    return !0;
  }

  function Sy(e, t) {
    if (e === t) return !0;
    if (!!e != !!t) return !1;
    if (!my(e) || !my(t)) return e === t;
    const n = e,
          r = t;
    let i,
        s = 0,
        o = 0;

    for (i in n) s++;

    for (i in r) o++;

    if (s !== o) return !1;

    for (i in n) {
      const e = n[i],
            t = r[i];

      if (My(e) && My(t)) {
        if (!wy(e, t)) return !1;
      } else if (my(e) && my(t)) {
        if (!Sy(e, t)) return !1;
      } else if (e !== t) return !1;
    }

    return !0;
  }

  function My(e) {
    return Array.isArray(e) || ArrayBuffer.isView(e);
  }

  const Ty = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",
        Ey = new Set(),
        Ay = function () {
    let e = "";

    for (let t = 0; t < 6; t++) e += Ty.charAt(Math.floor(Math.random() * Ty.length));

    return e;
  };

  class Cy {
    static dirname(e) {
      const t = e.lastIndexOf("/");
      return -1 === t ? "./" : e.substring(0, t + 1);
    }

    static basename(e) {
      return fy.basename(new URL(e, "https://null.example").pathname);
    }

    static extension(e) {
      return fy.extension(new URL(e, "https://null.example").pathname);
    }

    static resolve(e, t) {
      if (!this.isRelativePath(t)) return t;
      const n = e.split("/"),
            r = t.split("/");
      n.pop();

      for (let e = 0; e < r.length; e++) "." !== r[e] && (".." === r[e] ? n.pop() : n.push(r[e]));

      return n.join("/");
    }

    static isAbsoluteURL(e) {
      return this.PROTOCOL_REGEXP.test(e);
    }

    static isRelativePath(e) {
      return !/^(?:[a-zA-Z]+:)?\//.test(e);
    }

  }

  Cy.DEFAULT_INIT = {}, Cy.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;

  const Ry = e => e;

  class ky extends Zx {
    constructor(e, t = "") {
      super(e), this[qx].name = t, this.init(), this.dispatchEvent({
        type: "create"
      });
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        name: "",
        extras: {}
      });
    }

    getName() {
      return this.get("name");
    }

    setName(e) {
      return this.set("name", e);
    }

    getExtras() {
      return this.get("extras");
    }

    setExtras(e) {
      return this.set("extras", e);
    }

    clone() {
      return new (0, this.constructor)(this.graph).copy(this, Ry);
    }

    copy(e, t = Ry) {
      for (const e in this[qx]) {
        const t = this[qx][e];
        if (t instanceof Vx) this[Yx].has(e) || t.dispose();else if (Array.isArray(t) && t[0] instanceof Vx) for (const e of t) e.dispose();else if (my(t) && Object.values(t)[0] instanceof Vx) for (const e in t) t[e].dispose();
      }

      for (const n in e[qx]) {
        const r = this[qx][n],
              i = e[qx][n];
        if (i instanceof Vx) this[Yx].has(n) ? r.getChild().copy(t(i.getChild()), t) : this.setRef(n, t(i.getChild()), i.getAttributes());else if (Array.isArray(i) && i[0] instanceof Vx) for (const e of i) this.addRef(n, t(e.getChild()), e.getAttributes());else if (my(i) && Object.values(i)[0] instanceof Vx) for (const e in i) {
          const r = i[e];
          this.setRefMap(n, e, t(r.getChild()), r.getAttributes());
        } else this[qx][n] = my(i) ? JSON.parse(JSON.stringify(i)) : Array.isArray(i) || i instanceof ArrayBuffer || ArrayBuffer.isView(i) ? i.slice() : i;
      }

      return this;
    }

    equals(e) {
      if (this === e) return !0;
      if (this.propertyType !== e.propertyType) return !1;

      for (const t in this[qx]) {
        const n = this[qx][t],
              r = e[qx][t];

        if (Wx(n) || Wx(r)) {
          if (!by(n, r)) return !1;
        } else if (Kx(n) || Kx(r)) {
          if (!xy(n, r)) return !1;
        } else if (Xx(n) || Xx(r)) {
          if (!yy(n, r)) return !1;
        } else if (my(n) || my(r)) {
          if (!Sy(n, r)) return !1;
        } else if (My(n) || My(r)) {
          if (!wy(n, r)) return !1;
        } else if (n !== r) return !1;
      }

      return !0;
    }

    detach() {
      return this.graph.disconnectParents(this, e => "Root" !== e.propertyType), this;
    }

    listParents() {
      return this.graph.listParents(this);
    }

  }

  class Py extends ky {
    getDefaults() {
      return Object.assign(super.getDefaults(), {
        extensions: {}
      });
    }

    getExtension(e) {
      return this.getRefMap("extensions", e);
    }

    setExtension(e, t) {
      return t && t.t(this), this.setRefMap("extensions", e, t);
    }

    listExtensions() {
      return this.listRefMapValues("extensions");
    }

  }

  class Dy extends Py {
    constructor(...e) {
      super(...e), this.i = vy.identity, this.o = vy.identity;
    }

    init() {
      this.propertyType = $x.ACCESSOR;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        array: null,
        type: Dy.Type.SCALAR,
        componentType: Dy.ComponentType.FLOAT,
        normalized: !1,
        buffer: null
      });
    }

    copy(e, t = Ry) {
      return super.copy(e, t), this.i = e.i, this.o = e.o, this;
    }

    static getElementSize(e) {
      switch (e) {
        case Dy.Type.SCALAR:
          return 1;

        case Dy.Type.VEC2:
          return 2;

        case Dy.Type.VEC3:
          return 3;

        case Dy.Type.VEC4:
        case Dy.Type.MAT2:
          return 4;

        case Dy.Type.MAT3:
          return 9;

        case Dy.Type.MAT4:
          return 16;

        default:
          throw new Error("Unexpected type: " + e);
      }
    }

    static getComponentSize(e) {
      switch (e) {
        case Dy.ComponentType.BYTE:
        case Dy.ComponentType.UNSIGNED_BYTE:
          return 1;

        case Dy.ComponentType.SHORT:
        case Dy.ComponentType.UNSIGNED_SHORT:
          return 2;

        case Dy.ComponentType.UNSIGNED_INT:
        case Dy.ComponentType.FLOAT:
          return 4;

        default:
          throw new Error("Unexpected component type: " + e);
      }
    }

    getMinNormalized(e) {
      const t = this.getElementSize();
      this.getMin(e);

      for (let n = 0; n < t; n++) e[n] = this.o(e[n]);

      return e;
    }

    getMin(e) {
      const t = this.get("array"),
            n = this.getCount(),
            r = this.getElementSize();

      for (let t = 0; t < r; t++) e[t] = 1 / 0;

      for (let i = 0; i < n * r; i += r) for (let n = 0; n < r; n++) {
        const r = t[i + n];
        Number.isFinite(r) && (e[n] = Math.min(e[n], r));
      }

      return e;
    }

    getMaxNormalized(e) {
      const t = this.getElementSize();
      this.getMax(e);

      for (let n = 0; n < t; n++) e[n] = this.o(e[n]);

      return e;
    }

    getMax(e) {
      const t = this.get("array"),
            n = this.getCount(),
            r = this.getElementSize();

      for (let t = 0; t < r; t++) e[t] = -1 / 0;

      for (let i = 0; i < n * r; i += r) for (let n = 0; n < r; n++) {
        const r = t[i + n];
        Number.isFinite(r) && (e[n] = Math.max(e[n], r));
      }

      return e;
    }

    getCount() {
      const e = this.get("array");
      return e ? e.length / this.getElementSize() : 0;
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getElementSize() {
      return Dy.getElementSize(this.get("type"));
    }

    getComponentSize() {
      return this.get("array").BYTES_PER_ELEMENT;
    }

    getComponentType() {
      return this.get("componentType");
    }

    getNormalized() {
      return this.get("normalized");
    }

    setNormalized(e) {
      return this.set("normalized", e), e ? (this.o = e => vy.denormalize(e, this.get("componentType")), this.i = e => vy.normalize(e, this.get("componentType"))) : (this.o = vy.identity, this.i = vy.identity), this;
    }

    getScalar(e) {
      const t = this.getElementSize();
      return this.o(this.get("array")[e * t]);
    }

    setScalar(e, t) {
      return this.get("array")[e * this.getElementSize()] = this.i(t), this;
    }

    getElement(e, t) {
      const n = this.getElementSize(),
            r = this.get("array");

      for (let i = 0; i < n; i++) t[i] = this.o(r[e * n + i]);

      return t;
    }

    setElement(e, t) {
      const n = this.getElementSize(),
            r = this.get("array");

      for (let i = 0; i < n; i++) r[e * n + i] = this.i(t[i]);

      return this;
    }

    getBuffer() {
      return this.getRef("buffer");
    }

    setBuffer(e) {
      return this.setRef("buffer", e);
    }

    getArray() {
      return this.get("array");
    }

    setArray(e) {
      return this.set("componentType", e ? function (e) {
        switch (e.constructor) {
          case Float32Array:
            return Dy.ComponentType.FLOAT;

          case Uint32Array:
            return Dy.ComponentType.UNSIGNED_INT;

          case Uint16Array:
            return Dy.ComponentType.UNSIGNED_SHORT;

          case Uint8Array:
            return Dy.ComponentType.UNSIGNED_BYTE;

          case Int16Array:
            return Dy.ComponentType.SHORT;

          case Int8Array:
            return Dy.ComponentType.BYTE;

          default:
            throw new Error("Unknown accessor componentType.");
        }
      }(e) : Dy.ComponentType.FLOAT), this.set("array", e), this;
    }

    getByteLength() {
      const e = this.get("array");
      return e ? e.byteLength : 0;
    }

  }

  Dy.Type = {
    SCALAR: "SCALAR",
    VEC2: "VEC2",
    VEC3: "VEC3",
    VEC4: "VEC4",
    MAT2: "MAT2",
    MAT3: "MAT3",
    MAT4: "MAT4"
  }, Dy.ComponentType = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_INT: 5125,
    FLOAT: 5126
  };

  class Oy extends Py {
    init() {
      this.propertyType = $x.ANIMATION;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        channels: [],
        samplers: []
      });
    }

    addChannel(e) {
      return this.addRef("channels", e);
    }

    removeChannel(e) {
      return this.removeRef("channels", e);
    }

    listChannels() {
      return this.listRefs("channels");
    }

    addSampler(e) {
      return this.addRef("samplers", e);
    }

    removeSampler(e) {
      return this.removeRef("samplers", e);
    }

    listSamplers() {
      return this.listRefs("samplers");
    }

  }

  class Ly extends Py {
    init() {
      this.propertyType = $x.ANIMATION_CHANNEL;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        targetPath: null,
        targetNode: null,
        sampler: null
      });
    }

    getTargetPath() {
      return this.get("targetPath");
    }

    setTargetPath(e) {
      return this.set("targetPath", e);
    }

    getTargetNode() {
      return this.getRef("targetNode");
    }

    setTargetNode(e) {
      return this.setRef("targetNode", e);
    }

    getSampler() {
      return this.getRef("sampler");
    }

    setSampler(e) {
      return this.setRef("sampler", e);
    }

  }

  Ly.TargetPath = {
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights"
  };

  class Iy extends Py {
    init() {
      this.propertyType = $x.ANIMATION_SAMPLER;
    }

    getDefaultAttributes() {
      return Object.assign(super.getDefaults(), {
        interpolation: Iy.Interpolation.LINEAR,
        input: null,
        output: null
      });
    }

    getInterpolation() {
      return this.get("interpolation");
    }

    setInterpolation(e) {
      return this.set("interpolation", e);
    }

    getInput() {
      return this.getRef("input");
    }

    setInput(e) {
      return this.setRef("input", e, {
        usage: ey.OTHER
      });
    }

    getOutput() {
      return this.getRef("output");
    }

    setOutput(e) {
      return this.setRef("output", e, {
        usage: ey.OTHER
      });
    }

  }

  Iy.Interpolation = {
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
  };

  class Fy extends Py {
    init() {
      this.propertyType = $x.BUFFER;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        uri: ""
      });
    }

    getURI() {
      return this.get("uri");
    }

    setURI(e) {
      return this.set("uri", e);
    }

  }

  class Ny extends Py {
    init() {
      this.propertyType = $x.CAMERA;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        type: Ny.Type.PERSPECTIVE,
        znear: .1,
        zfar: 100,
        aspectRatio: null,
        yfov: 2 * Math.PI * 50 / 360,
        xmag: 1,
        ymag: 1
      });
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getZNear() {
      return this.get("znear");
    }

    setZNear(e) {
      return this.set("znear", e);
    }

    getZFar() {
      return this.get("zfar");
    }

    setZFar(e) {
      return this.set("zfar", e);
    }

    getAspectRatio() {
      return this.get("aspectRatio");
    }

    setAspectRatio(e) {
      return this.set("aspectRatio", e);
    }

    getYFov() {
      return this.get("yfov");
    }

    setYFov(e) {
      return this.set("yfov", e);
    }

    getXMag() {
      return this.get("xmag");
    }

    setXMag(e) {
      return this.set("xmag", e);
    }

    getYMag() {
      return this.get("ymag");
    }

    setYMag(e) {
      return this.set("ymag", e);
    }

  }

  Ny.Type = {
    PERSPECTIVE: "perspective",
    ORTHOGRAPHIC: "orthographic"
  };

  class Uy extends ky {
    t(e) {
      if (!this.parentTypes.includes(e.propertyType)) throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`);
    }

  }

  Uy.EXTENSION_NAME = void 0;

  class By extends Py {
    init() {
      this.propertyType = $x.TEXTURE_INFO;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        texCoord: 0,
        magFilter: null,
        minFilter: null,
        wrapS: By.WrapMode.REPEAT,
        wrapT: By.WrapMode.REPEAT
      });
    }

    getTexCoord() {
      return this.get("texCoord");
    }

    setTexCoord(e) {
      return this.set("texCoord", e);
    }

    getMagFilter() {
      return this.get("magFilter");
    }

    setMagFilter(e) {
      return this.set("magFilter", e);
    }

    getMinFilter() {
      return this.get("minFilter");
    }

    setMinFilter(e) {
      return this.set("minFilter", e);
    }

    getWrapS() {
      return this.get("wrapS");
    }

    setWrapS(e) {
      return this.set("wrapS", e);
    }

    getWrapT() {
      return this.get("wrapT");
    }

    setWrapT(e) {
      return this.set("wrapT", e);
    }

  }

  By.WrapMode = {
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
  }, By.MagFilter = {
    NEAREST: 9728,
    LINEAR: 9729
  }, By.MinFilter = {
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987
  };
  const {
    R: jy,
    G: zy,
    B: Vy,
    A: Gy
  } = ty;

  class Hy extends Py {
    init() {
      this.propertyType = $x.MATERIAL;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        alphaMode: Hy.AlphaMode.OPAQUE,
        alphaCutoff: .5,
        doubleSided: !1,
        baseColorFactor: [1, 1, 1, 1],
        baseColorTexture: null,
        baseColorTextureInfo: new By(this.graph, "baseColorTextureInfo"),
        emissiveFactor: [0, 0, 0],
        emissiveTexture: null,
        emissiveTextureInfo: new By(this.graph, "emissiveTextureInfo"),
        normalScale: 1,
        normalTexture: null,
        normalTextureInfo: new By(this.graph, "normalTextureInfo"),
        occlusionStrength: 1,
        occlusionTexture: null,
        occlusionTextureInfo: new By(this.graph, "occlusionTextureInfo"),
        roughnessFactor: 1,
        metallicFactor: 1,
        metallicRoughnessTexture: null,
        metallicRoughnessTextureInfo: new By(this.graph, "metallicRoughnessTextureInfo")
      });
    }

    getDoubleSided() {
      return this.get("doubleSided");
    }

    setDoubleSided(e) {
      return this.set("doubleSided", e);
    }

    getAlpha() {
      return this.get("baseColorFactor")[3];
    }

    setAlpha(e) {
      const t = this.get("baseColorFactor").slice();
      return t[3] = e, this.set("baseColorFactor", t);
    }

    getAlphaMode() {
      return this.get("alphaMode");
    }

    setAlphaMode(e) {
      return this.set("alphaMode", e);
    }

    getAlphaCutoff() {
      return this.get("alphaCutoff");
    }

    setAlphaCutoff(e) {
      return this.set("alphaCutoff", e);
    }

    getBaseColorFactor() {
      return this.get("baseColorFactor");
    }

    setBaseColorFactor(e) {
      return this.set("baseColorFactor", e);
    }

    getBaseColorHex() {
      return uy.factorToHex(this.get("baseColorFactor"));
    }

    setBaseColorHex(e) {
      const t = this.get("baseColorFactor").slice();
      return this.set("baseColorFactor", uy.hexToFactor(e, t));
    }

    getBaseColorTexture() {
      return this.getRef("baseColorTexture");
    }

    getBaseColorTextureInfo() {
      return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
    }

    setBaseColorTexture(e) {
      return this.setRef("baseColorTexture", e, {
        channels: jy | zy | Vy | Gy
      });
    }

    getEmissiveFactor() {
      return this.get("emissiveFactor");
    }

    setEmissiveFactor(e) {
      return this.set("emissiveFactor", e);
    }

    getEmissiveHex() {
      return uy.factorToHex(this.get("emissiveFactor"));
    }

    setEmissiveHex(e) {
      const t = this.get("emissiveFactor").slice();
      return this.set("emissiveFactor", uy.hexToFactor(e, t));
    }

    getEmissiveTexture() {
      return this.getRef("emissiveTexture");
    }

    getEmissiveTextureInfo() {
      return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
    }

    setEmissiveTexture(e) {
      return this.setRef("emissiveTexture", e, {
        channels: jy | zy | Vy
      });
    }

    getNormalScale() {
      return this.get("normalScale");
    }

    setNormalScale(e) {
      return this.set("normalScale", e);
    }

    getNormalTexture() {
      return this.getRef("normalTexture");
    }

    getNormalTextureInfo() {
      return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
    }

    setNormalTexture(e) {
      return this.setRef("normalTexture", e, {
        channels: jy | zy | Vy
      });
    }

    getOcclusionStrength() {
      return this.get("occlusionStrength");
    }

    setOcclusionStrength(e) {
      return this.set("occlusionStrength", e);
    }

    getOcclusionTexture() {
      return this.getRef("occlusionTexture");
    }

    getOcclusionTextureInfo() {
      return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
    }

    setOcclusionTexture(e) {
      return this.setRef("occlusionTexture", e, {
        channels: jy
      });
    }

    getRoughnessFactor() {
      return this.get("roughnessFactor");
    }

    setRoughnessFactor(e) {
      return this.set("roughnessFactor", e);
    }

    getMetallicFactor() {
      return this.get("metallicFactor");
    }

    setMetallicFactor(e) {
      return this.set("metallicFactor", e);
    }

    getMetallicRoughnessTexture() {
      return this.getRef("metallicRoughnessTexture");
    }

    getMetallicRoughnessTextureInfo() {
      return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
    }

    setMetallicRoughnessTexture(e) {
      return this.setRef("metallicRoughnessTexture", e, {
        channels: zy | Vy
      });
    }

  }

  Hy.AlphaMode = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };

  class Wy extends Py {
    init() {
      this.propertyType = $x.MESH;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        weights: [],
        primitives: []
      });
    }

    addPrimitive(e) {
      return this.addRef("primitives", e);
    }

    removePrimitive(e) {
      return this.removeRef("primitives", e);
    }

    listPrimitives() {
      return this.listRefs("primitives");
    }

    getWeights() {
      return this.get("weights");
    }

    setWeights(e) {
      return this.set("weights", e);
    }

  }

  class Ky extends Py {
    constructor(...e) {
      super(...e), this.u = null;
    }

    init() {
      this.propertyType = $x.NODE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        translation: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scale: [1, 1, 1],
        weights: [],
        camera: null,
        mesh: null,
        skin: null,
        children: []
      });
    }

    copy(e, t = Ry) {
      if (t === Ry) throw new Error("Node cannot be copied.");
      return super.copy(e, t);
    }

    getTranslation() {
      return this.get("translation");
    }

    getRotation() {
      return this.get("rotation");
    }

    getScale() {
      return this.get("scale");
    }

    setTranslation(e) {
      return this.set("translation", e);
    }

    setRotation(e) {
      return this.set("rotation", e);
    }

    setScale(e) {
      return this.set("scale", e);
    }

    getMatrix() {
      return vy.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
    }

    setMatrix(e) {
      const t = this.get("translation").slice(),
            n = this.get("rotation").slice(),
            r = this.get("scale").slice();
      return vy.decompose(e, t, n, r), this.set("translation", t).set("rotation", n).set("scale", r);
    }

    getWorldTranslation() {
      const e = [0, 0, 0];
      return vy.decompose(this.getWorldMatrix(), e, [0, 0, 0, 1], [1, 1, 1]), e;
    }

    getWorldRotation() {
      const e = [0, 0, 0, 1];
      return vy.decompose(this.getWorldMatrix(), [0, 0, 0], e, [1, 1, 1]), e;
    }

    getWorldScale() {
      const e = [1, 1, 1];
      return vy.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e), e;
    }

    getWorldMatrix() {
      const e = [];

      for (let t = this; t instanceof Ky; t = t.u) e.push(t);

      let t;
      const n = e.pop().getMatrix();

      for (; t = e.pop();) oy(n, n, t.getMatrix());

      return n;
    }

    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[qx].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }

    removeChild(e) {
      return this.removeRef("children", e);
    }

    listChildren() {
      return this.listRefs("children");
    }

    getParent() {
      return this.u;
    }

    getMesh() {
      return this.getRef("mesh");
    }

    setMesh(e) {
      return this.setRef("mesh", e);
    }

    getCamera() {
      return this.getRef("camera");
    }

    setCamera(e) {
      return this.setRef("camera", e);
    }

    getSkin() {
      return this.getRef("skin");
    }

    setSkin(e) {
      return this.setRef("skin", e);
    }

    getWeights() {
      return this.get("weights");
    }

    setWeights(e) {
      return this.set("weights", e);
    }

    traverse(e) {
      e(this);

      for (const t of this.listChildren()) t.traverse(e);

      return this;
    }

  }

  class Xy extends Py {
    init() {
      this.propertyType = $x.PRIMITIVE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mode: Xy.Mode.TRIANGLES,
        material: null,
        indices: null,
        attributes: {},
        targets: []
      });
    }

    getIndices() {
      return this.getRef("indices");
    }

    setIndices(e) {
      return this.setRef("indices", e, {
        usage: ey.ELEMENT_ARRAY_BUFFER
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: ey.ARRAY_BUFFER
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

    getMaterial() {
      return this.getRef("material");
    }

    setMaterial(e) {
      return this.setRef("material", e);
    }

    getMode() {
      return this.get("mode");
    }

    setMode(e) {
      return this.set("mode", e);
    }

    listTargets() {
      return this.listRefs("targets");
    }

    addTarget(e) {
      return this.addRef("targets", e);
    }

    removeTarget(e) {
      return this.removeRef("targets", e);
    }

  }

  Xy.Mode = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };

  class qy extends ky {
    init() {
      this.propertyType = $x.PRIMITIVE_TARGET;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: ey.ARRAY_BUFFER
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

  }

  function Yy() {
    return (Yy = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  class Zy extends Py {
    init() {
      this.propertyType = $x.SCENE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        children: []
      });
    }

    copy(e, t = Ry) {
      if (t === Ry) throw new Error("Scene cannot be copied.");
      return super.copy(e, t);
    }

    addChild(e) {
      e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
      const t = this[qx].children;
      return t[t.length - 1].addEventListener("dispose", () => e.u = null), this;
    }

    removeChild(e) {
      return this.removeRef("children", e);
    }

    listChildren() {
      return this.listRefs("children");
    }

    traverse(e) {
      for (const t of this.listChildren()) t.traverse(e);

      return this;
    }

  }

  class Jy extends Py {
    init() {
      this.propertyType = $x.SKIN;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        skeleton: null,
        inverseBindMatrices: null,
        joints: []
      });
    }

    getSkeleton() {
      return this.getRef("skeleton");
    }

    setSkeleton(e) {
      return this.setRef("skeleton", e);
    }

    getInverseBindMatrices() {
      return this.getRef("inverseBindMatrices");
    }

    setInverseBindMatrices(e) {
      return this.setRef("inverseBindMatrices", e, {
        usage: ey.INVERSE_BIND_MATRICES
      });
    }

    addJoint(e) {
      return this.addRef("joints", e);
    }

    removeJoint(e) {
      return this.removeRef("joints", e);
    }

    listJoints() {
      return this.listRefs("joints");
    }

  }

  class $y extends Py {
    init() {
      this.propertyType = $x.TEXTURE;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        image: null,
        mimeType: "",
        uri: ""
      });
    }

    getMimeType() {
      return this.get("mimeType") || hy.extensionToMimeType(fy.extension(this.get("uri")));
    }

    setMimeType(e) {
      return this.set("mimeType", e);
    }

    getURI() {
      return this.get("uri");
    }

    setURI(e) {
      return this.set("uri", e), this.set("mimeType", hy.extensionToMimeType(fy.extension(e))), this;
    }

    getImage() {
      return this.get("image");
    }

    setImage(e) {
      return this.set("image", cy.assertView(e));
    }

    getSize() {
      const e = this.get("image");
      return e ? hy.getSize(e, this.getMimeType()) : null;
    }

  }

  class Qy extends Py {
    init() {
      this.propertyType = $x.ROOT;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        asset: {
          generator: "glTF-Transform v2.2.0",
          version: "2.0"
        },
        defaultScene: null,
        accessors: [],
        animations: [],
        buffers: [],
        cameras: [],
        materials: [],
        meshes: [],
        nodes: [],
        scenes: [],
        skins: [],
        textures: []
      });
    }

    constructor(e) {
      super(e), this.h = new Set(), e.addEventListener("node:create", e => {
        this.l(e.target);
      });
    }

    clone() {
      throw new Error("Root cannot be cloned.");
    }

    copy(e, t = Ry) {
      if (t === Ry) throw new Error("Root cannot be copied.");
      this.set("asset", Yy({}, e.get("asset"))), this.setName(e.getName()), this.setExtras(Yy({}, e.getExtras())), this.setDefaultScene(e.getDefaultScene() ? t(e.getDefaultScene()) : null);

      for (const n of e.listRefMapKeys("extensions")) {
        const r = e.getExtension(n);
        this.setExtension(n, t(r));
      }

      return this;
    }

    l(e) {
      return e instanceof Zy ? this.addRef("scenes", e) : e instanceof Ky ? this.addRef("nodes", e) : e instanceof Ny ? this.addRef("cameras", e) : e instanceof Jy ? this.addRef("skins", e) : e instanceof Wy ? this.addRef("meshes", e) : e instanceof Hy ? this.addRef("materials", e) : e instanceof $y ? this.addRef("textures", e) : e instanceof Oy ? this.addRef("animations", e) : e instanceof Dy ? this.addRef("accessors", e) : e instanceof Fy && this.addRef("buffers", e), this;
    }

    getAsset() {
      return this.get("asset");
    }

    listExtensionsUsed() {
      return Array.from(this.h);
    }

    listExtensionsRequired() {
      return this.listExtensionsUsed().filter(e => e.isRequired());
    }

    g(e) {
      return this.h.add(e), this;
    }

    p(e) {
      return this.h.delete(e), this;
    }

    listScenes() {
      return this.listRefs("scenes");
    }

    setDefaultScene(e) {
      return this.setRef("defaultScene", e);
    }

    getDefaultScene() {
      return this.getRef("defaultScene");
    }

    listNodes() {
      return this.listRefs("nodes");
    }

    listCameras() {
      return this.listRefs("cameras");
    }

    listSkins() {
      return this.listRefs("skins");
    }

    listMeshes() {
      return this.listRefs("meshes");
    }

    listMaterials() {
      return this.listRefs("materials");
    }

    listTextures() {
      return this.listRefs("textures");
    }

    listAnimations() {
      return this.listRefs("animations");
    }

    listAccessors() {
      return this.listRefs("accessors");
    }

    listBuffers() {
      return this.listRefs("buffers");
    }

  }

  class ew {
    constructor() {
      this.m = new Gx(), this.T = new Qy(this.m), this.v = gy.DEFAULT_INSTANCE;
    }

    getRoot() {
      return this.T;
    }

    getGraph() {
      return this.m;
    }

    getLogger() {
      return this.v;
    }

    setLogger(e) {
      return this.v = e, this;
    }

    clone() {
      return new ew().setLogger(this.v).merge(this);
    }

    merge(e) {
      for (const t of e.getRoot().listExtensionsUsed()) {
        const e = this.createExtension(t.constructor);
        t.isRequired() && e.setRequired(!0);
      }

      const t = new Set(),
            n = new Map();
      t.add(e.T), n.set(e.T, this.T);

      for (const r of e.m.listEdges()) for (const e of [r.getParent(), r.getChild()]) {
        if (t.has(e)) continue;
        let r;
        r = e.propertyType === $x.TEXTURE_INFO ? e : new (0, e.constructor)(this.m), n.set(e, r), t.add(e);
      }

      const r = e => {
        const t = n.get(e);
        if (!t) throw new Error("Could resolve property.");
        return t;
      };

      for (const e of t) {
        const t = n.get(e);
        if (!t) throw new Error("Could resolve property.");
        t.propertyType !== $x.TEXTURE_INFO && t.copy(e, r);
      }

      return this;
    }

    async transform(...e) {
      const t = e.map(e => e.name);

      for (const n of e) await n(this, {
        stack: t
      });

      return this;
    }

    createExtension(e) {
      const t = e.EXTENSION_NAME;
      return this.getRoot().listExtensionsUsed().find(e => e.extensionName === t) || new e(this);
    }

    createScene(e = "") {
      return new Zy(this.m, e);
    }

    createNode(e = "") {
      return new Ky(this.m, e);
    }

    createCamera(e = "") {
      return new Ny(this.m, e);
    }

    createSkin(e = "") {
      return new Jy(this.m, e);
    }

    createMesh(e = "") {
      return new Wy(this.m, e);
    }

    createPrimitive() {
      return new Xy(this.m);
    }

    createPrimitiveTarget(e = "") {
      return new qy(this.m, e);
    }

    createMaterial(e = "") {
      return new Hy(this.m, e);
    }

    createTexture(e = "") {
      return new $y(this.m, e);
    }

    createAnimation(e = "") {
      return new Oy(this.m, e);
    }

    createAnimationChannel(e = "") {
      return new Ly(this.m, e);
    }

    createAnimationSampler(e = "") {
      return new Iy(this.m, e);
    }

    createAccessor(e = "", t = null) {
      return t || (t = this.getRoot().listBuffers()[0]), new Dy(this.m, e).setBuffer(t);
    }

    createBuffer(e = "") {
      return new Fy(this.m, e);
    }

  }

  class tw {
    constructor(e) {
      this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = !1, this.properties = new Set(), this.S = void 0, this.document = e, e.getRoot().g(this), this.S = e => {
        const t = e,
              n = t.target;
        n instanceof Uy && n.extensionName === this.extensionName && ("node:create" === t.type && this.M(n), "node:dispose" === t.type && this.I(n));
      };
      const t = e.getGraph();
      t.addEventListener("node:create", this.S), t.addEventListener("node:dispose", this.S);
    }

    dispose() {
      this.document.getRoot().p(this);
      const e = this.document.getGraph();
      e.removeEventListener("node:create", this.S), e.removeEventListener("node:dispose", this.S);

      for (const e of this.properties) e.dispose();
    }

    static register() {}

    isRequired() {
      return this.required;
    }

    setRequired(e) {
      return this.required = e, this;
    }

    M(e) {
      return this.properties.add(e), this;
    }

    I(e) {
      return this.properties.delete(e), this;
    }

    install(e, t) {
      return this;
    }

    preread(e, t) {
      return this;
    }

    prewrite(e, t) {
      return this;
    }

  }

  tw.EXTENSION_NAME = void 0;

  class nw {
    constructor(e) {
      this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = new Map(), this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e;
    }

    setTextureInfo(e, t) {
      this.textureInfos.set(e, t), void 0 !== t.texCoord && e.setTexCoord(t.texCoord);
      const n = this.jsonDoc.json.textures[t.index];
      if (void 0 === n.sampler) return;
      const r = this.jsonDoc.json.samplers[n.sampler];
      void 0 !== r.magFilter && e.setMagFilter(r.magFilter), void 0 !== r.minFilter && e.setMinFilter(r.minFilter), void 0 !== r.wrapS && e.setWrapS(r.wrapS), void 0 !== r.wrapT && e.setWrapT(r.wrapT);
    }

  }

  const rw = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
        iw = {
    logger: gy.DEFAULT_INSTANCE,
    extensions: [],
    dependencies: {}
  };

  function sw(e, t) {
    const n = t.bufferViews[e.bufferView],
          r = t.jsonDoc.json.bufferViews[e.bufferView],
          i = rw[e.componentType],
          s = Dy.getElementSize(e.type),
          o = i.BYTES_PER_ELEMENT;
    if (void 0 !== r.byteStride && r.byteStride !== s * o) return function (e, t) {
      const n = t.bufferViews[e.bufferView],
            r = t.jsonDoc.json.bufferViews[e.bufferView],
            i = rw[e.componentType],
            s = Dy.getElementSize(e.type),
            o = i.BYTES_PER_ELEMENT,
            a = e.byteOffset || 0,
            l = new i(e.count * s),
            c = new DataView(n.buffer, n.byteOffset, n.byteLength),
            u = r.byteStride;

      for (let t = 0; t < e.count; t++) for (let n = 0; n < s; n++) {
        const r = a + t * u + n * o;
        let i;

        switch (e.componentType) {
          case Dy.ComponentType.FLOAT:
            i = c.getFloat32(r, !0);
            break;

          case Dy.ComponentType.UNSIGNED_INT:
            i = c.getUint32(r, !0);
            break;

          case Dy.ComponentType.UNSIGNED_SHORT:
            i = c.getUint16(r, !0);
            break;

          case Dy.ComponentType.UNSIGNED_BYTE:
            i = c.getUint8(r);
            break;

          case Dy.ComponentType.SHORT:
            i = c.getInt16(r, !0);
            break;

          case Dy.ComponentType.BYTE:
            i = c.getInt8(r);
            break;

          default:
            throw new Error(`Unexpected componentType "${e.componentType}".`);
        }

        l[t * s + n] = i;
      }

      return l;
    }(e, t);
    const a = n.byteOffset + (e.byteOffset || 0);
    return new i(n.buffer.slice(a, a + e.count * s * o));
  }

  var ow;
  !function (e) {
    e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(ow || (ow = {}));

  class aw {
    constructor(e, t, n) {
      this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = new Map(), this.animationIndexMap = new Map(), this.bufferIndexMap = new Map(), this.cameraIndexMap = new Map(), this.skinIndexMap = new Map(), this.materialIndexMap = new Map(), this.meshIndexMap = new Map(), this.nodeIndexMap = new Map(), this.imageIndexMap = new Map(), this.textureDefIndexMap = new Map(), this.textureInfoDefMap = new Map(), this.samplerDefIndexMap = new Map(), this.sceneIndexMap = new Map(), this.imageBufferViews = [], this.otherBufferViews = new Map(), this.otherBufferViewsIndexMap = new Map(), this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = new Map(), this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]), this.accessorParents = new Map(), this.N = e, this.jsonDoc = t, this.options = n;
      const r = e.getRoot(),
            i = r.listBuffers().length,
            s = r.listTextures().length;
      this.bufferURIGenerator = new lw(i > 1, n.basename), this.imageURIGenerator = new lw(s > 1, n.basename), this.logger = e.getLogger();
    }

    createTextureInfoDef(e, t) {
      const n = {
        magFilter: t.getMagFilter() || void 0,
        minFilter: t.getMinFilter() || void 0,
        wrapS: t.getWrapS(),
        wrapT: t.getWrapT()
      },
            r = JSON.stringify(n);
      this.samplerDefIndexMap.has(r) || (this.samplerDefIndexMap.set(r, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(n));
      const i = {
        source: this.imageIndexMap.get(e),
        sampler: this.samplerDefIndexMap.get(r)
      },
            s = JSON.stringify(i);
      this.textureDefIndexMap.has(s) || (this.textureDefIndexMap.set(s, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i));
      const o = {
        index: this.textureDefIndexMap.get(s)
      };
      return 0 !== t.getTexCoord() && (o.texCoord = t.getTexCoord()), this.textureInfoDefMap.set(t, o), o;
    }

    createPropertyDef(e) {
      const t = {};
      return e.getName() && (t.name = e.getName()), Object.keys(e.getExtras()).length > 0 && (t.extras = e.getExtras()), t;
    }

    createAccessorDef(e) {
      const t = this.createPropertyDef(e);
      return t.type = e.getType(), t.componentType = e.getComponentType(), t.count = e.getCount(), this.N.getGraph().listParentEdges(e).some(e => "attributes" === e.getName() && "POSITION" === e.getAttributes().key || "input" === e.getName()) && (t.max = e.getMax([]).map(Math.fround), t.min = e.getMin([]).map(Math.fround)), e.getNormalized() && (t.normalized = e.getNormalized()), t;
    }

    createImageData(e, t, n) {
      if (this.options.format === ny.GLB) this.imageBufferViews.push(t), e.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({
        buffer: 0,
        byteOffset: -1,
        byteLength: t.byteLength
      });else {
        const r = hy.mimeTypeToExtension(n.getMimeType());
        e.uri = this.imageURIGenerator.createURI(n, r), this.jsonDoc.resources[e.uri] = t;
      }
    }

    getAccessorUsage(e) {
      const t = this.O.get(e);
      if (t) return t;

      for (const t of this.N.getGraph().listParentEdges(e)) {
        const {
          usage: e
        } = t.getAttributes();
        if (e) return e;
        t.getParent().propertyType !== $x.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t.getName()}".`);
      }

      return aw.BufferViewUsage.OTHER;
    }

    addAccessorToUsageGroup(e, t) {
      const n = this.O.get(e);
      if (n && n !== t) throw new Error(`Accessor with usage "${n}" cannot be reused as "${t}".`);
      return this.O.set(e, t), this;
    }

    listAccessorUsageGroups() {
      const e = {};

      for (const [t, n] of Array.from(this.O.entries())) e[n] = e[n] || [], e[n].push(t);

      return e;
    }

  }

  aw.BufferViewTarget = ow, aw.BufferViewUsage = ey, aw.USAGE_TO_TARGET = {
    [ey.ARRAY_BUFFER]: ow.ARRAY_BUFFER,
    [ey.ELEMENT_ARRAY_BUFFER]: ow.ELEMENT_ARRAY_BUFFER
  };

  class lw {
    constructor(e, t) {
      this.multiple = void 0, this.basename = void 0, this.counter = 1, this.multiple = e, this.basename = t;
    }

    createURI(e, t) {
      return e.getURI() ? e.getURI() : this.multiple ? `${this.basename}_${this.counter++}.${t}` : `${this.basename}.${t}`;
    }

  }

  const {
    BufferViewUsage: cw
  } = aw;
  var uw;
  !function (e) {
    e[e.JSON = 1313821514] = "JSON", e[e.BIN = 5130562] = "BIN";
  }(uw || (uw = {}));

  class pw extends class {
    constructor() {
      this.v = gy.DEFAULT_INSTANCE, this.h = new Set(), this.C = {}, this.F = Qx.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0;
    }

    setLogger(e) {
      return this.v = e, this;
    }

    registerExtensions(e) {
      for (const t of e) this.h.add(t), t.register();

      return this;
    }

    registerDependencies(e) {
      return Object.assign(this.C, e), this;
    }

    setVertexLayout(e) {
      return this.F = e, this;
    }

    async read(e) {
      return await this.readJSON(await this.readAsJSON(e));
    }

    async readAsJSON(e) {
      return e.match(/^data:application\/octet-stream;/) || this.detectFormat(e) === ny.GLB ? this.U(e) : this.P(e);
    }

    async readJSON(e) {
      return e = this.j(e), this.L(e), class {
        static read(e, t = iw) {
          const n = Yy({}, iw, t),
                {
            json: r
          } = e,
                i = new ew();
          this.validate(e, n);
          const s = new nw(e),
                o = r.asset,
                a = i.getRoot().getAsset();
          o.copyright && (a.copyright = o.copyright), o.extras && (a.extras = o.extras), void 0 !== r.extras && i.getRoot().setExtras(Yy({}, r.extras));
          const l = r.extensionsUsed || [],
                c = r.extensionsRequired || [];

          for (const e of n.extensions) if (l.includes(e.EXTENSION_NAME)) {
            const t = i.createExtension(e).setRequired(c.includes(e.EXTENSION_NAME));

            for (const e of t.readDependencies) t.install(e, n.dependencies[e]);
          }

          const u = r.buffers || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes($x.BUFFER)).forEach(e => e.preread(s, $x.BUFFER)), s.buffers = u.map(e => {
            const t = i.createBuffer(e.name);
            return e.extras && t.setExtras(e.extras), e.uri && 0 !== e.uri.indexOf("__") && t.setURI(e.uri), t;
          }), s.bufferViewBuffers = (r.bufferViews || []).map((t, n) => {
            if (!s.bufferViews[n]) {
              const r = e.json.buffers[t.buffer];
              s.bufferViews[n] = cy.toView(r.uri ? e.resources[r.uri] : e.resources["@glb.bin"], t.byteOffset || 0, t.byteLength);
            }

            return s.buffers[t.buffer];
          }), s.accessors = (r.accessors || []).map(e => {
            const t = i.createAccessor(e.name, s.bufferViewBuffers[e.bufferView]).setType(e.type);
            if (e.extras && t.setExtras(e.extras), void 0 !== e.normalized && t.setNormalized(e.normalized), void 0 === e.bufferView && !e.sparse) return t;
            let n;
            return n = void 0 !== e.sparse ? function (e, t) {
              const n = rw[e.componentType],
                    r = Dy.getElementSize(e.type);
              let i;
              i = void 0 !== e.bufferView ? sw(e, t) : new n(e.count * r);
              const s = e.sparse,
                    o = s.count,
                    a = Yy({}, e, s.indices, {
                count: o,
                type: "SCALAR"
              }),
                    l = Yy({}, e, s.values, {
                count: o
              }),
                    c = sw(a, t),
                    u = sw(l, t);

              for (let e = 0; e < a.count; e++) for (let t = 0; t < r; t++) i[c[e] * r + t] = u[e * r + t];

              return i;
            }(e, s) : sw(e, s), t.setArray(n), t;
          });
          const p = r.images || [],
                h = r.textures || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes($x.TEXTURE)).forEach(e => e.preread(s, $x.TEXTURE)), s.textures = p.map(t => {
            const n = i.createTexture(t.name);

            if (t.extras && n.setExtras(t.extras), void 0 !== t.bufferView) {
              const i = r.bufferViews[t.bufferView],
                    s = e.json.buffers[i.buffer],
                    o = i.byteOffset || 0,
                    a = (s.uri ? e.resources[s.uri] : e.resources["@glb.bin"]).slice(o, o + i.byteLength);
              n.setImage(a);
            } else void 0 !== t.uri && (n.setImage(e.resources[t.uri]), 0 !== t.uri.indexOf("__") && n.setURI(t.uri));

            if (void 0 !== t.mimeType) n.setMimeType(t.mimeType);else if (t.uri) {
              const e = fy.extension(t.uri);
              n.setMimeType(hy.extensionToMimeType(e));
            }
            return n;
          }), s.materials = (r.materials || []).map(e => {
            const t = i.createMaterial(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.alphaMode && t.setAlphaMode(e.alphaMode), void 0 !== e.alphaCutoff && t.setAlphaCutoff(e.alphaCutoff), void 0 !== e.doubleSided && t.setDoubleSided(e.doubleSided);
            const n = e.pbrMetallicRoughness || {};

            if (void 0 !== n.baseColorFactor && t.setBaseColorFactor(n.baseColorFactor), void 0 !== e.emissiveFactor && t.setEmissiveFactor(e.emissiveFactor), void 0 !== n.metallicFactor && t.setMetallicFactor(n.metallicFactor), void 0 !== n.roughnessFactor && t.setRoughnessFactor(n.roughnessFactor), void 0 !== n.baseColorTexture) {
              const e = n.baseColorTexture;
              t.setBaseColorTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getBaseColorTextureInfo(), e);
            }

            if (void 0 !== e.emissiveTexture) {
              const n = e.emissiveTexture;
              t.setEmissiveTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getEmissiveTextureInfo(), n);
            }

            if (void 0 !== e.normalTexture) {
              const n = e.normalTexture;
              t.setNormalTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getNormalTextureInfo(), n), void 0 !== e.normalTexture.scale && t.setNormalScale(e.normalTexture.scale);
            }

            if (void 0 !== e.occlusionTexture) {
              const n = e.occlusionTexture;
              t.setOcclusionTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getOcclusionTextureInfo(), n), void 0 !== e.occlusionTexture.strength && t.setOcclusionStrength(e.occlusionTexture.strength);
            }

            if (void 0 !== n.metallicRoughnessTexture) {
              const e = n.metallicRoughnessTexture;
              t.setMetallicRoughnessTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getMetallicRoughnessTextureInfo(), e);
            }

            return t;
          });
          const d = r.meshes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes($x.PRIMITIVE)).forEach(e => e.preread(s, $x.PRIMITIVE)), s.meshes = d.map(e => {
            const t = i.createMesh(e.name);
            return e.extras && t.setExtras(e.extras), void 0 !== e.weights && t.setWeights(e.weights), (e.primitives || []).forEach(n => {
              const r = i.createPrimitive();
              n.extras && r.setExtras(n.extras), void 0 !== n.material && r.setMaterial(s.materials[n.material]), void 0 !== n.mode && r.setMode(n.mode);

              for (const [e, t] of Object.entries(n.attributes || {})) r.setAttribute(e, s.accessors[t]);

              void 0 !== n.indices && r.setIndices(s.accessors[n.indices]);
              const o = e.extras && e.extras.targetNames || [];
              (n.targets || []).forEach((e, t) => {
                const n = o[t] || t.toString(),
                      a = i.createPrimitiveTarget(n);

                for (const [t, n] of Object.entries(e)) a.setAttribute(t, s.accessors[n]);

                r.addTarget(a);
              }), t.addPrimitive(r);
            }), t;
          }), s.cameras = (r.cameras || []).map(e => {
            const t = i.createCamera(e.name).setType(e.type);

            if (e.extras && t.setExtras(e.extras), e.type === Ny.Type.PERSPECTIVE) {
              const n = e.perspective;
              t.setYFov(n.yfov), t.setZNear(n.znear), void 0 !== n.zfar && t.setZFar(n.zfar), void 0 !== n.aspectRatio && t.setAspectRatio(n.aspectRatio);
            } else {
              const n = e.orthographic;
              t.setZNear(n.znear).setZFar(n.zfar).setXMag(n.xmag).setYMag(n.ymag);
            }

            return t;
          });
          const f = r.nodes || [];
          i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes($x.NODE)).forEach(e => e.preread(s, $x.NODE)), s.nodes = f.map(e => {
            const t = i.createNode(e.name);

            if (e.extras && t.setExtras(e.extras), void 0 !== e.translation && t.setTranslation(e.translation), void 0 !== e.rotation && t.setRotation(e.rotation), void 0 !== e.scale && t.setScale(e.scale), void 0 !== e.matrix) {
              const n = [0, 0, 0],
                    r = [0, 0, 0, 1],
                    i = [1, 1, 1];
              vy.decompose(e.matrix, n, r, i), t.setTranslation(n), t.setRotation(r), t.setScale(i);
            }

            return void 0 !== e.weights && t.setWeights(e.weights), t;
          }), s.skins = (r.skins || []).map(e => {
            const t = i.createSkin(e.name);
            e.extras && t.setExtras(e.extras), void 0 !== e.inverseBindMatrices && t.setInverseBindMatrices(s.accessors[e.inverseBindMatrices]), void 0 !== e.skeleton && t.setSkeleton(s.nodes[e.skeleton]);

            for (const n of e.joints) t.addJoint(s.nodes[n]);

            return t;
          }), f.map((e, t) => {
            const n = s.nodes[t];
            (e.children || []).forEach(e => n.addChild(s.nodes[e])), void 0 !== e.mesh && n.setMesh(s.meshes[e.mesh]), void 0 !== e.camera && n.setCamera(s.cameras[e.camera]), void 0 !== e.skin && n.setSkin(s.skins[e.skin]);
          }), s.animations = (r.animations || []).map(e => {
            const t = i.createAnimation(e.name);
            e.extras && t.setExtras(e.extras);
            const n = (e.samplers || []).map(e => {
              const n = i.createAnimationSampler().setInput(s.accessors[e.input]).setOutput(s.accessors[e.output]).setInterpolation(e.interpolation || Iy.Interpolation.LINEAR);
              return e.extras && n.setExtras(e.extras), t.addSampler(n), n;
            });
            return (e.channels || []).forEach(e => {
              const r = i.createAnimationChannel().setSampler(n[e.sampler]).setTargetPath(e.target.path);
              void 0 !== e.target.node && r.setTargetNode(s.nodes[e.target.node]), e.extras && r.setExtras(e.extras), t.addChannel(r);
            }), t;
          });

          const _ = r.scenes || [];

          return i.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes($x.SCENE)).forEach(e => e.preread(s, $x.SCENE)), s.scenes = _.map(e => {
            const t = i.createScene(e.name);
            return e.extras && t.setExtras(e.extras), (e.nodes || []).map(e => s.nodes[e]).forEach(e => t.addChild(e)), t;
          }), void 0 !== r.scene && i.getRoot().setDefaultScene(s.scenes[r.scene]), i.getRoot().listExtensionsUsed().forEach(e => e.read(s)), i;
        }

        static validate(e, t) {
          const n = e.json;
          if ("2.0" !== n.asset.version) throw new Error(`Unsupported glTF version, "${n.asset.version}".`);
          if (n.extensionsRequired) for (const e of n.extensionsRequired) if (!t.extensions.find(t => t.EXTENSION_NAME === e)) throw new Error(`Missing required extension, "${e}".`);
          if (n.extensionsUsed) for (const e of n.extensionsUsed) t.extensions.find(t => t.EXTENSION_NAME === e) || t.logger.warn(`Missing optional extension, "${e}".`);
        }

      }.read(e, {
        extensions: Array.from(this.h),
        dependencies: this.C,
        logger: this.v
      });
    }

    async binaryToJSON(e) {
      const t = this._(cy.assertView(e));

      this.L(t);
      const n = t.json;
      if (n.buffers && n.buffers.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources);
      }(t, e))) throw new Error("Cannot resolve external buffers with binaryToJSON().");
      if (n.images && n.images.some(e => function (e, t) {
        return void 0 !== t.uri && !(t.uri in e.resources) && void 0 === t.bufferView;
      }(t, e))) throw new Error("Cannot resolve external images with binaryToJSON().");
      return t;
    }

    async readBinary(e) {
      return this.readJSON(await this.binaryToJSON(cy.assertView(e)));
    }

    async writeJSON(e, t = {}) {
      if (t.format === ny.GLB && e.getRoot().listBuffers().length > 1) throw new Error("GLB must have 0–1 buffers.");
      return class {
        static write(e, t) {
          const n = e.getRoot(),
                r = {
            asset: Yy({
              generator: "glTF-Transform v2.2.0"
            }, n.getAsset()),
            extras: Yy({}, n.getExtras())
          },
                i = {
            json: r,
            resources: {}
          },
                s = new aw(e, i, t),
                o = t.logger || gy.DEFAULT_INSTANCE,
                a = new Set(t.extensions.map(e => e.EXTENSION_NAME)),
                l = e.getRoot().listExtensionsUsed().filter(e => a.has(e.extensionName)),
                c = e.getRoot().listExtensionsRequired().filter(e => a.has(e.extensionName));
          l.length < e.getRoot().listExtensionsUsed().length && o.debug("Some extensions were not registered for I/O, and will not be written.");

          for (const e of l) for (const n of e.writeDependencies) e.install(n, t.dependencies[n]);

          function u(e, t, n, i) {
            const o = [];
            let a = 0;

            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = r.bufferViews.length;
              const n = t.getArray(),
                    i = cy.pad(cy.toView(n));
              e.byteOffset = a, a += i.byteLength, o.push(i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e);
            }

            const l = {
              buffer: t,
              byteOffset: n,
              byteLength: cy.concat(o).byteLength
            };
            return i && (l.target = i), r.bufferViews.push(l), {
              buffers: o,
              byteLength: a
            };
          }

          function p(e, t, n) {
            const i = e[0].getCount();
            let o = 0;

            for (const t of e) {
              const e = s.createAccessorDef(t);
              e.bufferView = r.bufferViews.length, e.byteOffset = o;
              const n = t.getElementSize(),
                    i = t.getComponentSize();
              o += cy.padNumber(n * i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e);
            }

            const a = i * o,
                  l = new ArrayBuffer(a),
                  c = new DataView(l);

            for (let t = 0; t < i; t++) {
              let n = 0;

              for (const r of e) {
                const e = r.getElementSize(),
                      i = r.getComponentSize(),
                      s = r.getComponentType(),
                      a = r.getArray();

                for (let r = 0; r < e; r++) {
                  const l = t * o + n + r * i,
                        u = a[t * e + r];

                  switch (s) {
                    case Dy.ComponentType.FLOAT:
                      c.setFloat32(l, u, !0);
                      break;

                    case Dy.ComponentType.BYTE:
                      c.setInt8(l, u);
                      break;

                    case Dy.ComponentType.SHORT:
                      c.setInt16(l, u, !0);
                      break;

                    case Dy.ComponentType.UNSIGNED_BYTE:
                      c.setUint8(l, u);
                      break;

                    case Dy.ComponentType.UNSIGNED_SHORT:
                      c.setUint16(l, u, !0);
                      break;

                    case Dy.ComponentType.UNSIGNED_INT:
                      c.setUint32(l, u, !0);
                      break;

                    default:
                      throw new Error("Unexpected component type: " + s);
                  }
                }

                n += cy.padNumber(e * i);
              }
            }

            return r.bufferViews.push({
              buffer: t,
              byteOffset: n,
              byteLength: a,
              byteStride: o,
              target: aw.BufferViewTarget.ARRAY_BUFFER
            }), {
              byteLength: a,
              buffers: [new Uint8Array(l)]
            };
          }

          const h = new Map();

          for (const t of e.getGraph().listEdges()) {
            if (t.getParent() === n) continue;
            const e = t.getChild();

            if (e instanceof Dy) {
              const n = h.get(e) || [];
              n.push(t), h.set(e, n);
            }
          }

          if (r.accessors = [], r.bufferViews = [], r.samplers = [], r.textures = [], r.images = n.listTextures().map((e, t) => {
            const n = s.createPropertyDef(e);
            e.getMimeType() && (n.mimeType = e.getMimeType());
            const r = e.getImage();
            return r && s.createImageData(n, r, e), s.imageIndexMap.set(e, t), n;
          }), l.filter(e => e.prewriteTypes.includes($x.ACCESSOR)).forEach(e => e.prewrite(s, $x.ACCESSOR)), n.listAccessors().forEach(e => {
            const t = s.accessorUsageGroupedByParent,
                  n = s.accessorParents;
            if (s.accessorIndexMap.has(e)) return;
            const r = h.get(e) || [],
                  i = s.getAccessorUsage(e);

            if (s.addAccessorToUsageGroup(e, i), t.has(i)) {
              const t = r[0].getParent(),
                    i = n.get(t) || new Set();
              i.add(e), n.set(t, i);
            }
          }), l.filter(e => e.prewriteTypes.includes($x.BUFFER)).forEach(e => e.prewrite(s, $x.BUFFER)), (n.listAccessors().length > 0 || n.listTextures().length > 0 || s.otherBufferViews.size > 0) && 0 === n.listBuffers().length) throw new Error("Buffer required for Document resources, but none was found.");
          r.buffers = [], n.listBuffers().forEach((e, n) => {
            const o = s.createPropertyDef(e),
                  a = s.accessorUsageGroupedByParent,
                  l = s.accessorParents,
                  c = e.listParents().filter(e => e instanceof Dy),
                  h = new Set(c),
                  d = [],
                  f = r.buffers.length;
            let _ = 0;
            const m = s.listAccessorUsageGroups();

            for (const e in m) if (a.has(e)) for (const n of Array.from(l.values())) {
              const r = Array.from(n).filter(e => h.has(e)).filter(t => s.getAccessorUsage(t) === e);
              if (r.length) if (e !== cw.ARRAY_BUFFER || t.vertexLayout === Qx.INTERLEAVED) {
                const t = e === cw.ARRAY_BUFFER ? p(r, f, _) : u(r, f, _);
                _ += t.byteLength, d.push(...t.buffers);
              } else for (const e of r) {
                const t = p([e], f, _);
                _ += t.byteLength, d.push(...t.buffers);
              }
            } else {
              const t = m[e].filter(e => h.has(e));
              if (!t.length) continue;
              const n = u(t, f, _, e === cw.ELEMENT_ARRAY_BUFFER ? aw.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
              _ += n.byteLength, d.push(...n.buffers);
            }

            if (s.imageBufferViews.length && 0 === n) for (let e = 0; e < s.imageBufferViews.length; e++) if (r.bufferViews[r.images[e].bufferView].byteOffset = _, _ += s.imageBufferViews[e].byteLength, d.push(s.imageBufferViews[e]), _ % 8) {
              const e = 8 - _ % 8;
              _ += e, d.push(new Uint8Array(e));
            }
            if (s.otherBufferViews.has(e)) for (const t of s.otherBufferViews.get(e)) r.bufferViews.push({
              buffer: f,
              byteOffset: _,
              byteLength: t.byteLength
            }), s.otherBufferViewsIndexMap.set(t, r.bufferViews.length - 1), _ += t.byteLength, d.push(t);

            if (_) {
              let n;
              t.format === ny.GLB ? n = "@glb.bin" : (n = s.bufferURIGenerator.createURI(e, "bin"), o.uri = n), o.byteLength = _, i.resources[n] = cy.concat(d);
            }

            r.buffers.push(o), s.bufferIndexMap.set(e, n);
          }), n.listAccessors().find(e => !e.getBuffer()) && o.warn("Skipped writing one or more Accessors: no Buffer assigned."), r.materials = n.listMaterials().map((e, t) => {
            const n = s.createPropertyDef(e);

            if (e.getAlphaMode() !== Hy.AlphaMode.OPAQUE && (n.alphaMode = e.getAlphaMode()), e.getAlphaMode() === Hy.AlphaMode.MASK && (n.alphaCutoff = e.getAlphaCutoff()), e.getDoubleSided() && (n.doubleSided = !0), n.pbrMetallicRoughness = {}, vy.eq(e.getBaseColorFactor(), [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = e.getBaseColorFactor()), vy.eq(e.getEmissiveFactor(), [0, 0, 0]) || (n.emissiveFactor = e.getEmissiveFactor()), 1 !== e.getRoughnessFactor() && (n.pbrMetallicRoughness.roughnessFactor = e.getRoughnessFactor()), 1 !== e.getMetallicFactor() && (n.pbrMetallicRoughness.metallicFactor = e.getMetallicFactor()), e.getBaseColorTexture()) {
              const t = e.getBaseColorTexture(),
                    r = e.getBaseColorTextureInfo();
              n.pbrMetallicRoughness.baseColorTexture = s.createTextureInfoDef(t, r);
            }

            if (e.getEmissiveTexture()) {
              const t = e.getEmissiveTexture(),
                    r = e.getEmissiveTextureInfo();
              n.emissiveTexture = s.createTextureInfoDef(t, r);
            }

            if (e.getNormalTexture()) {
              const t = e.getNormalTexture(),
                    r = e.getNormalTextureInfo(),
                    i = s.createTextureInfoDef(t, r);
              1 !== e.getNormalScale() && (i.scale = e.getNormalScale()), n.normalTexture = i;
            }

            if (e.getOcclusionTexture()) {
              const t = e.getOcclusionTexture(),
                    r = e.getOcclusionTextureInfo(),
                    i = s.createTextureInfoDef(t, r);
              1 !== e.getOcclusionStrength() && (i.strength = e.getOcclusionStrength()), n.occlusionTexture = i;
            }

            if (e.getMetallicRoughnessTexture()) {
              const t = e.getMetallicRoughnessTexture(),
                    r = e.getMetallicRoughnessTextureInfo();
              n.pbrMetallicRoughness.metallicRoughnessTexture = s.createTextureInfoDef(t, r);
            }

            return s.materialIndexMap.set(e, t), n;
          }), r.meshes = n.listMeshes().map((e, t) => {
            const n = s.createPropertyDef(e);
            let r = null;
            return n.primitives = e.listPrimitives().map(e => {
              const t = {
                attributes: {}
              };
              t.mode = e.getMode();
              const n = e.getMaterial();
              n && (t.material = s.materialIndexMap.get(n)), Object.keys(e.getExtras()).length && (t.extras = e.getExtras());
              const i = e.getIndices();
              i && (t.indices = s.accessorIndexMap.get(i));

              for (const n of e.listSemantics()) t.attributes[n] = s.accessorIndexMap.get(e.getAttribute(n));

              for (const n of e.listTargets()) {
                const e = {};

                for (const t of n.listSemantics()) e[t] = s.accessorIndexMap.get(n.getAttribute(t));

                t.targets = t.targets || [], t.targets.push(e);
              }

              return e.listTargets().length && !r && (r = e.listTargets().map(e => e.getName())), t;
            }), e.getWeights().length && (n.weights = e.getWeights()), r && (n.extras = n.extras || {}, n.extras.targetNames = r), s.meshIndexMap.set(e, t), n;
          }), r.cameras = n.listCameras().map((e, t) => {
            const n = s.createPropertyDef(e);

            if (n.type = e.getType(), n.type === Ny.Type.PERSPECTIVE) {
              n.perspective = {
                znear: e.getZNear(),
                zfar: e.getZFar(),
                yfov: e.getYFov()
              };
              const t = e.getAspectRatio();
              null !== t && (n.perspective.aspectRatio = t);
            } else n.orthographic = {
              znear: e.getZNear(),
              zfar: e.getZFar(),
              xmag: e.getXMag(),
              ymag: e.getYMag()
            };

            return s.cameraIndexMap.set(e, t), n;
          }), r.nodes = n.listNodes().map((e, t) => {
            const n = s.createPropertyDef(e);
            return vy.eq(e.getTranslation(), [0, 0, 0]) || (n.translation = e.getTranslation()), vy.eq(e.getRotation(), [0, 0, 0, 1]) || (n.rotation = e.getRotation()), vy.eq(e.getScale(), [1, 1, 1]) || (n.scale = e.getScale()), e.getWeights().length && (n.weights = e.getWeights()), s.nodeIndexMap.set(e, t), n;
          }), r.skins = n.listSkins().map((e, t) => {
            const n = s.createPropertyDef(e),
                  r = e.getInverseBindMatrices();
            r && (n.inverseBindMatrices = s.accessorIndexMap.get(r));
            const i = e.getSkeleton();
            return i && (n.skeleton = s.nodeIndexMap.get(i)), n.joints = e.listJoints().map(e => s.nodeIndexMap.get(e)), s.skinIndexMap.set(e, t), n;
          }), n.listNodes().forEach((e, t) => {
            const n = r.nodes[t],
                  i = e.getMesh();
            i && (n.mesh = s.meshIndexMap.get(i));
            const o = e.getCamera();
            o && (n.camera = s.cameraIndexMap.get(o));
            const a = e.getSkin();
            a && (n.skin = s.skinIndexMap.get(a)), e.listChildren().length > 0 && (n.children = e.listChildren().map(e => s.nodeIndexMap.get(e)));
          }), r.animations = n.listAnimations().map((e, t) => {
            const n = s.createPropertyDef(e),
                  r = new Map();
            return n.samplers = e.listSamplers().map((e, t) => {
              const n = s.createPropertyDef(e);
              return n.input = s.accessorIndexMap.get(e.getInput()), n.output = s.accessorIndexMap.get(e.getOutput()), n.interpolation = e.getInterpolation(), r.set(e, t), n;
            }), n.channels = e.listChannels().map(e => {
              const t = s.createPropertyDef(e);
              return t.sampler = r.get(e.getSampler()), t.target = {
                node: s.nodeIndexMap.get(e.getTargetNode()),
                path: e.getTargetPath()
              }, t;
            }), s.animationIndexMap.set(e, t), n;
          }), r.scenes = n.listScenes().map((e, t) => {
            const n = s.createPropertyDef(e);
            return n.nodes = e.listChildren().map(e => s.nodeIndexMap.get(e)), s.sceneIndexMap.set(e, t), n;
          });
          const d = n.getDefaultScene();
          return d && (r.scene = n.listScenes().indexOf(d)), r.extensionsUsed = l.map(e => e.extensionName), r.extensionsRequired = c.map(e => e.extensionName), l.forEach(e => e.write(s)), function (e) {
            const t = [];

            for (const n in e) {
              const r = e[n];
              (Array.isArray(r) && 0 === r.length || null === r || "" === r || r && "object" == typeof r && 0 === Object.keys(r).length) && t.push(n);
            }

            for (const n of t) delete e[n];
          }(r), i;
        }

      }.write(e, {
        format: t.format || ny.GLTF,
        basename: t.basename || "",
        logger: this.v,
        vertexLayout: this.F,
        dependencies: Yy({}, this.C),
        extensions: Array.from(this.h)
      });
    }

    async writeBinary(e) {
      const {
        json: t,
        resources: n
      } = await this.writeJSON(e, {
        format: ny.GLB
      }),
            r = new Uint32Array([1179937895, 2, 12]),
            i = JSON.stringify(t),
            s = cy.pad(cy.encodeText(i), 32),
            o = cy.toView(new Uint32Array([s.byteLength, 1313821514])),
            a = cy.concat([o, s]);
      r[r.length - 1] += a.byteLength;
      const l = Object.values(n)[0];
      if (!l || !l.byteLength) return cy.concat([cy.toView(r), a]);
      const c = cy.pad(l, 0),
            u = cy.toView(new Uint32Array([c.byteLength, 5130562])),
            p = cy.concat([u, c]);
      return r[r.length - 1] += p.byteLength, cy.concat([cy.toView(r), a, p]);
    }

    detectFormat(e) {
      return "glb" === (Cy.isAbsoluteURL(e) ? Cy.extension(e) : fy.extension(e)) ? ny.GLB : ny.GLTF;
    }

    async P(e) {
      this.lastReadBytes = 0;
      const t = await this.readURI(e, "text");
      this.lastReadBytes += t.length;
      const n = {
        json: JSON.parse(t),
        resources: {}
      };
      return await this.D(n, this.dirname(e)), this.L(n), n;
    }

    async U(e) {
      const t = await this.readURI(e, "view");
      this.lastReadBytes = t.byteLength;

      const n = this._(t);

      return await this.D(n, this.dirname(e)), this.L(n), n;
    }

    async D(e, t) {
      var n = this;
      const r = [...(e.json.images || []), ...(e.json.buffers || [])].map(async function (r) {
        const i = r.uri;
        if (!i || i.match(/data:/)) return Promise.resolve();
        e.resources[i] = await n.readURI(n.resolve(t, i), "view"), n.lastReadBytes += e.resources[i].byteLength;
      });
      await Promise.all(r);
    }

    L(e) {
      function t(t) {
        if (t.uri) if (t.uri in e.resources) cy.assertView(e.resources[t.uri]);else if (t.uri.match(/data:/)) {
          const n = `__${function () {
            for (let e = 0; e < 999; e++) {
              const e = Ay();
              if (!Ey.has(e)) return Ey.add(e), e;
            }

            return "";
          }()}.${fy.extension(t.uri)}`;
          e.resources[n] = cy.createBufferFromDataURI(t.uri), t.uri = n;
        }
      }

      (e.json.images || []).forEach(e => {
        if (void 0 === e.bufferView && void 0 === e.uri) throw new Error("Missing resource URI or buffer view.");
        t(e);
      }), (e.json.buffers || []).forEach(t);
    }

    j(e) {
      const {
        images: t,
        buffers: n
      } = e.json;
      return e = {
        json: Yy({}, e.json),
        resources: Yy({}, e.resources)
      }, t && (e.json.images = t.map(e => Yy({}, e))), n && (e.json.buffers = n.map(e => Yy({}, e))), e;
    }

    _(e) {
      const t = new Uint32Array(e.buffer, e.byteOffset, 3);
      if (1179937895 !== t[0]) throw new Error("Invalid glTF asset.");
      if (2 !== t[1]) throw new Error(`Unsupported glTF binary version, "${t[1]}".`);
      const n = new Uint32Array(e.buffer, e.byteOffset + 12, 2);
      if (n[1] !== uw.JSON) throw new Error("Missing required GLB JSON chunk.");
      const r = n[0],
            i = cy.decodeText(cy.toView(e, 20, r)),
            s = JSON.parse(i),
            o = 20 + r;
      if (e.byteLength <= o) return {
        json: s,
        resources: {}
      };
      const a = new Uint32Array(e.buffer, e.byteOffset + o, 2);
      if (a[1] !== uw.BIN) throw new Error("Expected GLB BIN in second chunk.");
      return {
        json: s,
        resources: {
          "@glb.bin": cy.toView(e, o + 8, a[0])
        }
      };
    }

  } {
    constructor(e = Cy.DEFAULT_INIT) {
      super(), this.V = void 0, this.V = e;
    }

    async readURI(e, t) {
      const n = await fetch(e, this.V);

      switch (t) {
        case "view":
          return new Uint8Array(await n.arrayBuffer());

        case "text":
          return n.text();
      }
    }

    resolve(e, t) {
      return Cy.resolve(e, t);
    }

    dirname(e) {
      return Cy.dirname(e);
    }

    detectFormat(e) {
      return "glb" === Cy.extension(e) ? ny.GLB : ny.GLTF;
    }

  }

  class hw {
    constructor() {
      this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
        vendorId: 0,
        descriptorType: 0,
        descriptorBlockSize: 0,
        versionNumber: 2,
        colorModel: 0,
        colorPrimaries: 1,
        transferFunction: 2,
        flags: 0,
        texelBlockDimension: [0, 0, 0, 0],
        bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
        samples: []
      }], this.keyValue = {}, this.globalData = null;
    }

  }

  class dw {
    constructor(e, t, n, r) {
      this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0;
    }

    _nextUint8() {
      const e = this._dataView.getUint8(this._offset);

      return this._offset += 1, e;
    }

    _nextUint16() {
      const e = this._dataView.getUint16(this._offset, this._littleEndian);

      return this._offset += 2, e;
    }

    _nextUint32() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _nextUint64() {
      const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);

      return this._offset += 8, e;
    }

    _nextInt32() {
      const e = this._dataView.getInt32(this._offset, this._littleEndian);

      return this._offset += 4, e;
    }

    _skip(e) {
      return this._offset += e, this;
    }

    _scan(e, t = 0) {
      const n = this._offset;
      let r = 0;

      for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;

      return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r);
    }

  }

  new Uint8Array([0]);
  const fw = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

  function _w(e) {
    return "undefined" != typeof TextDecoder ? new TextDecoder().decode(e) : Buffer.from(e).toString("utf8");
  }

  function mw(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, fw.length);
    if (t[0] !== fw[0] || t[1] !== fw[1] || t[2] !== fw[2] || t[3] !== fw[3] || t[4] !== fw[4] || t[5] !== fw[5] || t[6] !== fw[6] || t[7] !== fw[7] || t[8] !== fw[8] || t[9] !== fw[9] || t[10] !== fw[10] || t[11] !== fw[11]) throw new Error("Missing KTX 2.0 identifier.");
    const n = new hw(),
          r = 17 * Uint32Array.BYTES_PER_ELEMENT,
          i = new dw(e, fw.length, r, !0);
    n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();

    const s = i._nextUint32();

    n.supercompressionScheme = i._nextUint32();

    const o = i._nextUint32(),
          a = i._nextUint32(),
          l = i._nextUint32(),
          c = i._nextUint32(),
          u = i._nextUint64(),
          p = i._nextUint64(),
          h = new dw(e, fw.length + r, 3 * s * 8, !0);

    for (let t = 0; t < s; t++) n.levels.push({
      levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
      uncompressedByteLength: h._nextUint64()
    });

    const d = new dw(e, o, a, !0),
          f = {
      vendorId: d._skip(4)._nextUint16(),
      descriptorType: d._nextUint16(),
      versionNumber: d._nextUint16(),
      descriptorBlockSize: d._nextUint16(),
      colorModel: d._nextUint8(),
      colorPrimaries: d._nextUint8(),
      transferFunction: d._nextUint8(),
      flags: d._nextUint8(),
      texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
      samples: []
    },
          _ = (f.descriptorBlockSize / 4 - 6) / 4;

    for (let e = 0; e < _; e++) {
      const t = {
        bitOffset: d._nextUint16(),
        bitLength: d._nextUint8(),
        channelType: d._nextUint8(),
        samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
        sampleLower: -1 / 0,
        sampleUpper: 1 / 0
      };
      64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t;
    }

    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
    const m = new dw(e, l, c, !0);

    for (; m._offset < c;) {
      const e = m._nextUint32(),
            t = m._scan(e),
            r = _w(t),
            i = m._scan(e - t.byteLength);

      n.keyValue[r] = r.match(/^ktx/i) ? _w(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4);
    }

    if (p <= 0) return n;

    const g = new dw(e, u, p, !0),
          v = g._nextUint16(),
          b = g._nextUint16(),
          x = g._nextUint32(),
          y = g._nextUint32(),
          w = g._nextUint32(),
          S = g._nextUint32(),
          M = [];

    for (let e = 0; e < s; e++) M.push({
      imageFlags: g._nextUint32(),
      rgbSliceByteOffset: g._nextUint32(),
      rgbSliceByteLength: g._nextUint32(),
      alphaSliceByteOffset: g._nextUint32(),
      alphaSliceByteLength: g._nextUint32()
    });

    const T = u + g._offset,
          E = T + x,
          A = E + y,
          C = A + w,
          R = new Uint8Array(e.buffer, e.byteOffset + T, x),
          k = new Uint8Array(e.buffer, e.byteOffset + E, y),
          P = new Uint8Array(e.buffer, e.byteOffset + A, w),
          D = new Uint8Array(e.buffer, e.byteOffset + C, S);
    return n.globalData = {
      endpointCount: v,
      selectorCount: b,
      imageDescs: M,
      endpointsData: R,
      selectorsData: k,
      tablesData: P,
      extendedData: D
    }, n;
  }

  class gw extends Uy {
    init() {
      this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [$x.NODE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        attributes: {}
      });
    }

    getAttribute(e) {
      return this.getRefMap("attributes", e);
    }

    setAttribute(e, t) {
      return this.setRefMap("attributes", e, t, {
        usage: "INSTANCE_ATTRIBUTE"
      });
    }

    listAttributes() {
      return this.listRefMapValues("attributes");
    }

    listSemantics() {
      return this.listRefMapKeys("attributes");
    }

  }

  gw.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
  const vw = "EXT_mesh_gpu_instancing";

  function bw() {
    return (bw = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }

      return e;
    }).apply(this, arguments);
  }

  var xw, yw, ww;
  (class extends tw {
    constructor(...e) {
      super(...e), this.extensionName = vw, this.provideTypes = [$x.NODE], this.prewriteTypes = [$x.ACCESSOR];
    }

    createInstancedMesh() {
      return new gw(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.nodes || []).forEach((t, n) => {
        if (!t.extensions || !t.extensions[vw]) return;
        const r = t.extensions[vw],
              i = this.createInstancedMesh();

        for (const t in r.attributes) i.setAttribute(t, e.accessors[r.attributes[t]]);

        e.nodes[n].setExtension(vw, i);
      }), this;
    }

    prewrite(e) {
      e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");

      for (const t of this.properties) for (const n of t.listAttributes()) e.addAccessorToUsageGroup(n, "INSTANCE_ATTRIBUTE");

      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listNodes().forEach(n => {
        const r = n.getExtension(vw);

        if (r) {
          const i = e.nodeIndexMap.get(n),
                s = t.json.nodes[i],
                o = {
            attributes: {}
          };
          r.listSemantics().forEach(t => {
            const n = r.getAttribute(t);
            o.attributes[t] = e.accessorIndexMap.get(n);
          }), s.extensions = s.extensions || {}, s.extensions[vw] = o;
        }
      }), this;
    }

  }).EXTENSION_NAME = vw, function (e) {
    e.QUANTIZE = "quantize", e.FILTER = "filter";
  }(xw || (xw = {})), function (e) {
    e.ATTRIBUTES = "ATTRIBUTES", e.TRIANGLES = "TRIANGLES", e.INDICES = "INDICES";
  }(yw || (yw = {})), function (e) {
    e.NONE = "NONE", e.OCTAHEDRAL = "OCTAHEDRAL", e.QUATERNION = "QUATERNION", e.EXPONENTIAL = "EXPONENTIAL";
  }(ww || (ww = {}));
  const {
    BYTE: Sw,
    SHORT: Mw,
    FLOAT: Tw
  } = Dy.ComponentType,
        {
    normalize: Ew,
    denormalize: Aw
  } = vy;

  function Cw(e, t, n, r) {
    const {
      filter: i,
      bits: s
    } = r,
          o = {
      array: e.getArray(),
      byteStride: e.getElementSize() * e.getComponentSize(),
      componentType: e.getComponentType(),
      normalized: e.getNormalized()
    };
    if (n !== yw.ATTRIBUTES) return o;

    if (i !== ww.NONE) {
      let n = e.getNormalized() ? function (e) {
        const t = e.getComponentType(),
              n = e.getArray(),
              r = new Float32Array(n.length);

        for (let e = 0; e < n.length; e++) r[e] = Aw(n[e], t);

        return r;
      }(e) : new Float32Array(o.array);

      switch (i) {
        case ww.EXPONENTIAL:
          o.byteStride = 4 * e.getElementSize(), o.componentType = Tw, o.normalized = !1, o.array = t.encodeFilterExp(n, e.getCount(), o.byteStride, s);
          break;

        case ww.OCTAHEDRAL:
          o.byteStride = s > 8 ? 8 : 4, o.componentType = s > 8 ? Mw : Sw, o.normalized = !0, n = 3 === e.getElementSize() ? function (e) {
            const t = new Float32Array(4 * e.length / 3);

            for (let n = 0, r = e.length / 3; n < r; n++) t[4 * n] = e[3 * n], t[4 * n + 1] = e[3 * n + 1], t[4 * n + 2] = e[3 * n + 2];

            return t;
          }(n) : n, o.array = t.encodeFilterOct(n, e.getCount(), o.byteStride, s);
          break;

        case ww.QUATERNION:
          o.byteStride = 8, o.componentType = Mw, o.normalized = !0, o.array = t.encodeFilterQuat(n, e.getCount(), o.byteStride, s);
          break;

        default:
          throw new Error("Invalid filter.");
      }

      o.min = e.getMin([]), o.max = e.getMax([]), e.getNormalized() && (o.min = o.min.map(t => Aw(t, e.getComponentType())), o.max = o.max.map(t => Aw(t, e.getComponentType()))), o.normalized && (o.min = o.min.map(e => Ew(e, o.componentType)), o.max = o.max.map(e => Ew(e, o.componentType)));
    } else o.byteStride % 4 && (o.array = function (e, t) {
      const n = cy.padNumber(e.BYTES_PER_ELEMENT * t) / e.BYTES_PER_ELEMENT,
            r = new e.constructor(e.length / t * n);

      for (let i = 0; i * t < e.length; i++) for (let s = 0; s < t; s++) r[i * n + s] = e[i * t + s];

      return r;
    }(o.array, e.getElementSize()), o.byteStride = o.array.byteLength / e.getCount());

    return o;
  }

  function Rw(e, t) {
    return t === aw.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e.listParents().some(e => e instanceof Xy && e.getMode() === Xy.Mode.TRIANGLES) ? yw.TRIANGLES : yw.INDICES : yw.ATTRIBUTES;
  }

  function kw(e, t) {
    const n = t.getGraph().listParentEdges(e).filter(e => !(e.getParent() instanceof Qy));

    for (const t of n) {
      const n = t.getName(),
            r = t.getAttributes().key || "";
      if ("indices" === n) return {
        filter: ww.NONE
      };

      if ("attributes" === n) {
        if ("POSITION" === r) return {
          filter: ww.NONE
        };
        if ("TEXCOORD_0" === r) return {
          filter: ww.NONE
        };
        if ("NORMAL" === r) return {
          filter: ww.OCTAHEDRAL,
          bits: 8
        };
        if ("TANGENT" === r) return {
          filter: ww.OCTAHEDRAL,
          bits: 8
        };
        if (r.startsWith("JOINTS_")) return {
          filter: ww.NONE
        };
        if (r.startsWith("WEIGHTS_")) return {
          filter: ww.NONE
        };
      }

      if ("output" === n) {
        const t = Pw(e);
        return "rotation" === t ? {
          filter: ww.QUATERNION,
          bits: 16
        } : "translation" === t || "scale" === t ? {
          filter: ww.EXPONENTIAL,
          bits: 12
        } : {
          filter: ww.NONE
        };
      }

      if ("input" === n) return {
        filter: ww.NONE
      };
      if ("inverseBindMatrices" === n) return {
        filter: ww.NONE
      };
    }

    return {
      filter: ww.NONE
    };
  }

  function Pw(e) {
    for (const t of e.listParents()) if (t instanceof Iy) for (const e of t.listParents()) if (e instanceof Ly) return e.getTargetPath();

    return null;
  }

  const Dw = "EXT_meshopt_compression",
        Ow = {
    method: xw.QUANTIZE
  };

  class Lw extends tw {
    constructor(...e) {
      super(...e), this.extensionName = Dw, this.prereadTypes = [$x.BUFFER, $x.PRIMITIVE], this.prewriteTypes = [$x.BUFFER, $x.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = new Map(), this._encoder = null, this._encoderOptions = Ow, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
    }

    install(e, t) {
      return "meshopt.decoder" === e && (this._decoder = t), "meshopt.encoder" === e && (this._encoder = t), this;
    }

    setEncoderOptions(e) {
      return this._encoderOptions = bw({}, Ow, e), this;
    }

    preread(e, t) {
      if (!this._decoder) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Dw}] Please install extension dependency, "meshopt.decoder".`);
      }

      if (!this._decoder.supported) {
        if (!this.isRequired()) return this;
        throw new Error(`[${Dw}]: Missing WASM support.`);
      }

      return t === $x.BUFFER ? this._prereadBuffers(e) : t === $x.PRIMITIVE && this._prereadPrimitives(e), this;
    }

    _prereadBuffers(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach((n, r) => {
        if (!n.extensions || !n.extensions[Dw]) return;
        const i = n.extensions[Dw],
              s = i.byteOffset || 0,
              o = i.byteLength || 0,
              a = i.count,
              l = i.byteStride,
              c = new Uint8Array(a * l),
              u = t.json.buffers[n.buffer],
              p = cy.toView(u.uri ? t.resources[u.uri] : t.resources["@glb.bin"], s, o);
        this._decoder.decodeGltfBuffer(c, a, l, p, i.mode, i.filter), e.bufferViews[r] = c;
      });
    }

    _prereadPrimitives(e) {
      const t = e.jsonDoc;
      (t.json.bufferViews || []).forEach(n => {
        var r;
        n.extensions && n.extensions[Dw] && (r = t.json.buffers[n.buffer]).extensions && r.extensions.EXT_meshopt_compression && r.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e.buffers[n.buffer], e.buffers[n.extensions[Dw].buffer]);
      });
    }

    read(e) {
      if (!this.isRequired()) return this;

      for (const [e, t] of this._decoderFallbackBufferMap) {
        for (const n of e.listParents()) n instanceof Dy && n.swap(e, t);

        e.dispose();
      }

      return this;
    }

    prewrite(e, t) {
      return t === $x.ACCESSOR ? this._prewriteAccessors(e) : t === $x.BUFFER && this._prewriteBuffers(e), this;
    }

    _prewriteAccessors(e) {
      const t = e.jsonDoc.json,
            n = this._encoder,
            r = this._encoderOptions,
            i = this.document.createBuffer(),
            s = this.document.getRoot().listBuffers().indexOf(i);
      this._encoderFallbackBuffer = i, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};

      for (const i of this.document.getRoot().listAccessors()) {
        if ("weights" === Pw(i)) continue;
        const o = e.getAccessorUsage(i),
              a = Rw(i, o),
              l = r.method === xw.FILTER ? kw(i, this.document) : {
          filter: ww.NONE
        },
              c = Cw(i, n, a, l),
              {
          array: u,
          byteStride: p
        } = c,
              h = i.getBuffer();
        if (!h) throw new Error(`${Dw}: Missing buffer for accessor.`);
        const d = this.document.getRoot().listBuffers().indexOf(h),
              f = [o, a, l.filter, p, d].join(":");
        let _ = this._encoderBufferViews[f],
            m = this._encoderBufferViewData[f],
            g = this._encoderBufferViewAccessors[f];
        _ && m || (g = this._encoderBufferViewAccessors[f] = [], m = this._encoderBufferViewData[f] = [], _ = this._encoderBufferViews[f] = {
          buffer: s,
          target: aw.USAGE_TO_TARGET[o],
          byteOffset: 0,
          byteLength: 0,
          byteStride: o === aw.BufferViewUsage.ARRAY_BUFFER ? p : void 0,
          extensions: {
            [Dw]: {
              buffer: d,
              byteOffset: 0,
              byteLength: 0,
              mode: a,
              filter: l.filter !== ww.NONE ? l.filter : void 0,
              byteStride: p,
              count: 0
            }
          }
        });
        const v = e.createAccessorDef(i);
        v.componentType = c.componentType, v.normalized = c.normalized, v.byteOffset = _.byteLength, v.min && c.min && (v.min = c.min), v.max && c.max && (v.max = c.max), e.accessorIndexMap.set(i, t.accessors.length), t.accessors.push(v), g.push(v), m.push(new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), _.byteLength += u.byteLength, _.extensions.EXT_meshopt_compression.count += i.getCount();
      }
    }

    _prewriteBuffers(e) {
      const t = this._encoder;

      for (const n in this._encoderBufferViews) {
        const r = this._encoderBufferViews[n],
              i = this._encoderBufferViewData[n],
              s = this.document.getRoot().listBuffers()[r.extensions[Dw].buffer],
              o = e.otherBufferViews.get(s) || [],
              {
          count: a,
          byteStride: l,
          mode: c
        } = r.extensions[Dw],
              u = cy.concat(i),
              p = t.encodeGltfBuffer(u, a, l, c),
              h = cy.pad(p);
        r.extensions[Dw].byteLength = p.byteLength, i.length = 0, i.push(h), o.push(h), e.otherBufferViews.set(s, o);
      }
    }

    write(e) {
      let t = 0;

      for (const n in this._encoderBufferViews) {
        const r = this._encoderBufferViews[n],
              i = e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[n][0]),
              s = this._encoderBufferViewAccessors[n];

        for (const e of s) e.bufferView = i;

        const o = e.jsonDoc.json.bufferViews[i],
              a = o.byteOffset || 0;
        Object.assign(o, r), o.byteOffset = t, o.extensions[Dw].byteOffset = a, t += cy.padNumber(r.byteLength);
      }

      const n = this._encoderFallbackBuffer,
            r = e.bufferIndexMap.get(n),
            i = e.jsonDoc.json.buffers[r];
      return i.byteLength = t, i.extensions = {
        [Dw]: {
          fallback: !0
        }
      }, n.dispose(), this;
    }

  }

  Lw.EXTENSION_NAME = Dw, Lw.EncoderMethod = xw;
  const Iw = "EXT_texture_webp";

  class Fw {
    match(e) {
      return e.length >= 12 && 87 === e[8] && 69 === e[9] && 66 === e[10] && 80 === e[11];
    }

    getSize(e) {
      const t = cy.decodeText(e.slice(0, 4)),
            n = cy.decodeText(e.slice(8, 12));
      if ("RIFF" !== t || "WEBP" !== n) return null;
      const r = new DataView(e.buffer, e.byteOffset);
      let i = 12;

      for (; i < r.byteLength;) {
        const e = cy.decodeText(new Uint8Array([r.getUint8(i), r.getUint8(i + 1), r.getUint8(i + 2), r.getUint8(i + 3)])),
              t = r.getUint32(i + 4, !0);
        if ("VP8 " === e) return [16383 & r.getInt16(i + 14, !0), 16383 & r.getInt16(i + 16, !0)];

        if ("VP8L" === e) {
          const e = r.getUint8(i + 9),
                t = r.getUint8(i + 10),
                n = r.getUint8(i + 11);
          return [1 + ((63 & t) << 8 | e), 1 + ((15 & r.getUint8(i + 12)) << 10 | n << 2 | (192 & t) >> 6)];
        }

        i += 8 + t + t % 2;
      }

      return null;
    }

    getChannels(e) {
      return 4;
    }

  }

  (class extends tw {
    constructor(...e) {
      super(...e), this.extensionName = Iw, this.prereadTypes = [$x.TEXTURE];
    }

    static register() {
      hy.registerFormat("image/webp", new Fw());
    }

    preread(e) {
      return (e.jsonDoc.json.textures || []).forEach(e => {
        e.extensions && e.extensions.EXT_texture_webp && (e.source = e.extensions.EXT_texture_webp.source);
      }), this;
    }

    read(e) {
      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(n => {
        if ("image/webp" === n.getMimeType()) {
          const r = e.imageIndexMap.get(n);
          (t.json.textures || []).forEach(e => {
            e.source === r && (e.extensions = e.extensions || {}, e.extensions.EXT_texture_webp = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }

  }).EXTENSION_NAME = Iw;
  const Nw = "KHR_draco_mesh_compression";
  let Uw, Bw, jw, zw;

  function Vw(e, t) {
    const n = new Uw.DecoderBuffer();

    try {
      if (n.Init(t, t.length), e.GetEncodedGeometryType(n) !== Uw.TRIANGULAR_MESH) throw new Error(`[${Nw}] Unknown geometry type.`);
      const r = new Uw.Mesh();
      if (!e.DecodeBufferToMesh(n, r).ok() || 0 === r.ptr) throw new Error(`[${Nw}] Decoding failure.`);
      return r;
    } finally {
      Uw.destroy(n);
    }
  }

  function Gw(e, t) {
    const n = 3 * t.num_faces();
    let r, i;

    if (t.num_points() <= 65534) {
      const s = n * Uint16Array.BYTES_PER_ELEMENT;
      r = Uw._malloc(s), e.GetTrianglesUInt16Array(t, s, r), i = new Uint16Array(Uw.HEAPU16.buffer, r, n).slice();
    } else {
      const s = n * Uint32Array.BYTES_PER_ELEMENT;
      r = Uw._malloc(s), e.GetTrianglesUInt32Array(t, s, r), i = new Uint32Array(Uw.HEAPU32.buffer, r, n).slice();
    }

    return Uw._free(r), i;
  }

  function Hw(e, t, n, r) {
    const i = jw[r.componentType],
          s = Bw[r.componentType],
          o = n.num_components(),
          a = t.num_points() * o,
          l = a * s.BYTES_PER_ELEMENT,
          c = Uw._malloc(l);

    e.GetAttributeDataArrayForAllPoints(t, n, i, l, c);
    const u = new s(Uw.HEAPF32.buffer, c, a).slice();
    return Uw._free(c), u;
  }

  var Ww, Kw;
  !function (e) {
    e[e.EDGEBREAKER = 1] = "EDGEBREAKER", e[e.SEQUENTIAL = 0] = "SEQUENTIAL";
  }(Ww || (Ww = {})), function (e) {
    e.POSITION = "POSITION", e.NORMAL = "NORMAL", e.COLOR = "COLOR", e.TEX_COORD = "TEX_COORD", e.GENERIC = "GENERIC";
  }(Kw || (Kw = {}));
  const Xw = {
    [Kw.POSITION]: 14,
    [Kw.NORMAL]: 10,
    [Kw.COLOR]: 8,
    [Kw.TEX_COORD]: 12,
    [Kw.GENERIC]: 12
  },
        qw = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    method: Ww.EDGEBREAKER,
    quantizationBits: Xw,
    quantizationVolume: "mesh"
  };

  function Yw(e, t = qw) {
    const n = bw({}, qw, t);
    n.quantizationBits = bw({}, Xw, t.quantizationBits);
    const r = new zw.Encoder(),
          i = new zw.MeshBuilder(),
          s = new zw.Mesh(),
          o = {},
          a = new zw.DracoInt8Array();

    for (const t of e.listSemantics()) {
      const a = e.getAttribute(t),
            l = Zw(t),
            c = Jw(i, a.getComponentType(), s, zw[l], a.getCount(), a.getElementSize(), a.getArray());
      if (-1 === c) throw new Error(`Error compressing "${t}" attribute.`);
      if (o[t] = c, "mesh" === n.quantizationVolume || "POSITION" !== t) r.SetAttributeQuantization(zw[l], n.quantizationBits[l]);else {
        if ("object" != typeof n.quantizationVolume) throw new Error("Invalid quantization volume state.");
        {
          const {
            quantizationVolume: e
          } = n,
                t = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], e.max[2] - e.min[2]);
          r.SetAttributeExplicitQuantization(zw[l], n.quantizationBits[l], a.getElementSize(), e.min, t);
        }
      }
    }

    const l = e.getIndices();
    if (!l) throw new Error("Primitive must have indices.");
    i.AddFacesToMesh(s, l.getCount() / 3, l.getArray()), r.SetSpeedOptions(n.encodeSpeed, n.decodeSpeed), r.SetTrackEncodedProperties(!0), n.method === Ww.SEQUENTIAL || e.listTargets().length > 0 ? r.SetEncodingMethod(zw.MESH_SEQUENTIAL_ENCODING) : r.SetEncodingMethod(zw.MESH_EDGEBREAKER_ENCODING);
    const c = r.EncodeMeshToDracoBuffer(s, a);
    if (c <= 0) throw new Error("Error applying Draco compression.");
    const u = new Uint8Array(c);

    for (let e = 0; e < c; ++e) u[e] = a.GetValue(e);

    const p = e.getAttribute("POSITION").getCount(),
          h = r.GetNumberOfEncodedPoints(),
          d = 3 * r.GetNumberOfEncodedFaces();
    if (e.listTargets().length > 0 && h !== p) throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');
    return zw.destroy(a), zw.destroy(s), zw.destroy(i), zw.destroy(r), {
      numVertices: h,
      numIndices: d,
      data: u,
      attributeIDs: o
    };
  }

  function Zw(e) {
    return "POSITION" === e ? Kw.POSITION : "NORMAL" === e ? Kw.NORMAL : e.startsWith("COLOR_") ? Kw.COLOR : e.startsWith("TEXCOORD_") ? Kw.TEX_COORD : Kw.GENERIC;
  }

  function Jw(e, t, n, r, i, s, o) {
    switch (t) {
      case Dy.ComponentType.UNSIGNED_BYTE:
        return e.AddUInt8Attribute(n, r, i, s, o);

      case Dy.ComponentType.BYTE:
        return e.AddInt8Attribute(n, r, i, s, o);

      case Dy.ComponentType.UNSIGNED_SHORT:
        return e.AddUInt16Attribute(n, r, i, s, o);

      case Dy.ComponentType.SHORT:
        return e.AddInt16Attribute(n, r, i, s, o);

      case Dy.ComponentType.UNSIGNED_INT:
        return e.AddUInt32Attribute(n, r, i, s, o);

      case Dy.ComponentType.FLOAT:
        return e.AddFloatAttribute(n, r, i, s, o);

      default:
        throw new Error(`Unexpected component type, "${t}".`);
    }
  }

  const $w = "KHR_draco_mesh_compression";

  class Qw extends tw {
    constructor(...e) {
      super(...e), this.extensionName = $w, this.prereadTypes = [$x.PRIMITIVE], this.prewriteTypes = [$x.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {};
    }

    install(e, t) {
      return "draco3d.decoder" === e && (this._decoderModule = t, Uw = this._decoderModule, Bw = {
        [Dy.ComponentType.FLOAT]: Float32Array,
        [Dy.ComponentType.UNSIGNED_INT]: Uint32Array,
        [Dy.ComponentType.UNSIGNED_SHORT]: Uint16Array,
        [Dy.ComponentType.UNSIGNED_BYTE]: Uint8Array,
        [Dy.ComponentType.SHORT]: Int16Array,
        [Dy.ComponentType.BYTE]: Int8Array
      }, jw = {
        [Dy.ComponentType.FLOAT]: Uw.DT_FLOAT32,
        [Dy.ComponentType.UNSIGNED_INT]: Uw.DT_UINT32,
        [Dy.ComponentType.UNSIGNED_SHORT]: Uw.DT_UINT16,
        [Dy.ComponentType.UNSIGNED_BYTE]: Uw.DT_UINT8,
        [Dy.ComponentType.SHORT]: Uw.DT_INT16,
        [Dy.ComponentType.BYTE]: Uw.DT_INT8
      }), "draco3d.encoder" === e && (this._encoderModule = t, zw = this._encoderModule), this;
    }

    setEncoderOptions(e) {
      return this._encoderOptions = e, this;
    }

    preread(e) {
      if (!this._decoderModule) throw new Error(`[${$w}] Please install extension dependency, "draco3d.decoder".`);
      const t = this.document.getLogger(),
            n = e.jsonDoc,
            r = new Map();

      try {
        const i = n.json.meshes || [];

        for (const s of i) for (const i of s.primitives) {
          if (!i.extensions || !i.extensions[$w]) continue;
          const s = i.extensions[$w];
          let [o, a] = r.get(s.bufferView) || [];

          if (!a || !o) {
            const e = n.json.bufferViews[s.bufferView],
                  i = n.json.buffers[e.buffer],
                  l = cy.toView(i.uri ? n.resources[i.uri] : n.resources["@glb.bin"], e.byteOffset || 0, e.byteLength);
            o = new this._decoderModule.Decoder(), a = Vw(o, l), r.set(s.bufferView, [o, a]), t.debug(`[${$w}] Decompressed ${l.byteLength} bytes.`);
          }

          for (const t in i.attributes) {
            const n = e.jsonDoc.json.accessors[i.attributes[t]],
                  r = o.GetAttributeByUniqueId(a, s.attributes[t]),
                  l = Hw(o, a, r, n);
            e.accessors[i.attributes[t]].setArray(l);
          }

          void 0 !== i.indices && e.accessors[i.indices].setArray(Gw(o, a));
        }
      } finally {
        for (const [e, t] of Array.from(r.values())) this._decoderModule.destroy(e), this._decoderModule.destroy(t);
      }

      return this;
    }

    read(e) {
      return this;
    }

    prewrite(e, t) {
      if (!this._encoderModule) throw new Error(`[${$w}] Please install extension dependency, "draco3d.encoder".`);
      const n = this.document.getLogger();
      n.debug(`[${$w}] Compression options: ${JSON.stringify(this._encoderOptions)}`);

      const r = function (e) {
        const t = e.getLogger(),
              n = new Set(),
              r = new Set();

        for (const i of e.getRoot().listMeshes()) for (const e of i.listPrimitives()) e.getIndices() ? e.getMode() !== Xy.Mode.TRIANGLES ? (r.add(e), t.warn(`[${$w}] Skipping Draco compression on non-TRIANGLES primitive.`)) : n.add(e) : (r.add(e), t.warn(`[${$w}] Skipping Draco compression on non-indexed primitive.`));

        const i = e.getRoot().listAccessors(),
              s = new Map();

        for (let e = 0; e < i.length; e++) s.set(i[e], e);

        const o = new Map(),
              a = new Set(),
              l = new Map();

        for (const t of Array.from(n)) {
          let n = eS(t, s);
          if (a.has(n)) l.set(t, n);else {
            if (o.has(t.getIndices())) {
              const n = t.getIndices(),
                    r = n.clone();
              s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r);
            }

            for (const n of t.listAttributes()) if (o.has(n)) {
              const r = n.clone();
              s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r);
            }

            n = eS(t, s), a.add(n), l.set(t, n), o.set(t.getIndices(), n);

            for (const e of t.listAttributes()) o.set(e, n);
          }
        }

        for (const e of Array.from(o.keys())) {
          const t = new Set(e.listParents().map(e => e.propertyType));
          if (2 !== t.size || !t.has($x.PRIMITIVE) || !t.has($x.ROOT)) throw new Error(`[${$w}] Compressed accessors must only be used as indices or vertex attributes.`);
        }

        for (const e of Array.from(n)) {
          const t = l.get(e),
                n = e.getIndices();
          if (o.get(n) !== t || e.listAttributes().some(e => o.get(e) !== t)) throw new Error(`[${$w}] Draco primitives must share all, or no, accessors.`);
        }

        for (const e of Array.from(r)) {
          const t = e.getIndices();
          if (o.has(t) || e.listAttributes().some(e => o.has(e))) throw new Error(`[${$w}] Accessor cannot be shared by compressed and uncompressed primitives.`);
        }

        return l;
      }(this.document),
            i = new Map();

      let s = "mesh";
      "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? n.warn(`[${$w}]: quantizationVolume=scene requires exactly 1 scene.`) : s = function (e) {
        const t = {
          min: [1 / 0, 1 / 0, 1 / 0],
          max: [-1 / 0, -1 / 0, -1 / 0]
        },
              n = e.propertyType === $x.NODE ? [e] : e.listChildren();

        for (const e of n) e.traverse(e => {
          const n = e.getMesh();
          if (!n) return;
          const r = ay(n, e.getWorldMatrix());
          ly(r.min, t), ly(r.max, t);
        });

        return t;
      }(this.document.getRoot().listScenes().pop()));

      for (const t of Array.from(r.keys())) {
        const n = r.get(t);
        if (!n) throw new Error("Unexpected primitive.");

        if (i.has(n)) {
          i.set(n, i.get(n));
          continue;
        }

        const o = t.getIndices(),
              a = e.jsonDoc.json.accessors,
              l = Yw(t, bw({}, this._encoderOptions, {
          quantizationVolume: s
        }));
        i.set(n, l);
        const c = e.createAccessorDef(o);
        c.count = l.numIndices, e.accessorIndexMap.set(o, a.length), a.push(c);

        for (const n of t.listSemantics()) {
          const r = t.getAttribute(n),
                i = e.createAccessorDef(r);
          i.count = l.numVertices, e.accessorIndexMap.set(r, a.length), a.push(i);
        }

        const u = t.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
        e.otherBufferViews.has(u) || e.otherBufferViews.set(u, []), e.otherBufferViews.get(u).push(l.data);
      }

      return n.debug(`[${$w}] Compressed ${r.size} primitives.`), e.extensionData[$w] = {
        primitiveHashMap: r,
        primitiveEncodingMap: i
      }, this;
    }

    write(e) {
      const t = e.extensionData[$w];

      for (const n of this.document.getRoot().listMeshes()) {
        const r = e.jsonDoc.json.meshes[e.meshIndexMap.get(n)];

        for (let i = 0; i < n.listPrimitives().length; i++) {
          const s = n.listPrimitives()[i],
                o = r.primitives[i],
                a = t.primitiveHashMap.get(s);
          if (!a) continue;
          const l = t.primitiveEncodingMap.get(a);
          o.extensions = o.extensions || {}, o.extensions[$w] = {
            bufferView: e.otherBufferViewsIndexMap.get(l.data),
            attributes: l.attributeIDs
          };
        }
      }

      if (!t.primitiveHashMap.size) {
        const t = e.jsonDoc.json;
        t.extensionsUsed = (t.extensionsUsed || []).filter(e => e !== $w), t.extensionsRequired = (t.extensionsRequired || []).filter(e => e !== $w);
      }

      return this;
    }

  }

  function eS(e, t) {
    const n = [],
          r = e.getIndices();
    n.push(t.get(r));

    for (const r of e.listAttributes()) n.push(t.get(r));

    return n.sort().join("|");
  }

  Qw.EXTENSION_NAME = $w, Qw.EncoderMethod = Ww;

  class tS extends Uy {
    init() {
      this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [$x.NODE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        color: [1, 1, 1],
        intensity: 1,
        type: tS.Type.POINT,
        range: null,
        innerConeAngle: 0,
        outerConeAngle: Math.PI / 4
      });
    }

    getColor() {
      return this.get("color");
    }

    setColor(e) {
      return this.set("color", e);
    }

    getColorHex() {
      return uy.factorToHex(this.getColor());
    }

    setColorHex(e) {
      const t = this.getColor().slice();
      return uy.hexToFactor(e, t), this.setColor(t);
    }

    getIntensity() {
      return this.get("intensity");
    }

    setIntensity(e) {
      return this.set("intensity", e);
    }

    getType() {
      return this.get("type");
    }

    setType(e) {
      return this.set("type", e);
    }

    getRange() {
      return this.get("range");
    }

    setRange(e) {
      return this.set("range", e);
    }

    getInnerConeAngle() {
      return this.get("innerConeAngle");
    }

    setInnerConeAngle(e) {
      return this.set("innerConeAngle", e);
    }

    getOuterConeAngle() {
      return this.get("outerConeAngle");
    }

    setOuterConeAngle(e) {
      return this.set("outerConeAngle", e);
    }

  }

  tS.EXTENSION_NAME = "KHR_lights_punctual", tS.Type = {
    POINT: "point",
    SPOT: "spot",
    DIRECTIONAL: "directional"
  };
  const nS = "KHR_lights_punctual";

  class rS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = nS;
    }

    createLight(e = "") {
      return new tS(this.document.getGraph(), e);
    }

    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions.KHR_lights_punctual) return this;
      const n = (t.json.extensions.KHR_lights_punctual.lights || []).map(e => {
        var t, n;
        const r = this.createLight().setName(e.name || "").setType(e.type);
        return void 0 !== e.color && r.setColor(e.color), void 0 !== e.intensity && r.setIntensity(e.intensity), void 0 !== e.range && r.setRange(e.range), void 0 !== (null == (t = e.spot) ? void 0 : t.innerConeAngle) && r.setInnerConeAngle(e.spot.innerConeAngle), void 0 !== (null == (n = e.spot) ? void 0 : n.outerConeAngle) && r.setOuterConeAngle(e.spot.outerConeAngle), r;
      });
      return t.json.nodes.forEach((t, r) => {
        t.extensions && t.extensions.KHR_lights_punctual && e.nodes[r].setExtension(nS, n[t.extensions.KHR_lights_punctual.light]);
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      if (0 === this.properties.size) return this;
      const n = [],
            r = new Map();

      for (const e of this.properties) {
        const t = e,
              i = {
          type: t.getType()
        };
        vy.eq(t.getColor(), [1, 1, 1]) || (i.color = t.getColor()), 1 !== t.getIntensity() && (i.intensity = t.getIntensity()), null != t.getRange() && (i.range = t.getRange()), t.getName() && (i.name = t.getName()), t.getType() === tS.Type.SPOT && (i.spot = {
          innerConeAngle: t.getInnerConeAngle(),
          outerConeAngle: t.getOuterConeAngle()
        }), n.push(i), r.set(t, n.length - 1);
      }

      return this.document.getRoot().listNodes().forEach(n => {
        const i = n.getExtension(nS);

        if (i) {
          const s = e.nodeIndexMap.get(n),
                o = t.json.nodes[s];
          o.extensions = o.extensions || {}, o.extensions.KHR_lights_punctual = {
            light: r.get(i)
          };
        }
      }), t.json.extensions = t.json.extensions || {}, t.json.extensions.KHR_lights_punctual = {
        lights: n
      }, this;
    }

  }

  rS.EXTENSION_NAME = nS;
  const {
    R: iS,
    G: sS,
    B: oS
  } = ty;

  class aS extends Uy {
    init() {
      this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        clearcoatFactor: 0,
        clearcoatTexture: null,
        clearcoatTextureInfo: new By(this.graph, "clearcoatTextureInfo"),
        clearcoatRoughnessFactor: 0,
        clearcoatRoughnessTexture: null,
        clearcoatRoughnessTextureInfo: new By(this.graph, "clearcoatRoughnessTextureInfo"),
        clearcoatNormalScale: 1,
        clearcoatNormalTexture: null,
        clearcoatNormalTextureInfo: new By(this.graph, "clearcoatNormalTextureInfo")
      });
    }

    getClearcoatFactor() {
      return this.get("clearcoatFactor");
    }

    setClearcoatFactor(e) {
      return this.set("clearcoatFactor", e);
    }

    getClearcoatTexture() {
      return this.getRef("clearcoatTexture");
    }

    getClearcoatTextureInfo() {
      return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
    }

    setClearcoatTexture(e) {
      return this.setRef("clearcoatTexture", e, {
        channels: iS
      });
    }

    getClearcoatRoughnessFactor() {
      return this.get("clearcoatRoughnessFactor");
    }

    setClearcoatRoughnessFactor(e) {
      return this.set("clearcoatRoughnessFactor", e);
    }

    getClearcoatRoughnessTexture() {
      return this.getRef("clearcoatRoughnessTexture");
    }

    getClearcoatRoughnessTextureInfo() {
      return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
    }

    setClearcoatRoughnessTexture(e) {
      return this.setRef("clearcoatRoughnessTexture", e, {
        channels: sS
      });
    }

    getClearcoatNormalScale() {
      return this.get("clearcoatNormalScale");
    }

    setClearcoatNormalScale(e) {
      return this.set("clearcoatNormalScale", e);
    }

    getClearcoatNormalTexture() {
      return this.getRef("clearcoatNormalTexture");
    }

    getClearcoatNormalTextureInfo() {
      return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
    }

    setClearcoatNormalTexture(e) {
      return this.setRef("clearcoatNormalTexture", e, {
        channels: iS | sS | oS
      });
    }

  }

  aS.EXTENSION_NAME = "KHR_materials_clearcoat";
  const lS = "KHR_materials_clearcoat";

  class cS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = lS;
    }

    createClearcoat() {
      return new aS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[lS]) {
          const i = this.createClearcoat();
          e.materials[r].setExtension(lS, i);
          const s = t.extensions[lS];

          if (void 0 !== s.clearcoatFactor && i.setClearcoatFactor(s.clearcoatFactor), void 0 !== s.clearcoatRoughnessFactor && i.setClearcoatRoughnessFactor(s.clearcoatRoughnessFactor), void 0 !== s.clearcoatTexture) {
            const t = s.clearcoatTexture;
            i.setClearcoatTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatTextureInfo(), t);
          }

          if (void 0 !== s.clearcoatRoughnessTexture) {
            const t = s.clearcoatRoughnessTexture;
            i.setClearcoatRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatRoughnessTextureInfo(), t);
          }

          if (void 0 !== s.clearcoatNormalTexture) {
            const t = s.clearcoatNormalTexture;
            i.setClearcoatNormalTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatNormalTextureInfo(), t), void 0 !== t.scale && i.setClearcoatNormalScale(t.scale);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(lS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[lS] = {
            clearcoatFactor: r.getClearcoatFactor(),
            clearcoatRoughnessFactor: r.getClearcoatRoughnessFactor()
          };

          if (r.getClearcoatTexture()) {
            const t = r.getClearcoatTexture(),
                  n = r.getClearcoatTextureInfo();
            o.clearcoatTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getClearcoatRoughnessTexture()) {
            const t = r.getClearcoatRoughnessTexture(),
                  n = r.getClearcoatRoughnessTextureInfo();
            o.clearcoatRoughnessTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getClearcoatNormalTexture()) {
            const t = r.getClearcoatNormalTexture(),
                  n = r.getClearcoatNormalTextureInfo();
            o.clearcoatNormalTexture = e.createTextureInfoDef(t, n), 1 !== r.getClearcoatNormalScale() && (o.clearcoatNormalTexture.scale = r.getClearcoatNormalScale());
          }
        }
      }), this;
    }

  }

  cS.EXTENSION_NAME = lS;

  class uS extends Uy {
    init() {
      this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        emissiveStrength: 1
      });
    }

    getEmissiveStrength() {
      return this.get("emissiveStrength");
    }

    setEmissiveStrength(e) {
      return this.set("emissiveStrength", e);
    }

  }

  uS.EXTENSION_NAME = "KHR_materials_emissive_strength";
  const pS = "KHR_materials_emissive_strength";

  class hS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = pS;
    }

    createEmissiveStrength() {
      return new uS(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions[pS]) {
          const r = this.createEmissiveStrength();
          e.materials[n].setExtension(pS, r);
          const i = t.extensions[pS];
          void 0 !== i.emissiveStrength && r.setEmissiveStrength(i.emissiveStrength);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(pS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions[pS] = {
            emissiveStrength: r.getEmissiveStrength()
          };
        }
      }), this;
    }

  }

  hS.EXTENSION_NAME = pS;

  class dS extends Uy {
    init() {
      this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        ior: 0
      });
    }

    getIOR() {
      return this.get("ior");
    }

    setIOR(e) {
      return this.set("ior", e);
    }

  }

  dS.EXTENSION_NAME = "KHR_materials_ior";
  const fS = "KHR_materials_ior";

  class _S extends tw {
    constructor(...e) {
      super(...e), this.extensionName = fS;
    }

    createIOR() {
      return new dS(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        if (t.extensions && t.extensions.KHR_materials_ior) {
          const r = this.createIOR();
          e.materials[n].setExtension(fS, r);
          const i = t.extensions.KHR_materials_ior;
          void 0 !== i.ior && r.setIOR(i.ior);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(fS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {}, s.extensions.KHR_materials_ior = {
            ior: r.getIOR()
          };
        }
      }), this;
    }

  }

  _S.EXTENSION_NAME = fS;
  const {
    R: mS,
    G: gS
  } = ty;

  class vS extends Uy {
    init() {
      this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        iridescenceFactor: 0,
        iridescenceTexture: null,
        iridescenceTextureInfo: new By(this.graph, "iridescenceTextureInfo"),
        iridescenceIOR: 1.3,
        iridescenceThicknessMinimum: 100,
        iridescenceThicknessMaximum: 400,
        iridescenceThicknessTexture: null,
        iridescenceThicknessTextureInfo: new By(this.graph, "iridescenceThicknessTextureInfo")
      });
    }

    getIridescenceFactor() {
      return this.get("iridescenceFactor");
    }

    setIridescenceFactor(e) {
      return this.set("iridescenceFactor", e);
    }

    getIridescenceTexture() {
      return this.getRef("iridescenceTexture");
    }

    getIridescenceTextureInfo() {
      return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
    }

    setIridescenceTexture(e) {
      return this.setRef("iridescenceTexture", e, {
        channels: mS
      });
    }

    getIridescenceIOR() {
      return this.get("iridescenceIOR");
    }

    setIridescenceIOR(e) {
      return this.set("iridescenceIOR", e);
    }

    getIridescenceThicknessMinimum() {
      return this.get("iridescenceThicknessMinimum");
    }

    setIridescenceThicknessMinimum(e) {
      return this.set("iridescenceThicknessMinimum", e);
    }

    getIridescenceThicknessMaximum() {
      return this.get("iridescenceThicknessMaximum");
    }

    setIridescenceThicknessMaximum(e) {
      return this.set("iridescenceThicknessMaximum", e);
    }

    getIridescenceThicknessTexture() {
      return this.getRef("iridescenceThicknessTexture");
    }

    getIridescenceThicknessTextureInfo() {
      return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
    }

    setIridescenceThicknessTexture(e) {
      return this.setRef("iridescenceThicknessTexture", e, {
        channels: gS
      });
    }

  }

  vS.EXTENSION_NAME = "KHR_materials_iridescence";
  const bS = "KHR_materials_iridescence";

  class xS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = bS;
    }

    createIridescence() {
      return new vS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[bS]) {
          const i = this.createIridescence();
          e.materials[r].setExtension(bS, i);
          const s = t.extensions[bS];

          if (void 0 !== s.iridescenceFactor && i.setIridescenceFactor(s.iridescenceFactor), void 0 !== s.iridescenceIor && i.setIridescenceIOR(s.iridescenceIor), void 0 !== s.iridescenceThicknessMinimum && i.setIridescenceThicknessMinimum(s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && i.setIridescenceThicknessMaximum(s.iridescenceThicknessMaximum), void 0 !== s.iridescenceTexture) {
            const t = s.iridescenceTexture;
            i.setIridescenceTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceTextureInfo(), t);
          }

          if (void 0 !== s.iridescenceThicknessTexture) {
            const t = s.iridescenceThicknessTexture;
            i.setIridescenceThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceThicknessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(bS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[bS] = {};

          if (r.getIridescenceFactor() > 0 && (o.iridescenceFactor = r.getIridescenceFactor()), 1.3 !== r.getIridescenceIOR() && (o.iridescenceIor = r.getIridescenceIOR()), 100 !== r.getIridescenceThicknessMinimum() && (o.iridescenceThicknessMinimum = r.getIridescenceThicknessMinimum()), 400 !== r.getIridescenceThicknessMaximum() && (o.iridescenceThicknessMaximum = r.getIridescenceThicknessMaximum()), r.getIridescenceTexture()) {
            const t = r.getIridescenceTexture(),
                  n = r.getIridescenceTextureInfo();
            o.iridescenceTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getIridescenceThicknessTexture()) {
            const t = r.getIridescenceThicknessTexture(),
                  n = r.getIridescenceThicknessTextureInfo();
            o.iridescenceThicknessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  xS.EXTENSION_NAME = bS;
  const {
    R: yS,
    G: wS,
    B: SS,
    A: MS
  } = ty;

  class TS extends Uy {
    init() {
      this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        diffuseFactor: [1, 1, 1, 1],
        diffuseTexture: null,
        diffuseTextureInfo: new By(this.graph, "diffuseTextureInfo"),
        specularFactor: [1, 1, 1],
        glossinessFactor: 1,
        specularGlossinessTexture: null,
        specularGlossinessTextureInfo: new By(this.graph, "specularGlossinessTextureInfo")
      });
    }

    getDiffuseFactor() {
      return this.get("diffuseFactor");
    }

    setDiffuseFactor(e) {
      return this.set("diffuseFactor", e);
    }

    getDiffuseHex() {
      return uy.factorToHex(this.getDiffuseFactor());
    }

    setDiffuseHex(e) {
      const t = this.getDiffuseFactor().slice();
      return this.setDiffuseFactor(uy.hexToFactor(e, t));
    }

    getDiffuseTexture() {
      return this.getRef("diffuseTexture");
    }

    getDiffuseTextureInfo() {
      return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
    }

    setDiffuseTexture(e) {
      return this.setRef("diffuseTexture", e, {
        channels: yS | wS | SS | MS
      });
    }

    getSpecularFactor() {
      return this.get("specularFactor");
    }

    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }

    getGlossinessFactor() {
      return this.get("glossinessFactor");
    }

    setGlossinessFactor(e) {
      return this.set("glossinessFactor", e);
    }

    getSpecularGlossinessTexture() {
      return this.getRef("specularGlossinessTexture");
    }

    getSpecularGlossinessTextureInfo() {
      return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
    }

    setSpecularGlossinessTexture(e) {
      return this.setRef("specularGlossinessTexture", e, {
        channels: yS | wS | SS | MS
      });
    }

  }

  TS.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
  const ES = "KHR_materials_pbrSpecularGlossiness";

  class AS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = ES;
    }

    createPBRSpecularGlossiness() {
      return new TS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[ES]) {
          const i = this.createPBRSpecularGlossiness();
          e.materials[r].setExtension(ES, i);
          const s = t.extensions[ES];

          if (void 0 !== s.diffuseFactor && i.setDiffuseFactor(s.diffuseFactor), void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.glossinessFactor && i.setGlossinessFactor(s.glossinessFactor), void 0 !== s.diffuseTexture) {
            const t = s.diffuseTexture;
            i.setDiffuseTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getDiffuseTextureInfo(), t);
          }

          if (void 0 !== s.specularGlossinessTexture) {
            const t = s.specularGlossinessTexture;
            i.setSpecularGlossinessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularGlossinessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(ES);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[ES] = {
            diffuseFactor: r.getDiffuseFactor(),
            specularFactor: r.getSpecularFactor(),
            glossinessFactor: r.getGlossinessFactor()
          };

          if (r.getDiffuseTexture()) {
            const t = r.getDiffuseTexture(),
                  n = r.getDiffuseTextureInfo();
            o.diffuseTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSpecularGlossinessTexture()) {
            const t = r.getSpecularGlossinessTexture(),
                  n = r.getSpecularGlossinessTextureInfo();
            o.specularGlossinessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  AS.EXTENSION_NAME = ES;
  const {
    R: CS,
    G: RS,
    B: kS,
    A: PS
  } = ty;

  class DS extends Uy {
    init() {
      this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        sheenColorFactor: [0, 0, 0],
        sheenColorTexture: null,
        sheenColorTextureInfo: new By(this.graph, "sheenColorTextureInfo"),
        sheenRoughnessFactor: 0,
        sheenRoughnessTexture: null,
        sheenRoughnessTextureInfo: new By(this.graph, "sheenRoughnessTextureInfo")
      });
    }

    getSheenColorFactor() {
      return this.get("sheenColorFactor");
    }

    getSheenColorHex() {
      return uy.factorToHex(this.getSheenColorFactor());
    }

    setSheenColorFactor(e) {
      return this.set("sheenColorFactor", e);
    }

    setSheenColorHex(e) {
      const t = this.getSheenColorFactor().slice();
      return this.set("sheenColorFactor", uy.hexToFactor(e, t));
    }

    getSheenColorTexture() {
      return this.getRef("sheenColorTexture");
    }

    getSheenColorTextureInfo() {
      return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
    }

    setSheenColorTexture(e) {
      return this.setRef("sheenColorTexture", e, {
        channels: CS | RS | kS
      });
    }

    getSheenRoughnessFactor() {
      return this.get("sheenRoughnessFactor");
    }

    setSheenRoughnessFactor(e) {
      return this.set("sheenRoughnessFactor", e);
    }

    getSheenRoughnessTexture() {
      return this.getRef("sheenRoughnessTexture");
    }

    getSheenRoughnessTextureInfo() {
      return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
    }

    setSheenRoughnessTexture(e) {
      return this.setRef("sheenRoughnessTexture", e, {
        channels: PS
      });
    }

  }

  DS.EXTENSION_NAME = "KHR_materials_sheen";
  const OS = "KHR_materials_sheen";

  class LS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = OS;
    }

    createSheen() {
      return new DS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions.KHR_materials_sheen) {
          const i = this.createSheen();
          e.materials[r].setExtension(OS, i);
          const s = t.extensions.KHR_materials_sheen;

          if (void 0 !== s.sheenColorFactor && i.setSheenColorFactor(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && i.setSheenRoughnessFactor(s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture) {
            const t = s.sheenColorTexture;
            i.setSheenColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenColorTextureInfo(), t);
          }

          if (void 0 !== s.sheenRoughnessTexture) {
            const t = s.sheenRoughnessTexture;
            i.setSheenRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenRoughnessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(OS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_sheen = {
            sheenColorFactor: r.getSheenColorFactor(),
            sheenRoughnessFactor: r.getSheenRoughnessFactor()
          };

          if (r.getSheenColorTexture()) {
            const t = r.getSheenColorTexture(),
                  n = r.getSheenColorTextureInfo();
            o.sheenColorTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSheenRoughnessTexture()) {
            const t = r.getSheenRoughnessTexture(),
                  n = r.getSheenRoughnessTextureInfo();
            o.sheenRoughnessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  LS.EXTENSION_NAME = OS;
  const {
    R: IS,
    G: FS,
    B: NS,
    A: US
  } = ty;

  class BS extends Uy {
    init() {
      this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        specularFactor: 1,
        specularTexture: null,
        specularTextureInfo: new By(this.graph, "specularTextureInfo"),
        specularColorFactor: [1, 1, 1],
        specularColorTexture: null,
        specularColorTextureInfo: new By(this.graph, "specularColorTextureInfo")
      });
    }

    getSpecularFactor() {
      return this.get("specularFactor");
    }

    setSpecularFactor(e) {
      return this.set("specularFactor", e);
    }

    getSpecularColorFactor() {
      return this.get("specularColorFactor");
    }

    setSpecularColorFactor(e) {
      return this.set("specularColorFactor", e);
    }

    getSpecularColorHex() {
      return uy.factorToHex(this.getSpecularColorFactor());
    }

    setSpecularColorHex(e) {
      const t = this.getSpecularColorFactor().slice();
      return this.set("specularColorFactor", uy.hexToFactor(e, t));
    }

    getSpecularTexture() {
      return this.getRef("specularTexture");
    }

    getSpecularTextureInfo() {
      return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
    }

    setSpecularTexture(e) {
      return this.setRef("specularTexture", e, {
        channels: US
      });
    }

    getSpecularColorTexture() {
      return this.getRef("specularColorTexture");
    }

    getSpecularColorTextureInfo() {
      return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
    }

    setSpecularColorTexture(e) {
      return this.setRef("specularColorTexture", e, {
        channels: IS | FS | NS
      });
    }

  }

  BS.EXTENSION_NAME = "KHR_materials_specular";
  const jS = "KHR_materials_specular";

  class zS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = jS;
    }

    createSpecular() {
      return new BS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[jS]) {
          const i = this.createSpecular();
          e.materials[r].setExtension(jS, i);
          const s = t.extensions[jS];

          if (void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.specularColorFactor && i.setSpecularColorFactor(s.specularColorFactor), void 0 !== s.specularTexture) {
            const t = s.specularTexture;
            i.setSpecularTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularTextureInfo(), t);
          }

          if (void 0 !== s.specularColorTexture) {
            const t = s.specularColorTexture;
            i.setSpecularColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularColorTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(jS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[jS] = {};

          if (1 !== r.getSpecularFactor() && (o.specularFactor = r.getSpecularFactor()), vy.eq(r.getSpecularColorFactor(), [1, 1, 1]) || (o.specularColorFactor = r.getSpecularColorFactor()), r.getSpecularTexture()) {
            const t = r.getSpecularTexture(),
                  n = r.getSpecularTextureInfo();
            o.specularTexture = e.createTextureInfoDef(t, n);
          }

          if (r.getSpecularColorTexture()) {
            const t = r.getSpecularColorTexture(),
                  n = r.getSpecularColorTextureInfo();
            o.specularColorTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  zS.EXTENSION_NAME = jS;
  const {
    R: VS
  } = ty;

  class GS extends Uy {
    init() {
      this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        transmissionFactor: 0,
        transmissionTexture: null,
        transmissionTextureInfo: new By(this.graph, "transmissionTextureInfo")
      });
    }

    getTransmissionFactor() {
      return this.get("transmissionFactor");
    }

    setTransmissionFactor(e) {
      return this.set("transmissionFactor", e);
    }

    getTransmissionTexture() {
      return this.getRef("transmissionTexture");
    }

    getTransmissionTextureInfo() {
      return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
    }

    setTransmissionTexture(e) {
      return this.setRef("transmissionTexture", e, {
        channels: VS
      });
    }

  }

  GS.EXTENSION_NAME = "KHR_materials_transmission";
  const HS = "KHR_materials_transmission";

  class WS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = HS;
    }

    createTransmission() {
      return new GS(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions[HS]) {
          const i = this.createTransmission();
          e.materials[r].setExtension(HS, i);
          const s = t.extensions[HS];

          if (void 0 !== s.transmissionFactor && i.setTransmissionFactor(s.transmissionFactor), void 0 !== s.transmissionTexture) {
            const t = s.transmissionTexture;
            i.setTransmissionTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getTransmissionTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(HS);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions[HS] = {
            transmissionFactor: r.getTransmissionFactor()
          };

          if (r.getTransmissionTexture()) {
            const t = r.getTransmissionTexture(),
                  n = r.getTransmissionTextureInfo();
            o.transmissionTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  WS.EXTENSION_NAME = HS;

  class KS extends Uy {
    init() {
      this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [$x.MATERIAL];
    }

  }

  KS.EXTENSION_NAME = "KHR_materials_unlit";
  const XS = "KHR_materials_unlit";

  class qS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = XS;
    }

    createUnlit() {
      return new KS(this.document.getGraph());
    }

    read(e) {
      return (e.jsonDoc.json.materials || []).forEach((t, n) => {
        t.extensions && t.extensions.KHR_materials_unlit && e.materials[n].setExtension(XS, this.createUnlit());
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        if (n.getExtension(XS)) {
          const r = e.materialIndexMap.get(n),
                i = t.json.materials[r];
          i.extensions = i.extensions || {}, i.extensions.KHR_materials_unlit = {};
        }
      }), this;
    }

  }

  qS.EXTENSION_NAME = XS;

  class YS extends Uy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        material: null,
        variants: []
      });
    }

    getMaterial() {
      return this.getRef("material");
    }

    setMaterial(e) {
      return this.setRef("material", e);
    }

    addVariant(e) {
      return this.addRef("variants", e);
    }

    removeVariant(e) {
      return this.removeRef("variants", e);
    }

    listVariants() {
      return this.listRefs("variants");
    }

  }

  YS.EXTENSION_NAME = "KHR_materials_variants";

  class ZS extends Uy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [$x.PRIMITIVE];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        mappings: []
      });
    }

    addMapping(e) {
      return this.addRef("mappings", e);
    }

    removeMapping(e) {
      return this.removeRef("mappings", e);
    }

    listMappings() {
      return this.listRefs("mappings");
    }

  }

  ZS.EXTENSION_NAME = "KHR_materials_variants";

  class JS extends Uy {
    init() {
      this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"];
    }

  }

  JS.EXTENSION_NAME = "KHR_materials_variants";
  const $S = "KHR_materials_variants";

  class QS extends tw {
    constructor(...e) {
      super(...e), this.extensionName = $S;
    }

    createMappingList() {
      return new ZS(this.document.getGraph());
    }

    createVariant(e = "") {
      return new JS(this.document.getGraph(), e);
    }

    createMapping() {
      return new YS(this.document.getGraph());
    }

    listVariants() {
      return Array.from(this.properties).filter(e => e instanceof JS);
    }

    read(e) {
      const t = e.jsonDoc;
      if (!t.json.extensions || !t.json.extensions[$S]) return this;
      const n = (t.json.extensions[$S].variants || []).map(e => this.createVariant().setName(e.name || ""));
      return (t.json.meshes || []).forEach((t, r) => {
        const i = e.meshes[r];
        (t.primitives || []).forEach((t, r) => {
          if (!t.extensions || !t.extensions[$S]) return;
          const s = this.createMappingList(),
                o = t.extensions[$S];

          for (const t of o.mappings) {
            const r = this.createMapping();
            void 0 !== t.material && r.setMaterial(e.materials[t.material]);

            for (const e of t.variants || []) r.addVariant(n[e]);

            s.addMapping(r);
          }

          i.listPrimitives()[r].setExtension($S, s);
        });
      }), this;
    }

    write(e) {
      const t = e.jsonDoc,
            n = this.listVariants();
      if (!n.length) return this;
      const r = [],
            i = new Map();

      for (const t of n) i.set(t, r.length), r.push(e.createPropertyDef(t));

      for (const t of this.document.getRoot().listMeshes()) {
        const n = e.meshIndexMap.get(t);
        t.listPrimitives().forEach((t, r) => {
          const s = t.getExtension($S);
          if (!s) return;
          const o = e.jsonDoc.json.meshes[n].primitives[r],
                a = s.listMappings().map(t => {
            const n = e.createPropertyDef(t),
                  r = t.getMaterial();
            return r && (n.material = e.materialIndexMap.get(r)), n.variants = t.listVariants().map(e => i.get(e)), n;
          });
          o.extensions = o.extensions || {}, o.extensions[$S] = {
            mappings: a
          };
        });
      }

      return t.json.extensions = t.json.extensions || {}, t.json.extensions[$S] = {
        variants: r
      }, this;
    }

  }

  QS.EXTENSION_NAME = $S;
  const {
    G: eM
  } = ty;

  class tM extends Uy {
    init() {
      this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [$x.MATERIAL];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        thicknessFactor: 0,
        thicknessTexture: null,
        thicknessTextureInfo: new By(this.graph, "thicknessTexture"),
        attenuationDistance: 1 / 0,
        attenuationColor: [1, 1, 1]
      });
    }

    getThicknessFactor() {
      return this.get("thicknessFactor");
    }

    setThicknessFactor(e) {
      return this.set("thicknessFactor", e);
    }

    getThicknessTexture() {
      return this.getRef("thicknessTexture");
    }

    getThicknessTextureInfo() {
      return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
    }

    setThicknessTexture(e) {
      return this.setRef("thicknessTexture", e, {
        channels: eM
      });
    }

    getAttenuationDistance() {
      return this.get("attenuationDistance");
    }

    setAttenuationDistance(e) {
      return this.set("attenuationDistance", e);
    }

    getAttenuationColor() {
      return this.get("attenuationColor");
    }

    setAttenuationColor(e) {
      return this.set("attenuationColor", e);
    }

    getAttenuationColorHex() {
      return uy.factorToHex(this.getAttenuationColor());
    }

    setAttenuationColorHex(e) {
      const t = this.getAttenuationColor().slice();
      return this.set("attenuationColor", uy.hexToFactor(e, t));
    }

  }

  tM.EXTENSION_NAME = "KHR_materials_volume";
  const nM = "KHR_materials_volume";

  class rM extends tw {
    constructor(...e) {
      super(...e), this.extensionName = nM;
    }

    createVolume() {
      return new tM(this.document.getGraph());
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.textures || [];
      return (t.json.materials || []).forEach((t, r) => {
        if (t.extensions && t.extensions.KHR_materials_volume) {
          const i = this.createVolume();
          e.materials[r].setExtension(nM, i);
          const s = t.extensions.KHR_materials_volume;

          if (void 0 !== s.thicknessFactor && i.setThicknessFactor(s.thicknessFactor), void 0 !== s.attenuationDistance && i.setAttenuationDistance(s.attenuationDistance), void 0 !== s.attenuationColor && i.setAttenuationColor(s.attenuationColor), void 0 !== s.thicknessTexture) {
            const t = s.thicknessTexture;
            i.setThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getThicknessTextureInfo(), t);
          }
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(nM);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = s.extensions.KHR_materials_volume = {};

          if (r.getThicknessFactor() > 0 && (o.thicknessFactor = r.getThicknessFactor()), Number.isFinite(r.getAttenuationDistance()) && (o.attenuationDistance = r.getAttenuationDistance()), vy.eq(r.getAttenuationColor(), [1, 1, 1]) || (o.attenuationColor = r.getAttenuationColor()), r.getThicknessTexture()) {
            const t = r.getThicknessTexture(),
                  n = r.getThicknessTextureInfo();
            o.thicknessTexture = e.createTextureInfoDef(t, n);
          }
        }
      }), this;
    }

  }

  rM.EXTENSION_NAME = nM;
  const iM = "KHR_mesh_quantization";

  class sM extends tw {
    constructor(...e) {
      super(...e), this.extensionName = iM;
    }

    read(e) {
      return this;
    }

    write(e) {
      return this;
    }

  }

  sM.EXTENSION_NAME = iM;
  const oM = "KHR_texture_basisu";

  class aM {
    match(e) {
      return 171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 50 === e[5] && 48 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11];
    }

    getSize(e) {
      const t = mw(e);
      return [t.pixelWidth, t.pixelHeight];
    }

    getChannels(e) {
      const t = mw(e).dataFormatDescriptor[0];
      if (163 === t.colorModel) return 2 === t.samples.length && 15 == (15 & t.samples[1].channelType) ? 4 : 3;
      if (166 === t.colorModel) return 3 == (15 & t.samples[0].channelType) ? 4 : 3;
      throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`);
    }

    getGPUByteLength(e) {
      const t = mw(e),
            n = this.getChannels(e) > 3;
      let r = 0;

      for (let e = 0; e < t.levels.length; e++) {
        const i = t.levels[e];
        r += i.uncompressedByteLength ? i.uncompressedByteLength : Math.max(1, Math.floor(t.pixelWidth / Math.pow(2, e))) / 4 * (Math.max(1, Math.floor(t.pixelHeight / Math.pow(2, e))) / 4) * (n ? 16 : 8);
      }

      return r;
    }

  }

  class lM extends tw {
    constructor(...e) {
      super(...e), this.extensionName = oM, this.prereadTypes = [$x.TEXTURE];
    }

    static register() {
      hy.registerFormat("image/ktx2", new aM());
    }

    preread(e) {
      return e.jsonDoc.json.textures.forEach(e => {
        e.extensions && e.extensions.KHR_texture_basisu && (e.source = e.extensions.KHR_texture_basisu.source);
      }), this;
    }

    read(e) {
      return this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listTextures().forEach(n => {
        if ("image/ktx2" === n.getMimeType()) {
          const r = e.imageIndexMap.get(n);
          t.json.textures.forEach(e => {
            e.source === r && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_basisu = {
              source: e.source
            }, delete e.source);
          });
        }
      }), this;
    }

  }

  lM.EXTENSION_NAME = oM;

  class cM extends Uy {
    init() {
      this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [$x.TEXTURE_INFO];
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        offset: [0, 0],
        rotation: 0,
        scale: [1, 1],
        texCoord: null
      });
    }

    getOffset() {
      return this.get("offset");
    }

    setOffset(e) {
      return this.set("offset", e);
    }

    getRotation() {
      return this.get("rotation");
    }

    setRotation(e) {
      return this.set("rotation", e);
    }

    getScale() {
      return this.get("scale");
    }

    setScale(e) {
      return this.set("scale", e);
    }

    getTexCoord() {
      return this.get("texCoord");
    }

    setTexCoord(e) {
      return this.set("texCoord", e);
    }

  }

  cM.EXTENSION_NAME = "KHR_texture_transform";
  const uM = "KHR_texture_transform";

  class pM extends tw {
    constructor(...e) {
      super(...e), this.extensionName = uM;
    }

    createTransform() {
      return new cM(this.document.getGraph());
    }

    read(e) {
      for (const [t, n] of Array.from(e.textureInfos.entries())) {
        if (!n.extensions || !n.extensions.KHR_texture_transform) continue;
        const e = this.createTransform(),
              r = n.extensions.KHR_texture_transform;
        void 0 !== r.offset && e.setOffset(r.offset), void 0 !== r.rotation && e.setRotation(r.rotation), void 0 !== r.scale && e.setScale(r.scale), void 0 !== r.texCoord && e.setTexCoord(r.texCoord), t.setExtension(uM, e);
      }

      return this;
    }

    write(e) {
      const t = Array.from(e.textureInfoDefMap.entries());

      for (const [e, n] of t) {
        const t = e.getExtension(uM);
        if (!t) continue;
        n.extensions = n.extensions || {};
        const r = {},
              i = vy.eq;
        i(t.getOffset(), [0, 0]) || (r.offset = t.getOffset()), 0 !== t.getRotation() && (r.rotation = t.getRotation()), i(t.getScale(), [1, 1]) || (r.scale = t.getScale()), null != t.getTexCoord() && (r.texCoord = t.getTexCoord()), n.extensions.KHR_texture_transform = r;
      }

      return this;
    }

  }

  pM.EXTENSION_NAME = uM;
  const hM = [$x.ROOT, $x.SCENE, $x.NODE, $x.MESH, $x.MATERIAL, $x.TEXTURE, $x.ANIMATION];

  class dM extends Uy {
    init() {
      this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = hM;
    }

    getDefaults() {
      return Object.assign(super.getDefaults(), {
        context: {},
        properties: {}
      });
    }

    getContext() {
      return this.get("context");
    }

    setContext(e) {
      return this.set("context", bw({}, e));
    }

    listProperties() {
      return Object.keys(this.get("properties"));
    }

    getProperty(e) {
      const t = this.get("properties");
      return e in t ? t[e] : null;
    }

    setProperty(e, t) {
      this._assertContext(e);

      const n = bw({}, this.get("properties"));
      return t ? n[e] = t : delete n[e], this.set("properties", n);
    }

    toJSONLD() {
      return bw({
        "@context": fM(this.get("context"))
      }, fM(this.get("properties")));
    }

    fromJSONLD(e) {
      const t = (e = fM(e))["@context"];
      return t && this.set("context", t), delete e["@context"], this.set("properties", e);
    }

    _assertContext(e) {
      if (!(e.split(":")[0] in this.get("context"))) throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`);
    }

  }

  function fM(e) {
    return JSON.parse(JSON.stringify(e));
  }

  dM.EXTENSION_NAME = "KHR_xmp_json_ld";
  const _M = "KHR_xmp_json_ld";

  class mM extends tw {
    constructor(...e) {
      super(...e), this.extensionName = _M;
    }

    createPacket() {
      return new dM(this.document.getGraph());
    }

    listPackets() {
      return Array.from(this.properties);
    }

    read(e) {
      var t;
      const n = null == (t = e.jsonDoc.json.extensions) ? void 0 : t.KHR_xmp_json_ld;
      if (!n || !n.packets) return this;
      const r = e.jsonDoc.json,
            i = this.document.getRoot(),
            s = n.packets.map(e => this.createPacket().fromJSONLD(e)),
            o = [[r.asset], r.scenes, r.nodes, r.meshes, r.materials, r.images, r.animations],
            a = [[i], i.listScenes(), i.listNodes(), i.listMeshes(), i.listMaterials(), i.listTextures(), i.listAnimations()];

      for (let e = 0; e < o.length; e++) {
        const t = o[e] || [];

        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          r.extensions && r.extensions.KHR_xmp_json_ld && a[e][n].setExtension(_M, s[r.extensions.KHR_xmp_json_ld.packet]);
        }
      }

      return this;
    }

    write(e) {
      const {
        json: t
      } = e.jsonDoc,
            n = [];

      for (const r of this.properties) {
        n.push(r.toJSONLD());

        for (const i of r.listParents()) {
          let r;

          switch (i.propertyType) {
            case $x.ROOT:
              r = t.asset;
              break;

            case $x.SCENE:
              r = t.scenes[e.sceneIndexMap.get(i)];
              break;

            case $x.NODE:
              r = t.nodes[e.nodeIndexMap.get(i)];
              break;

            case $x.MESH:
              r = t.meshes[e.meshIndexMap.get(i)];
              break;

            case $x.MATERIAL:
              r = t.materials[e.materialIndexMap.get(i)];
              break;

            case $x.TEXTURE:
              r = t.images[e.imageIndexMap.get(i)];
              break;

            case $x.ANIMATION:
              r = t.animations[e.animationIndexMap.get(i)];
              break;

            default:
              r = null, this.document.getLogger().warn(`[KHR_xmp_json_ld]: Unsupported parent property, "${i.propertyType}"`);
          }

          r && (r.extensions = r.extensions || {}, r.extensions.KHR_xmp_json_ld = {
            packet: n.length - 1
          });
        }
      }

      return n.length > 0 && (t.extensions = t.extensions || {}, t.extensions.KHR_xmp_json_ld = {
        packets: n
      }), this;
    }

  }

  mM.EXTENSION_NAME = _M;
  const gM = [Qw, rS, cS, hS, _S, xS, AS, zS, LS, WS, qS, QS, rM, sM, lM, pM, mM];

  class vM extends Px {
    constructor(e) {
      super(), this._loadedLibs = !1, e = e || {
        method: Qw.EncoderMethod.EDGEBREAKER,
        encodeSpeed: 5
      }, this._io = new pw().registerExtensions(gM).registerExtensions([yM, AM, MM, TM, EM, CM, RM, kM, PM, DM, OM, LM, IM, FM]), this._encoderOptions = e;
    }

    preload() {
      return this._loadLibs(), this;
    }

    async _loadLibs() {
      if (this._loadedLibs || !this.loader) return;
      const e = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
      this._io.registerDependencies({
        "draco3d.encoder": e[0],
        "draco3d.decoder": e[1]
      }), this._loadedLibs = !0;
    }

    async parseAsync(e, t) {
      if (!this.loader) return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e, t);
      await this._loadLibs();
      const n = await new Promise((n, r) => this.parse(e, n, r, t)),
            r = await super.parseAsync(n, t);
      if (!1 === t.compress) return r;
      if (!n) throw new Error("GLTFDracoExporter: gltf is null");
      let i = n;
      const s = i.byteLength || 1 / 0,
            o = await ("object" != typeof i || i.byteLength ? this._io.readBinary(new Uint8Array(i)) : this._io.readJSON({
        json: i,
        resources: {}
      }));
      if (o.createExtension(Qw).setRequired(!0).setEncoderOptions(this._encoderOptions), "glb" === t.exportExt) i = await this._io.writeBinary(o), isFinite(s) && console.log("DRACO Compression ratio: " + (i.byteLength / s).toFixed(5));else {
        const e = await this._io.writeJSON(o);
        i = e.json, Object.values(e.resources).filter(e => e).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), i.resources = e.resources);
      }
      i.__isGLTFOutput = !0;
      const a = await super.parseAsync(i, t);
      return a.__uncompressed = r, a;
    }

  }

  class bM extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this.dependencies = [Vs, jx];
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = e.getManager().importer;
      if (!t) throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
      !function (e, t) {
        Ox(e, vM, e => {
          const n = Be() + ".drc",
                r = e;
          r.loader = t.registerFile(n), r.loader.setDecoderConfig({
            type: "js"
          }), r.loader.preload(!0, !0);
        });
      }(e, t);
    }

  }

  bM.PluginType = "GLTFDracoExportPlugin";

  class xM extends Uy {
    constructor() {
      super(...arguments), this.extensionName = Jn, this.parentTypes = [$x.SCENE], this.propertyType = "ViewerJSON";
    }

    init() {}

  }

  class yM extends tw {
    constructor() {
      super(...arguments), this.extensionName = Jn, this._viewerConfig = {}, this._texturesRef = [], this.required = !0;
    }

    read(e) {
      var t;
      return this._viewerConfig = {}, null === (t = e.jsonDoc.json.scenes) || void 0 === t || t.forEach((t, n) => {
        if (t.extensions && t.extensions[Jn]) {
          const r = new xM(this.document.getGraph());
          e.scenes[n].setExtension(Jn, r);
          const i = t.extensions[Jn];
          this._viewerConfig = i;
        }
      }), this;
    }

    write(e) {
      return this.document.getRoot().listScenes().forEach(t => {
        var n;

        if (t.getExtension(Jn)) {
          const t = null === (n = e.jsonDoc.json.scenes) || void 0 === n ? void 0 : n[e.jsonDoc.json.scene || 0];
          t && this._viewerConfig !== {} && (t.extensions = t.extensions || {}, t.extensions[Jn] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {});
        }
      }), this;
    }

  }

  yM.EXTENSION_NAME = Jn;

  class wM extends Uy {
    constructor(e, t, n) {
      super(e, t), this.parentTypes = [$x.MATERIAL, $x.MESH, $x.NODE, $x.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = n;
    }

    addTexture(e, t, n, r = 4369) {
      this.setRef(e, n, {
        channels: r
      }), this.textures[e] = [t, n];
    }

    copy(e, t = Ry) {
      return super.copy(e, t), this;
    }

    dispose() {
      Object.values(this.textures).forEach(([e, t]) => {
        null == e || e.dispose();
      }), super.dispose();
    }

    init() {}

  }

  class SM extends tw {
    constructor() {
      super(...arguments), this.textureChannels = {};
    }

    read(e) {
      const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
      return n.forEach((t, n) => {
        var i, s;

        if (t.extensions && t.extensions[this.extensionName]) {
          const o = new wM(this.document.getGraph(), "", this.extensionName);
          e.materials[n].setExtension(this.extensionName, o);
          const a = { ...t.extensions[this.extensionName]
          };

          for (const [t, n] of Object.entries(a)) if ("number" == typeof (null == n ? void 0 : n.index)) {
            const l = n,
                  c = null === (i = r[l.index]) || void 0 === i ? void 0 : i.source;

            if ("number" != typeof c) {
              console.warn("GLTF Pipeline: source texture not found for texture info", l);
              continue;
            }

            const u = e.textures[c],
                  p = new By(this.document.getGraph()),
                  h = null !== (s = this.textureChannels[t]) && void 0 !== s ? s : 4369;
            o.addTexture(t, p, u, h), e.setTextureInfo(p, l), delete a[t];
          }

          o.setExtras(a);
        }
      }), (t.json.meshes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new wM(this.document.getGraph(), "", this.extensionName);
          e.meshes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), (t.json.nodes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new wM(this.document.getGraph(), "", this.extensionName);
          e.nodes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), (t.json.scenes || []).forEach((t, n) => {
        if (t.extensions && t.extensions[this.extensionName]) {
          const r = new wM(this.document.getGraph(), "", this.extensionName);
          e.scenes[n].setExtension(this.extensionName, r);
          const i = t.extensions[this.extensionName];
          r.setExtras(i);
        }
      }), this;
    }

    write(e) {
      const t = e.jsonDoc;
      return this.document.getRoot().listMaterials().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.materialIndexMap.get(n),
                s = t.json.materials[i];
          s.extensions = s.extensions || {};
          const o = { ...r.getExtras()
          };

          for (const [t, n] of Object.entries(r.textures)) {
            const r = n[0],
                  i = n[1];
            i && (o[t] = e.createTextureInfoDef(i, r));
          }

          s.extensions[this.extensionName] = o;
        }
      }), this.document.getRoot().listMeshes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.meshIndexMap.get(n),
                s = t.json.meshes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras();
        }
      }), this.document.getRoot().listNodes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const i = e.nodeIndexMap.get(n),
                s = t.json.nodes[i];
          s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras();
        }
      }), this.document.getRoot().listScenes().forEach(n => {
        const r = n.getExtension(this.extensionName);

        if (r) {
          const n = e.jsonDoc.json.scene || 0,
                i = t.json.scenes[n];
          if (!i) return;
          i.extensions = i.extensions || {}, i.extensions[this.extensionName] = r.getExtras();
        }
      }), this;
    }

  }

  class MM extends SM {
    constructor() {
      super(...arguments), this.extensionName = MM.EXTENSION_NAME, this.textureChannels = {
        bumpTexture: ty.R
      };
    }

  }

  MM.EXTENSION_NAME = or;

  class TM extends SM {
    constructor() {
      super(...arguments), this.extensionName = TM.EXTENSION_NAME, this.textureChannels = {
        lightMapTexture: ty.R | ty.G | ty.B
      };
    }

  }

  TM.EXTENSION_NAME = lr;

  class EM extends SM {
    constructor() {
      super(...arguments), this.extensionName = EM.EXTENSION_NAME, this.textureChannels = {
        alphaTexture: ty.G
      };
    }

  }

  EM.EXTENSION_NAME = ar;

  class AM extends SM {
    constructor() {
      super(...arguments), this.extensionName = AM.EXTENSION_NAME;
    }

  }

  AM.EXTENSION_NAME = Pa.DIAMOND_GLTF_EXTENSION;

  class CM extends SM {
    constructor() {
      super(...arguments), this.extensionName = CM.EXTENSION_NAME;
    }

  }

  CM.EXTENSION_NAME = wc.AnimationMarkersExtension;

  class RM extends SM {
    constructor() {
      super(...arguments), this.extensionName = RM.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: ty.R | ty.G | ty.B
      };
    }

  }

  RM.EXTENSION_NAME = kc.ANISOTROPY_GLTF_EXTENSION;

  class kM extends SM {
    constructor() {
      super(...arguments), this.extensionName = kM.EXTENSION_NAME, this.textureChannels = {
        anisotropyDirection: ty.R | ty.G | ty.B
      };
    }

  }

  kM.EXTENSION_NAME = dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION;

  class PM extends SM {
    constructor() {
      super(...arguments), this.extensionName = PM.EXTENSION_NAME;
    }

  }

  PM.EXTENSION_NAME = Qn;

  class DM extends SM {
    constructor() {
      super(...arguments), this.extensionName = DM.EXTENSION_NAME;
    }

  }

  DM.EXTENSION_NAME = er;

  class OM extends SM {
    constructor() {
      super(...arguments), this.extensionName = OM.EXTENSION_NAME;
    }

  }

  OM.EXTENSION_NAME = tr;

  class LM extends SM {
    constructor() {
      super(...arguments), this.extensionName = LM.EXTENSION_NAME;
    }

  }

  LM.EXTENSION_NAME = lu.CLEARCOAT_TINT_GLTF_EXTENSION;

  class IM extends SM {
    constructor() {
      super(...arguments), this.extensionName = IM.EXTENSION_NAME;
    }

  }

  IM.EXTENSION_NAME = ru.THIN_FILM_LAYER_GLTF_EXTENSION;

  class FM extends SM {
    constructor() {
      super(...arguments), this.extensionName = FM.EXTENSION_NAME;
    }

  }

  FM.EXTENSION_NAME = xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;

  class NM extends r {
    constructor() {
      super(...arguments), this.processor = {
        forAssetType: "texture",
        process: (e, t) => e
      };
    }

    async onAdded(e) {}

    async onDispose(e) {}

    async onRemove(e) {
      this._pmrem = void 0;
    }

  }

  NM.PluginType = "PMREMGenerator";
  const UM = 1e4,
        BM = 50;

  class jM {
    constructor(e = BM) {
      this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e);
    }

    setDecayTime(e) {
      this.naturalFrequency = 1 / Math.max(.001, e);
    }

    update(e, t, n, r) {
      const i = 2e-4 * this.naturalFrequency;
      if (null == e || 0 === r) return t;
      if (e === t && 0 === this.velocity) return t;
      if (n < 0) return e;
      const s = e - t,
            o = this.velocity + this.naturalFrequency * s,
            a = s + n * o,
            l = Math.exp(-this.naturalFrequency * n),
            c = (o - this.naturalFrequency * a) * l,
            u = -this.naturalFrequency * (c + o * l);
      return Math.abs(c) < i * Math.abs(r) && u * s >= 0 ? (this.velocity = 0, t) : (this.velocity = c, t + a * l);
    }

  }

  const zM = new i.Pa4();

  class VM {
    constructor() {
      this.inputSource = null, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new i.Pa4(), this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new i.Pa4(), this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = !1, this.placementComplete = !1, this.xr = null, this.session = null, this._hitPosition = new i.Pa4(), this._hitMatrix = new i.yGw(), this.xDamper = new jM(), this.yDamper = new jM(), this.zDamper = new jM(), this.yawDamper = new jM(), this.scaleDamper = new jM(), this.onSelectStart = e => {
        const t = this.transientHitTestSource;
        if (null == t) return;
        const n = this.frame.getHitTestResultsForTransientInput(t),
              r = this.presentedScene,
              i = this.placementBox;

        if (1 === n.length) {
          this.inputSource = e.inputSource;
          const {
            axes: t
          } = this.inputSource.gamepad || {
            axes: [0, 0]
          },
                n = i.getHit(r, t[0], t[1]);
          i.show = !0, null != n ? (this.isTranslating = !0, this.lastDragPosition.copy(n)) : this.placeOnWall || (this.isRotating = !0, this.lastAngle = 1.5 * t[0]);
        } else if (2 === n.length) {
          i.show = !0, this.isTwoFingering = !0;
          const {
            separation: e
          } = this.fingerPolar(n);
          this.firstRatio = e / r.scale.x;
        }
      }, this.onSelectEnd = () => {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1;
      };
    }

    async setSession(e, t, n, r) {
      var i;
      this.transientHitTestSource = await (null === (i = e.requestHitTestSourceForTransientInput) || void 0 === i ? void 0 : i.call(e, {
        profile: "generic-touchscreen"
      })), this.presentedScene = t, this.placementBox = r, this.xr = n, this.session = e, this.placementComplete = !1, this.goalPosition.copy(t.position), this.goalYaw = t.rotation.y, this.goalScale = t.scale.x, e.addEventListener("selectstart", this.onSelectStart), e.addEventListener("selectend", this.onSelectEnd);
    }

    cancel() {
      this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = !1, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = !1, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null);
    }

    getHitPoint(e) {
      var t;
      const n = null === (t = this.xr) || void 0 === t ? void 0 : t.getReferenceSpace(),
            r = n ? e.getPose(n) : null;
      return r ? (this._hitMatrix.fromArray(r.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > .75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null;
    }

    moveScene(e) {
      if (!this.session) return;
      const t = this.presentedScene,
            n = t.position,
            r = t.rotation.y,
            i = this.placementBox,
            s = Math.max(i.boundingSize.x, i.boundingSize.y, i.boundingSize.z) / 2,
            o = this.goalPosition,
            a = t.scale.x;

      if (!o.equals(n) || this.goalScale !== a) {
        let {
          x: r,
          y: l,
          z: c
        } = n;
        r = this.xDamper.update(r, o.x, e, s), l = this.yDamper.update(l, o.y, e, s), c = this.zDamper.update(c, o.z, e, s), n.set(r, l, c);
        const u = this.scaleDamper.update(a, this.goalScale, e, 1);

        if (t.scale.set(u, u, u), !this.isTranslating) {
          const e = o.y - l;
          this.placementComplete && !this.placeOnWall ? i.offsetHeight = e / u : 0 === e && (this.placementComplete = !0, i.show = !1);
        }
      }

      i.updateOpacity(e), t.rotation.y = this.yawDamper.update(r, this.goalYaw, e, Math.PI);
    }

    processInput(e) {
      var t;
      this.frame = e;
      const n = this.transientHitTestSource;
      if (!n) return;
      if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
      const r = e.getHitTestResultsForTransientInput(n),
            i = this.presentedScene,
            s = i.scale.x;
      if (this.isTwoFingering) {
        if (r.length < 2) this.isTwoFingering = !1;else {
          const {
            separation: e,
            deltaYaw: t
          } = this.fingerPolar(r);

          if (this.placeOnWall || (this.goalYaw += t), !i.userData.__scaleDisabled) {
            const t = e / this.firstRatio;
            this.goalScale = t < 1.3 && t > .7692307692307692 ? 1 : t;
          }
        }
      } else if (2 !== r.length) {
        if (this.isRotating && (null === (t = this.inputSource) || void 0 === t ? void 0 : t.gamepad)) {
          const e = 1.5 * this.inputSource.gamepad.axes[0];
          this.goalYaw += e - this.lastAngle, this.lastAngle = e;
        } else this.isTranslating && (console.log("translating"), r.forEach(e => {
          if (e.inputSource !== this.inputSource) return;
          let t = null;

          if (e.results.length > 0 && (t = this.getHitPoint(e.results[0])), null == t && (t = this.getTouchLocation()), null != t) {
            if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
              const e = t.y - this.lastDragPosition.y;

              if (e < 0) {
                this.placementBox.offsetHeight = e / s;
                const n = zM.copy(this.xr.getCamera().position),
                      r = -e / (n.y - t.y);
                n.multiplyScalar(r), t.multiplyScalar(1 - r).add(n);
              }
            }

            this.goalPosition.add(t), this.lastDragPosition.copy(t);
          }
        }));
      } else {
        this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
        const {
          separation: e
        } = this.fingerPolar(r);
        this.firstRatio = e / s;
      }
    }

    getTouchLocation() {
      var e, t;
      const {
        axes: n
      } = null !== (e = this.inputSource.gamepad) && void 0 !== e ? e : {
        axes: [0, 0]
      },
            r = this.placementBox.getExpandedHit(this.presentedScene, n[0], n[1]);
      return null != r && (zM.copy(r).sub(null === (t = this.xr) || void 0 === t ? void 0 : t.getCamera().position), zM.length() > 10) ? null : r;
    }

    fingerPolar(e) {
      var t, n, r, i, s, o;
      const a = null !== (r = null === (n = null === (t = e[0].inputSource) || void 0 === t ? void 0 : t.gamepad) || void 0 === n ? void 0 : n.axes) && void 0 !== r ? r : [0, 0],
            l = null !== (o = null === (s = null === (i = e[1].inputSource) || void 0 === i ? void 0 : i.gamepad) || void 0 === s ? void 0 : s.axes) && void 0 !== o ? o : [0, 0],
            c = l[0] - a[0],
            u = l[1] - a[1],
            p = Math.atan2(u, c);
      let h = this.lastAngle - p;
      return h > Math.PI ? h -= 2 * Math.PI : h < -Math.PI && (h += 2 * Math.PI), this.lastAngle = p, {
        separation: Math.sqrt(c * c + u * u),
        deltaYaw: h
      };
    }

  }

  const GM = .2,
        HM = Math.PI / 24,
        WM = new i.FM8(),
        KM = (e, t, n) => {
    let r = t > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;

    for (let i = 0; i <= 12; ++i) e.push(t + .17 * Math.cos(r), n + .17 * Math.sin(r), 0, t + GM * Math.cos(r), n + GM * Math.sin(r), 0), r += HM;
  };

  class XM extends i.Kj0 {
    constructor(e, t, n = !1) {
      super(((e, t) => {
        const n = new i.u9r(),
              r = [],
              s = [],
              o = e.getSize(new i.Pa4()),
              a = o.x / 2,
              l = (t ? o.y : o.z) / 2;
        KM(s, a, l), KM(s, -a, l), KM(s, -a, -l), KM(s, a, -l);
        const c = s.length / 3;

        for (let e = 0; e < c - 2; e += 2) r.push(e, e + 1, e + 3, e, e + 3, e + 2);

        const u = c - 2;
        return r.push(u, u + 1, 1, u, 1, 0), n.setAttribute("position", new i.a$l(s, 3)), n.setIndex(r), n;
      })(e, n)), this.boundingSize = new i.Pa4(), this._raycaster = new i.iMs(), this._camera = t, this._placeOnWall = n;
      const r = this.material;
      r.side = i.Wl3, r.color = new ve(16711935), r.opacity = 0, this.userData.bboxVisible = !1;
      const s = e.getSize(this.boundingSize);
      console.log(e, n, s, this);
      const o = s.x / 2,
            a = (n ? s.y : s.z) / 2;
      this.hitPlane = new i.Kj0(new i.BKK(2 * (o + GM), 2 * (a + GM))), this.hitPlane.visible = !1, this.add(this.hitPlane), e.getCenter(this.position), n ? (this.shadowHeight = e.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0;
    }

    getHit(e, t, n) {
      WM.set(t, -n), this.hitPlane.visible = !0;

      const r = this._positionAndNormalFromPoint(WM, this.hitPlane);

      return this.hitPlane.visible = !1, null == r ? null : r.position;
    }

    getExpandedHit(e, t, n) {
      this.hitPlane.scale.set(1e3, 1e3, 1e3);
      const r = this.getHit(e, t, n);
      return this.hitPlane.scale.set(1, 1, 1), r;
    }

    set offsetHeight(e) {
      e -= .001, this._placeOnWall ? this.position.z = this.shadowHeight + e : this.position.y = this.shadowHeight + e;
    }

    get offsetHeight() {
      return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }

    set show(e) {
      this.material.opacity = e ? .75 : 0;
    }

    get show() {
      return this.material.opacity > .01;
    }

    updateOpacity(e) {
      const t = this.material;
      this.visible = t.opacity > 0;
    }

    dispose() {
      var e;
      const {
        geometry: t,
        material: n
      } = this.hitPlane;
      t.dispose(), n.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e = this.parent) || void 0 === e || e.remove(this);
    }

    _positionAndNormalFromPoint(e, t) {
      if (!this._camera) return null;

      this._raycaster.setFromCamera(e, this._camera);

      const n = this._raycaster.intersectObject(t, !0);

      if (0 === n.length) return null;
      const r = n[0];
      return null == r.face ? null : null == r.uv ? {
        position: r.point,
        normal: r.face.normal,
        uv: null
      } : (r.face.normal.applyNormalMatrix(new i.Vkp().getNormalMatrix(r.object.matrixWorld)), {
        position: r.point,
        normal: r.face.normal,
        uv: r.uv
      });
    }

  }

  class qM extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this._touchInputHelper = new VM(), this._preRender = () => {
        if (!(this._dirty && this._viewer && this._xrManager && this._xrSession)) return;
        this._viewer.renderer.composer.renderToScreen = !1, this._xrManager.enabled = !1;

        const e = this._xrManager.getCamera(),
              t = e.cameras[0] || e,
              n = this._viewer.scene.activeCamera;

        n.cameraObject.projectionMatrix.copy(t.projectionMatrix), n.cameraObject.projectionMatrixInverse.copy(n.cameraObject.projectionMatrix).invert();
      }, this._postRender = () => {
        var e, t;
        if (!this._dirty || !this._viewer || !this._xrSession) return;

        this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();

        const n = this._viewer.renderer,
              r = null === (t = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera()) || void 0 === t ? void 0 : t.cameras[0].viewport;
        r ? n.rendererObject.setViewport(r) : console.warn("no viewport for ar camera"), K(n.rendererObject, {
          sceneRender: !0,
          opaqueRender: !0,
          shadowMapRender: !1,
          backgroundRender: !1,
          transparentRender: !1,
          transmissionRender: !1,
          screenSpaceRendering: !1
        }, () => {
          YM.render(n.rendererObject, null, n.composer.readBuffer, 0, !1);
        }), this._xrManager.enabled = !0, this._viewer.renderer.composer.renderToScreen = !0;
      }, this._frameCount = 0, this._lastTime = 0, this._preFrame = ({
        xrFrame: e,
        deltaTime: t
      }) => {
        var n, r;
        if (this.dirty = !!e && (null === (n = this._xrManager) || void 0 === n ? void 0 : n.isPresenting) || !1, this._viewer.scene.activeCamera.interactionsEnabled = !this._dirty, this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, !this._dirty || !e) return void (this._xrSession && this._xrSessionEnd());
        if (!this._xrSession && !this._xrManager.getSession()) return console.error("no xr session found, shouldn't happen"), void (this.dirty = !1);
        this._xrSession || console.log("webxr: AR session init"), this._frameCount++;

        const i = this._xrManager.getReferenceSpace(),
              s = e.getViewerPose(i);

        if (null == s && this._frameCount, null == s || 0 === (null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot.children.length)) return this.dirty = !1, void console.log("no pose or no model");

        if (!this._xrSession) {
          if (this._xrSession = this._xrManager.getSession() || void 0, !this._xrSession) return;
          this._frameCount = 0, this._cancelHitSources(), this._savePreXRState(), this._preSetupModel(), this._xrSessionStart();
        }

        const o = this._viewer.scene.activeCamera;
        this._xrManager.updateCamera(o.cameraObject), o.setDirty(), this.moveToFloor(e), this._touchInputHelper.processInput(e), this._touchInputHelper.moveScene(t), this._updateShadow();
      }, this.placeOnWall = !1, this._preXRState = {
        viewerBg: null,
        modelScale: new i.Pa4(1, 1, 1),
        modelPosition: new i.Pa4(),
        modelRotation: new i._fP(),
        cameraPosition: new i.Pa4(0, 0, 5),
        cameraTarget: new i.Pa4(),
        cameraUp: new i.Pa4(0, 1, 0),
        cameraAspect: 1,
        cameraFov: 50,
        cameraZoom: 1,
        cameraNear: .01,
        cameraFar: 100,
        groundOffset: new i.Pa4(),
        groundScale: 1
      }, this._savePreXRState = () => {
        if (!this._viewer) return;
        this._preXRState.viewerBg = this._viewer.getBackground(!0);
        const e = this._viewer.scene.modelRoot,
              t = this._viewer.scene.activeCamera;
        e.updateMatrix(), e.updateMatrixWorld(!0), this._preXRState.modelScale.copy(e.scale), this._preXRState.modelPosition.copy(e.position), this._preXRState.modelRotation.copy(e.quaternion), this._preXRState.cameraPosition.copy(t.position), this._preXRState.cameraTarget.copy(t.target), this._preXRState.cameraUp.copy(t.cameraObject.up), t.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = t.cameraObject.fov, this._preXRState.cameraAspect = t.cameraObject.aspect), this._preXRState.cameraZoom = t.cameraObject.zoom, this._preXRState.cameraNear = t.cameraObject.near, this._preXRState.cameraFar = t.cameraObject.far;

        const n = this._viewer.getPluginByType("Ground");

        (null == n ? void 0 : n.mesh) && (this._preXRState.groundOffset.subVectors(e.position, n.mesh.modelObject.position), this._preXRState.groundScale = n.mesh.modelObject.scale.x, console.log("ground offset", this._preXRState.groundOffset, this._preXRState.groundScale), n.shadowBaker.enabled = !1);
      }, this._xrSessionStart = () => {
        if (!this._xrSession || !this._viewer) return;
        console.log("webxr: AR session start");
        const e = 20 * Math.PI / 180,
              t = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), {
          x: 0,
          y: -Math.sin(e),
          z: -Math.cos(e)
        });
        this._touchInputHelper.placeOnWall = this.placeOnWall, this._viewer.resize(), (async () => {
          var e, n;

          if (this._xrSession) {
            const r = await this._xrSession.requestReferenceSpace("viewer");
            this._hitTestSource = await (null === (n = (e = this._xrSession).requestHitTestSource) || void 0 === n ? void 0 : n.call(e, {
              space: r,
              offsetRay: t
            }));
          }

          this._xrSession && (await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._xrManager, this._placementBox));
        })();
      }, this._xrSessionEnd = () => {
        var e;
        console.log("webxr: AR session end"), this._frameCount = 0, null === (e = this._xrSession) || void 0 === e || e.removeEventListener("end", this._xrSessionEnd), this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._restorePreXRState(), this._viewer.resize());
      };
    }

    async onAdded(e) {
      await super.onAdded(e);
      const t = e.renderer.rendererObject.xr;
      t.enabled = !0, t.cameraAutoUpdate = !1, this._xrManager = t;
      const n = document.getElementById("tweakpaneUiContainer"),
            r = n ? {
        root: n
      } : void 0;
      document.body.appendChild(class {
        static createButton(e, t = {}) {
          const n = document.createElement("button");

          function r() {
            n.style.display = "", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null;
          }

          function i(e) {
            e.style.position = "absolute", e.style.bottom = "20px", e.style.padding = "12px 6px", e.style.border = "1px solid #fff", e.style.borderRadius = "4px", e.style.background = "rgba(0,0,0,0.1)", e.style.color = "#fff", e.style.font = "normal 13px sans-serif", e.style.textAlign = "center", e.style.opacity = "0.5", e.style.outline = "none", e.style.zIndex = "999";
          }

          if ("xr" in navigator) return n.id = "ARButton", n.style.display = "none", i(n), navigator.xr.isSessionSupported("immersive-ar").then(function (i) {
            i ? function () {
              if (void 0 === t.domOverlay) {
                const e = document.createElement("div");
                e.style.display = "none", document.body.appendChild(e);
                const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                n.setAttribute("width", 38), n.setAttribute("height", 38), n.style.position = "absolute", n.style.right = "20px", n.style.top = "20px", n.addEventListener("click", function () {
                  r.end();
                }), e.appendChild(n);
                const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
                i.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), i.setAttribute("stroke", "#fff"), i.setAttribute("stroke-width", 2), n.appendChild(i), void 0 === t.optionalFeatures && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
                  root: e
                };
              }

              let r = null;

              async function i(i) {
                i.addEventListener("end", s), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(i), n.textContent = "STOP AR", t.domOverlay.root.style.display = "", r = i;
              }

              function s() {
                r.removeEventListener("end", s), n.textContent = "START AR", t.domOverlay.root.style.display = "none", r = null;
              }

              n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 50px)", n.style.width = "100px", n.textContent = "START AR", n.onmouseenter = function () {
                n.style.opacity = "1.0";
              }, n.onmouseleave = function () {
                n.style.opacity = "0.5";
              }, n.onclick = function () {
                null === r ? navigator.xr.requestSession("immersive-ar", t).then(i) : r.end();
              };
            }() : (r(), n.textContent = "AR NOT SUPPORTED");
          }).catch(function (e) {
            r(), console.warn("Exception when trying to call xr.isSessionSupported", e), n.textContent = "AR NOT ALLOWED";
          }), n;
          {
            const e = document.createElement("a");
            return !1 === window.isSecureContext ? (e.href = document.location.href.replace(/^http:/, "https:"), e.innerHTML = "WEBXR NEEDS HTTPS") : (e.href = "https://immersiveweb.dev/", e.innerHTML = "WEBXR NOT AVAILABLE"), e.style.left = "calc(50% - 90px)", e.style.width = "180px", e.style.textDecoration = "none", i(e), e;
          }
        }

      }.createButton(e.renderer.rendererObject, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: r
      })), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame);
    }

    _updateShadow() {
      if (!this._viewer) return;

      const e = this._viewer.scene.modelRoot,
            t = this._viewer.getPluginByType("Ground");

      t && (t.groundReflection = !1, t.mesh.modelObject.position.copy(this._preXRState.groundOffset).multiplyScalar(e.modelObject.scale.x).sub(e.modelObject.position).negate(), t.mesh.modelObject.scale.setScalar(e.modelObject.scale.x * this._preXRState.groundScale));
    }

    moveToFloor(e) {
      if (!this._dirty || !this._hitTestSource || !this._xrManager) return;
      const t = e.getHitTestResults(this._hitTestSource);
      if (!t.length) return;

      const n = t[0],
            r = this._touchInputHelper.getHitPoint(n);

      r && (this._placementBox.show = !0, this._viewer.scene.modelRoot, this.placeOnWall ? this._touchInputHelper.goalPosition.copy(r) : this._touchInputHelper.goalPosition.y = r.y, this._hitTestSource.cancel(), this._hitTestSource = void 0, console.log("move to initial hit point", r));
    }

    _removePlacementBox() {
      this._placementBox && (this._placementBox.dispose(), this._placementBox = void 0);
    }

    _preSetupModel() {
      var e;
      const t = this._viewer.scene.modelRoot,
            n = this._viewer.scene.activeCamera,
            r = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera(),
            s = r.cameras[0] || r;

      this._removePlacementBox();

      const o = this._viewer.scene.getBounds(!0, !0);

      o.getSize(new i.Pa4()).length() > .01 && (this._placementBox = new XM(o, r, this.placeOnWall), t.add(this._placementBox), this._placementBox.show = !1);
      const a = r.getWorldDirection(new i.Pa4());
      t.rotation.y = Math.atan2(-a.x, -a.z) - 0, n.cameraObject.zoom = s.zoom, n.cameraObject.near = s.near, n.cameraObject.far = s.far, n.cameraObject.isPerspectiveCamera ? (n.cameraObject.fov = s.fov, n.cameraObject.aspect = s.viewport.width / s.viewport.height) : console.warn("Perspective camera required."), n.cameraObject.updateProjectionMatrix(), t.position.set(0, 0, 0);
      const l = t.userData.arScale || 1;
      t.scale.set(l, l, l), t.position.copy(r.position).add(a.multiplyScalar(5)), t.visible = !0, this._viewer.setBackground(null);
    }

    _restorePreXRState() {
      if (!this._viewer) return;
      this._viewer.setBackground(this._preXRState.viewerBg), this._preXRState.viewerBg = null;
      const e = this._viewer.scene.modelRoot;
      e.scale.copy(this._preXRState.modelScale), e.position.copy(this._preXRState.modelPosition), e.quaternion.copy(this._preXRState.modelRotation), e.updateMatrix(), e.updateMatrixWorld(!0), e.visible = !0;
      const t = this._viewer.scene.activeCamera;
      t.position.copy(this._preXRState.cameraPosition), t.target.copy(this._preXRState.cameraTarget), t.cameraObject.up.copy(this._preXRState.cameraUp), t.cameraObject.near = this._preXRState.cameraNear, t.cameraObject.far = this._preXRState.cameraFar, t.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (t.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (t.cameraObject.aspect = this._preXRState.cameraAspect)), t.positionUpdated(!1), t.targetUpdated(!0), t.cameraObject.updateMatrixWorld(!0), t.cameraObject.updateProjectionMatrix();
    }

    _cancelHitSources() {
      this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel();
    }

  }

  qM.PluginType = "WEBXR_ARPlugin";
  const YM = new u({
    vertexShader: s.vertexShader,
    fragmentShader: "\n    uniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\t// gl_FragColor = vec4(1,0,1,1);\n\t\t\tgl_FragColor = texel;\n\n\t\t}\n\t\t",
    uniforms: s.uniforms
  });

  async function ZM(e, t) {
    if (e.createWriter) {
      const n = await e.createWriter();
      return await n.write(0, t), void (await n.close());
    }

    const n = await e.createWritable();
    await n.write(t), await n.close();
  }

  async function JM(e, t) {
    const n = {};
    return t && (n.writable = !0, n.mode = "readwrite"), "granted" === (await e.queryPermission(n)) || "granted" === (await e.requestPermission(n));
  }

  YM.renderToScreen = !1, YM.useExistingRenderTarget = !0, YM.clear = !1;

  class $M extends r {
    constructor(e, t) {
      super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = !1, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = e => {
        var t;

        if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
          const e = new Blob(this._currentRecording, {
            type: this._options.mimeType
          });
          null === (t = this._recordingCallback) || void 0 === t || t.call(this, e);
        } else this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);

        this._recorder = void 0, this.dispatchEvent({
          type: "stop"
        });
      }, this._onstart = e => {
        var t;
        this._state = "recording", this._frameCount = 0, this.dispatchEvent({
          type: "start"
        }), this.stepMode && (null === (t = this._recorder) || void 0 === t || t.pause());
      }, this._onresume = e => {
        if (!this.stepMode) return;

        const t = () => {
          var e;
          "recording" === this._state && (null === (e = this._recorder) || void 0 === e || e.pause());
        },
              n = Math.min(this._resumeSyncTime - Ct(), 0) + 1e3 / this._options.frameRate;

        n > 0 ? _c(n).then(t) : t();
      }, this._onpause = e => {}, this._ondataavailable = e => {
        e.data && e.data.size > 0 && this._currentRecording.push(e.data);
      }, this._onerror = e => {
        this._state = "error", this._console.error(e), this.dispatchEvent({
          type: "error",
          error: e
        }), this._recorder = void 0;
      }, this._canvas = e;
      const n = null == t ? void 0 : t.mimeType;
      this._options = {
        mimeType: n || "auto",
        frameRate: 30
      }, this._setOptions(t || this._options);
    }

    _setOptions(e) {
      var t, n;
      Object.assign(this._options, e), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t = $M.GetSupportedMimeTypes([], ["h264"], !0)) && void 0 !== t ? t : $M.GetSupportedMimeTypes(void 0, void 0, !0)), this._options.mimeType && !(null === (n = this._options.mimeType) || void 0 === n ? void 0 : n.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"));
    }

    setOptions(e) {
      this._setOptions(e);
    }

    isRecording() {
      return "recording" === this._state;
    }

    start() {
      var e, t, n;
      if ("recording" === this._state) return void this._console.log("Already recording canvas");
      if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder) return "paused" === this._state ? (this.dispatchEvent({
        type: "starting"
      }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
      if ("paused" === this._state) return this.dispatchEvent({
        type: "starting"
      }), void (this._state = "recording");
      const r = {
        mimeType: this._options.mimeType,
        videoBitsPerSecond: this._options.videoBitsPerSecond
      };

      if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e = r.mimeType) || void 0 === e ? void 0 : e.startsWith("video")) {
        if (!window.MediaRecorder) return this._console.error("MediaRecorder not supported, use image sequence"), void (this._state = "error");
        {
          const e = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate),
                n = null === (t = e.getVideoTracks()) || void 0 === t ? void 0 : t[0];

          this._track = n, this._recorder = new window.MediaRecorder(e, r), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart;
        }
      }

      this.dispatchEvent({
        type: "starting"
      }), this._recorder ? (this._state = "recording", null === (n = this._recorder) || void 0 === n || n.start()) : window.showDirectoryPicker && window.showDirectoryPicker().then(async e => {
        const t = await (null == e ? void 0 : e.getDirectoryHandle("i-" + Math.floor(Date.now()), {
          create: !0
        }));
        this._imgDirectory = t, this._state = "recording", this._onstart({});
      }).catch(e => {
        this._onerror({
          detail: e
        });
      });
    }

    async requestFrame() {
      if ("recording" !== this._state) return;
      this._frameCount++;
      const e = this._options.mimeType;

      if (!this._recorder && e.startsWith("image/")) {
        const t = this._canvas.toDataURL(e, 90);

        this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e.includes("png") ? ".png" : ".jpg"), t]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = []);
      }

      this._recorder && this._track && this.stepMode && (this._resumeSyncTime = Ct(), this._track.requestFrame(), this._recorder.resume());
    }

    pause() {
      "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused");
    }

    stop(e) {
      "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e, this.dispatchEvent({
        type: "stopping"
      }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."));
    }

    get state() {
      return this._state;
    }

    dispose() {
      this._recorder && "error" !== this._state ? this.stop(e => {
        this._console.warn("disposed with blob", e), this.dispose();
      }) : this._recorder = void 0;
    }

    async _writeImages(e) {
      if (!this._imgDirectory) return;
      const t = await Promise.all(e.map(async ([e, t]) => await (await fetch(t)).blob())),
            n = [];

      for (let r = 0; r < e.length; r++) {
        const i = await this._imgDirectory.getFileHandle(e[r][0], {
          create: !0
        });
        n.push(ZM(i, t[r]));
      }

      await Promise.all(n);
    }

    static GetSupportedMimeTypes(e, t, n = !1) {
      if (!window.MediaRecorder) return n ? void 0 : [];
      const r = ["webm", "ogg", "mp4", "x-matroska"].filter(t => !e || e.length < 1 || e.includes(t)),
            i = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter(e => !t || t.length < 1 || t.includes(e)),
            s = [];
      return r.forEach(e => {
        const t = `video/${e}`;
        i.forEach(e => {
          [`${t};codecs=${e}`, `${t};codecs:${e}`, `${t};codecs=${e.toUpperCase()}`, `${t};codecs:${e.toUpperCase()}`, `${t}`].forEach(e => {
            MediaRecorder.isTypeSupported(e) && s.push(e);
          });
        });
      }), n ? s.length > 0 ? s[0] : void 0 : s;
    }

  }

  var QM = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class eT extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this.convergeMode = !1, this.mimeType = "auto", this.videoFrameRate = 30, this._renderToScreenDisabled = !1, this._preRender = () => {
        var e, t, n;

        if (this.convergeMode && (null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording())) {
          const e = this._viewer.renderer.composer.renderToScreen;
          this._viewer.renderer.composer.renderToScreen = (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co)) || void 0 === n ? void 0 : n.isConverged()) || !1, e && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = !0);
        }
      }, this._postRender = () => {
        var e, t, n;

        if ((null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && (!this.convergeMode || (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co)) || void 0 === n ? void 0 : n.isConverged(!0)))) {
          const e = () => {
            var e;
            return null === (e = this._recorder) || void 0 === e ? void 0 : e.requestFrame();
          };

          this.convergeMode ? _c(1).then(e) : e();
        }

        this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = !0);
      };
    }

    get recorder() {
      return this._recorder;
    }

    isRecording() {
      var e, t;
      return null !== (t = null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && void 0 !== t && t;
    }

    refreshRecorderOptions() {
      this._recorder && (this._recorder.setOptions({
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), this._recorder.stepMode = this.convergeMode);
    }

    async onAdded(e) {
      await super.onAdded(e), this._recorder = new $M(e.canvas, {
        frameRate: this.videoFrameRate,
        mimeType: this.mimeType
      }), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), this._recorder.addEventListener("starting", () => this._stateChange(!1)), this._recorder.addEventListener("start", () => {
        this.dispatchEvent({
          type: "start"
        }), this._stateChange(!this.convergeMode);
      }), this._recorder.addEventListener("error", () => {
        this.dispatchEvent({
          type: "error"
        });
      }), this._recorder.addEventListener("pause", () => this._stateChange(!1)), this._recorder.addEventListener("resume", () => this._stateChange(!this.convergeMode)), this._recorder.addEventListener("stop", () => {
        this.dispatchEvent({
          type: "stop"
        }), this._stateChange(!1);
      });
    }

    _stateChange(e) {
      var t, n, r;
      this.dirty = e, null === (t = this._viewer) || void 0 === t || t.setDirty(), null === (r = null === (n = this._uiConfig) || void 0 === n ? void 0 : n.children) || void 0 === r || r.map(e => x(e)).flat(2).forEach(e => {
        var t;
        return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e);
      });
    }

    async onRemove(e) {
      var t;
      return e.removeEventListener("preRender", this._preRender), e.removeEventListener("preRender", this._postRender), null === (t = this._recorder) || void 0 === t || t.dispose(), super.onRemove(e);
    }

    startRecording() {
      var e;
      return !!this.enabled && !1 === (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) && (this.recorder.stepMode = this.convergeMode, this.recorder.start(), !0);
    }

    async stopRecording() {
      var e;
      if (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) return new Promise((e, t) => {
        var n;
        return null === (n = this.recorder) || void 0 === n ? void 0 : n.stop(e);
      });
    }

    get uiConfig() {
      var e;
      if (this._uiConfig) return this._uiConfig;
      const t = this;
      return this._uiConfig = {
        type: "folder",
        label: "Recorder",
        children: [{
          label: "Quality",
          type: "slider",
          bounds: [.1, 4],
          stepSize: .5,
          limitedUi: !0,
          property: [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer, "displayCanvasScaling"]
        }, {
          type: "slider",
          label: "Frame Rate",
          bounds: [1, 60],
          stepSize: 1,
          property: [this, "videoFrameRate"]
        }, {
          type: "checkbox",
          limitedUi: !0,
          property: [this, "convergeMode"]
        }, {
          type: "dropdown",
          label: "Mime type",
          limitedUi: !0,
          property: [this, "mimeType"],
          children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"]].map(e => ({
            label: e[0],
            value: e[1]
          }))
        }, {
          type: "input",
          disabled: !0,
          label: "State",
          limitedUi: !0,

          get value() {
            var e, n;
            return null !== (n = null === (e = t.recorder) || void 0 === e ? void 0 : e.state) && void 0 !== n ? n : "not initialized";
          },

          set value(e) {}

        }, {
          type: "button",

          get label() {
            var e;
            return (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? "Stop" : "Start";
          },

          value: () => {
            var e;
            (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? this.stopRecording().then(e => {
              if (e) {
                console.log(e);
                const t = e.type.split(";")[0].split("/").pop() || "mp4";
                vt(e, "test." + t);
              }
            }) : this.startRecording();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views",
          hidden: () => {
            var e, n;
            return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews"));
          },
          value: () => {
            var e, t;
            null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("CameraViews")) || void 0 === t || t.recordAllViews();
          }
        }, {
          type: "button",
          limitedUi: !0,
          label: "Record Camera Views + GLTF Anim",
          hidden: () => {
            var e, n, r, i;
            return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || !(null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("GLTFAnimation")) || void 0 === i ? void 0 : i.animations.length);
          },
          value: () => {
            var e, t, n, r;
            const i = "playing" === (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t ? void 0 : t.animationState);
            null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || void 0 === r || r.recordAllViews(() => {
              var e, t;
              null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.playAnimation();
            }).then(() => {
              var e, t;
              i || null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.stopAnimation();
            });
          }
        }]
      };
    }

  }

  eT.PluginType = "CanvasRecorder", QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "convergeMode", void 0), QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "mimeType", void 0), QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "videoFrameRate", void 0);

  var tT = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const nT = new i.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      h: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  nT.depthTest = !1;
  const rT = new i.jyz({
    uniforms: {
      tDiffuse: {
        value: null
      },
      v: {
        value: 1 / 512
      }
    },
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
  });
  rT.depthTest = !1;

  class iT extends q_ {
    constructor(e = {}, t = !1) {
      super(e), this.contactShadows = !0, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new i.iKG(-1, 1, 1, -1, .001, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t, t && this.dependencies.push(j_);
    }

    async onAdded(e) {
      const t = e.renderer.createTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 512,
          height: 512
        },
        generateMipmaps: !1,
        depthBuffer: !0,
        minFilter: i.wem,
        magFilter: i.wem,
        isAntialiased: !1
      });
      t.texture.name = "groundContactDepthTexture";
      const n = new i.lRF({
        depthPacking: i.z81
      });

      n.onBeforeCompile = function (e) {
        e.uniforms.opacity.value = 1, e.fragmentShader = `\n\t\t\t\t\t\t${e.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}\n\t\t\t\t\t`;
      };

      const r = new qs(t, n, new ve(0, 0, 0), 0);
      this._depthPass = r, await super.onAdded(e);
    }

    _postFrame() {
      super._postFrame(), this._viewer;
    }

    _preRender() {
      if (super._preRender(), !this._viewer) return;
      if (!this._depthPass) return;
      this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject);

      const e = this._viewer.renderer.getTempTarget({
        type: i.ywz,
        format: i.wk1,
        encoding: i.rnI,
        size: {
          width: 1024,
          height: 1024
        },
        generateMipmaps: !1,
        depthBuffer: !1,
        minFilter: i.wem,
        magFilter: i.wem,
        isAntialiased: !1
      });

      this._blurShadow(e), this._blurShadow(e, .4), this._viewer.renderer.releaseTempTarget(e);
    }

    _blurShadow(e, t = 1) {
      this._viewer && this._depthPass && (nT.uniforms.h.value = t * this.blurAmount / 256, rT.uniforms.v.value = t * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e, {
        material: nT,
        clear: !0
      }), this._viewer.renderer.blit(e.texture, this._depthPass.target, {
        material: rT,
        clear: !0
      }));
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    async onRemove(e) {
      return super.onRemove(e);
    }

    _refreshTransform() {
      super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new i.Pa4())), this.shadowCamera.setRotationFromEuler(new i.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size);
    }

    _refreshShadowCameraFrustum() {
      this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty());
    }

    _setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    _removeMaterial() {
      this._material && super._removeMaterial();
    }

    refreshOptions() {
      this._viewer && super.refreshOptions();
    }

    _refreshMaterial() {
      var e;
      if (!this._viewer) return !1;

      const t = super._refreshMaterial();

      return this._material ? (this._material.alphaMap = (null === (e = this._depthPass) || void 0 === e ? void 0 : e.target.texture) || null, t && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = !0, this._material.materialObject.userData.ssreflDisabled = !0, this._material.materialObject.userData.ssreflNonPhysical = !1), t) : t;
    }

    _extraUiConfig() {
      return [{
        label: "Contact Shadows",
        type: "checkbox",
        property: [this, "contactShadows"]
      }, {
        label: "Shadow Scale",
        type: "slider",
        bounds: [0, 2],
        property: [this, "shadowScale"]
      }, {
        label: "Shadow Height",
        type: "slider",
        bounds: [0, 20],
        property: [this, "shadowHeight"]
      }, {
        label: "Blur Amount",
        type: "slider",
        bounds: [0, 10],
        property: [this, "blurAmount"]
      }, ...super._extraUiConfig()];
    }

  }

  iT.PluginType = "ContactShadowGroundPlugin", tT([C(iT.prototype.refreshOptions), xe()], iT.prototype, "contactShadows", void 0), tT([xe(), C(iT.prototype._setDirty)], iT.prototype, "blurAmount", void 0), tT([xe(), C(iT.prototype._refreshShadowCameraFrustum)], iT.prototype, "shadowScale", void 0), tT([xe(), C(iT.prototype._refreshShadowCameraFrustum)], iT.prototype, "shadowHeight", void 0);
  const sT = new i.cPb(45, 1, .1, 1e3);

  function oT(e, t, n, r = 7, s = new i.Pa4(0, 0, 1.5)) {
    n = null != n ? n : e.scene;
    const o = new P().expandByObject(null != n ? n : t, !0, !0),
          a = o.getCenter(new i.Pa4()),
          l = o.getSize(new i.Pa4());
    sT.position.copy(a).add(s.clone().multiplyScalar(Math.max(l.x, l.y, l.z))), sT.lookAt(a), t && t.traverseVisible(e => {
      e.layers.enable(r);
    }), r > 0 ? sT.layers.set(r) : sT.layers.enableAll();
    const c = null == t ? void 0 : t.visible;
    t && (t.visible = !0), e.renderer.rendererObject.setRenderTarget(null), e.renderer.rendererObject.render(n, sT);
    const u = e.renderer.rendererObject.domElement.toDataURL("image/png");
    return t && (t.visible = c, t.traverseVisible(e => {
      e.layers.disable(r);
    }), sT.layers.enableAll()), e.setDirty(), u;
  }

  class aT {
    constructor(e) {
      this.viewer = e, this._lights = [], this.shapes = {
        sphere: new i.Kj0(new i.xo$(1)),
        cube: new i.Kj0(new i.DvJ(1, 1, 1)),
        cylinder: new i.Kj0(new i.fHI(.5, .5, 1))
      };
      const t = new i.xsS();
      this._channel = 7;
      const n = new i.vmT(16777215, 4473924, 1);
      n.position.set(0, 10, 0), n.layers.set(this._channel), t.add(n), this._lights.push(n), this._scene = t;
    }

    dispose() {
      this._lights.forEach(e => e.dispose()), Object.values(this.shapes).forEach(e => {
        e.geometry && e.geometry.dispose();
      });
    }

    generate(e, t = "sphere") {
      const n = this.shapes[t] || new i.Kj0(new i.xo$(1));
      n.material = e.materialObject, this._scene.add(n), this._scene.environment = this.viewer.scene.getEnvironment();
      const r = n.material.envMapIntensity;
      "number" == typeof r && (n.material.envMapIntensity = Math.max(r, 2));
      const s = oT(this.viewer, n, this._scene, this._channel, new i.Pa4(0, 0, 1.5));
      return "number" == typeof r && (n.material.envMapIntensity = r), this._scene.remove(n), n.material = void 0, s;
    }

  }

  class lT extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e));
      }, this.dependencies = [Vs], this.variations = [], this._selectedMaterial = () => {
        var e, t;
        return (null === (t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0 === t ? void 0 : t.material) || void 0;
      }, this.uiConfig = {
        label: "Material Configurator",
        type: "folder",
        children: [() => {
          var e;
          return [{
            type: "input",
            label: "uuid",
            property: [this._selectedMaterial(), "uuid"],
            hidden: () => !this._selectedMaterial(),
            disabled: !0
          }, {
            type: "input",
            label: "title",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "title"],
            onChange: async () => this.refreshUi()
          }, {
            type: "dropdown",
            label: "Preview Type",
            hidden: () => !this._selectedMaterial(),
            property: () => [this.getSelectedVariation(), "preview"],
            onChange: async () => this.refreshUi(),
            children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Ht).filter(e => e.endsWith("Map"))].map(e => ({
              label: e,
              value: e
            }))
          }, ...((null === (e = this.getSelectedVariation()) || void 0 === e ? void 0 : e.materials.map(e => Object.assign(e.uiConfig, {
            expanded: !1
          }))) || []), {
            type: "button",
            label: "Remove All",
            hidden: () => !this._selectedMaterial(),
            value: () => {
              const e = this.getSelectedVariation();
              e && confirm("Remove all for this material?") && (e.materials = []), this.refreshUi();
            }
          }, {
            type: "button",
            label: "Remove Variation",
            hidden: () => !this._selectedMaterial(),
            value: () => {
              const e = this.getSelectedVariation();
              e && confirm("Remove this variation?") && this.removeVariation(e);
            }
          }, {
            type: "button",
            label: "Add Variation",
            hidden: () => !this._selectedMaterial(),
            value: () => this.addVariation(this._selectedMaterial())
          }, {
            type: "button",
            label: "Refresh Ui",
            value: () => this.refreshUi()
          }];
        }]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new aT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }

    async onRemove(e) {
      var t, n;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }

    findVariation(e) {
      return e ? this.variations.find(t => t.uuid === e) : void 0;
    }

    getSelectedVariation() {
      var e, t;
      return this.findVariation(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid) || this.findVariation(null === (t = this._selectedMaterial()) || void 0 === t ? void 0 : t.name);
    }

    applyVariation(e, t) {
      var n, r;
      const i = e.materials.find(e => e.uuid === t);

      if (i) {
        const t = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials;
        let s = null == t ? void 0 : t.findMaterialsByName(e.uuid);
        (!s || s.length < 1) && (s = [null == t ? void 0 : t.findMaterial(e.uuid)]), s.forEach(e => {
          if (!e) return;
          const t = e.name;
          e.copyProps(i), e.name = t;
        });
      }
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    async _refreshUi() {
      return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = !1, this._refreshUiConfig(), 0));
    }

    removeVariationForMaterial(e) {
      let t = this.findVariation(e.uuid);
      !t && e.name.length > 0 && (t = this.findVariation(e.name)), t && this.removeVariation(t);
    }

    removeVariation(e) {
      e && (this.variations.splice(this.variations.indexOf(e), 1), this.refreshUi());
    }

    addVariation(e) {
      var t;
      const n = null === (t = null == e ? void 0 : e.clone) || void 0 === t ? void 0 : t.call(e);

      if (e && n) {
        let t = this.findVariation(e.uuid);
        !t && e.name.length > 0 && (t = this.findVariation(e.name)), t || this.variations.push(t = {
          uuid: e.name.length > 0 ? e.name : e.uuid,
          title: "Name",
          preview: "generate:sphere",
          materials: []
        }), t.materials.push(n), this.refreshUi();
      }
    }

  }

  lT.PluginType = "MaterialConfiguratorBasePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], lT.prototype, "variations", void 0);

  const cT = (e, t = !0) => {
    const n = new ve().set(e);
    return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`;
  },
        uT = (e, t = !0) => {
    const n = new ve().set(e);
    return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`;
  },
        pT = e => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e}%3C/text%3E%3C/svg%3E%0A`,
        hT = async (e, t) => Ot(await St(e), t),
        dT = async (e, t) => await hT(e, t).then(e => e.toDataURL("image/png"));

  class fT {
    static _initialize() {
      this._inited = !0, Mt(T`
  .customContextGrid {
    background: #28223C;
    //backdrop-filter: blur(8px);
    border: 0.5px solid rgba(220, 220, 220, 0.3);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);

    color: white;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }
  .customContextGridItems:hover {
    color: white;
    background-color: #017AFF;
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 0.12rem;
    font-size: 0.85rem;
  }

        `);
    }

    static Create(e, t, n, r, i, s, o) {
      var a;
      this._inited || this._initialize();
      const l = Rt(),
            c = l ? .15 : .25,
            u = l ? 1.5 : 2.5,
            p = wt({
        classList: ["customContextGrid"],
        addToBody: !1,
        innerHTML: `\n            <div class="customContextGridHeading"> ${t} </div>\n            `
      });
      p.style.top = i + "px", p.style.left = r + "px", p.style.gap = c + "rem", p.style.width = (u + c) * n - c + "rem", p.dataset.tag = e;

      for (const e of s) {
        const t = wt({
          classList: ["customContextGridItems"],
          addToBody: !1,
          innerHTML: `\n            <img src="${e.image}" class="customContextGridItemImage">\n            `
        });
        t.style.width = u + "rem", t.style.height = u + "rem", p.appendChild(t), t.onclick = () => {
          var t;
          return null === (t = e.onClick) || void 0 === t ? void 0 : t.call(e, e.id);
        }, o(t, e);
      }

      return null === (a = this.Elements) || void 0 === a || a.push(p), p;
    }

    static RemoveAll(e) {
      if (e) {
        const t = this.Elements.filter(t => t.dataset.tag === e);

        for (const e of t) e.remove();

        this.Elements = this.Elements.filter(t => t.dataset.tag !== e);
      } else {
        for (const e of this.Elements) e.remove();

        this.Elements = [];
      }
    }

    static RebuildUi(e) {
      if (0 === this.Elements.length) return;
      e || (e = document.body);

      for (const e of this.Elements) e.remove();

      let t = 20;

      for (const n of this.Elements) n.style.top = t + "px", e.appendChild(n), t += n.clientHeight + 20;
    }

  }

  function _T(e) {
    if (null == e) return window;

    if ("[object Window]" !== e.toString()) {
      var t = e.ownerDocument;
      return t && t.defaultView || window;
    }

    return e;
  }

  function mT(e) {
    return e instanceof _T(e).Element || e instanceof Element;
  }

  function gT(e) {
    return e instanceof _T(e).HTMLElement || e instanceof HTMLElement;
  }

  function vT(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof _T(e).ShadowRoot || e instanceof ShadowRoot);
  }

  fT.Elements = [], fT._inited = !1;
  var bT = Math.max,
      xT = Math.min,
      yT = Math.round;

  function wT(e, t) {
    void 0 === t && (t = !1);
    var n = e.getBoundingClientRect(),
        r = 1,
        i = 1;

    if (gT(e) && t) {
      var s = e.offsetHeight,
          o = e.offsetWidth;
      o > 0 && (r = yT(n.width) / o || 1), s > 0 && (i = yT(n.height) / s || 1);
    }

    return {
      width: n.width / r,
      height: n.height / i,
      top: n.top / i,
      right: n.right / r,
      bottom: n.bottom / i,
      left: n.left / r,
      x: n.left / r,
      y: n.top / i
    };
  }

  function ST(e) {
    var t = _T(e);

    return {
      scrollLeft: t.pageXOffset,
      scrollTop: t.pageYOffset
    };
  }

  function MT(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }

  function TT(e) {
    return ((mT(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }

  function ET(e) {
    return wT(TT(e)).left + ST(e).scrollLeft;
  }

  function AT(e) {
    return _T(e).getComputedStyle(e);
  }

  function CT(e) {
    var t = AT(e),
        n = t.overflow,
        r = t.overflowX,
        i = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r);
  }

  function RT(e, t, n) {
    void 0 === n && (n = !1);

    var r,
        i,
        s = gT(t),
        o = gT(t) && function (e) {
      var t = e.getBoundingClientRect(),
          n = yT(t.width) / e.offsetWidth || 1,
          r = yT(t.height) / e.offsetHeight || 1;
      return 1 !== n || 1 !== r;
    }(t),
        a = TT(t),
        l = wT(e, o),
        c = {
      scrollLeft: 0,
      scrollTop: 0
    },
        u = {
      x: 0,
      y: 0
    };

    return (s || !s && !n) && (("body" !== MT(t) || CT(a)) && (c = (r = t) !== _T(r) && gT(r) ? {
      scrollLeft: (i = r).scrollLeft,
      scrollTop: i.scrollTop
    } : ST(r)), gT(t) ? ((u = wT(t, !0)).x += t.clientLeft, u.y += t.clientTop) : a && (u.x = ET(a))), {
      x: l.left + c.scrollLeft - u.x,
      y: l.top + c.scrollTop - u.y,
      width: l.width,
      height: l.height
    };
  }

  function kT(e) {
    var t = wT(e),
        n = e.offsetWidth,
        r = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: r
    };
  }

  function PT(e) {
    return "html" === MT(e) ? e : e.assignedSlot || e.parentNode || (vT(e) ? e.host : null) || TT(e);
  }

  function DT(e) {
    return ["html", "body", "#document"].indexOf(MT(e)) >= 0 ? e.ownerDocument.body : gT(e) && CT(e) ? e : DT(PT(e));
  }

  function OT(e, t) {
    var n;
    void 0 === t && (t = []);

    var r = DT(e),
        i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
        s = _T(r),
        o = i ? [s].concat(s.visualViewport || [], CT(r) ? r : []) : r,
        a = t.concat(o);

    return i ? a : a.concat(OT(PT(o)));
  }

  function LT(e) {
    return ["table", "td", "th"].indexOf(MT(e)) >= 0;
  }

  function IT(e) {
    return gT(e) && "fixed" !== AT(e).position ? e.offsetParent : null;
  }

  function FT(e) {
    for (var t = _T(e), n = IT(e); n && LT(n) && "static" === AT(n).position;) n = IT(n);

    return n && ("html" === MT(n) || "body" === MT(n) && "static" === AT(n).position) ? t : n || function (e) {
      var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && gT(e) && "fixed" === AT(e).position) return null;
      var n = PT(e);

      for (vT(n) && (n = n.host); gT(n) && ["html", "body"].indexOf(MT(n)) < 0;) {
        var r = AT(n);
        if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n;
        n = n.parentNode;
      }

      return null;
    }(e) || t;
  }

  var NT = "top",
      UT = "bottom",
      BT = "right",
      jT = "left",
      zT = "auto",
      VT = [NT, UT, BT, jT],
      GT = "start",
      HT = "end",
      WT = "clippingParents",
      KT = "viewport",
      XT = "popper",
      qT = "reference",
      YT = VT.reduce(function (e, t) {
    return e.concat([t + "-" + GT, t + "-" + HT]);
  }, []),
      ZT = [].concat(VT, [zT]).reduce(function (e, t) {
    return e.concat([t, t + "-" + GT, t + "-" + HT]);
  }, []),
      JT = "beforeRead",
      $T = "read",
      QT = "afterRead",
      eE = "beforeMain",
      tE = "main",
      nE = "afterMain",
      rE = "beforeWrite",
      iE = "write",
      sE = "afterWrite",
      oE = [JT, $T, QT, eE, tE, nE, rE, iE, sE];

  function aE(e) {
    var t = new Map(),
        n = new Set(),
        r = [];

    function i(e) {
      n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
        if (!n.has(e)) {
          var r = t.get(e);
          r && i(r);
        }
      }), r.push(e);
    }

    return e.forEach(function (e) {
      t.set(e.name, e);
    }), e.forEach(function (e) {
      n.has(e.name) || i(e);
    }), r;
  }

  function lE(e) {
    var t;
    return function () {
      return t || (t = new Promise(function (n) {
        Promise.resolve().then(function () {
          t = void 0, n(e());
        });
      })), t;
    };
  }

  var cE = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };

  function uE() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];

    return !t.some(function (e) {
      return !(e && "function" == typeof e.getBoundingClientRect);
    });
  }

  function pE(e) {
    void 0 === e && (e = {});
    var t = e,
        n = t.defaultModifiers,
        r = void 0 === n ? [] : n,
        i = t.defaultOptions,
        s = void 0 === i ? cE : i;
    return function (e, t, n) {
      void 0 === n && (n = s);
      var i = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, cE, s),
        modifiersData: {},
        elements: {
          reference: e,
          popper: t
        },
        attributes: {},
        styles: {}
      },
          o = [],
          a = !1,
          l = {
        state: i,
        setOptions: function (n) {
          var a = "function" == typeof n ? n(i.options) : n;
          c(), i.options = Object.assign({}, s, i.options, a), i.scrollParents = {
            reference: mT(e) ? OT(e) : e.contextElement ? OT(e.contextElement) : [],
            popper: OT(t)
          };

          var u,
              p,
              h = function (e) {
            var t = aE(e);
            return oE.reduce(function (e, n) {
              return e.concat(t.filter(function (e) {
                return e.phase === n;
              }));
            }, []);
          }((u = [].concat(r, i.options.modifiers), p = u.reduce(function (e, t) {
            var n = e[t.name];
            return e[t.name] = n ? Object.assign({}, n, t, {
              options: Object.assign({}, n.options, t.options),
              data: Object.assign({}, n.data, t.data)
            }) : t, e;
          }, {}), Object.keys(p).map(function (e) {
            return p[e];
          })));

          return i.orderedModifiers = h.filter(function (e) {
            return e.enabled;
          }), i.orderedModifiers.forEach(function (e) {
            var t = e.name,
                n = e.options,
                r = void 0 === n ? {} : n,
                s = e.effect;

            if ("function" == typeof s) {
              var a = s({
                state: i,
                name: t,
                instance: l,
                options: r
              });
              o.push(a || function () {});
            }
          }), l.update();
        },
        forceUpdate: function () {
          if (!a) {
            var e = i.elements,
                t = e.reference,
                n = e.popper;

            if (uE(t, n)) {
              i.rects = {
                reference: RT(t, FT(n), "fixed" === i.options.strategy),
                popper: kT(n)
              }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach(function (e) {
                return i.modifiersData[e.name] = Object.assign({}, e.data);
              });

              for (var r = 0; r < i.orderedModifiers.length; r++) if (!0 !== i.reset) {
                var s = i.orderedModifiers[r],
                    o = s.fn,
                    c = s.options,
                    u = void 0 === c ? {} : c,
                    p = s.name;
                "function" == typeof o && (i = o({
                  state: i,
                  options: u,
                  name: p,
                  instance: l
                }) || i);
              } else i.reset = !1, r = -1;
            }
          }
        },
        update: lE(function () {
          return new Promise(function (e) {
            l.forceUpdate(), e(i);
          });
        }),
        destroy: function () {
          c(), a = !0;
        }
      };
      if (!uE(e, t)) return l;

      function c() {
        o.forEach(function (e) {
          return e();
        }), o = [];
      }

      return l.setOptions(n).then(function (e) {
        !a && n.onFirstUpdate && n.onFirstUpdate(e);
      }), l;
    };
  }

  var hE = pE(),
      dE = {
    passive: !0
  },
      fE = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (e) {
      var t = e.state,
          n = e.instance,
          r = e.options,
          i = r.scroll,
          s = void 0 === i || i,
          o = r.resize,
          a = void 0 === o || o,
          l = _T(t.elements.popper),
          c = [].concat(t.scrollParents.reference, t.scrollParents.popper);

      return s && c.forEach(function (e) {
        e.addEventListener("scroll", n.update, dE);
      }), a && l.addEventListener("resize", n.update, dE), function () {
        s && c.forEach(function (e) {
          e.removeEventListener("scroll", n.update, dE);
        }), a && l.removeEventListener("resize", n.update, dE);
      };
    },
    data: {}
  };

  function _E(e) {
    return e.split("-")[0];
  }

  function mE(e) {
    return e.split("-")[1];
  }

  function gE(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
  }

  function vE(e) {
    var t,
        n = e.reference,
        r = e.element,
        i = e.placement,
        s = i ? _E(i) : null,
        o = i ? mE(i) : null,
        a = n.x + n.width / 2 - r.width / 2,
        l = n.y + n.height / 2 - r.height / 2;

    switch (s) {
      case NT:
        t = {
          x: a,
          y: n.y - r.height
        };
        break;

      case UT:
        t = {
          x: a,
          y: n.y + n.height
        };
        break;

      case BT:
        t = {
          x: n.x + n.width,
          y: l
        };
        break;

      case jT:
        t = {
          x: n.x - r.width,
          y: l
        };
        break;

      default:
        t = {
          x: n.x,
          y: n.y
        };
    }

    var c = s ? gE(s) : null;

    if (null != c) {
      var u = "y" === c ? "height" : "width";

      switch (o) {
        case GT:
          t[c] = t[c] - (n[u] / 2 - r[u] / 2);
          break;

        case HT:
          t[c] = t[c] + (n[u] / 2 - r[u] / 2);
      }
    }

    return t;
  }

  var bE = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: function (e) {
      var t = e.state,
          n = e.name;
      t.modifiersData[n] = vE({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
      });
    },
    data: {}
  },
      xE = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };

  function yE(e) {
    var t,
        n = e.popper,
        r = e.popperRect,
        i = e.placement,
        s = e.variation,
        o = e.offsets,
        a = e.position,
        l = e.gpuAcceleration,
        c = e.adaptive,
        u = e.roundOffsets,
        p = e.isFixed,
        h = o.x,
        d = void 0 === h ? 0 : h,
        f = o.y,
        _ = void 0 === f ? 0 : f,
        m = "function" == typeof u ? u({
      x: d,
      y: _
    }) : {
      x: d,
      y: _
    };

    d = m.x, _ = m.y;
    var g = o.hasOwnProperty("x"),
        v = o.hasOwnProperty("y"),
        b = jT,
        x = NT,
        y = window;

    if (c) {
      var w = FT(n),
          S = "clientHeight",
          M = "clientWidth";
      w === _T(n) && "static" !== AT(w = TT(n)).position && "absolute" === a && (S = "scrollHeight", M = "scrollWidth"), w = w, (i === NT || (i === jT || i === BT) && s === HT) && (x = UT, _ -= (p && w === y && y.visualViewport ? y.visualViewport.height : w[S]) - r.height, _ *= l ? 1 : -1), i !== jT && (i !== NT && i !== UT || s !== HT) || (b = BT, d -= (p && w === y && y.visualViewport ? y.visualViewport.width : w[M]) - r.width, d *= l ? 1 : -1);
    }

    var T,
        E = Object.assign({
      position: a
    }, c && xE),
        A = !0 === u ? function (e) {
      var t = e.x,
          n = e.y,
          r = window.devicePixelRatio || 1;
      return {
        x: yT(t * r) / r || 0,
        y: yT(n * r) / r || 0
      };
    }({
      x: d,
      y: _
    }) : {
      x: d,
      y: _
    };
    return d = A.x, _ = A.y, l ? Object.assign({}, E, ((T = {})[x] = v ? "0" : "", T[b] = g ? "0" : "", T.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + _ + "px)" : "translate3d(" + d + "px, " + _ + "px, 0)", T)) : Object.assign({}, E, ((t = {})[x] = v ? _ + "px" : "", t[b] = g ? d + "px" : "", t.transform = "", t));
  }

  var wE = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = n.gpuAcceleration,
          i = void 0 === r || r,
          s = n.adaptive,
          o = void 0 === s || s,
          a = n.roundOffsets,
          l = void 0 === a || a,
          c = {
        placement: _E(t.placement),
        variation: mE(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: i,
        isFixed: "fixed" === t.options.strategy
      };
      null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, yE(Object.assign({}, c, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: l
      })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, yE(Object.assign({}, c, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
      })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
      });
    },
    data: {}
  },
      SE = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (e) {
      var t = e.state;
      Object.keys(t.elements).forEach(function (e) {
        var n = t.styles[e] || {},
            r = t.attributes[e] || {},
            i = t.elements[e];
        gT(i) && MT(i) && (Object.assign(i.style, n), Object.keys(r).forEach(function (e) {
          var t = r[e];
          !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
        }));
      });
    },
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () {
        Object.keys(t.elements).forEach(function (e) {
          var r = t.elements[e],
              i = t.attributes[e] || {},
              s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
            return e[t] = "", e;
          }, {});
          gT(r) && MT(r) && (Object.assign(r.style, s), Object.keys(i).forEach(function (e) {
            r.removeAttribute(e);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  },
      ME = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name,
          i = n.offset,
          s = void 0 === i ? [0, 0] : i,
          o = ZT.reduce(function (e, n) {
        return e[n] = function (e, t, n) {
          var r = _E(e),
              i = [jT, NT].indexOf(r) >= 0 ? -1 : 1,
              s = "function" == typeof n ? n(Object.assign({}, t, {
            placement: e
          })) : n,
              o = s[0],
              a = s[1];

          return o = o || 0, a = (a || 0) * i, [jT, BT].indexOf(r) >= 0 ? {
            x: a,
            y: o
          } : {
            x: o,
            y: a
          };
        }(n, t.rects, s), e;
      }, {}),
          a = o[t.placement],
          l = a.x,
          c = a.y;
      null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = o;
    }
  },
      TE = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };

  function EE(e) {
    return e.replace(/left|right|bottom|top/g, function (e) {
      return TE[e];
    });
  }

  var AE = {
    start: "end",
    end: "start"
  };

  function CE(e) {
    return e.replace(/start|end/g, function (e) {
      return AE[e];
    });
  }

  function RE(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;

    if (n && vT(n)) {
      var r = t;

      do {
        if (r && e.isSameNode(r)) return !0;
        r = r.parentNode || r.host;
      } while (r);
    }

    return !1;
  }

  function kE(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }

  function PE(e, t) {
    return t === KT ? kE(function (e) {
      var t = _T(e),
          n = TT(e),
          r = t.visualViewport,
          i = n.clientWidth,
          s = n.clientHeight,
          o = 0,
          a = 0;

      return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
        width: i,
        height: s,
        x: o + ET(e),
        y: a
      };
    }(e)) : mT(t) ? function (e) {
      var t = wT(e);
      return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
    }(t) : kE(function (e) {
      var t,
          n = TT(e),
          r = ST(e),
          i = null == (t = e.ownerDocument) ? void 0 : t.body,
          s = bT(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
          o = bT(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
          a = -r.scrollLeft + ET(e),
          l = -r.scrollTop;
      return "rtl" === AT(i || n).direction && (a += bT(n.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: a,
        y: l
      };
    }(TT(e)));
  }

  function DE(e) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e);
  }

  function OE(e, t) {
    return t.reduce(function (t, n) {
      return t[n] = e, t;
    }, {});
  }

  function LE(e, t) {
    void 0 === t && (t = {});

    var n = t,
        r = n.placement,
        i = void 0 === r ? e.placement : r,
        s = n.boundary,
        o = void 0 === s ? WT : s,
        a = n.rootBoundary,
        l = void 0 === a ? KT : a,
        c = n.elementContext,
        u = void 0 === c ? XT : c,
        p = n.altBoundary,
        h = void 0 !== p && p,
        d = n.padding,
        f = void 0 === d ? 0 : d,
        _ = DE("number" != typeof f ? f : OE(f, VT)),
        m = u === XT ? qT : XT,
        g = e.rects.popper,
        v = e.elements[h ? m : u],
        b = function (e, t, n) {
      var r = "clippingParents" === t ? function (e) {
        var t = OT(PT(e)),
            n = ["absolute", "fixed"].indexOf(AT(e).position) >= 0 && gT(e) ? FT(e) : e;
        return mT(n) ? t.filter(function (e) {
          return mT(e) && RE(e, n) && "body" !== MT(e);
        }) : [];
      }(e) : [].concat(t),
          i = [].concat(r, [n]),
          s = i[0],
          o = i.reduce(function (t, n) {
        var r = PE(e, n);
        return t.top = bT(r.top, t.top), t.right = xT(r.right, t.right), t.bottom = xT(r.bottom, t.bottom), t.left = bT(r.left, t.left), t;
      }, PE(e, s));
      return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
    }(mT(v) ? v : v.contextElement || TT(e.elements.popper), o, l),
        x = wT(e.elements.reference),
        y = vE({
      reference: x,
      element: g,
      strategy: "absolute",
      placement: i
    }),
        w = kE(Object.assign({}, g, y)),
        S = u === XT ? w : x,
        M = {
      top: b.top - S.top + _.top,
      bottom: S.bottom - b.bottom + _.bottom,
      left: b.left - S.left + _.left,
      right: S.right - b.right + _.right
    },
        T = e.modifiersData.offset;

    if (u === XT && T) {
      var E = T[i];
      Object.keys(M).forEach(function (e) {
        var t = [BT, UT].indexOf(e) >= 0 ? 1 : -1,
            n = [NT, UT].indexOf(e) >= 0 ? "y" : "x";
        M[e] += E[n] * t;
      });
    }

    return M;
  }

  var IE = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name;

      if (!t.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = void 0 === i || i, o = n.altAxis, a = void 0 === o || o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, p = n.rootBoundary, h = n.altBoundary, d = n.flipVariations, f = void 0 === d || d, _ = n.allowedAutoPlacements, m = t.options.placement, g = _E(m), v = l || (g !== m && f ? function (e) {
          if (_E(e) === zT) return [];
          var t = EE(e);
          return [CE(e), t, CE(t)];
        }(m) : [EE(m)]), b = [m].concat(v).reduce(function (e, n) {
          return e.concat(_E(n) === zT ? function (e, t) {
            void 0 === t && (t = {});
            var n = t,
                r = n.placement,
                i = n.boundary,
                s = n.rootBoundary,
                o = n.padding,
                a = n.flipVariations,
                l = n.allowedAutoPlacements,
                c = void 0 === l ? ZT : l,
                u = mE(r),
                p = u ? a ? YT : YT.filter(function (e) {
              return mE(e) === u;
            }) : VT,
                h = p.filter(function (e) {
              return c.indexOf(e) >= 0;
            });
            0 === h.length && (h = p);
            var d = h.reduce(function (t, n) {
              return t[n] = LE(e, {
                placement: n,
                boundary: i,
                rootBoundary: s,
                padding: o
              })[_E(n)], t;
            }, {});
            return Object.keys(d).sort(function (e, t) {
              return d[e] - d[t];
            });
          }(t, {
            placement: n,
            boundary: u,
            rootBoundary: p,
            padding: c,
            flipVariations: f,
            allowedAutoPlacements: _
          }) : n);
        }, []), x = t.rects.reference, y = t.rects.popper, w = new Map(), S = !0, M = b[0], T = 0; T < b.length; T++) {
          var E = b[T],
              A = _E(E),
              C = mE(E) === GT,
              R = [NT, UT].indexOf(A) >= 0,
              k = R ? "width" : "height",
              P = LE(t, {
            placement: E,
            boundary: u,
            rootBoundary: p,
            altBoundary: h,
            padding: c
          }),
              D = R ? C ? BT : jT : C ? UT : NT;

          x[k] > y[k] && (D = EE(D));
          var O = EE(D),
              L = [];

          if (s && L.push(P[A] <= 0), a && L.push(P[D] <= 0, P[O] <= 0), L.every(function (e) {
            return e;
          })) {
            M = E, S = !1;
            break;
          }

          w.set(E, L);
        }

        if (S) for (var I = function (e) {
          var t = b.find(function (t) {
            var n = w.get(t);
            if (n) return n.slice(0, e).every(function (e) {
              return e;
            });
          });
          if (t) return M = t, "break";
        }, F = f ? 3 : 1; F > 0 && "break" !== I(F); F--);
        t.placement !== M && (t.modifiersData[r]._skip = !0, t.placement = M, t.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };

  function FE(e, t, n) {
    return bT(e, xT(t, n));
  }

  var NE = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options,
          r = e.name,
          i = n.mainAxis,
          s = void 0 === i || i,
          o = n.altAxis,
          a = void 0 !== o && o,
          l = n.boundary,
          c = n.rootBoundary,
          u = n.altBoundary,
          p = n.padding,
          h = n.tether,
          d = void 0 === h || h,
          f = n.tetherOffset,
          _ = void 0 === f ? 0 : f,
          m = LE(t, {
        boundary: l,
        rootBoundary: c,
        padding: p,
        altBoundary: u
      }),
          g = _E(t.placement),
          v = mE(t.placement),
          b = !v,
          x = gE(g),
          y = "x" === x ? "y" : "x",
          w = t.modifiersData.popperOffsets,
          S = t.rects.reference,
          M = t.rects.popper,
          T = "function" == typeof _ ? _(Object.assign({}, t.rects, {
        placement: t.placement
      })) : _,
          E = "number" == typeof T ? {
        mainAxis: T,
        altAxis: T
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, T),
          A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
          C = {
        x: 0,
        y: 0
      };

      if (w) {
        if (s) {
          var R,
              k = "y" === x ? NT : jT,
              P = "y" === x ? UT : BT,
              D = "y" === x ? "height" : "width",
              O = w[x],
              L = O + m[k],
              I = O - m[P],
              F = d ? -M[D] / 2 : 0,
              N = v === GT ? S[D] : M[D],
              U = v === GT ? -M[D] : -S[D],
              B = t.elements.arrow,
              j = d && B ? kT(B) : {
            width: 0,
            height: 0
          },
              z = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          },
              V = z[k],
              G = z[P],
              H = FE(0, S[D], j[D]),
              W = b ? S[D] / 2 - F - H - V - E.mainAxis : N - H - V - E.mainAxis,
              K = b ? -S[D] / 2 + F + H + G + E.mainAxis : U + H + G + E.mainAxis,
              X = t.elements.arrow && FT(t.elements.arrow),
              q = X ? "y" === x ? X.clientTop || 0 : X.clientLeft || 0 : 0,
              Y = null != (R = null == A ? void 0 : A[x]) ? R : 0,
              Z = O + K - Y,
              J = FE(d ? xT(L, O + W - Y - q) : L, O, d ? bT(I, Z) : I);
          w[x] = J, C[x] = J - O;
        }

        if (a) {
          var $,
              Q = "x" === x ? NT : jT,
              ee = "x" === x ? UT : BT,
              te = w[y],
              ne = "y" === y ? "height" : "width",
              re = te + m[Q],
              ie = te - m[ee],
              se = -1 !== [NT, jT].indexOf(g),
              oe = null != ($ = null == A ? void 0 : A[y]) ? $ : 0,
              ae = se ? re : te - S[ne] - M[ne] - oe + E.altAxis,
              le = se ? te + S[ne] + M[ne] - oe - E.altAxis : ie,
              ce = d && se ? function (e, t, n) {
            var r = FE(e, t, n);
            return r > n ? n : r;
          }(ae, te, le) : FE(d ? ae : re, te, d ? le : ie);
          w[y] = ce, C[y] = ce - te;
        }

        t.modifiersData[r] = C;
      }
    },
    requiresIfExists: ["offset"]
  },
      UE = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t,
          n = e.state,
          r = e.name,
          i = e.options,
          s = n.elements.arrow,
          o = n.modifiersData.popperOffsets,
          a = _E(n.placement),
          l = gE(a),
          c = [jT, BT].indexOf(a) >= 0 ? "height" : "width";

      if (s && o) {
        var u = function (e, t) {
          return DE("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {
            placement: t.placement
          })) : e) ? e : OE(e, VT));
        }(i.padding, n),
            p = kT(s),
            h = "y" === l ? NT : jT,
            d = "y" === l ? UT : BT,
            f = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c],
            _ = o[l] - n.rects.reference[l],
            m = FT(s),
            g = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
            v = f / 2 - _ / 2,
            b = u[h],
            x = g - p[c] - u[d],
            y = g / 2 - p[c] / 2 + v,
            w = FE(b, y, x),
            S = l;

        n.modifiersData[r] = ((t = {})[S] = w, t.centerOffset = w - y, t);
      }
    },
    effect: function (e) {
      var t = e.state,
          n = e.options.element,
          r = void 0 === n ? "[data-popper-arrow]" : n;
      null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && RE(t.elements.popper, r) && (t.elements.arrow = r);
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  function BE(e, t, n) {
    return void 0 === n && (n = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    };
  }

  function jE(e) {
    return [NT, BT, UT, jT].some(function (t) {
      return e[t] >= 0;
    });
  }

  var zE = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: function (e) {
      var t = e.state,
          n = e.name,
          r = t.rects.reference,
          i = t.rects.popper,
          s = t.modifiersData.preventOverflow,
          o = LE(t, {
        elementContext: "reference"
      }),
          a = LE(t, {
        altBoundary: !0
      }),
          l = BE(o, r),
          c = BE(a, i, s),
          u = jE(l),
          p = jE(c);
      t.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: p
      }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": p
      });
    }
  },
      VE = pE({
    defaultModifiers: [fE, bE, wE, SE, ME, IE, NE, UE, zE]
  }),
      GE = "tippy-content",
      HE = "tippy-arrow",
      WE = "tippy-svg-arrow",
      KE = {
    passive: !0,
    capture: !0
  },
      XE = function () {
    return document.body;
  };

  function qE(e, t, n) {
    if (Array.isArray(e)) {
      var r = e[t];
      return null == r ? Array.isArray(n) ? n[t] : n : r;
    }

    return e;
  }

  function YE(e, t) {
    var n = {}.toString.call(e);
    return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1;
  }

  function ZE(e, t) {
    return "function" == typeof e ? e.apply(void 0, t) : e;
  }

  function JE(e, t) {
    return 0 === t ? e : function (r) {
      clearTimeout(n), n = setTimeout(function () {
        e(r);
      }, t);
    };
    var n;
  }

  function $E(e) {
    return [].concat(e);
  }

  function QE(e, t) {
    -1 === e.indexOf(t) && e.push(t);
  }

  function eA(e) {
    return [].slice.call(e);
  }

  function tA(e) {
    return Object.keys(e).reduce(function (t, n) {
      return void 0 !== e[n] && (t[n] = e[n]), t;
    }, {});
  }

  function nA() {
    return document.createElement("div");
  }

  function rA(e) {
    return ["Element", "Fragment"].some(function (t) {
      return YE(e, t);
    });
  }

  function iA(e, t) {
    e.forEach(function (e) {
      e && (e.style.transitionDuration = t + "ms");
    });
  }

  function sA(e, t) {
    e.forEach(function (e) {
      e && e.setAttribute("data-state", t);
    });
  }

  function oA(e, t, n) {
    var r = t + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function (t) {
      e[r](t, n);
    });
  }

  function aA(e, t) {
    for (var n = t; n;) {
      var r;
      if (e.contains(n)) return !0;
      n = null == n.getRootNode || null == (r = n.getRootNode()) ? void 0 : r.host;
    }

    return !1;
  }

  var lA = {
    isTouch: !1
  },
      cA = 0;

  function uA() {
    lA.isTouch || (lA.isTouch = !0, window.performance && document.addEventListener("mousemove", pA));
  }

  function pA() {
    var e = performance.now();
    e - cA < 20 && (lA.isTouch = !1, document.removeEventListener("mousemove", pA)), cA = e;
  }

  function hA() {
    var e,
        t = document.activeElement;

    if ((e = t) && e._tippy && e._tippy.reference === e) {
      var n = t._tippy;
      t.blur && !n.state.isVisible && t.blur();
    }
  }

  var dA = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto),
      fA = Object.assign({
    appendTo: XE,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: !0,
    ignoreAttributes: !1,
    interactive: !1,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function () {},
    onBeforeUpdate: function () {},
    onCreate: function () {},
    onDestroy: function () {},
    onHidden: function () {},
    onHide: function () {},
    onMount: function () {},
    onShow: function () {},
    onShown: function () {},
    onTrigger: function () {},
    onUntrigger: function () {},
    onClickOutside: function () {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: !1,
    touch: !0,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, {
    animateFill: !1,
    followCursor: !1,
    inlinePositioning: !1,
    sticky: !1
  }, {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  }),
      _A = Object.keys(fA);

  function mA(e) {
    var t = (e.plugins || []).reduce(function (t, n) {
      var r,
          i = n.name,
          s = n.defaultValue;
      return i && (t[i] = void 0 !== e[i] ? e[i] : null != (r = fA[i]) ? r : s), t;
    }, {});
    return Object.assign({}, e, t);
  }

  function gA(e, t) {
    var n = Object.assign({}, t, {
      content: ZE(t.content, [e])
    }, t.ignoreAttributes ? {} : function (e, t) {
      return (t ? Object.keys(mA(Object.assign({}, fA, {
        plugins: t
      }))) : _A).reduce(function (t, n) {
        var r = (e.getAttribute("data-tippy-" + n) || "").trim();
        if (!r) return t;
        if ("content" === n) t[n] = r;else try {
          t[n] = JSON.parse(r);
        } catch (e) {
          t[n] = r;
        }
        return t;
      }, {});
    }(e, t.plugins));
    return n.aria = Object.assign({}, fA.aria, n.aria), n.aria = {
      expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded,
      content: "auto" === n.aria.content ? t.interactive ? null : "describedby" : n.aria.content
    }, n;
  }

  function vA(e, t) {
    e.innerHTML = t;
  }

  function bA(e) {
    var t = nA();
    return !0 === e ? t.className = HE : (t.className = WE, rA(e) ? t.appendChild(e) : vA(t, e)), t;
  }

  function xA(e, t) {
    rA(t.content) ? (vA(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? vA(e, t.content) : e.textContent = t.content);
  }

  function yA(e) {
    var t = e.firstElementChild,
        n = eA(t.children);
    return {
      box: t,
      content: n.find(function (e) {
        return e.classList.contains(GE);
      }),
      arrow: n.find(function (e) {
        return e.classList.contains(HE) || e.classList.contains(WE);
      }),
      backdrop: n.find(function (e) {
        return e.classList.contains("tippy-backdrop");
      })
    };
  }

  function wA(e) {
    var t = nA(),
        n = nA();
    n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
    var r = nA();

    function i(n, r) {
      var i = yA(t),
          s = i.box,
          o = i.content,
          a = i.arrow;
      r.theme ? s.setAttribute("data-theme", r.theme) : s.removeAttribute("data-theme"), "string" == typeof r.animation ? s.setAttribute("data-animation", r.animation) : s.removeAttribute("data-animation"), r.inertia ? s.setAttribute("data-inertia", "") : s.removeAttribute("data-inertia"), s.style.maxWidth = "number" == typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? s.setAttribute("role", r.role) : s.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || xA(o, e.props), r.arrow ? a ? n.arrow !== r.arrow && (s.removeChild(a), s.appendChild(bA(r.arrow))) : s.appendChild(bA(r.arrow)) : a && s.removeChild(a);
    }

    return r.className = GE, r.setAttribute("data-state", "hidden"), xA(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props), {
      popper: t,
      onUpdate: i
    };
  }

  wA.$$tippy = !0;
  var SA = 1,
      MA = [],
      TA = [];

  function EA(e, t) {
    var n,
        r,
        i,
        s,
        o,
        a,
        l,
        c,
        u = gA(e, Object.assign({}, fA, mA(tA(t)))),
        p = !1,
        h = !1,
        d = !1,
        f = !1,
        _ = [],
        m = JE(X, u.interactiveDebounce),
        g = SA++,
        v = (c = u.plugins).filter(function (e, t) {
      return c.indexOf(e) === t;
    }),
        b = {
      id: g,
      reference: e,
      popper: nA(),
      popperInstance: null,
      props: u,
      state: {
        isEnabled: !0,
        isVisible: !1,
        isDestroyed: !1,
        isMounted: !1,
        isShown: !1
      },
      plugins: v,
      clearDelayTimeouts: function () {
        clearTimeout(n), clearTimeout(r), cancelAnimationFrame(i);
      },
      setProps: function (t) {
        if (!b.state.isDestroyed) {
          O("onBeforeUpdate", [b, t]), W();
          var n = b.props,
              r = gA(e, Object.assign({}, n, tA(t), {
            ignoreAttributes: !0
          }));
          b.props = r, H(), n.interactiveDebounce !== r.interactiveDebounce && (F(), m = JE(X, r.interactiveDebounce)), n.triggerTarget && !r.triggerTarget ? $E(n.triggerTarget).forEach(function (e) {
            e.removeAttribute("aria-expanded");
          }) : r.triggerTarget && e.removeAttribute("aria-expanded"), I(), D(), w && w(n, r), b.popperInstance && (J(), Q().forEach(function (e) {
            requestAnimationFrame(e._tippy.popperInstance.forceUpdate);
          })), O("onAfterUpdate", [b, t]);
        }
      },
      setContent: function (e) {
        b.setProps({
          content: e
        });
      },
      show: function () {
        var e = b.state.isVisible,
            t = b.state.isDestroyed,
            n = !b.state.isEnabled,
            r = lA.isTouch && !b.props.touch,
            i = qE(b.props.duration, 0, fA.duration);

        if (!(e || t || n || r || C().hasAttribute("disabled") || (O("onShow", [b], !1), !1 === b.props.onShow(b)))) {
          if (b.state.isVisible = !0, A() && (y.style.visibility = "visible"), D(), j(), b.state.isMounted || (y.style.transition = "none"), A()) {
            var s = k();
            iA([s.box, s.content], 0);
          }

          var o, l, c;
          a = function () {
            var e;

            if (b.state.isVisible && !f) {
              if (f = !0, y.offsetHeight, y.style.transition = b.props.moveTransition, A() && b.props.animation) {
                var t = k(),
                    n = t.box,
                    r = t.content;
                iA([n, r], i), sA([n, r], "visible");
              }

              L(), I(), QE(TA, b), null == (e = b.popperInstance) || e.forceUpdate(), O("onMount", [b]), b.props.animation && A() && function (e, t) {
                V(e, function () {
                  b.state.isShown = !0, O("onShown", [b]);
                });
              }(i);
            }
          }, l = b.props.appendTo, c = C(), (o = b.props.interactive && l === XE || "parent" === l ? c.parentNode : ZE(l, [c])).contains(y) || o.appendChild(y), b.state.isMounted = !0, J();
        }
      },
      hide: function () {
        var e = !b.state.isVisible,
            t = b.state.isDestroyed,
            n = !b.state.isEnabled,
            r = qE(b.props.duration, 1, fA.duration);

        if (!(e || t || n) && (O("onHide", [b], !1), !1 !== b.props.onHide(b))) {
          if (b.state.isVisible = !1, b.state.isShown = !1, f = !1, p = !1, A() && (y.style.visibility = "hidden"), F(), z(), D(!0), A()) {
            var i = k(),
                s = i.box,
                o = i.content;
            b.props.animation && (iA([s, o], r), sA([s, o], "hidden"));
          }

          L(), I(), b.props.animation ? A() && function (e, t) {
            V(e, function () {
              !b.state.isVisible && y.parentNode && y.parentNode.contains(y) && t();
            });
          }(r, b.unmount) : b.unmount();
        }
      },
      hideWithInteractivity: function (e) {
        R().addEventListener("mousemove", m), QE(MA, m), m(e);
      },
      enable: function () {
        b.state.isEnabled = !0;
      },
      disable: function () {
        b.hide(), b.state.isEnabled = !1;
      },
      unmount: function () {
        b.state.isVisible && b.hide(), b.state.isMounted && ($(), Q().forEach(function (e) {
          e._tippy.unmount();
        }), y.parentNode && y.parentNode.removeChild(y), TA = TA.filter(function (e) {
          return e !== b;
        }), b.state.isMounted = !1, O("onHidden", [b]));
      },
      destroy: function () {
        b.state.isDestroyed || (b.clearDelayTimeouts(), b.unmount(), W(), delete e._tippy, b.state.isDestroyed = !0, O("onDestroy", [b]));
      }
    };
    if (!u.render) return b;
    var x = u.render(b),
        y = x.popper,
        w = x.onUpdate;
    y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + b.id, b.popper = y, e._tippy = b, y._tippy = b;
    var S = v.map(function (e) {
      return e.fn(b);
    }),
        M = e.hasAttribute("aria-expanded");
    return H(), I(), D(), O("onCreate", [b]), u.showOnCreate && ee(), y.addEventListener("mouseenter", function () {
      b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
    }), y.addEventListener("mouseleave", function () {
      b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && R().addEventListener("mousemove", m);
    }), b;

    function T() {
      var e = b.props.touch;
      return Array.isArray(e) ? e : [e, 0];
    }

    function E() {
      return "hold" === T()[0];
    }

    function A() {
      var e;
      return !(null == (e = b.props.render) || !e.$$tippy);
    }

    function C() {
      return l || e;
    }

    function R() {
      var e,
          t,
          n = C().parentNode;
      return n ? null != (t = $E(n)[0]) && null != (e = t.ownerDocument) && e.body ? t.ownerDocument : document : document;
    }

    function k() {
      return yA(y);
    }

    function P(e) {
      return b.state.isMounted && !b.state.isVisible || lA.isTouch || s && "focus" === s.type ? 0 : qE(b.props.delay, e ? 0 : 1, fA.delay);
    }

    function D(e) {
      void 0 === e && (e = !1), y.style.pointerEvents = b.props.interactive && !e ? "" : "none", y.style.zIndex = "" + b.props.zIndex;
    }

    function O(e, t, n) {
      var r;
      void 0 === n && (n = !0), S.forEach(function (n) {
        n[e] && n[e].apply(n, t);
      }), n && (r = b.props)[e].apply(r, t);
    }

    function L() {
      var t = b.props.aria;

      if (t.content) {
        var n = "aria-" + t.content,
            r = y.id;
        $E(b.props.triggerTarget || e).forEach(function (e) {
          var t = e.getAttribute(n);
          if (b.state.isVisible) e.setAttribute(n, t ? t + " " + r : r);else {
            var i = t && t.replace(r, "").trim();
            i ? e.setAttribute(n, i) : e.removeAttribute(n);
          }
        });
      }
    }

    function I() {
      !M && b.props.aria.expanded && $E(b.props.triggerTarget || e).forEach(function (e) {
        b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === C() ? "true" : "false") : e.removeAttribute("aria-expanded");
      });
    }

    function F() {
      R().removeEventListener("mousemove", m), MA = MA.filter(function (e) {
        return e !== m;
      });
    }

    function N(t) {
      if (!lA.isTouch || !d && "mousedown" !== t.type) {
        var n = t.composedPath && t.composedPath()[0] || t.target;

        if (!b.props.interactive || !aA(y, n)) {
          if ($E(b.props.triggerTarget || e).some(function (e) {
            return aA(e, n);
          })) {
            if (lA.isTouch) return;
            if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return;
          } else O("onClickOutside", [b, t]);

          !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout(function () {
            h = !1;
          }), b.state.isMounted || z());
        }
      }
    }

    function U() {
      d = !0;
    }

    function B() {
      d = !1;
    }

    function j() {
      var e = R();
      e.addEventListener("mousedown", N, !0), e.addEventListener("touchend", N, KE), e.addEventListener("touchstart", B, KE), e.addEventListener("touchmove", U, KE);
    }

    function z() {
      var e = R();
      e.removeEventListener("mousedown", N, !0), e.removeEventListener("touchend", N, KE), e.removeEventListener("touchstart", B, KE), e.removeEventListener("touchmove", U, KE);
    }

    function V(e, t) {
      var n = k().box;

      function r(e) {
        e.target === n && (oA(n, "remove", r), t());
      }

      if (0 === e) return t();
      oA(n, "remove", o), oA(n, "add", r), o = r;
    }

    function G(t, n, r) {
      void 0 === r && (r = !1), $E(b.props.triggerTarget || e).forEach(function (e) {
        e.addEventListener(t, n, r), _.push({
          node: e,
          eventType: t,
          handler: n,
          options: r
        });
      });
    }

    function H() {
      var e;
      E() && (G("touchstart", K, {
        passive: !0
      }), G("touchend", q, {
        passive: !0
      })), (e = b.props.trigger, e.split(/\s+/).filter(Boolean)).forEach(function (e) {
        if ("manual" !== e) switch (G(e, K), e) {
          case "mouseenter":
            G("mouseleave", q);
            break;

          case "focus":
            G(dA ? "focusout" : "blur", Y);
            break;

          case "focusin":
            G("focusout", Y);
        }
      });
    }

    function W() {
      _.forEach(function (e) {
        var t = e.node,
            n = e.eventType,
            r = e.handler,
            i = e.options;
        t.removeEventListener(n, r, i);
      }), _ = [];
    }

    function K(e) {
      var t,
          n = !1;

      if (b.state.isEnabled && !Z(e) && !h) {
        var r = "focus" === (null == (t = s) ? void 0 : t.type);
        s = e, l = e.currentTarget, I(), !b.state.isVisible && YE(e, "MouseEvent") && MA.forEach(function (t) {
          return t(e);
        }), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || p) && !1 !== b.props.hideOnClick && b.state.isVisible ? n = !0 : ee(e), "click" === e.type && (p = !n), n && !r && te(e);
      }
    }

    function X(e) {
      var t = e.target,
          n = C().contains(t) || y.contains(t);
      "mousemove" === e.type && n || function (e, t) {
        var n = t.clientX,
            r = t.clientY;
        return e.every(function (e) {
          var t = e.popperRect,
              i = e.popperState,
              s = e.props.interactiveBorder,
              o = i.placement.split("-")[0],
              a = i.modifiersData.offset;
          if (!a) return !0;

          var l = "bottom" === o ? a.top.y : 0,
              c = "top" === o ? a.bottom.y : 0,
              u = "right" === o ? a.left.x : 0,
              p = "left" === o ? a.right.x : 0,
              h = t.top - r + l > s,
              d = r - t.bottom - c > s,
              f = t.left - n + u > s,
              _ = n - t.right - p > s;

          return h || d || f || _;
        });
      }(Q().concat(y).map(function (e) {
        var t,
            n = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
        return n ? {
          popperRect: e.getBoundingClientRect(),
          popperState: n,
          props: u
        } : null;
      }).filter(Boolean), e) && (F(), te(e));
    }

    function q(e) {
      Z(e) || b.props.trigger.indexOf("click") >= 0 && p || (b.props.interactive ? b.hideWithInteractivity(e) : te(e));
    }

    function Y(e) {
      b.props.trigger.indexOf("focusin") < 0 && e.target !== C() || b.props.interactive && e.relatedTarget && y.contains(e.relatedTarget) || te(e);
    }

    function Z(e) {
      return !!lA.isTouch && E() !== e.type.indexOf("touch") >= 0;
    }

    function J() {
      $();
      var t = b.props,
          n = t.popperOptions,
          r = t.placement,
          i = t.offset,
          s = t.getReferenceClientRect,
          o = t.moveTransition,
          l = A() ? yA(y).arrow : null,
          c = s ? {
        getBoundingClientRect: s,
        contextElement: s.contextElement || C()
      } : e,
          u = [{
        name: "offset",
        options: {
          offset: i
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !o
        }
      }, {
        name: "$$tippy",
        enabled: !0,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function (e) {
          var t = e.state;

          if (A()) {
            var n = k().box;
            ["placement", "reference-hidden", "escaped"].forEach(function (e) {
              "placement" === e ? n.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? n.setAttribute("data-" + e, "") : n.removeAttribute("data-" + e);
            }), t.attributes.popper = {};
          }
        }
      }];
      A() && l && u.push({
        name: "arrow",
        options: {
          element: l,
          padding: 3
        }
      }), u.push.apply(u, (null == n ? void 0 : n.modifiers) || []), b.popperInstance = VE(c, y, Object.assign({}, n, {
        placement: r,
        onFirstUpdate: a,
        modifiers: u
      }));
    }

    function $() {
      b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
    }

    function Q() {
      return eA(y.querySelectorAll("[data-tippy-root]"));
    }

    function ee(e) {
      b.clearDelayTimeouts(), e && O("onTrigger", [b, e]), j();
      var t = P(!0),
          r = T(),
          i = r[0],
          s = r[1];
      lA.isTouch && "hold" === i && s && (t = s), t ? n = setTimeout(function () {
        b.show();
      }, t) : b.show();
    }

    function te(e) {
      if (b.clearDelayTimeouts(), O("onUntrigger", [b, e]), b.state.isVisible) {
        if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && p)) {
          var t = P(!1);
          t ? r = setTimeout(function () {
            b.state.isVisible && b.hide();
          }, t) : i = requestAnimationFrame(function () {
            b.hide();
          });
        }
      } else z();
    }
  }

  function AA(e, t) {
    void 0 === t && (t = {});
    var n = fA.plugins.concat(t.plugins || []);
    document.addEventListener("touchstart", uA, KE), window.addEventListener("blur", hA);
    var r,
        i = Object.assign({}, t, {
      plugins: n
    }),
        s = (r = e, rA(r) ? [r] : function (e) {
      return YE(e, "NodeList");
    }(r) ? eA(r) : Array.isArray(r) ? r : eA(document.querySelectorAll(r))).reduce(function (e, t) {
      var n = t && EA(t, i);
      return n && e.push(n), e;
    }, []);
    return rA(e) ? s[0] : s;
  }

  AA.defaultProps = fA, AA.setDefaultProps = function (e) {
    Object.keys(e).forEach(function (t) {
      fA[t] = e[t];
    });
  }, AA.currentInput = lA, Object.assign({}, SE, {
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow);
    }
  }), AA.setDefaultProps({
    render: wA
  });
  var CA = AA;

  class RA extends lT {
    async _refreshUi() {
      var e;
      if (!(await super._refreshUi())) return !1;
      fT.RemoveAll(RA.PluginType);

      for (const e of this.variations) fT.Create(RA.PluginType, e.title, 5, 20, 0, e.materials.map(t => {
        let n;
        if (e.preview.startsWith("generate:")) n = this._previewGenerator.generate(t, e.preview.split(":")[1]);else {
          const r = t[e.preview] || "#ff00ff";
          n = r.image ? Et(r.image, 100) : void 0, n || (n = uT(r, !0));
        }
        return {
          id: t.uuid,
          image: n,
          onClick: t => this.applyVariation(e, t),
          tooltip: t.name || t.uuid
        };
      }), (e, t) => CA(e, {
        placement: "bottom",
        content: t.tooltip
      }));

      return fT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), !0;
    }

  }

  RA.PluginType = "MaterialConfiguratorPlugin";

  class kA extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
        var e, t;
        this.enabled && (null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      }, this.dependencies = [Vs], this._selectedObject = () => {
        var e;
        return (null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0;
      }, this._selectedMaterial = () => {
        var e, t;
        return (null === (t = null === (e = this._selectedObject()) || void 0 === e ? void 0 : e.modelObject) || void 0 === t ? void 0 : t.material) || void 0;
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new aT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi);
    }

    async onRemove(e) {
      var t, n;
      return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e);
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    async _refreshUi() {
      return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = !1, !1;
    }

  }

  kA.PluginType = "MaterialLibraryBasePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Enabled")], kA.prototype, "enabled", void 0);

  class PA extends kA {
    constructor() {
      super(...arguments), this.replaceMaterial = !1, this.uiConfig = {
        type: "folder",
        label: "Material Library",
        uuid: Be(),
        children: [...Je(this), () => {
          var e;
          return {
            type: "dropdown",
            label: "Apply Material",
            limitedUi: !0,
            hidden: () => !this._selectedObject(),
            children: [{
              label: "select one",
              value: ""
            }, [...(this._viewer.getPlugin(Vs).materials.getMaterialsOfType(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.typeSlug).map(e => ({
              label: e.name || e.uuid,
              value: e.uuid
            })) || [])]],
            getValue: () => {
              var e;
              return null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid;
            },
            setValue: e => {
              var t, n, r, i, s;
              const o = null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Vs)) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e);
              if (o) if (this.replaceMaterial) null === (s = null === (i = this._selectedObject()) || void 0 === i ? void 0 : i.modelObject) || void 0 === s || s.userData.setMaterial(o);else {
                const e = this._selectedMaterial();

                if (e) {
                  const t = e.name,
                        n = e.uuid;
                  e.copyProps(o), e.name = t, e.uuid = n, e.userData.uuid && (e.userData.uuid = n);
                }
              }

              this._refreshUi();
            }
          };
        }]
      };
    }

    async _refreshUi() {
      var e, t, n, r;
      if (!(await super._refreshUi())) return !1;
      const i = [Kt.TypeSlug, Fo.TypeSlug],
            s = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials,
            o = i.map(e => [e, null == s ? void 0 : s.getMaterialsOfType(e)]);
      fT.RemoveAll(PA.PluginType);

      for (const [e, t] of o) fT.Create(PA.PluginType, e, 5, 20, 0, null === (n = t) || void 0 === n ? void 0 : n.filter(e => !e.userData.__runtimeMaterial).map(e => {
        let t;
        const n = "generate:sphere";
        if (n.startsWith("generate:")) t = this._previewGenerator.generate(e, n.split(":")[1]);else {
          const r = e[n] || "#ff00ff";
          t = r.image ? Et(r.image, 100) : void 0, t || (t = cT(r, !0));
        }
        return {
          id: e.uuid,
          image: t,
          onClick: e => {
            const t = null == s ? void 0 : s.findMaterial(e);

            if (console.log(null == t ? void 0 : t.name), t) {
              const e = t.userData.appliedMeshes;

              if (null == e ? void 0 : e.size) {
                const t = e.keys().next().value;
                t.dispatchEvent({
                  type: "select",
                  value: t
                });
              }
            }
          },
          tooltip: e.name || e.uuid
        };
      }), (e, t) => CA(e, {
        placement: "bottom",
        content: t.tooltip
      }));

      return fT.RebuildUi(null === (r = this._viewer) || void 0 === r ? void 0 : r.container), !0;
    }

  }

  function DA(e, t, n, r) {
    e.traverse(e => {
      if (!e) return;
      e.userData.cloneRotI = t, e.userData.rotationCount = n, e.userData.rotationAxis = r;
      const s = e;

      if (s.isMesh && s.material && t > 0) {
        const e = s.material;
        e.extraUniformsToUpload || (e.extraUniformsToUpload = {}), e.extraUniformsToUpload.uvTransform || (e.extraUniformsToUpload.uvTransform = {
          value: new i.Vkp()
        });
      }
    });
  }

  function OA(e, t, n, r = "x") {
    var i;
    if (e.userData.rotationCount > 1 && !e.userData.rotationRoot) return e;
    const s = e.parent;
    if (!s) throw new Error("No parent");

    if (e.userData.cloneParent) {
      const t = e.userData.cloneParent;
      if (!(e = s.children.find(e => t === e.uuid))) return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t, s), e;
    }

    let o = s.children.filter(t => {
      var n;
      return (null === (n = t.userData) || void 0 === n ? void 0 : n.cloneParent) === e.uuid;
    }).sort((e, t) => e.userData.cloneRotI - t.userData.cloneRotI);
    if (e.userData.rotationCount === t && t === o.length && void 0 === n && e.userData.rotationAxis === r) return e;

    if (null == n && (n = null !== (i = e.userData.rotationSkips) && void 0 !== i ? i : []), n !== e.userData.rotationSkips && (e.userData.rotationSkips = [...n]), DA(e, 0, t, r), e.userData.rotationRoot = !0, e.visible = !0, t <= o.length) {
      for (let e = t - 1; e < o.length; e++) s.remove(o[e]), o[e].traverse(e => e.userData = {
        __disposed: !0
      });

      o = o.slice(0, t);
    }

    for (let i = 1; i < t; i++) {
      const a = i <= o.length ? o[i - 1] : e.clone();
      a.rotation.copy(e.rotation), a.rotation[r] += i / t * Math.PI * 2, DA(a, i, t, r), i > o.length && s.add(a), a.visible = !n.includes(i);
    }

    return e.visible = !n.includes(0), e;
  }

  PA.PluginType = "MaterialLibraryPlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([Ve("Replace Material")], PA.prototype, "replaceMaterial", void 0);

  var LA,
      IA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let FA = LA = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this);
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }

    _selectedObjectChanged() {
      var e, t, n, r, i, s, o, a, l;
      if (!this.enabled) return;
      const c = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      if (!c) return void (null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
      const u = c.userData.rotationRoot && null !== (i = c.userData.rotationCount) && void 0 !== i ? i : 1;
      this.rotations = u, this.skips = null !== (o = null === (s = c.userData.rotationSkips) || void 0 === s ? void 0 : s.join(",")) && void 0 !== o ? o : "", this.axis = c.userData.rotationAxis || "x", null === (l = (a = this.uiConfig).uiRefresh) || void 0 === l || l.call(a, "postFrame", !0);
    }

    _paramsChanged() {
      var e, t, n, r, s, o;
      if (!this.enabled) return;
      const a = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();

      if (a) {
        if (this.rotations > 1 || a.userData.rotationCount) {
          const e = a.userData.rotationCount,
                t = OA(a, this.rotations, this.skips.split(",").map(e => parseInt(e)).filter(e => isFinite(e)), this.axis),
                o = null == t ? void 0 : t.userData.rotationCount;

          if (o && o !== e) {
            const e = [];
            null == t || t.traverseAncestors(t => {
              e.push(t);
            });

            for (const t of e) if (t.userData.autoScaled) {
              X(t), null === (n = this._viewer) || void 0 === n || n.resetCamera({
                rootObject: t,
                centerOffset: new i.Pa4(4, 4, 4)
              });
              break;
            }
          }

          a.parent && !a.userData.__disposed || null === (s = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("Picking")) || void 0 === s || s.setSelectedObject(t, !0);
        }

        null === (o = this._viewer) || void 0 === o || o.scene.setDirty({
          frameFade: !1,
          sceneUpdate: !0
        });
      }
    }

  };
  FA.PluginType = "ObjectRotationPlugin", IA([xe(), Ve("Enabled"), C(LA.prototype._paramsChanged)], FA.prototype, "enabled", void 0), IA([He("Rotation Count", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(LA.prototype._paramsChanged)], FA.prototype, "rotations", void 0), IA([Ke("Axis", ["x", "y", "z"].map(e => ({
    label: e
  })), e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(LA.prototype._paramsChanged)], FA.prototype, "axis", void 0), IA([qe("Rotation Skips", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations;
    }
  })), C(LA.prototype._paramsChanged)], FA.prototype, "skips", void 0), FA = LA = IA([Qe("Object Rotations")], FA);

  var NA,
      UA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let BA = NA = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.debugNormals = !1, this.debugHitHeight = !1, this._defines = {
        PARALLAX_NORMAL_MAP_QUALITY: 0
      }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = {
        shaderExtender: (e, t, n) => {
          if (t.materialObject.bumpMap && this.enabled) {
            e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_begin>", ""), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", ""), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");

            for (const t of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"]) e.fragmentShader = e.fragmentShader.replace(`#include <${t}>`, i.WdD[t].replace("vUv", "parallaxUv.xy"));

            (this.debugNormals || this.debugHitHeight) && (e.fragmentShader = e.fragmentShader.replace("texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", i.WdD.normal_fragment_maps.replace("#elif defined( TANGENTSPACE_NORMALMAP )", "#elif defined( TANGENTSPACE_NORMALMAP ) && !defined( USE_BUMPMAP )").replace("normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"));
          }
        },
        parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vUv,0.);float parallaxHeight;vec2 texCoords=vUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vUv);vec2 duv2=dFdy(vUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "",
        isCompatible: e => e.isMeshStandardMaterial2,
        computeCacheKey: e => {
          var t;
          return this.enabled + " " + (null === (t = e.materialObject.bumpMap) || void 0 === t ? void 0 : t.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  ";
        },
        onObjectRender: (e, {
          materialObject: t
        }, n) => {
          for (const [e, n] of Object.entries(this._defines)) {
            const r = "number" == typeof n ? n : n ? 1 : 0;
            t.defines[e] !== r && (t.defines[e] = r, t.needsUpdate = !0);
          }
        }
      }, this.dependencies = [Vs], this._updateExtension = this._updateExtension.bind(this);
    }

    _updateExtension() {
      var e, t, n;
      null === (t = null === (e = this._bumpMapExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty();
    }

    async onAdded(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e);
    }

    async onRemove(e) {
      var t, n;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e);
    }

  };
  BA.PluginType = "ReliefParallaxMapping", UA([C(NA.prototype._updateExtension), Ve("Enabled")], BA.prototype, "enabled", void 0), UA([C(NA.prototype._updateExtension), Ve("Debug Normals")], BA.prototype, "debugNormals", void 0), UA([C(NA.prototype._updateExtension), Ve("Debug Hit Height")], BA.prototype, "debugHitHeight", void 0), UA([G("PARALLAX_MAP_STEPS", void 0, !0, NA.prototype._updateExtension), He("Step count", [1, 32], 1), xe()], BA.prototype, "stepCount", void 0), UA([G("PARALLAX_MAP_B_STEPS", void 0, !0, NA.prototype._updateExtension), He("Binary search steps", [1, 8], 1), xe()], BA.prototype, "binaryStepCount", void 0), BA = NA = UA([Qe("Parallax Mapping")], BA);

  class jA extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this.dependencies = [Vs], this.variations = [], this._selectedSwitchNode = () => {
        var e;
        const t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject();
        if (!t) return;
        const n = this.variations.map(e => e.name);
        let r;
        return t.traverseAncestors(e => {
          r || n.includes(e.name) && (r = e);
        }), r;
      }, this.uiConfig = {
        label: "Switch Node",
        type: "folder",
        children: [() => [{
          type: "folder",
          label: "All nodes",
          expanded: !0,
          children: [this.variations.map(e => ({
            type: "input",
            label: e.title,
            property: [e, "name"],
            onChange: () => this.refreshUi()
          }))]
        }, {
          type: "button",
          label: "Add Node",
          value: () => {
            this.variations.push({
              name: "switch_node",
              selected: "",
              title: "Switch Node",
              camView: "front",
              camDistance: 1
            }), this.refreshUi();
          }
        }, {
          type: "button",
          label: "Refresh UI",
          value: () => this.refreshUi()
        }, {
          type: "input",
          label: "Selected node title",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "title"] : [];
          },
          onChange: () => this.refreshUi()
        }, {
          type: "slider",
          bounds: [.01, 2],
          stepSize: .01,
          label: "Cam Distance",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "camDistance"] : [];
          }
        }, {
          type: "dropdown",
          label: "Cam View",
          hidden: () => !this._selectedSwitchNode(),
          property: () => {
            const e = this._selectedSwitchNode();

            return e ? [this.variations.find(t => t.name === e.name), "camView"] : [];
          },
          onChange: () => this.refreshUi(),
          children: ["top", "bottom", "front", "back", "left", "right"].map(e => ({
            label: e,
            value: e
          }))
        }]]
      };
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", () => {
        var e, t;
        null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e);
      }), e.addEventListener("postFrame", () => {
        this._uiNeedRefresh && this._refreshUi();
      }), e.addEventListener("preRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          if (!t || t.children.length < 1) return;
          e.selected || (e.selected = t.children[0].name || t.children[0].uuid);

          for (const n of t.children) n.visible = (n.name || n.uuid) === e.selected;
        }
      }), e.addEventListener("postRender", () => {
        if (this._viewer) for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          if (!t || t.children.length < 1) return;

          for (const e of t.children) e.visible = !0;
        }
      }), this.addEventListener("deserialize", async () => {
        await _c(200), this.refreshUi();
      });
    }

    refreshUi() {
      this.enabled && (this._uiNeedRefresh = !0);
    }

    _refreshUi() {
      var e, t, n;

      if (this.enabled && this._viewer) {
        this._uiNeedRefresh = !1, fT.RemoveAll(jA.PluginType);

        for (const e of this.variations) {
          const t = this._viewer.scene.getObjectByName(e.name);

          t ? (t.children.length < 1 && console.warn("SwitchNode does not have enough children", e), fT.Create(jA.PluginType, e.title, Math.min(5, t.children.length), 20, 0, t.children.map(t => {
            const n = e.camView,
                  r = new i.Pa4((n.includes("right") ? 1 : 0) - (n.includes("left") ? 1 : 0), (n.includes("top") ? 1 : 0) - (n.includes("bottom") ? 1 : 0), (n.includes("front") ? 1 : 0) - (n.includes("back") ? 1 : 0));
            e.camDistance || (e.camDistance = 1);
            const s = oT(this._viewer, t, void 0, 7, r.multiplyScalar(.5 * e.camDistance));
            return {
              id: t.uuid,
              image: s,
              onClick: () => {
                var n;
                e.selected = t.name || t.uuid, null === (n = this._viewer) || void 0 === n || n.scene.setDirty({
                  sceneUpdate: !0,
                  frameFade: !0
                });
              },
              tooltip: t.name || t.uuid
            };
          }), (e, t) => CA(e, {
            placement: "bottom",
            content: t.tooltip
          }))) : console.warn("no object found for variation, skipping", e);
        }

        fT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t);
      }
    }

  }

  jA.PluginType = "SwitchNodePlugin", function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    s > 3 && o && Object.defineProperty(t, n, o);
  }([xe()], jA.prototype, "variations", void 0);

  class zA extends i.u9r {
    constructor(e, t, n = 32, r = 64, s = !1, o = new i.FM8(1, 1), a = "shape") {
      super(), this.type = "TubeShapeGeometry", this.parameters = {
        path: t,
        shape: e,
        shapeSegments: n,
        tubularSegments: r,
        closed: s,
        primary: a,
        shapeScale: o.clone()
      };
      const l = t.computeFrenetFrames(r, s);
      this.frames = l;
      const c = new i.Pa4(),
            u = new i.Pa4(),
            p = new i.Pa4(),
            h = new i.FM8();
      let d = new i.Pa4();
      const f = [],
            _ = [],
            m = [],
            g = e.getSpacedPoints(n);

      for (const e of g) e.multiply(o);

      !function () {
        for (let e = 0; e < r; e++) b(e);

        b(!1 === s ? r : 0), function () {
          for (let e = 0; e <= r; e++) for (let t = 0; t <= n; t++) h.x = e / r, h.y = t / n, _.push(h.x, h.y);
        }(), function () {
          const e = "shape" === a,
                t = e ? n : r,
                i = e ? r : n;

          for (let r = 1; r <= t; r++) for (let t = 1; t <= i; t++) {
            const [i, s] = e ? [t, r] : [r, t],
                  o = (n + 1) * (i - 1) + (s - 1),
                  a = (n + 1) * i + (s - 1),
                  l = (n + 1) * i + s,
                  c = (n + 1) * (i - 1) + s;
            m.push(o, a, c), m.push(a, l, c);
          }
        }();
      }(), this.setIndex(m), this.setAttribute("position", new i.a$l(f, 3)), this.setAttribute("uv", new i.a$l(_, 2)), this.computeVertexNormals();
      const v = this.attributes.normal;

      function b(e) {
        d = t.getPointAt(e / r, d);
        const i = l.normals[e],
              s = l.binormals[e];

        for (let e = 0; e <= n; e++) {
          const t = g[e % n];
          u.set(0, 0, 0).addScaledVector(i, t.x).addScaledVector(s, t.y), c.copy(d).add(u), f.push(c.x, c.y, c.z);
        }
      }

      !function () {
        for (let e = 1; e < n; e++) {
          const t = e + r * (n + 1);
          u.fromBufferAttribute(v, e), p.fromBufferAttribute(v, t), u.add(p).normalize(), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(t, u.x, u.y, u.z);
        }

        for (let e = 1; e < r; e++) {
          const t = e * (n + 1),
                r = t + n;
          u.fromBufferAttribute(v, t), p.fromBufferAttribute(v, r), u.add(p).normalize(), v.setXYZ(t, u.x, u.y, u.z), v.setXYZ(r, u.x, u.y, u.z);
        }

        u.fromBufferAttribute(v, 0), p.fromBufferAttribute(v, n), u.add(p);
        const e = r * (n + 1);
        p.fromBufferAttribute(v, e), u.add(p), p.fromBufferAttribute(v, e + n), u.add(p), u.normalize(), v.setXYZ(0, u.x, u.y, u.z), v.setXYZ(n, u.x, u.y, u.z), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(e + n, u.x, u.y, u.z), v.needsUpdate = !0;
      }();
    }

    createSplits(e) {
      this.clearGroups();
      const t = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments,
            n = this.index.count,
            r = [...e, 1].sort();
      let i = 0,
          s = 0;

      for (const e of r) {
        const r = Math.round(t * e) * n / t;
        this.addGroup(i, r - i, s++), i = r;
      }

      return this.groups.length;
    }

    toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e.shape = this.parameters.shape.toJSON(), e;
    }

  }

  var VA,
      GA = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  let HA = VA = class extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new i.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = !0, this.extrudeCirceTube = async () => {
        var e, t;
        const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject();
        if (!n) return;
        let r = prompt("Radius", "1");
        if (!r) return;
        r = parseFloat(r);
        const i = new WA(0, 0, r, r, 0, 2 * Math.PI, !0, 0);
        await this.extrudeObject(n, i);
      };
    }

    async onAdded(e) {
      await super.onAdded(e);
    }

    static CreateCurve(e, t) {
      var n, r;
      if ("circle" === e) return new WA(0, 0, null !== (n = t.radius) && void 0 !== n ? n : 1, null !== (r = t.radius) && void 0 !== r ? r : 1, 0, 2 * Math.PI, !0, 0);
      throw new Error("Unknown curve type");
    }

    async extrudeObject(e, t, n = this.shapeSegments, r = this.tubularSegments, s = this.shapeScale, o = this.materialSplits.split(",").map(e => parseFloat(e.trim())), a = this.horizontalSplits) {
      var l, c, u, p, h, d;

      if (e.userData.isExtrudedTube, e.userData._extrudeSource) {
        const t = e.userData._extrudeSource;
        if (!(e = null === (l = e.parent) || void 0 === l ? void 0 : l.children.find(e => t === e.uuid))) return void console.warn("Could not find extrude source with uuid", t);
      }

      if (e.userData.extrudedObject) {
        const t = e.userData.extrudedObject,
              n = null === (c = e.parent) || void 0 === c ? void 0 : c.children.find(e => t === e.uuid);
        n && (n.removeFromParent(), n.geometry.dispose(), n.geometry = null, n.material = null), delete e.userData.extrudedObject;
      }

      const f = e.geometry;
      if (!f) return void alert("no geometry to extrude");
      const _ = [e.material];
      let m;

      try {
        const e = VA.ConvertGeometryToFlatShape(f);
        m = new zA(e, t, n, r, !0, s, a ? "shape" : "path"), m.computeBoundingBox(), m.createSplits(o);
      } catch (e) {
        return void alert("string" == typeof e ? e : null == e ? void 0 : e.message);
      }

      _[0].color.set(16777215);

      for (let e = _.length; e < m.groups.length; e++) {
        const e = _[0].clone();

        _.push(e), e.color.set(16777215 * Math.random());
      }

      const g = new i.Kj0(m, _);
      g.userData._extrudeSource = e.uuid, g.userData.isExtrudedTube = !0, e.visible = !1, e.userData.bboxVisible = !1, g.name = e.name + "_extruded";
      const v = lt(g),
            b = await (null === (h = null === (p = null === (u = this._viewer) || void 0 === u ? void 0 : u.getManager()) || void 0 === p ? void 0 : p.importer) || void 0 === h ? void 0 : h.processImportedSingle(v, {
        pseudoCenter: !1,
        autoScale: !1
      }));
      b && (null === (d = e.parent) || void 0 === d || d.add(b.modelObject), e.userData.extrudedObject = b.modelObject.uuid, b.dispatchEvent({
        type: "select",
        ui: !0,
        value: b
      }));
    }

    static ExtrudeShape(e, t, n, r, s, o, a, l) {
      const c = new zA(e, r, t, n, !0, new i.FM8(s, o), l ? "shape" : "path");
      c.computeBoundingBox(), c.createSplits(a);
      const u = lt(new i.Kj0(c, []));
      return u.userData.isExtrudedTube = !0, u;
    }

    static ConvertGeometryToFlatShape(e, t = !0) {
      if (e.userData.__planarShape) return e.userData.__planarShape;
      let n = e.attributes.position;
      if (!n) throw "no position attribute";
      if (n.count > 500) throw "too large to extrude";
      const r = e;
      n = r.attributes.position, r.boundingBox || r.computeBoundingBox();
      const s = r.boundingBox.getSize(new i.Pa4()),
            o = s.x < .001 ? "x" : s.y < .001 ? "y" : s.z < .001 ? "z" : null;
      if (!o) throw "geometry is not axis aligned not planar";
      let a = [];

      for (let e = 0; e < n.count; e++) {
        const t = new i.FM8();
        "x" === o ? t.set(n.getY(e), n.getZ(e)) : "y" === o ? t.set(n.getX(e), n.getZ(e)) : t.set(n.getX(e), n.getY(e)), a.push(t);
      }

      if (t) {
        let e = 0;

        for (let t = 0; t < a.length; t++) (a[t].x < a[e].x || a[t].x === a[e].x && a[t].y < a[e].y) && (e = t);

        0 !== e && (a = a.slice(e).concat(a.slice(0, e)));
      }

      const l = new i.bnF(a);
      return e.userData.__planarShape = l, l;
    }

  };
  HA.PluginType = "ShapeTubeExtrudePlugin", GA([Ve("Enabled")], HA.prototype, "enabled", void 0), GA([He("Shape Segments (X)", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "shapeSegments", void 0), GA([He("Tube Segments (Y)", [1, 100], 1, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "tubularSegments", void 0), GA([We("Shape scale", [.01, 10], .01, e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "shapeScale", void 0), GA([qe("Material Splits", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "materialSplits", void 0), GA([Ve("Horizontal Splits", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "horizontalSplits", void 0), GA([Xe("Extrude Circle Tube", e => ({
    hidden: () => {
      var t, n;
      return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject());
    }
  }))], HA.prototype, "extrudeCirceTube", void 0), HA = VA = GA([Qe("Extrude Tube Shapes")], HA);

  class WA extends i.Ny0 {
    getPoint(e, t) {
      return super.getPoint(e, t || new i.Pa4());
    }

  }

  class KA extends Gs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = !1, this.disableFrameFade = !0, this._postFrame = () => {
        var e, t;
        if (!this._viewer) return;
        if (!this.enabled || Object.keys(this.animations).length < 1) return this._lastFrameTime = 0, void (this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(KA.PluginType), this._fadeDisabled = !1));
        const n = Ct() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
        let r = n - this._lastFrameTime;
        this._lastFrameTime = n;
        const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();

        if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= .001) && (this._updaters.forEach(e => {
          let t = r;
          e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t);
        }), !this._fadeDisabled && this.disableFrameFade))) {
          const e = this._viewer.getPluginByType("FrameFade");

          e && (e.disable(KA.PluginType), this._fadeDisabled = !0);
        }
      }, this.defaultDriver = e => ({
        start: () => this._updaters.push({
          u: e,
          time: 0
        }),
        stop: () => this._updaters.splice(this._updaters.findIndex(t => t.u === e), 1)
      }), this.animations = {}, this.enabled = e, this._postFrame = this._postFrame.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), e.addEventListener("postFrame", this._postFrame);
    }

    async onRemove(e) {
      return e.removeEventListener("postFrame", this._postFrame), super.onRemove(e);
    }

    animate(e) {
      const t = Be(),
            n = {
        id: t,
        options: e,
        stop: () => {
          var e, n, r;
          (null === (e = this.animations[t]) || void 0 === e ? void 0 : e._stop) ? null === (r = null === (n = this.animations[t]) || void 0 === n ? void 0 : n._stop) || void 0 === r || r.call(n) : console.warn("Animation not started");
        }
      };
      return this.animations[t] = n, n.promise = new Promise((n, r) => {
        const i = {
          driver: this.defaultDriver,
          onComplete: () => {
            var t;
            null === (t = e.onComplete) || void 0 === t || t.call(e), n();
          },
          onStop: () => {
            var t;
            null === (t = e.onStop) || void 0 === t || t.call(e), n();
          },
          ...e
        },
              s = dc(i);
        this.animations[t]._stop = s.stop, this.animations[t].options = i;
      }).then(() => (delete this.animations[t], t)), this.animations[t];
    }

    async animateAsync(e) {
      return this.animate(e).promise;
    }

  }

  KA.PluginType = "PopmotionPlugin";

  const XA = async e => bt(await (await fetch(e)).blob());

  async function qA(e, t = XA) {
    const n = e.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
    if (n) for (const r of n) {
      const n = await t(r);
      e = e.replace(r, n);
    }
    return e;
  }

  function YA(e, t, {
    width: n,
    height: r
  }, i = !0) {
    const s = `\n<svg viewBox="0 0 ${n} ${r}" xmlns="http://www.w3.org/2000/svg">\n    <style>\n    ${t}\n    </style>\n    <foreignObject x="0" y="0" width="100%" height="100%">\n        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">\n            ${e}\n        </div>\n    </foreignObject>\n</svg>\n    `;
    return i ? A(s) : s;
  }

  async function ZA(e, t, n) {
    const r = YA(e, t, n);
    return await hT(r, n);
  }

  async function JA(e, t, n) {
    const r = YA(e, t, n);
    return await dT(r, n);
  }

  var $A,
      QA,
      eC = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  const tC = e => ({
    onChange: t => {
      t.last && e.onChange();
    }
  });

  let nC = $A = class {
    constructor() {
      this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.fontFamily = "", this.fontPath = "", this.maskText = !1, this.innerShadow = !1, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {};
    }

    set(e) {
      Object.assign(this, e);
    }

    reset() {
      const e = this.onChange;
      Object.assign(this, new $A()), this.onChange = e;
    }

    toJSON() {
      return {
        text: this.text,
        fontFamily: this.fontFamily,
        fontPath: this.fontPath,
        svgBackground: this.svgBackground,
        width: this.width,
        height: this.height,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        boxWidth: this.boxWidth,
        boxHeight: this.boxHeight,
        fontSize: this.fontSize,
        maskText: this.maskText,
        innerShadow: this.innerShadow,
        bgFillColor: this.bgFillColor,
        textColor: this.textColor
      };
    }

  };
  eC([qe("Text", tC)], nC.prototype, "text", void 0), eC([He("Font Size", [2, 400], 1, tC)], nC.prototype, "fontSize", void 0), eC([He("Width", [2, 4096], 1, tC)], nC.prototype, "width", void 0), eC([He("Height", [2, 4096], 1, tC)], nC.prototype, "height", void 0), eC([He("X Offset", [-1024, 1024], 1, tC)], nC.prototype, "xOffset", void 0), eC([He("Y Offset", [-1024, 1024], 1, tC)], nC.prototype, "yOffset", void 0), eC([He("V-Width", [2, 4096], 1, tC)], nC.prototype, "boxWidth", void 0), eC([He("V-Height", [2, 4096], 1, tC)], nC.prototype, "boxHeight", void 0), eC([qe("Font", tC)], nC.prototype, "fontFamily", void 0), eC([qe("Font Url", tC)], nC.prototype, "fontPath", void 0), eC([Ve("Mask Text", tC)], nC.prototype, "maskText", void 0), eC([Ve("Inner Shadow", tC)], nC.prototype, "innerShadow", void 0), eC([Ye("Text Color", tC)], nC.prototype, "textColor", void 0), eC([Ye("BG Fill", tC)], nC.prototype, "bgFillColor", void 0), eC([Ye("SVG BG", tC)], nC.prototype, "svgBackground", void 0), nC = $A = eC([Qe("Text SVG Options")], nC);

  const rC = {
    woff: "woff",
    woff2: "woff2",
    ttf: "truetype",
    otf: "opentype",
    eot: "embedded-opentype"
  },
        iC = e => ({
    hidden: () => {
      const t = e.getSelected();
      return !t || !t.userData[sC.PluginType];
    }
  });

  let sC = QA = class extends Gs {
    constructor() {
      super(), this.enabled = !0, this.getSelected = () => {
        var e, t;
        return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
      }, this.options = new nC(), this.applyToMap = !0, this.applyToBumpMap = !1, this.applyToAlphaMap = !0, this.inverseAlphaMap = !1, this._lastMeta = void 0, this.fonts = {
        roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2"
      }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged;
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged);
    }

    _selectedObjectChanged() {
      var e, t, n, r, i, s;
      if (!this.enabled) return;
      const o = this.getSelected();
      if (!o) return void (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
      const a = o.userData[QA.PluginType];
      if (!a) return this.options.reset(), this._lastMeta = void 0, void (null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
      this._lastMeta !== a && (this.options.set(a), this._lastMeta = a), null === (s = (i = this.uiConfig).uiRefresh) || void 0 === s || s.call(i, "postFrame", !0);
    }

    _paramsChanged() {
      if (!this.enabled) return;
      const e = this.getSelected();
      e && e.isMesh && e.userData[QA.PluginType] && this.updateText(e, this.options.toJSON());
    }

    addTextToSelected() {
      const e = this.getSelected();
      if (e && e.isMesh) {
        if (e.material) {
          if (e.userData[QA.PluginType] || !e.material.map || confirm("This mesh already has a texture. Adding text will replace the texture. Continue?")) return this.addText(e);
        } else console.error("no material on mesh");
      } else console.error("no mesh is selected");
    }

    async addText(e, t) {
      return this.updateText(e, Object.assign(this.options.toJSON(), t));
    }

    async updateText(e, t) {
      var n, r;
      if (!e.isMesh) return;
      if (!e.material) return void console.error("updateText: no material on mesh");
      let i = e.userData[QA.PluginType];
      i || (e.userData[QA.PluginType] = i = {}), Object.assign(i, t);
      const s = e.material;
      s.map && (s.map._isSimpleTextTexture && s.map.dispose(), s.map = void 0), s.alphaMap && (s.alphaMap._isSimpleTextTexture && s.alphaMap.dispose(), s.alphaMap = void 0), s.bumpMap && (s.bumpMap._isSimpleTextTexture && s.bumpMap.dispose(), s.bumpMap = void 0);
      const o = await this.makeTextSvg(i);
      this.applyToMap && (s.map = o), this.applyToAlphaMap && (s.alphaMap = o, s.transparent = !0), this.applyToBumpMap && (s.bumpMap = o), s.userData.inverseAlphaMap = this.inverseAlphaMap, s.userData.setDirty(), s.needsUpdate = !0, null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0);
    }

    async makeTextSvg(e) {
      const t = e.fontFamily || "Arial",
            n = e.fontPath || this.fonts[t] || "";
      let r = e.style;

      if (n.length > 0) {
        const e = n.split("?")[0].split(".").pop() || "woff";
        r += "\n" + (n.length > 0 ? `\n            @font-face {\n                font-family: ${t};\n                src: url(${n}) format(${rC[e] || e});\n            }` : "");
      }

      let s = function ({
        text: e = "Custom Text",
        svgBackground: t = "#ffffff",
        xOffset: n = 0,
        yOffset: r = 0,
        width: i = 1024,
        height: s = 1024,
        boxWidth: o = 1024,
        boxHeight: a = 1024,
        fontFamily: l = "",
        fontSize: c = 32,
        maskText: u = !0,
        innerShadow: p = !0,
        bgFillColor: h = "#000000",
        textColor: d = "#ffffff",
        style: f = ""
      }) {
        return `\n<svg style="background-color:${t}" width="${i}" height="${s}" viewBox="0 0 ${o} ${a}"\n xmlns="http://www.w3.org/2000/svg"\n xmlns:xlink="http://www.w3.org/1999/xlink">\n     <defs>\n        <style>\n        ${f}\n        </style>\n    </defs>\n\n    <g style="overflow:hidden; text-anchor: middle; font-size: ${c}px; font-family: ${l || "Arial"}">\n        <defs>\n\n` + (u ? `\n<mask id="textMask">\n<text style="fill:white; font-size: ${c}px;" x="${n + o / 2}" y="${a / 2 + r + c / 4}" > ${e} </text>\n</mask>\n` : "") + "\n\n" + (p ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u ? '\n        <g mask="url(#textMask)">\n' : "") + `\n\n        <rect x="0" y="0" width="${o}" height="${a}" style="fill:${h}"/>\n        <text style="${p ? "filter: url(#innerShadow);" : ""} fill:${d};" x="${n + o / 2}" y="${a / 2 + r + c / 4}"> ${e} </text>\n\n` + (u ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n";
      }({ ...e,
        fontFamily: t,
        style: r
      });

      s = await qA(s, async e => this._getAssetData(e)), s = A(s);
      const o = await this._viewer.getManager().importer.importSinglePath(s, {
        generateMipmaps: !1,
        minFilter: i.wem
      });
      return o._isSimpleTextTexture = !0, o.flipY = !1, o.needsUpdate = !0, o;
    }

    async _getAssetData(e) {
      var t, n;
      if (e.startsWith("http://www.w3.org")) return e;
      const r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getManager()) || void 0 === n ? void 0 : n.importer;
      if (!r) throw new Error("no importer");
      this._assetLoadOptions = this._assetLoadOptions || {
        fileHandler: new ox(r.loadingManager),
        processImported: !1
      };

      try {
        return await r.importPath(e, this._assetLoadOptions);
      } catch (e) {
        return console.error(e), "";
      }
    }

  };
  sC.PluginType = "SimpleTextPlugin", eC([ze(void 0, {
    params: iC
  })], sC.prototype, "options", void 0), eC([Ve("Apply Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToMap", void 0), eC([Ve("Apply Bump Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToBumpMap", void 0), eC([Ve("Apply Alpha Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToAlphaMap", void 0), eC([Ve("Invert Alpha Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "inverseAlphaMap", void 0), eC([Xe("Add Text", e => ({
    hidden: () => !e.getSelected()
  }))], sC.prototype, "addTextToSelected", null), sC = QA = eC([Qe("Simple Text")], sC);

  var oC = __webpackgi_require__(819);

  class aC {
    static _initialize() {
      this._inited = !0, Mt(T`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", e => {
        this.Element && !this.Element.contains(e.target) && this.Remove();
      });
    }

    static Create(e, t, n) {
      this._inited || this._initialize(), this.Element && this.Remove();
      const r = wt({
        id: "customContextMenu",
        addToBody: !1
      });
      r.style.top = n + "px", r.style.left = t + "px";

      for (const [t, n] of Object.entries(e)) {
        const e = wt({
          classList: ["customContextMenuItems"],
          addToBody: !1,
          innerHTML: t
        });
        r.appendChild(e), e.onclick = n;
      }

      return this.Element = r, r;
    }

    static Remove() {
      var e;
      null === (e = this.Element) || void 0 === e || e.remove(), this.Element = void 0;
    }

  }

  aC.Element = void 0, aC._inited = !1;

  var lC = __webpackgi_require__(665),
      cC = __webpackgi_require__(532),
      uC = {};

  uC.styleTagTransform = Am(), uC.setAttributes = Sm(), uC.insert = ym().bind(null, "head"), uC.domAPI = bm(), uC.insertStyleElement = Tm(), gm()(cC.Z, uC), cC.Z && cC.Z.locals && cC.Z.locals;

  const pC = (e, t, n) => {
    var r, i, s;
    const o = e.controller_,
          a = null === (i = null === (r = o.parent) || void 0 === r ? void 0 : r.children) || void 0 === i ? void 0 : i.indexOf(o);
    return !(((e, t) => t.controller_.rackController.rack === e.controller_.parent)(e, t) && a === n || (void 0 !== a && a >= 0 && (null === (s = o.parent) || void 0 === s || s.remove(e)), t.add(e, n), 0));
  },
        hC = (e, t, n, r) => {
    var i, s, o, a, l;
    let c = t.uiRef;
    const u = null == c ? void 0 : c.expanded;
    if (c || (c = e.addFolder({
      title: ""
    }), c.on("fold", e => {
      var n, r, i;
      let s = c.expanded;
      g(t, "expanded", s, !0), s = null !== (n = x(t.expanded)) && void 0 !== n ? n : s, s !== c.expanded && (c.expanded = s), null === (r = t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0), s && (null === (i = t.onExpand) || void 0 === i || i.call(t, t));
    })), !c) return c;
    c.expanded = null !== (s = null !== (i = x(t.expanded)) && void 0 !== i ? i : u) && void 0 !== s && s;
    const p = (null !== (o = t.children) && void 0 !== o ? o : []).map(e => e && x(e)).flat(2).filter(e => e);
    let h = 0;

    for (const e of p) {
      let t = e.uiRef;
      t && t.controller_.viewProps.get("disposed") && (e.uiRef = void 0), t = e.uiRef, t || (n.appendUiObject({
        uiConfig: e
      }, c), t = e.uiRef), t && pC(t, c, h++) && n.appendUiObject({
        uiConfig: e
      }, c);
    }

    let d = c.children;

    for (; d.length > h;) {
      const e = d[d.length - 1];
      c.remove(e), d = c.children;
    }

    c.controller_.props.set("title", null !== (a = x(t.label)) && void 0 !== a ? a : "");

    const f = c.controller_.view.containerElement,
          _ = x(t.domChildren, []);

    if (void 0 !== (null == _ ? void 0 : _.length)) {
      const e = [];

      for (let t = 0; t < f.children.length; t++) {
        const n = f.children[t];
        (null === (l = n.dataset) || void 0 === l ? void 0 : l.tpCustomDOM) && e.push(n);
      }

      for (const t of e) f.removeChild(t);

      for (const e of _) e.parentElement !== f && (f.appendChild(e), e.dataset.tpCustomDOM = "true");

      c.controller_.foldable.cleanUpTransition();
    }

    return c;
  },
        dC = (e, t, n, r) => {
    var i, s;
    const [o, a] = null !== (i = t.property) && void 0 !== i ? i : [void 0, void 0],
          l = null !== (s = x(t.label)) && void 0 !== s ? s : a;
    let c = t.uiRef;
    return c || (c = e.addButton({
      title: ""
    }), c.on("click", () => {
      var e;
      const r = null !== (e = o && a ? o[a] : void 0) && void 0 !== e ? e : t.value;

      if ("function" == typeof r) {
        const e = () => {
          n.removeEventListener("postFrame", e), r();
        };

        n.addEventListener("postFrame", e);
      } else console.warn("Invalid action type for button");
    })), c && (c.title = null != l ? l : "click me"), c;
  },
        fC = (e, t, n, r) => {
    var i;
    const s = Object.fromEntries((null !== (i = x(t.children)) && void 0 !== i ? i : []).map(e => x(e)).flat(2).filter(e => e).map(e => {
      var t;
      const n = x(e.label);
      return [n, null !== (t = e.value) && void 0 !== t ? t : n];
    }));
    return vC(e, t, n, {
      options: s,
      ...(null != r ? r : {})
    });
  },
        _C = (e, t, n, r) => {
    var i, s, o, a;
    const l = (null !== (s = null === (i = t.bounds) || void 0 === i ? void 0 : i.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
          c = (null !== (a = null === (o = t.bounds) || void 0 === o ? void 0 : o.length) && void 0 !== a ? a : 0) >= 1 ? t.bounds[0] : 0,
          u = t.stepSize || void 0;
    return vC(e, t, n, {
      min: c,
      max: l,
      step: u,
      ...(null != r ? r : {})
    });
  },
        mC = (e, t, n, r) => {
    var s, o, a;
    if (!t.bounds || t.bounds.length < 1) return vC(e, t, n, { ...(null != r ? r : {})
    });
    const l = (null !== (s = t.bounds.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
          c = (null !== (o = t.bounds.length) && void 0 !== o ? o : 0) >= 1 ? t.bounds[0] : 0,
          u = {
      min: c,
      max: l,
      step: null !== (a = t.stepSize) && void 0 !== a ? a : (l - c) / 100
    },
          p = {
      x: u,
      y: u
    };
    "vec3" !== t.type && "vec4" !== t.type || (p.z = u), "vec4" === t.type && (p.w = u);
    const h = t.property;

    if (void 0 === t.value && h && h[0] && "object" == typeof h[0] && h[0][h[1]] && Array.isArray(h[0][h[1]])) {
      const [e, n] = h,
            r = e[n],
            s = r.length,
            o = new (2 === s ? i.FM8 : 3 === s ? i.Pa4 : i.Ltg)().fromArray(r);
      t.value = o, t.property = void 0, t.onChange = [() => {
        e[n] = o.toArray();
      }, ...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = n);
    }

    return vC(e, t, n, { ...p,
      ...(null != r ? r : {})
    });
  },
        gC = (e, t, n, r) => {
    var i;
    const s = t.property;

    if (void 0 === t.value && s && "object" == typeof s[0] && (null === (i = s[0][s[1]]) || void 0 === i ? void 0 : i.isColor)) {
      const [e, n] = s,
            r = new ve().set(e[n]).convertSRGBToLinear();
      Object.defineProperty(t, "value", {
        get: () => {
          const t = e[n];
          return t ? r.set(t).convertLinearToSRGB().getHex() : 0;
        },
        set: t => {
          var i;
          const s = e[n];
          r.setHex(t).convertSRGBToLinear(), s.isColor ? s.copy(r) : "number" == typeof s ? e[n] = r.getHex() : "string" == typeof s && (e[n] = "#" + r.getHexString()), "function" == typeof (null === (i = null == e ? void 0 : e.userData) || void 0 === i ? void 0 : i.setDirty) && e.userData.setDirty();
        }
      }), t.property = void 0, t.onChange = [...(Array.isArray(t.onChange) ? t.onChange : [t.onChange])].filter(e => e), void 0 === t.label && (t.label = n);
    }

    return (r = null != r ? r : {}).view = "color", x(t.inlinePicker) && (r.picker = "inline"), vC(e, t, n, r);
  },
        vC = (e, t, n, r) => {
    var i;
    let s = x(t.property);
    if ((t.getValue || t.setValue) && s && console.error("specify either property or value, or getValue and setValue", t), s) t.value && console.warn("Both property and value are defined, value will be ignored", t);else if (void 0 === t.value && (t.getValue || t.setValue) && (Object.defineProperty(t, "value", {
      get: () => {
        var e;
        return null === (e = t.getValue) || void 0 === e ? void 0 : e.call(t);
      },
      set: e => {
        var n;
        return null === (n = t.setValue) || void 0 === n ? void 0 : n.call(t, e);
      }
    }), s = [t, "value"]), s || void 0 === t.value || (s = [t, "value"]), !s) return void console.error("cannot determine property", t);
    r = null != r ? r : {};
    const o = {
      label: null !== (i = x(t.label)) && void 0 !== i ? i : s[1],
      ...r
    };
    let a = t.uiRef;

    if (!a && "object" == typeof s[0] && s[0]) {
      const [n, r] = s;

      try {
        a = t.isMonitor ? e.addMonitor(n, r, o) : e.addInput(n, r, o).on("change", e => {
          var r;
          [t.onChange].flat().forEach(t => "function" == typeof t && (null == t ? void 0 : t(e))), "function" == typeof (null === (r = null == n ? void 0 : n.userData) || void 0 === r ? void 0 : r.setDirty) && n.userData.setDirty(e);
        });
      } catch (e) {
        if (!e.message.startsWith("No matching controller for")) throw e;
        a = void 0;
      }
    }

    if (a) {
      for (const [e, t] of Object.entries(o)) {
        const n = a.controller_.props.value(e);
        void 0 !== n && n.rawValue !== t && a.controller_.props.set(e, t);
      }

      a.refresh();
    }

    return a;
  };

  class bC extends r {
    constructor(e = !1, t = !1, n = !1, r = !0) {
      super(), this._refreshQueue = {
        preRender: [],
        postRender: [],
        preFrame: [],
        postFrame: []
      }, this._typeGenerators = {
        folder: hC,
        input: vC,
        slider: _C,
        dropdown: fC,
        checkbox: vC,
        color: gC,
        vec: mC,
        vec2: mC,
        vec3: mC,
        vec4: mC,
        button: dC,
        monitor: (e, t, n, r) => (t.isMonitor = !0, vC(e, t, n, r)),
        dummy: (e, t, n, r) => vC(e, t, n, r)
      }, this._expand = e, this._limitedOptions = n;

      const i = this._createUiContainer();

      this._pane = new lC.Pane({
        title: "Configuration",
        container: i
      }), this._pane.expanded = this._expand, r && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")), setTimeout(() => {
        this.dispatchEvent({
          type: "postFrame"
        });
      }, 32));
    }

    refreshQueue(e) {
      const t = this._refreshQueue[e];
      this._refreshQueue[e] = [], t.forEach(e => this._refreshUiObject(e[0], e[1], e[2]));
    }

    addToRefreshQueue(e, t) {
      var n;
      const r = null === (n = t[0]) || void 0 === n ? void 0 : n.uiConfig,
            i = null == r ? void 0 : r.uuid,
            s = this._refreshQueue[e];
      s.findIndex(e => e[3] === i) < 0 && s.push([...t, i]), this._refreshQueue[e] = s;
    }

    dispose() {
      var e;
      null === (e = this._pane) || void 0 === e || e.dispose(), this._pane = void 0;
    }

    appendUiObject(e, t) {
      e && this._appendUiObject(e, t);
    }

    _appendUiObject(e, t) {
      var n, r, i, s;
      const {
        uiConfig: o
      } = null != e ? e : {};

      if (o && (!this._limitedOptions || o.limitedUi) && (t = null != t ? t : this._pane, o.type)) {
        o.uuid || (o.uuid = Be()), o.uiRef && o.uiRefType !== o.type && (console.log("Removing UI object because of type mismatch", o.uiRef), this.removeUiConfig(o));
        const a = null === (r = (n = this._typeGenerators)[o.type]) || void 0 === r ? void 0 : r.call(n, t, o, this);
        a && (a.hidden = null !== (i = x(o.hidden)) && void 0 !== i && i, a.disabled = null !== (s = x(o.disabled)) && void 0 !== s && s), o.uiRef = a, o.uiRefType = a ? o.type : void 0, o.uiRefresh = (n = "postFrame", r = !1, i = 0) => {
          var s;
          return this._uiObjectRefresh(n, null !== (s = null == e ? void 0 : e.uiConfig) && void 0 !== s ? s : o, t, r, i);
        };
      }
    }

    removeUiObject(e) {
      this.removeUiConfig(null == e ? void 0 : e.uiConfig);
    }

    removeUiConfig(e) {
      var t, n;
      e && e.uiRef && e.uiRefType !== e.type && (null === (n = (t = e.uiRef).dispose) || void 0 === n || n.call(t), e.uiRefType = void 0, e.uiRefresh = void 0);
    }

    _uiObjectRefresh(e, t, n, r, i) {
      (r ? xC(t, n) : [{
        uiConfig: t,
        parentFolder: n
      }]).forEach(t => {
        const n = [{
          uiConfig: t.uiConfig
        }, t.parentFolder, i];
        "immediate" === e ? this._refreshUiObject(...n) : this.addToRefreshQueue(e, n);
      });
    }

    _refreshUiObject(e, t, n = 0) {
      this._appendUiObject(e, t), n > 1e-4 && console.error("no support for immediate delay");
    }

    _createUiContainer() {
      const e = wt({
        id: "tweakpaneUiContainer"
      });
      return Mt(T`
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: max(20%, 300px);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
          }
        `), e;
    }

  }

  function xC(e, t, n) {
    var r;
    return n = null != n ? n : [], e ? (n.push({
      uiConfig: e,
      parentFolder: t
    }), null === (r = e.children) || void 0 === r || r.forEach(t => n = xC(t, e.uiRef, n)), n) : n;
  }

  class yC {
    constructor() {
      yC.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }

    set(e, t, n, r, i, s, o, a, l) {
      const c = this.elements;
      return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this;
    }

    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }

    copy(e) {
      const t = this.elements,
            n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
    }

    extractBasis(e, t, n) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }

    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }

    multiply(e) {
      return this.multiplyMatrices(this, e);
    }

    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }

    multiplyMatrices(e, t) {
      const n = e.elements,
            r = t.elements,
            i = this.elements,
            s = n[0],
            o = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            p = n[2],
            h = n[5],
            d = n[8],
            f = r[0],
            _ = r[3],
            m = r[6],
            g = r[1],
            v = r[4],
            b = r[7],
            x = r[2],
            y = r[5],
            w = r[8];
      return i[0] = s * f + o * g + a * x, i[3] = s * _ + o * v + a * y, i[6] = s * m + o * b + a * w, i[1] = l * f + c * g + u * x, i[4] = l * _ + c * v + u * y, i[7] = l * m + c * b + u * w, i[2] = p * f + h * g + d * x, i[5] = p * _ + h * v + d * y, i[8] = p * m + h * b + d * w, this;
    }

    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }

    determinant() {
      const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8];
      return t * s * c - t * o * l - n * i * c + n * o * a + r * i * l - r * s * a;
    }

    invert() {
      const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            s = e[4],
            o = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = c * s - o * l,
            p = o * a - c * i,
            h = l * i - s * a,
            d = t * u + n * p + r * h;
      if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / d;
      return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * s) * f, e[3] = p * f, e[4] = (c * t - r * a) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * a - l * t) * f, e[8] = (s * t - n * i) * f, this;
    }

    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }

    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }

    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }

    setUvTransform(e, t, n, r, i, s, o) {
      const a = Math.cos(i),
            l = Math.sin(i);
      return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -r * l, r * a, -r * (-l * s + a * o) + o + t, 0, 0, 1), this;
    }

    scale(e, t) {
      const n = this.elements;
      return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
    }

    rotate(e) {
      const t = Math.cos(e),
            n = Math.sin(e),
            r = this.elements,
            i = r[0],
            s = r[3],
            o = r[6],
            a = r[1],
            l = r[4],
            c = r[7];
      return r[0] = t * i + n * a, r[3] = t * s + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * a, r[4] = -n * s + t * l, r[7] = -n * o + t * c, this;
    }

    translate(e, t) {
      const n = this.elements;
      return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this;
    }

    equals(e) {
      const t = this.elements,
            n = e.elements;

      for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;

      return !0;
    }

    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];

      return this;
    }

    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
    }

    clone() {
      return new this.constructor().fromArray(this.elements);
    }

  }

  function wC(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e);
  }

  let SC;
  Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

  class MC {
    constructor(e = null) {
      this.isSource = !0, this.uuid = $(), this.data = e, this.version = 0;
    }

    set needsUpdate(e) {
      !0 === e && this.version++;
    }

    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      },
            r = this.data;

      if (null !== r) {
        let e;

        if (Array.isArray(r)) {
          e = [];

          for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(TC(r[t].image)) : e.push(TC(r[t]));
        } else e = TC(r);

        n.url = e;
      }

      return t || (e.images[this.uuid] = n), n;
    }

  }

  function TC(e) {
    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? class {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;else {
          void 0 === SC && (SC = wC("canvas")), SC.width = e.width, SC.height = e.height;
          const n = SC.getContext("2d");
          e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = SC;
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png");
      }

      static sRGBToLinear(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
          const t = wC("canvas");
          t.width = e.width, t.height = e.height;
          const n = t.getContext("2d");
          n.drawImage(e, 0, 0, e.width, e.height);
          const r = n.getImageData(0, 0, e.width, e.height),
                i = r.data;

          for (let e = 0; e < i.length; e++) i[e] = 255 * le(i[e] / 255);

          return n.putImageData(r, 0, 0), t;
        }

        if (e.data) {
          const t = e.data.slice(0);

          for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * le(t[e] / 255)) : t[e] = le(t[e]);

          return {
            data: t,
            width: e.width,
            height: e.height
          };
        }

        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
      }

    }.getDataURL(e) : e.data ? {
      data: Array.from(e.data),
      width: e.width,
      height: e.height,
      type: e.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }

  let EC = 0;

  class AC extends class {
    addEventListener(e, t) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
    }

    hasEventListener(e, t) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[e] && -1 !== n[e].indexOf(t);
    }

    removeEventListener(e, t) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[e];

      if (void 0 !== n) {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      }
    }

    dispatchEvent(e) {
      if (void 0 === this._listeners) return;
      const t = this._listeners[e.type];

      if (void 0 !== t) {
        e.target = this;
        const n = t.slice(0);

        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);

        e.target = null;
      }
    }

  } {
    constructor(e = AC.DEFAULT_IMAGE, t = AC.DEFAULT_MAPPING, n = 1001, r = 1001, i = se, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) {
      super(), this.isTexture = !0, Object.defineProperty(this, "id", {
        value: EC++
      }), this.uuid = $(), this.name = "", this.source = new MC(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new yC(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
    }

    get image() {
      return this.source.data;
    }

    set image(e) {
      this.source.data = e;
    }

    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }

    clone() {
      return new this.constructor().copy(this);
    }

    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
    }

    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
    }

    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }

    transformUv(e) {
      if (300 !== this.mapping) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case 1e3:
          e.x = e.x - Math.floor(e.x);
          break;

        case 1001:
          e.x = e.x < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case 1e3:
          e.y = e.y - Math.floor(e.y);
          break;

        case 1001:
          e.y = e.y < 0 ? 0 : 1;
          break;

        case 1002:
          1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }

    set needsUpdate(e) {
      !0 === e && (this.version++, this.source.needsUpdate = !0);
    }

  }

  AC.DEFAULT_IMAGE = null, AC.DEFAULT_MAPPING = 300;

  class CC extends bC {
    constructor(e = !1, t = !1, n = !1) {
      super(e, t, n, !1), this.dependencies = [Vs], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = e => {
        this.dispatchEvent(e), this.refreshQueue("postFrame");
      }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this._pane.registerPlugin(oC);
    }

    async onAdded(e) {
      this._viewer = e, this._typeGenerators.image = (e => (t, n, r, s) => {
        const o = n.property,
              a = "placeholder";

        if (void 0 === n.value && o && "object" == typeof o[0]) {
          const [t, r] = o,
                s = pT("Render Target"),
                l = pT("Data Texture"),
                c = pT("Compressed Texture"),
                u = {},
                p = {};
          Object.defineProperty(n, "value", {
            get: () => {
              var e;
              let n,
                  i = t[r];
              if ((null == i ? void 0 : i.get) && (i = i.get()), !i) return a;

              if (i.isRenderTargetTexture && !i.image.tp_src && (i.image.tp_src = s), i.isDataTexture && !i.image.tp_src && (i.image.tp_src = l), i.isCompressedTexture && !i.image.tp_src && (i.image.tp_src = c), i.isTexture ? (i.image && (i.image instanceof ImageBitmap || i.image instanceof HTMLImageElement || i.image instanceof HTMLVideoElement) && !i.image.tp_src && (i.image.tp_src = Et(i.image, 160)), i.image && (n = i.image.tp_src_uuid, n = n ? u[n] : void 0, n || (n = i.image.tp_src || i.image.src))) : "string" == typeof i ? n = i : i && console.error("unknown value", i), n || (n = a), i.image && !i.image.tp_src_uuid) {
                const e = Be();
                i.image.tp_src_uuid = e, p[n] = e;
              }

              return "string" == typeof n && (n = null !== (e = u[n]) && void 0 !== e ? e : n), n;
            },
            set: s => {
              var o, l, c, h, d, f, _, m, g, v, b, x, y;

              const w = t[r],
                    S = e => {
                var n;
                t[r] = e, (null == e ? void 0 : e.isTexture) && (e.flipY = e.isDataTexture ? e.flipY : null === (n = null == w ? void 0 : w.flipY) || void 0 === n || n);
              };

              if ("string" == typeof s) return void ("string" == typeof w && S(s));
              let M = s.tp_src_uuid;
              if (M || (M = null !== (o = s.src) && void 0 !== o ? o : s.tp_src, M = null !== (l = p[M]) && void 0 !== l ? l : M, delete p[M], s.tp_src_uuid = M), M && (u[M] = s), s) {
                if (s.isPlaceholder) w && (S("string" == typeof w ? "" : null), "function" == typeof (null === (c = null == t ? void 0 : t.userData) || void 0 === c ? void 0 : c.setDirty) && t.userData.setDirty());else if ("string" != typeof w) {
                  if (!((null == w ? void 0 : w.image) === s || (null === (h = null == w ? void 0 : w.image) || void 0 === h ? void 0 : h.src) === s.src || (null === (d = null == w ? void 0 : w.image) || void 0 === d ? void 0 : d.tp_src) === s.tp_src && null != s.tp_src || (null === (f = null == w ? void 0 : w.image) || void 0 === f ? void 0 : f.tp_src) === s.src && null != s.src || (null === (_ = null == w ? void 0 : w.image) || void 0 === _ ? void 0 : _.src) === s.tp_src && null != s.tp_src)) if (s instanceof File) {
                    const r = null == e ? void 0 : e.getPlugin(Vs);
                    if (!r) throw "Viewer or AssetManagerPlugin not found";
                    null === (m = r.importer) || void 0 === m || m.importSingle({
                      file: s,
                      path: s.src
                    }).then(e => {
                      var r, i, o, a, l;

                      if (e) {
                        e.isDataTexture && (e.needsUpdate = !0);
                        const c = null === (o = null === (i = null === (r = s.src) || void 0 === r ? void 0 : r.split("?")) || void 0 === i ? void 0 : i[0]) || void 0 === o ? void 0 : o.split(".").pop();
                        e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(c) ? "jpeg" : "png")), S(e), [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (a = null == t ? void 0 : t.userData) || void 0 === a ? void 0 : a.setDirty) && t.userData.setDirty(), null === (l = n.uiRefresh) || void 0 === l || l.call(n, "postFrame", !1);
                      }
                    });
                  } else {
                    const e = new AC(s);
                    e.assetType = "texture", e.needsUpdate = !0;
                    const o = null === (b = null === (v = null === (g = s.src) || void 0 === g ? void 0 : g.split("?")) || void 0 === v ? void 0 : v[0]) || void 0 === b ? void 0 : b.split(".").pop();
                    e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o) ? "jpeg" : "png")), S(e);
                    const a = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(r);
                    e.encoding = a ? i.rnI : i.knz, e.wrapS = i.rpg, e.wrapT = i.rpg, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (x = null == t ? void 0 : t.userData) || void 0 === x ? void 0 : x.setDirty) && t.userData.setDirty(), null === (y = n.uiRefresh) || void 0 === y || y.call(n, "postFrame", !1);
                  }
                } else S(M);
              } else n.value = a;
            }
          }), n.property = void 0, void 0 === n.label && (n.label = r);
        }

        return (s = null != s ? s : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp"], void 0 === s.imageFit && (s.imageFit = "contain"), void 0 === s.clickCallback && (s.clickCallback = (t, r) => {
          var i;
          const s = null == t ? void 0 : t.target,
                l = null == s ? void 0 : s.getBoundingClientRect();
          if (!l) return void r.click();
          const c = n.uiRef.controller_.valueController.value.rawValue;
          if (c === a || (null == c ? void 0 : c.isPlaceholder)) r.click();else {
            const t = aC.Create({
              "remove image": () => {
                var e, t;
                n.uiRef.controller_.valueController.value.setRawValue("");
                const [r, i] = o || [n, "value"],
                      s = "string" == typeof r[i];
                r[i] = s ? "" : null, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (e = null == r ? void 0 : r.userData) || void 0 === e ? void 0 : e.setDirty) && r.userData.setDirty(), null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !1), aC.Remove();
              },
              "replace image": () => {
                r.click(), aC.Remove();
              },
              "download image": () => {
                var e, t, r;
                const [i, s] = o || [n, "value"];
                let a = null !== (t = null === (e = i[s]) || void 0 === e ? void 0 : e.image) && void 0 !== t ? t : n.uiRef.controller_.valueController.value.rawValue;
                a && (a instanceof ImageBitmap || a instanceof HTMLImageElement || a instanceof HTMLVideoElement) && !a.src && (a = Et(a));
                const l = document.createElement("a");
                document.body.appendChild(l), l.style.display = "none", l.href = null !== (r = null == a ? void 0 : a.src) && void 0 !== r ? r : a, l.download = "image.png", l.click(), document.body.removeChild(l), aC.Remove();
              },
              "from url": async () => {
                var t, r, i;
                let s = "";
                if (s && (s.startsWith("http") || s.startsWith("data:image")) || (s = ""), s = prompt("enter image url", s), !s || !s.startsWith("http") && !s.startsWith("data:image")) return null !== s && alert("invalid url"), void aC.Remove();
                const [a, l] = o || [n, "value"],
                      c = a[l];
                if ("string" == typeof c) a[l] = s, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (t = null == a ? void 0 : a.userData) || void 0 === t ? void 0 : t.setDirty) && a.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1);else {
                  const t = null == e ? void 0 : e.getPlugin(Vs);
                  if (!t) throw "Viewer or AssetManagerPlugin not found";
                  null === (i = t.importer) || void 0 === i || i.importSinglePath(s).then(e => {
                    var t, r;
                    e && (e.isDataTexture ? e.needsUpdate = !0 : e && void 0 !== (null == c ? void 0 : c.flipY) && (e.flipY = c.flipY), a[l] = e, [n.onChange].flat().forEach(e => "function" == typeof e && (null == e ? void 0 : e())), "function" == typeof (null === (t = null == a ? void 0 : a.userData) || void 0 === t ? void 0 : t.setDirty) && a.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1));
                  });
                }
                aC.Remove();
              },
              cancel: () => {
                aC.Remove();
              }
            }, 2, l.height + 8);
            null === (i = s.parentElement) || void 0 === i || i.appendChild(t), l.y > .7 * document.body.clientHeight && (t.style.top = "auto", t.style.bottom = l.height + 8 + "px");
          }
        }), s.view = "input-image", vC(t, n, r, s);
      })(this._viewer), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame), e.addEventListener("postFrame", this._postFrame);
    }

    async onDispose(e) {
      this.dispose();
    }

    async onRemove(e) {
      this._viewer = void 0, e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), e.removeEventListener("preFrame", this._preFrame), e.removeEventListener("postFrame", this._postFrame), this.dispose();
    }

    setupPluginUi(e) {
      var t;
      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(e);
      if (!n) return void console.warn("plugin not found:", e);
      this._plugins.push(n), n.uiConfig && (n.uiConfig.limitedUi = !0), n.uiConfig && void 0 === n.uiConfig.hidden && (n.uiConfig.hidden = !1), this._appendUiObject(n);
      const r = n.uiConfig;

      if ((null == r ? void 0 : r.uiRef) && n.toJSON) {
        const e = r.uiRef.controller_.view.element,
              t = wt({
          innerHTML: "&#8942;",
          classList: ["pluginOptionsButton"],
          elementTag: "button"
        });
        t.onclick = t => {
          const r = {};
          "function" == typeof n.toJSON && (r["download preset"] = async () => {
            var e, t;
            const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.exportPluginPreset(n);
            await vt(new Blob([JSON.stringify(r, null, 2)], {
              type: "application/json"
            }), "preset." + n.constructor.PluginType + ".json"), aC.Remove();
          }), "function" == typeof n.fromJSON && (r["upload preset"] = async () => {
            var e, t;
            aC.Remove();
            const r = await yt(!1, !1);
            if (0 === r.length) return;
            const i = r[0],
                  s = await i.text(),
                  o = JSON.parse(s);
            await (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importPluginPreset(o, n));
          });
          const i = aC.Create(r, e.clientWidth - 120, 12);
          e.append(i), t.preventDefault();
        }, e.appendChild(t);
      }

      return r;
    }

    setupPlugins(...e) {
      e.forEach(e => this.setupPluginUi(e));
    }

    refreshPluginsEnabled() {
      this._plugins.forEach(e => {
        var t;
        const n = e.uiConfig;
        n && (!0 !== x(n.hidden) ? null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !0) : n.uiRef && (n.uiRef.hidden = !0));
      });
    }

  }

  CC.PluginType = "TweakpaneUi";

  class RC extends Gs {
    constructor() {
      super(...arguments), this.enabled = !0, this.toJSON = void 0, this.bgUIConfig = {
        label: "Color",
        type: "color",
        inlinePicker: !0,
        onChange: () => {
          if (!this._viewer) return;
          const e = new ve(this.bgUIConfig.value || 16777215).convertSRGBToLinear();

          this._viewer.setBackground(e.getHex());
        },
        expanded: !0,
        limitedUi: !0
      }, this.uiConfig = {
        label: "Background / Environment",
        type: "folder",
        expanded: !1,
        limitedUi: !0,
        children: [this.bgUIConfig, {
          label: "Image",
          property: [this, "sceneBackground"],
          type: "image",
          limitedUi: !0
        }, {
          label: "EnvMap BG",
          type: "checkbox",
          property: [this, "envmapBg"]
        }, () => ({
          type: "slider",
          label: "BG Intensity",
          property: [this._viewer, "backgroundIntensity"],
          bounds: [0, 16]
        }), {
          label: "Set Transparent BG",
          type: "button",
          hidden: () => !this._viewer || this._viewer.useRgbm,
          value: () => {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setBackground(null);
          }
        }, {
          label: "Environment",
          property: [this, "sceneEnvironment"],
          type: "image",
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Rotation",
          property: [this, "sceneEnvironmentRotation"],
          bounds: [0, 2 * Math.PI],
          limitedUi: !0
        }, {
          type: "slider",
          label: "Env Intensity",
          property: [this, "sceneEnvironmentIntensity"],
          bounds: [0, 4],
          limitedUi: !0
        }]
      };
    }

    get sceneBackground() {
      var e;
      const t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground();
      return t && (t.isTexture || "texture" === t.assetType) ? t : null;
    }

    set sceneBackground(e) {
      var t, n;
      e ? null === (t = this._viewer) || void 0 === t || t.setBackground(e) : null === (n = this._viewer) || void 0 === n || n.setBackground(this.bgUIConfig.value);
    }

    get sceneEnvironment() {
      var e;
      return null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment();
    }

    set sceneEnvironment(e) {
      var t;
      null === (t = this._viewer) || void 0 === t || t.scene.setEnvironment(e);
    }

    get sceneEnvironmentRotation() {
      var e, t, n;
      return null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || void 0 === t ? void 0 : t.rotation) && void 0 !== n ? n : 0;
    }

    set sceneEnvironmentRotation(e) {
      var t, n;
      const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.getEnvironment();
      r && (r.rotation = e, null === (n = this._viewer) || void 0 === n || n.scene.setDirty());
    }

    get sceneEnvironmentIntensity() {
      var e, t;
      return null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.envMapIntensity) && void 0 !== t ? t : 1;
    }

    set sceneEnvironmentIntensity(e) {
      var t;
      (null === (t = this._viewer) || void 0 === t ? void 0 : t.scene) && (this._viewer.scene.envMapIntensity = e);
    }

    get envmapBg() {
      var e;
      return (null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0)) === io;
    }

    set envmapBg(e) {
      if (this._viewer) if (e) {
        const e = this._viewer.getBackground(!0);

        e && e !== io && (this.lastBgVal = e), this._viewer.setBackground(io);
      } else this._viewer.getBackground() === this._viewer.scene.getEnvironment() && this._viewer.setBackground(this.lastBgVal || this.bgUIConfig.value);
    }

    async onAdded(e) {
      var t;
      await super.onAdded(e);
      const n = e.getBackground();
      this.bgUIConfig.value = "string" == typeof n && n !== io || "number" == typeof n || (null === (t = n) || void 0 === t ? void 0 : t.isColor) ? "#" + new ve(n).getHexString() : "#000000", this.lastBgVal = n;
    }

  }

  RC.PluginType = "SimpleBackgroundEnvUiPlugin1";

  class kC extends Gs {
    constructor() {
      super(), this.enabled = !0, this.toJSON = void 0, this._uiConfig = {
        type: "folder",
        label: "Scene",
        children: [],
        onExpand: () => {
          var e, t;
          null === (t = (e = this._uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
        }
      }, this._onSelect = e => {
        var t, n;
        e.value ? null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n || n.setSelectedObject(e.value, !0) : console.warn("e.value must be set for picking");
      }, this._sceneUpdate = this._sceneUpdate.bind(this);
    }

    async onAdded(e) {
      await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n, r, i;
      return this._viewer ? (this._uiConfig.children = [], this._uiConfig.children.push(this._viewer.scene.activeCamera.uiConfig), this._uiConfig.children.push(...(null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.modelRoot.modelObject.children) || void 0 === t ? void 0 : t.map(e => "light" === e.assetType ? null : e.uiConfig).filter(e => null != e)) && void 0 !== n ? n : [])), null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot.modelObject.children) || void 0 === i || i.forEach(e => {
        e.addEventListener("select", this._onSelect);
      }), this._uiConfig) : this._uiConfig;
    }

    _sceneUpdate() {
      var e, t;
      null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0);
    }

  }

  kC.PluginType = "SimpleUi";

  var PC = __webpackgi_require__(466);

  class DC extends Gs {
    constructor(e = !0) {
      super(), this.enabled = !0, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = wt({
        innerHTML: "",
        id: "tpHierarchyContainer"
      }), this._uiConfig = {
        type: "folder",
        label: "Hierarchy",
        children: []
      }, this._buildData = (e, t) => (e.push({
        text: t.name || "unnamed",
        id: t.uuid,
        children: t.children.reduce(this._buildData, [])
      }), e), this._findVisible = (e, t) => t.visible ? (t.children.length < 1 ? e.push(t.uuid) : e.push(...t.children.reduce(this._findVisible, [])), e) : e, this._setVisible = e => {
        var t, n, r;
        const i = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
        if (!i || null == e) return;
        const s = new Set();
        i.traverse(t => {
          t !== i && (t.visible = e.includes(t.uuid), t.visible && t.traverseAncestors(e => s.add(e)));
        }), s.forEach(e => e.visible = !0), null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.scene) || void 0 === r || r.setDirty({
          sceneUpdate: !0,
          fromHierarchyPlugin: !0,
          updateGround: !1
        });
      }, this.enabled = e, this.reset = this.reset.bind(this), Mt(T`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: #e9e9ed;
  margin-top: 0;
}
`);
    }

    reset(e) {
      var t;
      if (null == e ? void 0 : e.fromHierarchyPlugin) return;

      for (; this.hierarchyDiv.firstChild;) this.hierarchyDiv.firstChild.remove();

      const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
      if (!n) return;
      const r = n.children.reduce(this._buildData, []),
            i = n.children.reduce(this._findVisible, []);
      let s = !1;
      return new Promise((e, t) => {
        this.treeView = new PC("#tpHierarchyContainer", {
          closeDepth: 1,
          data: r,
          loaded: function () {
            this.values = i, e();
          },
          onChange: () => {
            s ? _c(200).then(() => {
              this.treeView && this._setVisible(this.treeView.values);
            }) : s = !0;
          },
          onItemLabelClick: e => {
            var t;
            const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot.modelObject.getObjectByProperty("uuid", e);
            r && n.visible && r.dispatchEvent({
              type: "select",
              value: r
            });
          }
        });
      });
    }

    async onAdded(e) {
      await super.onAdded(e), this.reset(), e.scene.addEventListener("sceneUpdate", this.reset);
    }

    async onRemove(e) {
      return e.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e);
    }

    async onDispose(e) {
      return super.onDispose(e);
    }

    get uiConfig() {
      return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig;
    }

  }

  DC.PluginType = "HierarchyUiPlugin";

  var OC = pE({
    defaultModifiers: [fE, bE, wE, SE]
  }),
      LC = __webpackgi_require__(388),
      IC = __webpackgi_require__.n(LC);

  function FC(e) {
    const t = [];
    e.traverse(e => {
      e.geometry && t.push(e);
    });
    const n = {},
          r = {};
    t.forEach(e => {
      var t;

      if (!n[e.geometry.uuid]) {
        const t = e.geometry.toJSON().data,
              r = t ? IC()({
          a: t.attributes || {},
          b: t.index || []
        }) : "";
        n[e.geometry.uuid] = r;
      }

      const i = n[e.geometry.uuid],
            s = null !== (t = r[i]) && void 0 !== t ? t : r[i] = [];
      s.includes(e) || s.push(e);
    }), Object.values(r).forEach(e => {
      if (e.length < 2) return;
      const t = e[0].geometry;
      e.forEach((e, n) => {
        n < 1 || (e.geometry.dispose(), e.geometry = t);
      });
    });
  }

  const NC = new i.Pa4(),
        UC = new i.Pa4(),
        BC = new i.Pa4(),
        jC = new i.Pa4(),
        zC = new i.Pa4(),
        VC = new i.Pa4();
  let GC = 1;
  const HC = new i.Pa4(0, 1, 0);

  class WC extends Pe {
    constructor(e, t) {
      super(e, t), this.targetOffset = new i.Pa4(0, 0, 0);
      const n = this.update;

      this.update = () => this._update(n);
    }

    _update(e) {
      this.target.add(this.targetOffset), NC.copy(this.object.position).sub(this.target), GC = NC.length(), VC.copy(this.target);
      const t = e();
      return VC.sub(this.target), NC.copy(this.object.position).sub(this.target), GC /= NC.length(), this.target.add(VC), this.object.position.copy(this.target).add(NC), NC.normalize(), UC.crossVectors(HC, NC).normalize(), BC.crossVectors(NC, UC).normalize(), jC.crossVectors(UC, BC).normalize().negate(), UC.length() > .1 && this.object.up.crossVectors(NC.clone().normalize(), UC), this.enablePan && (zC.set(0, 0, 0).addScaledVector(UC, VC.x).addScaledVector(BC, VC.y).addScaledVector(jC, VC.z), this.targetOffset.add(zC), this.targetOffset.multiplyScalar(1 / GC)), zC.set(0, 0, 0).addScaledVector(UC, -this.targetOffset.x).addScaledVector(BC, -this.targetOffset.y).addScaledVector(jC, -this.targetOffset.z), this.object.lookAt(zC.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t;
    }

  }

  class KC extends Ma {
    constructor(e) {
      super(e), this.boundingScaleMultiplier = 1.2, this._initGeometry(new i.cJO(1, 0));
    }

  }

  function XC(e, t) {
    var n, r;
    const i = Array.from((null !== (n = e.access) && void 0 !== n ? n : "").split(".")),
          s = i.pop();
    let o = null !== (r = e.targetObject) && void 0 !== r ? r : t;
    if (!s || 0 === s.length) return {
      key: void 0,
      tar: o
    };
    if (o = v(i, o), o && !(s in o)) throw console.error("invalid key", s, o, t, e), "";
    return {
      key: s,
      tar: o
    };
  }

  function qC(e, t, n, r) {
    const {
      key: i,
      tar: s
    } = XC(e, t);
    return i && s ? mc(s, i, () => {
      var t;
      n && (null === (t = e.updater) || void 0 === t ? void 0 : t.length) && e.updater.forEach(e => n[e]()), null == r || r();
    }) : n => console.warn("Unable to set ", n, i, s, e, t);
  }

  async function YC(e, t, n) {
    var r, i, s, o;
    const {
      key: a,
      tar: l
    } = XC(t, e),
          c = t.animSet ? [ZC(l, t.animSet, n, null !== (r = t.animSetParallel) && void 0 !== r && r)] : [];

    if (a && l) {
      const e = null !== (o = t.updater) && void 0 !== o ? o : [],
            r = async () => vc(l, a, { ...t,
        onUpdate: r => {
          var i;
          null === (i = t.onUpdate) || void 0 === i || i.call(t, r), e.forEach(e => {
            var t;
            return null === (t = n[e]) || void 0 === t ? void 0 : t.call(n);
          });
        }
      });

      t.delay ? c.push(_c(t.delay).then(r)) : c.push(r());
    } else (t.duration || t.delay) && c.push(_c((null !== (i = t.delay) && void 0 !== i ? i : 0) + (null !== (s = t.duration) && void 0 !== s ? s : 0)));

    return 1 === c.length ? c[0] : Promise.all(c);
  }

  async function ZC(e, t, n, r = !1) {
    if (r) return Promise.all(t.map(async t => YC(e, t, n)));

    for (const r of t) await YC(e, r, n);
  }

  function JC(e, t, n, r) {
    var i, s, o, a, l, c, u;
    if (!e) return;
    t || (t = []);
    const p = null != r ? r : {},
          h = e;

    for (let e = 0, d = t.length; e < d; e++) {
      const d = t[e];

      if (d.uiRef) {
        const t = null !== (l = null == h ? void 0 : h.indexOf(d.uiRef)) && void 0 !== l ? l : -1;
        t !== e && (t >= 0 && (null == h || h.splice(t, 1)), null == h || h.splice(e, 0, d.uiRef));
      } else {
        d.uiRef = {
          type: "folder",
          label: null !== (i = d.name) && void 0 !== i ? i : "Animation " + e,
          children: []
        };
        const t = [{
          type: "button",
          label: "animate",
          value: () => {
            YC(n, d, p).then(() => {
              var e;
              return console.log((null === (e = d.uiRef) || void 0 === e ? void 0 : e.label) + " finished");
            });
          }
        }];
        void 0 !== d.access && t.push({
          type: "input",
          property: [d, "access"]
        }), void 0 !== d.from && t.push({
          type: null !== (s = d.uiObjectType) && void 0 !== s ? s : "input",
          property: [d, "from"],
          onChange: () => {
            var e;
            qC(d, n)(d.from), null === (e = d.updater) || void 0 === e || e.forEach(e => e in p && p[e]());
          }
        }), void 0 !== d.to && t.push({
          type: null !== (o = d.uiObjectType) && void 0 !== o ? o : "input",
          property: [d, "to"],
          onChange: () => {
            var e;
            qC(d, n)(d.to), null === (e = d.updater) || void 0 === e || e.forEach(e => e in p && p[e]());
          }
        }), void 0 !== d.duration && t.push({
          type: "input",
          property: [d, "duration"]
        }), d.animSet && (d.animSetParallel || (d.animSetParallel = !1), t.push({
          type: "input",
          label: "run parallel",
          property: [d, "animSetParallel"]
        })), d.animSet && t.push({
          type: "folder",
          label: "AnimSet",
          expanded: !1,
          children: [],
          animSetContainer: !0
        }), null === (a = d.uiRef.children) || void 0 === a || a.push(...t), null == h || h.splice(e, 0, d.uiRef);
      }

      const f = null === (c = d.uiRef.children) || void 0 === c ? void 0 : c.map(e => x(e)).flat(2).find(e => null == e ? void 0 : e.animSetContainer);
      d.animSet && f && JC(f.children, d.animSet, null !== (u = d.targetObject) && void 0 !== u ? u : n, r);
    }
  }

  class $C extends Gs {
    constructor() {
      super(), this.enabled = !0, this.uiConfig = {
        type: "folder",
        label: "Lights",
        children: [{
          type: "button",
          label: "Add Directional Light",
          value: () => {
            if (!this._viewer) return;
            const e = new Is();
            e.position.set(0, 0, 0), e.target.position.set(0, 0, -1).normalize(), e.intensity = 2, e.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e), this._processor(e, {});
          }
        }],
        limitedUi: !0
      }, this.dependencies = [Vs], this._processor = (e, t) => {
        const n = e;
        return e.modelObject.traverse(e => {
          var t, n, r;
          if (!e.lightObject) return;
          const i = e.uiConfig;
          i && !(null === (t = this.uiConfig.children) || void 0 === t ? void 0 : t.includes(i)) && (this.uiConfig.children.push(i), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
        }), n;
      };
    }

    async onAdded(e) {
      var t, n, r, i;
      await super.onAdded(e), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.add("model", {
        forAssetType: "model",
        process: this._processor
      }), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.add("light", {
        forAssetType: "light",
        process: this._processor
      });
    }

    async onRemove(e) {
      var t, n, r, i;
      return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.remove("model", {
        forAssetType: "model",
        process: this._processor
      }), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.remove("light", {
        forAssetType: "light",
        process: this._processor
      }), super.onRemove(e);
    }

  }

  $C.PluginType = "SimpleLightsUi";

  var QC = function (e, t, n, r) {
    var i,
        s = arguments.length,
        o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);else for (var a = e.length - 1; a >= 0; a--) (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
    return s > 3 && o && Object.defineProperty(t, n, o), o;
  };

  class eR extends Ft {
    constructor(e, t, n, r = !1) {
      super({
        vertexShader: _o,
        fragmentShader: `\n\n${go}\n${mo}\n${vo}\n${bo}\n${n}\n\n${xo}\n\nvarying vec2 vUv;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);\n#endif\nreturn vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount)/(frameCount+1.));}\n\n            `,
        uniforms: {
          tLastThis: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          tNormalDepth: {
            value: null
          },
          tLastFrame: {
            value: null
          },
          opacity: {
            value: 1
          },
          intensity: {
            value: 2.14
          },
          rayCount: {
            value: .1
          },
          objectRadius: {
            value: 1
          },
          autoRadius: {
            value: !r
          },
          power: {
            value: 1.1
          },
          bias: {
            value: .015
          },
          falloff: {
            value: .7
          },
          tolerance: {
            value: 1.5
          },
          frameCount: {
            value: 0
          },
          projection: {
            value: new i.yGw()
          },
          screenSize: {
            value: new i.FM8()
          },
          cameraPositionWorld: {
            value: new i.Pa4()
          },
          cameraNearFar: {
            value: new i.FM8(.1, 1e3)
          }
        },
        defines: {
          PERSPECTIVE_CAMERA: 1,
          SSGI_ENABLED: r ? 1 : 0
        }
      }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = {
        shaderExtender: (e, t, n) => {
          if (!e.defines.SSRTAO_ENABLED) return;
          const r = "vec3 totalDiffuse =";
          e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0\nvec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);\n#endif\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\n#if !defined(SSR_ENABLED) || SSR_ENABLED < 1\nreflectedLight.indirectSpecular+=ssgiColor*material.specularColor;\n#endif\n#endif\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`), e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", ""), e.vertexUvs = !0;
        },
        onObjectRender: (e, t, n) => {
          var r, i, s;
          this.materialExtension.extraUniforms.tSSGIMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
          const o = t.materialObject,
                a = !o.transparent && o.transmission < .001;
          let l = this.enabled && a && (this.renderWithCamera || this._renderer.frameCount > 1) && !1 !== n.userData.screenSpaceRendering && !(null === (i = o.userData) || void 0 === i ? void 0 : i.ssrtaoDisabled) && !(null === (s = o.userData) || void 0 === s ? void 0 : s.ssaoDisabled) ? 1 : 0;
          o.defines.SSRTAO_ENABLED !== l && (o.defines.SSRTAO_ENABLED = l, o.needsUpdate = !0), l = this.material.defines.SSGI_ENABLED, o.defines.SSGI_ENABLED !== l && (o.defines.SSGI_ENABLED = l, o.needsUpdate = !0), l = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== l && (this.materialExtension.extraUniforms.tSSGIMap.value = l, o.needsUpdate = !0);
        },
        parsFragmentSnippet: e => {
          var t;
          return M`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${U("tSSGIMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2)}

            ${wo}

        `;
        },
        extraUniforms: {
          tSSGIMap: {
            value: null
          },
          ssaoPower: this.material.uniforms.power,
          ssgiIntensity: this.material.uniforms.intensity
        },
        computeCacheKey: e => {
          var t, n;
          return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding);
        },
        isCompatible: e => {
          var t;
          return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2;
        }
      }, this.intensity = 2, this.power = 1.1, this.autoRadius = !0, this.objectRadius = 2, this.tolerance = 1, this.bias = .15, this.falloff = .7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = !0, this.renderWithCamera = !0, this.uiConfig = {
        type: "folder",
        label: "SS Global illumination (Dev)",
        children: [...Je(this), {
          type: "checkbox",
          label: "GI Enabled",
          hidden: () => !this._giActivated,
          property: [this, "ssgiEnabled"]
        }]
      }, this._renderer = e, this._target = t, this.needsSwap = !0, this._giActivated = r, this.ssgiEnabled = r, this.bilateralPass = new Ao(this._target, n, "rgba");
    }

    get ssgiEnabled() {
      return parseInt(this.material.defines.SSGI_ENABLED) > .5;
    }

    set ssgiEnabled(e) {
      e = e && this._giActivated, this.material.defines.SSGI_ENABLED = e ? 1 : 0, this.material.needsUpdate = !0;
    }

    render(e, t, n, r, i) {
      this.needsSwap = !1, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.smoothEnabled && this.bilateralPass.render(e, t, n, r, i));
    }

  }

  QC([xe()], eR.prototype, "bilateralPass", void 0), QC([He("Intensity", [0, 4]), xe(), V()], eR.prototype, "intensity", void 0), QC([He("Power", [0, 3]), xe(), V()], eR.prototype, "power", void 0), QC([Ve("Auto radius"), xe(), V()], eR.prototype, "autoRadius", void 0), QC([He("Object Radius", [.01, 10]), xe(), V()], eR.prototype, "objectRadius", void 0), QC([He("Tolerance", [.1, 5]), xe(), V()], eR.prototype, "tolerance", void 0), QC([He("Bias", [-.3, .3]), xe(), V()], eR.prototype, "bias", void 0), QC([He("Falloff", [1e-4, 4]), xe(), V()], eR.prototype, "falloff", void 0), QC([He("Ray Count", [1, 5], 1), xe(), V()], eR.prototype, "rayCount", void 0), QC([He("Step count", [1, 16], 1), xe(), G("RTAO_STEP_COUNT")], eR.prototype, "stepCount", void 0), QC([Ve("Smooth Enabled"), xe()], eR.prototype, "smoothEnabled", void 0), QC([Ve("Render with Camera")], eR.prototype, "renderWithCamera", void 0);

  class tR extends oo {
    constructor(e = !0) {
      super(), this.dependencies = [Vs, Ys, co], this._initEnabled = !1, this.setDirty = this.setDirty.bind(this), this._initEnabled = e;
    }

    get rtgiTarget() {
      return this._rtgiTarget;
    }

    async onAdded(e) {
      var t, n;
      await super.onAdded(e), this.enabled = this._initEnabled, null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0);
    }

    get enabled() {
      var e, t;
      return (null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1;
    }

    set enabled(e) {
      var t;
      (null === (t = this.passes.ssrtgi) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssrtgi.passObject.enabled = e);
    }

    createPasses(e) {
      var t, n, r;
      this._rtgiTarget = e.renderer.createTarget({
        sizeMultiplier: 1
      });
      let i = !1;
      const s = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("debug");
      return s && s.addTexture("SSRTGI", () => {
        var e;
        return null === (e = this._rtgiTarget) || void 0 === e ? void 0 : e.texture;
      }, [40, 100, 400, 200]), [Hs(e, {
        passId: "ssrtgi",
        after: ["gbuffer"],
        before: ["render"],
        required: ["render", "gbuffer", "progressive"],
        passObject: new eR(e.renderer, this._rtgiTarget, null !== (r = null === (n = e.getPlugin(Ys)) || void 0 === n ? void 0 : n.getUnpackSnippet()) && void 0 !== r ? r : "", !0),
        update: () => {
          var t;
          let n = this.enabled;

          if (n && !i) {
            const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SSAO");
            (null == e ? void 0 : e.enabled) && (confirm("SSAO Plugin needs to be disabled to enable SSRTGI or SSRTAO. Disable now?") ? e.enabled = !1 : (this.enabled = !1, n = !1));
          }

          i = n, n && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Ys)]);
        }
      }, () => [e.getPlugin(Ys), e.getPlugin(co), e.scene.activeCamera, e.renderer])];
    }

    async onRemove(e) {
      return e.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e);
    }

    setDirty() {
      var e;
      null === (e = this._viewer) || void 0 === e || e.setDirty();
    }

    get uiConfig() {
      var e, t, n, r, i;
      const s = null !== (n = null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
      return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map(e => x(e))) || void 0 === i || i.flat(2).forEach(e => e && (e.onChange = this.setDirty)), s;
    }

  }

  async function nR(e, {
    debug: t = !1,
    ground: n = !0,
    bloom: r = !0,
    depthTonemap: i = !1,
    importPopup: s = !0
  }) {
    const o = new ro(e);
    o.enabled = !1, t && (await o.addPlugin(j_)), await o.addPlugin(Vs, void 0, void 0, {
      storage: caches ? await caches.open("webgi-cache-storage") : void 0
    }), await o.addPlugin(jx), await o.addPlugin(bM), s && (await o.addPlugin(Dm)), await o.addPlugin(tx), await o.addPlugin(Ob), await o.addPlugin(Ub), await o.addPlugin(zb), await o.addPlugin(ab), await o.addPlugin(ix), await o.addPlugin(Bb), await o.addPlugin(um), await o.addPlugin(Ca, Ta, !1, !0), await Om(o, {
      ground: n,
      bloom: r,
      depthTonemap: i
    }), await o.addPlugin(tR, !1), await o.addPlugin(BA, !1), await o.addPlugin(FA), await o.addPlugin(HA), await o.addPlugin(sC), await o.addPlugin(RA), await o.addPlugin(jA), await o.addPlugin(PA), await o.addPlugin(eT), await o.addPlugin(Nc), await o.addPlugin(DC), await o.addPlugin(kC), await o.addPlugin($C), await o.addPlugin(RC);
    const a = await o.addPlugin(new CC(!Rt()));
    return o.renderer.refreshPipeline(), o.scene.addEventListener("textureAdded", e => {
      e.texture && o.scene.setEnvironment(e.texture);
    }), a.setupPluginUi($_), a.setupPluginUi(um), a.setupPluginUi(RC), a.setupPluginUi(jx), a.setupPluginUi(wc), a.setupPluginUi($c), a.setupPluginUi(jA), a.setupPluginUi(RA), a.setupPluginUi(DC), a.setupPluginUi(PA), a.setupPluginUi(Pa), a.setupPluginUi(Ca), n && a.setupPluginUi(Z_), a.setupPluginUi(To), a.setupPluginUi(zc), a.setupPluginUi(eT), a.setupPluginUi(fo), a.setupPluginUi(vu), a.setupPluginUi(ko), a.setupPluginUi(kC), a.setupPluginUi(FA), a.setupPluginUi(HA), a.setupPluginUi(co), a.setupPluginUi($C), a.setupPluginUi(ru), a.setupPluginUi(xu), r && a.setupPluginUi(Cc), a.setupPluginUi(Nc), a.setupPluginUi(kc), a.setupPluginUi(Lc), a.setupPluginUi(tu), a.setupPluginUi(tR), a.setupPluginUi(sC), a.setupPluginUi(Ea), a.setupPluginUi(B_), a.setupPluginUi(lm), a.setupPluginUi(dm), a.setupPluginUi(BA), a.setupPluginUi(Dm), o.enabled = !0, o;
  }

  tR.PluginType = "SSGI";
}();
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__.LY2,
    __webpackgi_exports__AMaterialManager = __webpackgi_exports__.HRj,
    __webpackgi_exports__ARPlacementBox = __webpackgi_exports__.li4,
    __webpackgi_exports__ARPlugin = __webpackgi_exports__.FO5,
    __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__.Nlh,
    __webpackgi_exports__AViewerPlugin = __webpackgi_exports__.QvI,
    __webpackgi_exports__AddBlendPass = __webpackgi_exports__.JHp,
    __webpackgi_exports__AddEquation = __webpackgi_exports__.bGH,
    __webpackgi_exports__AddOperation = __webpackgi_exports__.NDo,
    __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__.gSk,
    __webpackgi_exports__AdditiveBlending = __webpackgi_exports__.WMw,
    __webpackgi_exports__AlphaFormat = __webpackgi_exports__.OTo,
    __webpackgi_exports__AlwaysDepth = __webpackgi_exports__.Se2,
    __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__.cum,
    __webpackgi_exports__AmbientLight = __webpackgi_exports__.Mig,
    __webpackgi_exports__AmbientLight2 = __webpackgi_exports__.B$7,
    __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__.i_9,
    __webpackgi_exports__AnimationClip = __webpackgi_exports__.m7l,
    __webpackgi_exports__AnimationLoader = __webpackgi_exports__.sYA,
    __webpackgi_exports__AnimationMixer = __webpackgi_exports__.Xcj,
    __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__.mzJ,
    __webpackgi_exports__AnimationUtils = __webpackgi_exports__.ZZA,
    __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__.$Ph,
    __webpackgi_exports__ArcCurve = __webpackgi_exports__.T__,
    __webpackgi_exports__ArrayCamera = __webpackgi_exports__.HkE,
    __webpackgi_exports__ArrowHelper = __webpackgi_exports__.tGC,
    __webpackgi_exports__AssetExporter = __webpackgi_exports__.g1S,
    __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__.I$C,
    __webpackgi_exports__AssetImportBasicPopupPlugin = __webpackgi_exports__._HT,
    __webpackgi_exports__AssetImporter = __webpackgi_exports__.QIH,
    __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__.ksm,
    __webpackgi_exports__AsyncCompress = __webpackgi_exports__.jl_,
    __webpackgi_exports__AsyncDecompress = __webpackgi_exports__.b7R,
    __webpackgi_exports__AsyncDeflate = __webpackgi_exports__.BDV,
    __webpackgi_exports__AsyncGunzip = __webpackgi_exports__.Ea_,
    __webpackgi_exports__AsyncGzip = __webpackgi_exports__.qff,
    __webpackgi_exports__AsyncInflate = __webpackgi_exports__.tmC,
    __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__.BON,
    __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__.P40,
    __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__.wLL,
    __webpackgi_exports__AsyncZlib = __webpackgi_exports__.iHO,
    __webpackgi_exports__Audio = __webpackgi_exports__.BbS,
    __webpackgi_exports__AudioAnalyser = __webpackgi_exports__.kqm,
    __webpackgi_exports__AudioContext = __webpackgi_exports__.Hmr,
    __webpackgi_exports__AudioListener = __webpackgi_exports__.SJI,
    __webpackgi_exports__AudioLoader = __webpackgi_exports__.mTL,
    __webpackgi_exports__AxesHelper = __webpackgi_exports__.y8_,
    __webpackgi_exports__BackSide = __webpackgi_exports__._Li,
    __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__.g56,
    __webpackgi_exports__BaseRenderer = __webpackgi_exports__.bj3,
    __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__.z81,
    __webpackgi_exports__BasicShadowMap = __webpackgi_exports__._MY,
    __webpackgi_exports__BlobLoader = __webpackgi_exports__.yEv,
    __webpackgi_exports__BloomPlugin = __webpackgi_exports__.dFZ,
    __webpackgi_exports__Bone = __webpackgi_exports__.N$j,
    __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__._YM,
    __webpackgi_exports__Box2 = __webpackgi_exports__.TUj,
    __webpackgi_exports__Box3 = __webpackgi_exports__.ZzF,
    __webpackgi_exports__Box3B = __webpackgi_exports__.qzb,
    __webpackgi_exports__Box3Helper = __webpackgi_exports__.GQ,
    __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__.nvb,
    __webpackgi_exports__BoxGeometry = __webpackgi_exports__.DvJ,
    __webpackgi_exports__BoxHelper = __webpackgi_exports__.fQA,
    __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__.cPz,
    __webpackgi_exports__BufferAttribute = __webpackgi_exports__.TlE,
    __webpackgi_exports__BufferGeometry = __webpackgi_exports__.u9r,
    __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__.s4_,
    __webpackgi_exports__ByteType = __webpackgi_exports__.T95,
    __webpackgi_exports__Cache = __webpackgi_exports__.CtF,
    __webpackgi_exports__Camera = __webpackgi_exports__.V1s,
    __webpackgi_exports__CameraController = __webpackgi_exports__.jOv,
    __webpackgi_exports__CameraHelper = __webpackgi_exports__.Rki,
    __webpackgi_exports__CameraView = __webpackgi_exports__.itZ,
    __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__.qKx,
    __webpackgi_exports__CanvasRecorder = __webpackgi_exports__.vlJ,
    __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__.nPO,
    __webpackgi_exports__CanvasSnipper = __webpackgi_exports__.zcQ,
    __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__.GH1,
    __webpackgi_exports__CanvasTexture = __webpackgi_exports__.ROQ,
    __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__.YN5,
    __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__.BVQ,
    __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__.YT8,
    __webpackgi_exports__CineonToneMapping = __webpackgi_exports__.YGz,
    __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__.trn,
    __webpackgi_exports__CircleGeometry = __webpackgi_exports__.zf8,
    __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__.uWy,
    __webpackgi_exports__Clock = __webpackgi_exports__.SUY,
    __webpackgi_exports__Color = __webpackgi_exports__.Ilk,
    __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__.R2R,
    __webpackgi_exports__ColorManagement = __webpackgi_exports__.epp,
    __webpackgi_exports__Compress = __webpackgi_exports__.GD$,
    __webpackgi_exports__CompressedTexture = __webpackgi_exports__.EB7,
    __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__.DqL,
    __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__._3,
    __webpackgi_exports__ConeGeometry = __webpackgi_exports__.b_z,
    __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__.OCn,
    __webpackgi_exports__CubeCamera = __webpackgi_exports__._am,
    __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__.kB7,
    __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__.fY$,
    __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__.vxC,
    __webpackgi_exports__CubeTexture = __webpackgi_exports__.BtG,
    __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__.cBK,
    __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__.g8_,
    __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__.AXT,
    __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__.yj7,
    __webpackgi_exports__CubicInterpolant = __webpackgi_exports__.dYG,
    __webpackgi_exports__CullFaceBack = __webpackgi_exports__.tm_,
    __webpackgi_exports__CullFaceFront = __webpackgi_exports__.S2y,
    __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__.B02,
    __webpackgi_exports__CullFaceNone = __webpackgi_exports__.PeU,
    __webpackgi_exports__Curve = __webpackgi_exports__.Hyl,
    __webpackgi_exports__CurvePath = __webpackgi_exports__.Wqd,
    __webpackgi_exports__CustomBlending = __webpackgi_exports__.Xaj,
    __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__.DUb,
    __webpackgi_exports__CustomToneMapping = __webpackgi_exports__.dZ3,
    __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__.m_w,
    __webpackgi_exports__CylinderGeometry = __webpackgi_exports__.fHI,
    __webpackgi_exports__Cylindrical = __webpackgi_exports__.LBq,
    __webpackgi_exports__DECAY_MILLISECONDS = __webpackgi_exports__.dHf,
    __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__.Qww,
    __webpackgi_exports__Damper = __webpackgi_exports__.CGV,
    __webpackgi_exports__Data3DTexture = __webpackgi_exports__.JUT,
    __webpackgi_exports__DataArrayTexture = __webpackgi_exports__.p3g,
    __webpackgi_exports__DataTexture = __webpackgi_exports__.IEO,
    __webpackgi_exports__DataTexture2DArray = __webpackgi_exports__.CN8,
    __webpackgi_exports__DataTexture3D = __webpackgi_exports__.zob,
    __webpackgi_exports__DataTextureLoader = __webpackgi_exports__.yxD,
    __webpackgi_exports__DataUrlLoader = __webpackgi_exports__.CUS,
    __webpackgi_exports__DataUtils = __webpackgi_exports__.A5E,
    __webpackgi_exports__DebugPlugin = __webpackgi_exports__.zqG,
    __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__.PfX,
    __webpackgi_exports__Decompress = __webpackgi_exports__.Q1o,
    __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__.jfJ,
    __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__.T_J,
    __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__.tEQ,
    __webpackgi_exports__Deflate = __webpackgi_exports__.gb4,
    __webpackgi_exports__DepthFormat = __webpackgi_exports__.qkB,
    __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__.cvk,
    __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__.HWo,
    __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__.brP,
    __webpackgi_exports__DepthTexture = __webpackgi_exports__.$YQ,
    __webpackgi_exports__DiamondMaterial = __webpackgi_exports__.yNB,
    __webpackgi_exports__DiamondPlugin = __webpackgi_exports__.h7x,
    __webpackgi_exports__DirectionalLight = __webpackgi_exports__.Ox3,
    __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__.qtn,
    __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__.cBI,
    __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__.cU9,
    __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__.DT1,
    __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__.Kgo,
    __webpackgi_exports__DoubleSide = __webpackgi_exports__.ehD,
    __webpackgi_exports__Dropzone = __webpackgi_exports__.fhJ,
    __webpackgi_exports__DropzonePlugin = __webpackgi_exports__.y1s,
    __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__.fSK,
    __webpackgi_exports__DstColorFactor = __webpackgi_exports__.Vdb,
    __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__.l8J,
    __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__.dj0,
    __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__.QM0,
    __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__.OIS,
    __webpackgi_exports__EasingFunctions = __webpackgi_exports__.q8b,
    __webpackgi_exports__EdgesGeometry = __webpackgi_exports__.TOt,
    __webpackgi_exports__EffectComposer2 = __webpackgi_exports__.xaN,
    __webpackgi_exports__EllipseCurve = __webpackgi_exports__.Ny0,
    __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__.Zof,
    __webpackgi_exports__EqualDepth = __webpackgi_exports__.eD,
    __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__.jwo,
    __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__.dSO,
    __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__.Bf4,
    __webpackgi_exports__Euler = __webpackgi_exports__.USm,
    __webpackgi_exports__EventDispatcher = __webpackgi_exports__.pBf,
    __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__.$Vf,
    __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__.O7d,
    __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__.ksq,
    __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__.gXf,
    __webpackgi_exports__FileLoader = __webpackgi_exports__.hH6,
    __webpackgi_exports__FlatShading = __webpackgi_exports__.esl,
    __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__.e62,
    __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__.a$l,
    __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__.OM3,
    __webpackgi_exports__FloatType = __webpackgi_exports__.VzW,
    __webpackgi_exports__Fog = __webpackgi_exports__.ybr,
    __webpackgi_exports__FogExp2 = __webpackgi_exports__.yo9,
    __webpackgi_exports__Font = __webpackgi_exports__.Zxw,
    __webpackgi_exports__FontLoader = __webpackgi_exports__.JfN,
    __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__.$Bt,
    __webpackgi_exports__FramebufferTexture = __webpackgi_exports__.Wzm,
    __webpackgi_exports__FrontSide = __webpackgi_exports__.Wl3,
    __webpackgi_exports__Frustum = __webpackgi_exports__.iWj,
    __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__.DNz,
    __webpackgi_exports__GBufferPlugin = __webpackgi_exports__.m1M,
    __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__.ylh,
    __webpackgi_exports__GLSL1 = __webpackgi_exports__.v9Y,
    __webpackgi_exports__GLSL3 = __webpackgi_exports__.LSk,
    __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__.LHE,
    __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__.KE0,
    __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__.KCF,
    __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__.a4n,
    __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__.zIH,
    __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__.Hfk,
    __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__.png,
    __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__.Eb_,
    __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__.BT2,
    __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__._8p,
    __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__.hkn,
    __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__.GFY,
    __webpackgi_exports__GreaterDepth = __webpackgi_exports__.w$m,
    __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__.ksN,
    __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__.j4z,
    __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__.OAl,
    __webpackgi_exports__GridHelper = __webpackgi_exports__.VLJ,
    __webpackgi_exports__GroundPlugin = __webpackgi_exports__.C73,
    __webpackgi_exports__Group = __webpackgi_exports__.ZAu,
    __webpackgi_exports__Gunzip = __webpackgi_exports__.ibP,
    __webpackgi_exports__Gzip = __webpackgi_exports__._fI,
    __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__.hUN,
    __webpackgi_exports__HalfFloatType = __webpackgi_exports__.cLu,
    __webpackgi_exports__HemisphereLight = __webpackgi_exports__.vmT,
    __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__.Qpg,
    __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__.So8,
    __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__.eOv,
    __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__.Wjw,
    __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__.cJO,
    __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__.QRU,
    __webpackgi_exports__ImageLoader = __webpackgi_exports__.S3k,
    __webpackgi_exports__ImageUtils = __webpackgi_exports__.PpQ,
    __webpackgi_exports__ImmediateRenderObject = __webpackgi_exports__.AHu,
    __webpackgi_exports__Importer = __webpackgi_exports__.q_9,
    __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__.ZRs,
    __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__.oqc,
    __webpackgi_exports__Inflate = __webpackgi_exports__.T_x,
    __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__.lb7,
    __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__.L5s,
    __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__.$TI,
    __webpackgi_exports__InstancedMesh = __webpackgi_exports__.SPe,
    __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__.aVm,
    __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__.j87,
    __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__.RNb,
    __webpackgi_exports__IntType = __webpackgi_exports__.Kz5,
    __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__.vpT,
    __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__.kB5,
    __webpackgi_exports__Interpolant = __webpackgi_exports__._C8,
    __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__.Syv,
    __webpackgi_exports__InterpolateLinear = __webpackgi_exports__.NMF,
    __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__.pIN,
    __webpackgi_exports__InvertStencilOp = __webpackgi_exports__.eMJ,
    __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__.rN7,
    __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__.iUp,
    __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__.GFd,
    __webpackgi_exports__KeepStencilOp = __webpackgi_exports__.x5V,
    __webpackgi_exports__KeyframeTrack = __webpackgi_exports__.tUh,
    __webpackgi_exports__LOD = __webpackgi_exports__.z8B,
    __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__.GZb,
    __webpackgi_exports__LatheGeometry = __webpackgi_exports__.p7y,
    __webpackgi_exports__Layers = __webpackgi_exports__.S9g,
    __webpackgi_exports__LessDepth = __webpackgi_exports__.Zr5,
    __webpackgi_exports__LessEqualDepth = __webpackgi_exports__.vCF,
    __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__.yt0,
    __webpackgi_exports__LessStencilFunc = __webpackgi_exports__.uXU,
    __webpackgi_exports__Light = __webpackgi_exports__._kC,
    __webpackgi_exports__LightProbe = __webpackgi_exports__.lk7,
    __webpackgi_exports__Line = __webpackgi_exports__.x12,
    __webpackgi_exports__Line3 = __webpackgi_exports__.Zzh,
    __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__.nls,
    __webpackgi_exports__LineCurve = __webpackgi_exports__.g_z,
    __webpackgi_exports__LineCurve3 = __webpackgi_exports__.U7,
    __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__.FT0,
    __webpackgi_exports__LineLoop = __webpackgi_exports__.blk,
    __webpackgi_exports__LineSegments = __webpackgi_exports__.ejS,
    __webpackgi_exports__LinearEncoding = __webpackgi_exports__.rnI,
    __webpackgi_exports__LinearFilter = __webpackgi_exports__.wem,
    __webpackgi_exports__LinearInterpolant = __webpackgi_exports__.lfu,
    __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__.FDw,
    __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__.lRj,
    __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__.D1R,
    __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__.qyh,
    __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__.GUF,
    __webpackgi_exports__LinearToneMapping = __webpackgi_exports__.EoG,
    __webpackgi_exports__Loader = __webpackgi_exports__.aNw,
    __webpackgi_exports__LoaderUtils = __webpackgi_exports__.Zp0,
    __webpackgi_exports__LoadingManager = __webpackgi_exports__.lLk,
    __webpackgi_exports__LoopOnce = __webpackgi_exports__.jAl,
    __webpackgi_exports__LoopPingPong = __webpackgi_exports__.uEv,
    __webpackgi_exports__LoopRepeat = __webpackgi_exports__.YKA,
    __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__.cRx,
    __webpackgi_exports__LuminanceFormat = __webpackgi_exports__.Y8D,
    __webpackgi_exports__MOUSE = __webpackgi_exports__.RsA,
    __webpackgi_exports__MTLLoader2 = __webpackgi_exports__.Y0m,
    __webpackgi_exports__Material = __webpackgi_exports__.F5T,
    __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__.EDU,
    __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__.z$Q,
    __webpackgi_exports__MaterialExtender = __webpackgi_exports__.KA8,
    __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__.XUj,
    __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__.Me$,
    __webpackgi_exports__MaterialLoader = __webpackgi_exports__.u7G,
    __webpackgi_exports__MaterialManager = __webpackgi_exports__.PEk,
    __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__.BG4,
    __webpackgi_exports__MathUtils = __webpackgi_exports__.M8C,
    __webpackgi_exports__Matrix3 = __webpackgi_exports__.Vkp,
    __webpackgi_exports__Matrix4 = __webpackgi_exports__.yGw,
    __webpackgi_exports__MaxEquation = __webpackgi_exports__.Sm8,
    __webpackgi_exports__Mesh = __webpackgi_exports__.Kj0,
    __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__.vBJ,
    __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__.lRF,
    __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__.Lun,
    __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__.YBo,
    __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__.kaV,
    __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__.RSm,
    __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__.xoR,
    __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__.EJi,
    __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__.Wid,
    __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__.iuj,
    __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__.IKL,
    __webpackgi_exports__MinEquation = __webpackgi_exports__.r_,
    __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__.OoA,
    __webpackgi_exports__MixOperation = __webpackgi_exports__.qhX,
    __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__.qPT,
    __webpackgi_exports__MultiplyBlending = __webpackgi_exports__.M5h,
    __webpackgi_exports__MultiplyOperation = __webpackgi_exports__.Ns1,
    __webpackgi_exports__NearestFilter = __webpackgi_exports__.TyD,
    __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__.vZf,
    __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__.HTd,
    __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__.aH4,
    __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__.YLQ,
    __webpackgi_exports__NeverDepth = __webpackgi_exports__.BVF,
    __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__.MyG,
    __webpackgi_exports__NoBlending = __webpackgi_exports__.jFi,
    __webpackgi_exports__NoColorSpace = __webpackgi_exports__.aCh,
    __webpackgi_exports__NoToneMapping = __webpackgi_exports__.uL9,
    __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__.TNj,
    __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__.IFH,
    __webpackgi_exports__NormalBlending = __webpackgi_exports__.bdR,
    __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__.kM_,
    __webpackgi_exports__NotEqualDepth = __webpackgi_exports__.M6v,
    __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__.RvT,
    __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__.dUE,
    __webpackgi_exports__OBJLoader2 = __webpackgi_exports__.oe_,
    __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__.BuN,
    __webpackgi_exports__Object3D = __webpackgi_exports__.Tme,
    __webpackgi_exports__Object3DModel = __webpackgi_exports__.N9P,
    __webpackgi_exports__ObjectLoader = __webpackgi_exports__.Gql,
    __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__.$XY,
    __webpackgi_exports__ObjectPicker = __webpackgi_exports__.O9d,
    __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__.zEO,
    __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__.qfx,
    __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__.PA7,
    __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__.REq,
    __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__.pQR,
    __webpackgi_exports__OneFactor = __webpackgi_exports__.ghN,
    __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__.Hy8,
    __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__.Wpd,
    __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__.LgZ,
    __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__.iWC,
    __webpackgi_exports__OrbitControls2 = __webpackgi_exports__.mqn,
    __webpackgi_exports__OrthographicCamera = __webpackgi_exports__.iKG,
    __webpackgi_exports__PCFShadowMap = __webpackgi_exports__._iA,
    __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__.ntZ,
    __webpackgi_exports__PMREMGenerator = __webpackgi_exports__.anP,
    __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__.X2e,
    __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__.FCo,
    __webpackgi_exports__ParametricGeometry = __webpackgi_exports__.jjw,
    __webpackgi_exports__Path = __webpackgi_exports__.y$t,
    __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__.cPb,
    __webpackgi_exports__PickingPlugin = __webpackgi_exports__.lmx,
    __webpackgi_exports__Plane = __webpackgi_exports__.JOQ,
    __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__.BKK,
    __webpackgi_exports__PlaneGeometry = __webpackgi_exports__._12,
    __webpackgi_exports__PlaneHelper = __webpackgi_exports__.tJx,
    __webpackgi_exports__PointLight = __webpackgi_exports__.cek,
    __webpackgi_exports__PointLightHelper = __webpackgi_exports__.xG9,
    __webpackgi_exports__Points = __webpackgi_exports__.woe,
    __webpackgi_exports__PointsMaterial = __webpackgi_exports__.UY4,
    __webpackgi_exports__PolarGridHelper = __webpackgi_exports__.aq0,
    __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__.ujx,
    __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__.Uol,
    __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__.JiH,
    __webpackgi_exports__PositionalAudio = __webpackgi_exports__.VYz,
    __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__.EsW,
    __webpackgi_exports__PropertyBinding = __webpackgi_exports__.iUV,
    __webpackgi_exports__PropertyMixer = __webpackgi_exports__.tf,
    __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__.ZQ6,
    __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__.mXe,
    __webpackgi_exports__Quaternion = __webpackgi_exports__._fP,
    __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__.iLg,
    __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__.zbs,
    __webpackgi_exports__REVISION = __webpackgi_exports__.UZH,
    __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__.mSO,
    __webpackgi_exports__RGBAFormat = __webpackgi_exports__.wk1,
    __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__.E2K,
    __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__.FUD,
    __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__.pKu,
    __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__.GG6,
    __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__.Gih,
    __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__.iiP,
    __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__.SvJ,
    __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__.ptH,
    __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__.jZA,
    __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__.y2t,
    __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__.gi4,
    __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__.Djp,
    __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__.BG$,
    __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__.NYV,
    __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__.xJs,
    __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__.bsb,
    __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__.ekQ,
    __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__.CaW,
    __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__.eaV,
    __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__.BFQ,
    __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__.v3W,
    __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__.ILR,
    __webpackgi_exports__RGBFormat = __webpackgi_exports__.UCm,
    __webpackgi_exports__RGBM16Encoding = __webpackgi_exports__.Inb,
    __webpackgi_exports__RGBM7Encoding = __webpackgi_exports__.LgE,
    __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__.fto,
    __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__.l0P,
    __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__.vCx,
    __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__._AM,
    __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__.wuA,
    __webpackgi_exports__RGFormat = __webpackgi_exports__.av9,
    __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__.CtA,
    __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__.BvQ,
    __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__.FZJ,
    __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__.FIo,
    __webpackgi_exports__Ray = __webpackgi_exports__.zHn,
    __webpackgi_exports__Raycaster = __webpackgi_exports__.iMs,
    __webpackgi_exports__RectAreaLight = __webpackgi_exports__.T_f,
    __webpackgi_exports__RedFormat = __webpackgi_exports__.hEm,
    __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__.D9w,
    __webpackgi_exports__Reflector2 = __webpackgi_exports__.sHH,
    __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__.CdI,
    __webpackgi_exports__RepeatWrapping = __webpackgi_exports__.rpg,
    __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__.ce8,
    __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__.rOj,
    __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__.P6m,
    __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__.JA6,
    __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__.V4E,
    __webpackgi_exports__RingGeometry = __webpackgi_exports__.o8S,
    __webpackgi_exports__RootScene = __webpackgi_exports__.flB,
    __webpackgi_exports__SETTLING_TIME = __webpackgi_exports__.DUH,
    __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__.KI_,
    __webpackgi_exports__SSAOPlugin = __webpackgi_exports__.iLN,
    __webpackgi_exports__SSContactShadows = __webpackgi_exports__.jsw,
    __webpackgi_exports__SSRPlugin = __webpackgi_exports__.i6Z,
    __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__.vfv,
    __webpackgi_exports__Scene = __webpackgi_exports__.xsS,
    __webpackgi_exports__SelectionWidget = __webpackgi_exports__.ov0,
    __webpackgi_exports__SerializableOrbitControls = __webpackgi_exports__.cQH,
    __webpackgi_exports__ShaderChunk = __webpackgi_exports__.WdD,
    __webpackgi_exports__ShaderLib = __webpackgi_exports__.Vj0,
    __webpackgi_exports__ShaderMaterial = __webpackgi_exports__.jyz,
    __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__.Mn1,
    __webpackgi_exports__ShaderPass2 = __webpackgi_exports__.Hlq,
    __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__.Fi7,
    __webpackgi_exports__ShadowMaterial = __webpackgi_exports__.Tn7,
    __webpackgi_exports__Shape = __webpackgi_exports__.bnF,
    __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__.HW6,
    __webpackgi_exports__ShapeGeometry = __webpackgi_exports__.oa8,
    __webpackgi_exports__ShapePath = __webpackgi_exports__.T_1,
    __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__.zHJ,
    __webpackgi_exports__ShapeUtils = __webpackgi_exports__.iDF,
    __webpackgi_exports__ShortType = __webpackgi_exports__.iAb,
    __webpackgi_exports__SimpleAssetList = __webpackgi_exports__.d4E,
    __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__.lBg,
    __webpackgi_exports__SimpleDataSource = __webpackgi_exports__.JeJ,
    __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__.FKY,
    __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__.zlZ,
    __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__.vkg,
    __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__.brh,
    __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__.kZK,
    __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__.puG,
    __webpackgi_exports__Skeleton = __webpackgi_exports__.OdW,
    __webpackgi_exports__SkeletonHelper = __webpackgi_exports__._YX,
    __webpackgi_exports__SkinnedMesh = __webpackgi_exports__.TUv,
    __webpackgi_exports__SmoothShading = __webpackgi_exports__.wcA,
    __webpackgi_exports__Source = __webpackgi_exports__.Hw6,
    __webpackgi_exports__Sphere = __webpackgi_exports__.aLr,
    __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__.Aip,
    __webpackgi_exports__SphereGeometry = __webpackgi_exports__.xo$,
    __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__.bIn,
    __webpackgi_exports__Spherical = __webpackgi_exports__.$V,
    __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__.lDi,
    __webpackgi_exports__SplineCurve = __webpackgi_exports__.gti,
    __webpackgi_exports__SpotLight = __webpackgi_exports__.PMe,
    __webpackgi_exports__SpotLight2 = __webpackgi_exports__.iwP,
    __webpackgi_exports__SpotLightHelper = __webpackgi_exports__.FvO,
    __webpackgi_exports__Sprite = __webpackgi_exports__.jyi,
    __webpackgi_exports__SpriteMaterial = __webpackgi_exports__.xeV,
    __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__.k74,
    __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__.RlZ,
    __webpackgi_exports__SrcColorFactor = __webpackgi_exports__.KhW,
    __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__.HgB,
    __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__.W2J,
    __webpackgi_exports__StaticReadUsage = __webpackgi_exports__.JWc,
    __webpackgi_exports__StereoCamera = __webpackgi_exports__.u37,
    __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__.Z6B,
    __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__.QZ1,
    __webpackgi_exports__StreamReadUsage = __webpackgi_exports__.Ir4,
    __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__.NwF,
    __webpackgi_exports__SubtractEquation = __webpackgi_exports__.Wbm,
    __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__.N4l,
    __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__.ej9,
    __webpackgi_exports__TOUCH = __webpackgi_exports__.QmN,
    __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__.IOt,
    __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__.NOD,
    __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__.L5g,
    __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__.H$k,
    __webpackgi_exports__TextGeometry = __webpackgi_exports__.MP$,
    __webpackgi_exports__TextSVGOptions = __webpackgi_exports__.cuP,
    __webpackgi_exports__Texture = __webpackgi_exports__.xEZ,
    __webpackgi_exports__TextureLoader = __webpackgi_exports__.dpR,
    __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__.wOD,
    __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__.KNb,
    __webpackgi_exports__TonemapPass = __webpackgi_exports__.Rk2,
    __webpackgi_exports__TonemapPlugin = __webpackgi_exports__.IiN,
    __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__.Cne,
    __webpackgi_exports__TorusGeometry = __webpackgi_exports__.XvJ,
    __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__.XZw,
    __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__.FE5,
    __webpackgi_exports__TransformControls2 = __webpackgi_exports__.lVp,
    __webpackgi_exports__Triangle = __webpackgi_exports__.CJI,
    __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__.z$h,
    __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__.UlW,
    __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__.WwZ,
    __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__.Lcc,
    __webpackgi_exports__TubeGeometry = __webpackgi_exports__.WXh,
    __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__.Vjr,
    __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__.LuM,
    __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__.LP5,
    __webpackgi_exports__UVMapping = __webpackgi_exports__.xfE,
    __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__.qlB,
    __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__.lCJ,
    __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__.WTc,
    __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__.rAo,
    __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__.LZj,
    __webpackgi_exports__Uniform = __webpackgi_exports__.xWb,
    __webpackgi_exports__UniformsGroup = __webpackgi_exports__.gH0,
    __webpackgi_exports__UniformsLib = __webpackgi_exports__.rBU,
    __webpackgi_exports__UniformsUtils = __webpackgi_exports__.rDY,
    __webpackgi_exports__UnsignedByteType = __webpackgi_exports__.ywz,
    __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__.wJv,
    __webpackgi_exports__UnsignedIntType = __webpackgi_exports__.JQ4,
    __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__.k0A,
    __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__.irR,
    __webpackgi_exports__UnsignedShortType = __webpackgi_exports__.LsT,
    __webpackgi_exports__Unzip = __webpackgi_exports__.q5h,
    __webpackgi_exports__UnzipInflate = __webpackgi_exports__.TKh,
    __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__.tyg,
    __webpackgi_exports__Unzlib = __webpackgi_exports__.Ro5,
    __webpackgi_exports__VSMShadowMap = __webpackgi_exports__.dwk,
    __webpackgi_exports__Vector2 = __webpackgi_exports__.FM8,
    __webpackgi_exports__Vector3 = __webpackgi_exports__.Pa4,
    __webpackgi_exports__Vector4 = __webpackgi_exports__.Ltg,
    __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__.yC1,
    __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__.lHq,
    __webpackgi_exports__VideoTexture = __webpackgi_exports__.fO1,
    __webpackgi_exports__ViewerApp = __webpackgi_exports__.oMA,
    __webpackgi_exports__ViewerState = __webpackgi_exports__.JzW,
    __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__.b5g,
    __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__.Ywn,
    __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__.GVz,
    __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__.oAp,
    __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__.kFz,
    __webpackgi_exports__WebGLMultisampleRenderTarget = __webpackgi_exports__.p7A,
    __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__.dd2,
    __webpackgi_exports__WebGLRenderer = __webpackgi_exports__.CP7,
    __webpackgi_exports__WebGLUtils = __webpackgi_exports__.fQK,
    __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__.Wd$,
    __webpackgi_exports__WireframeGeometry = __webpackgi_exports__.Uk6,
    __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__._sL,
    __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__.Pnf,
    __webpackgi_exports__ZeroFactor = __webpackgi_exports__.c8b,
    __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__._lf,
    __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__.ad5,
    __webpackgi_exports__Zip = __webpackgi_exports__.sZV,
    __webpackgi_exports__ZipDeflate = __webpackgi_exports__.TfA,
    __webpackgi_exports__ZipLoader = __webpackgi_exports__.sKX,
    __webpackgi_exports__ZipPassThrough = __webpackgi_exports__.UdM,
    __webpackgi_exports__Zlib = __webpackgi_exports__.P0y,
    __webpackgi_exports___SRGBAFormat = __webpackgi_exports__.L_r,
    __webpackgi_exports__addBasePlugins = __webpackgi_exports__.Bve,
    __webpackgi_exports__addDracoLoader = __webpackgi_exports__.UeO,
    __webpackgi_exports__addGLTFExporter = __webpackgi_exports__.$nx,
    __webpackgi_exports__addGLTFLoader = __webpackgi_exports__.Bk6,
    __webpackgi_exports__addRGBELoader = __webpackgi_exports__.y4l,
    __webpackgi_exports__addZipLoader = __webpackgi_exports__.pQ0,
    __webpackgi_exports__afterMain = __webpackgi_exports__.wXW,
    __webpackgi_exports__afterRead = __webpackgi_exports__.r5x,
    __webpackgi_exports__afterWrite = __webpackgi_exports__.MSI,
    __webpackgi_exports__animate = __webpackgi_exports__.jtH,
    __webpackgi_exports__animateAsync = __webpackgi_exports__.T0T,
    __webpackgi_exports__animateObject = __webpackgi_exports__.gAb,
    __webpackgi_exports__animatePromise = __webpackgi_exports__.iwT,
    __webpackgi_exports__animateSet = __webpackgi_exports__.je_,
    __webpackgi_exports__animateTarget = __webpackgi_exports__.wBP,
    __webpackgi_exports__applyStyles = __webpackgi_exports__.Zs7,
    __webpackgi_exports__arrow = __webpackgi_exports__.x7s,
    __webpackgi_exports__auto = __webpackgi_exports__.d73,
    __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__.RG9,
    __webpackgi_exports__basePlacements = __webpackgi_exports__.mvg,
    __webpackgi_exports__beforeMain = __webpackgi_exports__.XMc,
    __webpackgi_exports__beforeRead = __webpackgi_exports__.N7M,
    __webpackgi_exports__beforeWrite = __webpackgi_exports__.iv,
    __webpackgi_exports__blobToDataURL = __webpackgi_exports__.n55,
    __webpackgi_exports__bottom = __webpackgi_exports__.IaC,
    __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__.$MY,
    __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__.wJl,
    __webpackgi_exports__clippingParents = __webpackgi_exports__.zVI,
    __webpackgi_exports__combineDofShader = __webpackgi_exports__.DpF,
    __webpackgi_exports__compress = __webpackgi_exports__.nNb,
    __webpackgi_exports__compressSync = __webpackgi_exports__.cqZ,
    __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__.KlC,
    __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__.KVn,
    __webpackgi_exports__computeStyles = __webpackgi_exports__.oau,
    __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__.aw9,
    __webpackgi_exports__copyObjectUserData = __webpackgi_exports__.leS,
    __webpackgi_exports__copyProps = __webpackgi_exports__.Dxg,
    __webpackgi_exports__createCanvasElement = __webpackgi_exports__.O5A,
    __webpackgi_exports__createDiv = __webpackgi_exports__.wCn,
    __webpackgi_exports__createImage = __webpackgi_exports__.Bi6,
    __webpackgi_exports__createPopper = __webpackgi_exports__.fi_,
    __webpackgi_exports__createPopperBase = __webpackgi_exports__.TT,
    __webpackgi_exports__createPopperLite = __webpackgi_exports__.q2Z,
    __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__.NyK,
    __webpackgi_exports__createScriptFromURL = __webpackgi_exports__.bgu,
    __webpackgi_exports__createStyles = __webpackgi_exports__.kcS,
    __webpackgi_exports__css = __webpackgi_exports__.ivY,
    __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__._HO,
    __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__.tpL,
    __webpackgi_exports__decompress = __webpackgi_exports__.LjN,
    __webpackgi_exports__decompressSync = __webpackgi_exports__.iFs,
    __webpackgi_exports__deepAccessObject = __webpackgi_exports__.qTg,
    __webpackgi_exports__deflate = __webpackgi_exports__.Wtl,
    __webpackgi_exports__deflateSync = __webpackgi_exports__.DmK,
    __webpackgi_exports__deserializeObject = __webpackgi_exports__.Hx7,
    __webpackgi_exports__deserializers = __webpackgi_exports__.imt,
    __webpackgi_exports__detectOverflow = __webpackgi_exports__.US6,
    __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__.vZs,
    __webpackgi_exports__downloadBlob = __webpackgi_exports__.lmu,
    __webpackgi_exports__downloadFile = __webpackgi_exports__.SvO,
    __webpackgi_exports__embedUrlRefs = __webpackgi_exports__.omp,
    __webpackgi_exports__end = __webpackgi_exports__.utz,
    __webpackgi_exports__envMapBackground = __webpackgi_exports__.TFV,
    __webpackgi_exports__escapeRegExp = __webpackgi_exports__.hrz,
    __webpackgi_exports__eventListeners = __webpackgi_exports__.JKM,
    __webpackgi_exports__extractAnimationKey = __webpackgi_exports__.jZf,
    __webpackgi_exports__flattenUiConfig = __webpackgi_exports__.RjL,
    __webpackgi_exports__flip = __webpackgi_exports__.RRI,
    __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__.RUq,
    __webpackgi_exports__generateUiConfig = __webpackgi_exports__._t4,
    __webpackgi_exports__generateUiFolder = __webpackgi_exports__.YHh,
    __webpackgi_exports__getEncodingComponents = __webpackgi_exports__.R8g,
    __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__.Bbl,
    __webpackgi_exports__getKeyByValue = __webpackgi_exports__.V9r,
    __webpackgi_exports__getOrCall = __webpackgi_exports__.PZ2,
    __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__.w7A,
    __webpackgi_exports__getTexelDecoding = __webpackgi_exports__.N6S,
    __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__.Uxp,
    __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__.tAz,
    __webpackgi_exports__getTexelEncoding = __webpackgi_exports__.R$F,
    __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__.N33,
    __webpackgi_exports__getTextureDataType = __webpackgi_exports__.gw2,
    __webpackgi_exports__getTextureEncodingFromMap = __webpackgi_exports__.KlU,
    __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__.wo6,
    __webpackgi_exports__glsl = __webpackgi_exports__.H4P,
    __webpackgi_exports__gunzip = __webpackgi_exports__.swA,
    __webpackgi_exports__gunzipSync = __webpackgi_exports__._Z3,
    __webpackgi_exports__gzip = __webpackgi_exports__.ivc,
    __webpackgi_exports__gzipSync = __webpackgi_exports__.rZ1,
    __webpackgi_exports__hide = __webpackgi_exports__.CpZ,
    __webpackgi_exports__html = __webpackgi_exports__.dyc,
    __webpackgi_exports__htmlToCanvas = __webpackgi_exports__.MxZ,
    __webpackgi_exports__htmlToPng = __webpackgi_exports__.btp,
    __webpackgi_exports__htmlToSvg = __webpackgi_exports__.mXy,
    __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__.Ej0,
    __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__.ep4,
    __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__.DQP,
    __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__.V7q,
    __webpackgi_exports__imageToCanvas = __webpackgi_exports__.zEk,
    __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__.qfq,
    __webpackgi_exports__includesAll = __webpackgi_exports__.piB,
    __webpackgi_exports__inflate = __webpackgi_exports__.rrF,
    __webpackgi_exports__inflateSync = __webpackgi_exports__.naq,
    __webpackgi_exports__isAnimatableType = __webpackgi_exports__.p5I,
    __webpackgi_exports__isPropertyWritable = __webpackgi_exports__.GpE,
    __webpackgi_exports__left = __webpackgi_exports__.t$v,
    __webpackgi_exports__lerpAngle = __webpackgi_exports__.tdn,
    __webpackgi_exports__lerpAngle2 = __webpackgi_exports__.Y9t,
    __webpackgi_exports__main = __webpackgi_exports__.DH3,
    __webpackgi_exports__makeColorSvg = __webpackgi_exports__.uxM,
    __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__.zH3,
    __webpackgi_exports__makeFilter = __webpackgi_exports__.MLs,
    __webpackgi_exports__makeGeometryUiConfig = __webpackgi_exports__.le6,
    __webpackgi_exports__makeObject3DUiConfig = __webpackgi_exports__.s6f,
    __webpackgi_exports__makeSetterFor = __webpackgi_exports__.YM4,
    __webpackgi_exports__makeSetterForAnimObject = __webpackgi_exports__.B3r,
    __webpackgi_exports__makeTextSvg = __webpackgi_exports__.iAx,
    __webpackgi_exports__matDefine = __webpackgi_exports__.lDn,
    __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__.TIc,
    __webpackgi_exports__modifierPhases = __webpackgi_exports__.xsC,
    __webpackgi_exports__now = __webpackgi_exports__.zOc,
    __webpackgi_exports__offset = __webpackgi_exports__.r46,
    __webpackgi_exports__onChange = __webpackgi_exports__.z2C,
    __webpackgi_exports__parseFileExtension = __webpackgi_exports__._X$,
    __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__._yn,
    __webpackgi_exports__pathJoin = __webpackgi_exports__.Dyg,
    __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__.cUc,
    __webpackgi_exports__placements = __webpackgi_exports__.Ctq,
    __webpackgi_exports__popper = __webpackgi_exports__.k5b,
    __webpackgi_exports__popperGenerator = __webpackgi_exports__.kZl,
    __webpackgi_exports__popperOffsets = __webpackgi_exports__.OCg,
    __webpackgi_exports__preventOverflow = __webpackgi_exports__.YjH,
    __webpackgi_exports__processViewer = __webpackgi_exports__.Ui8,
    __webpackgi_exports__read = __webpackgi_exports__.ij3,
    __webpackgi_exports__reference = __webpackgi_exports__.YPW,
    __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__.Bg1,
    __webpackgi_exports__replaceAll = __webpackgi_exports__.kon,
    __webpackgi_exports__right = __webpackgi_exports__.F2z,
    __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__.pJF,
    __webpackgi_exports__sRGBEncoding = __webpackgi_exports__.knz,
    __webpackgi_exports__safeSetProperty = __webpackgi_exports__.Ejo,
    __webpackgi_exports__serializable = __webpackgi_exports__.BgY,
    __webpackgi_exports__serialize = __webpackgi_exports__.qCG,
    __webpackgi_exports__serializeObject = __webpackgi_exports__.HD9,
    __webpackgi_exports__serializers = __webpackgi_exports__.fEB,
    __webpackgi_exports__setMeshGeometry = __webpackgi_exports__.Udc,
    __webpackgi_exports__setMeshMaterial = __webpackgi_exports__.ZQg,
    __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__.ofC,
    __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__.yRy,
    __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__._NL,
    __webpackgi_exports__setupIModel = __webpackgi_exports__.LCA,
    __webpackgi_exports__setupObject3dModel = __webpackgi_exports__.j1w,
    __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__.i8J,
    __webpackgi_exports__shaderReplaceString = __webpackgi_exports__.p7C,
    __webpackgi_exports__slerp = __webpackgi_exports__.ZAS,
    __webpackgi_exports__snapObject = __webpackgi_exports__.VWG,
    __webpackgi_exports__sphericalFromObject = __webpackgi_exports__.pQ7,
    __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__.jc8,
    __webpackgi_exports__start = __webpackgi_exports__.BL_,
    __webpackgi_exports__strFromU8 = __webpackgi_exports__.T8U,
    __webpackgi_exports__strToU8 = __webpackgi_exports__.TD6,
    __webpackgi_exports__svgToCanvas = __webpackgi_exports__.akS,
    __webpackgi_exports__svgToPng = __webpackgi_exports__.QKE,
    __webpackgi_exports__svgUrl = __webpackgi_exports__.dKx,
    __webpackgi_exports__syncAnimSetUi = __webpackgi_exports__.OvX,
    __webpackgi_exports__timeout = __webpackgi_exports__.VsW,
    __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__.aPg,
    __webpackgi_exports__toTitleCase = __webpackgi_exports__.LFn,
    __webpackgi_exports__top = __webpackgi_exports__.wey,
    __webpackgi_exports__uiButton = __webpackgi_exports__.MaE,
    __webpackgi_exports__uiColor = __webpackgi_exports__.s4x,
    __webpackgi_exports__uiConfig = __webpackgi_exports__.FJA,
    __webpackgi_exports__uiDropdown = __webpackgi_exports__.vIA,
    __webpackgi_exports__uiFolder = __webpackgi_exports__.Spv,
    __webpackgi_exports__uiImage = __webpackgi_exports__.w8l,
    __webpackgi_exports__uiInput = __webpackgi_exports__.riG,
    __webpackgi_exports__uiMonitor = __webpackgi_exports__.Kbh,
    __webpackgi_exports__uiSlider = __webpackgi_exports__.t8K,
    __webpackgi_exports__uiToggle = __webpackgi_exports__.Q7n,
    __webpackgi_exports__uiVector = __webpackgi_exports__.KGF,
    __webpackgi_exports__uniform = __webpackgi_exports__.e5,
    __webpackgi_exports__unzip = __webpackgi_exports__.Rik,
    __webpackgi_exports__unzipSync = __webpackgi_exports__.GZo,
    __webpackgi_exports__unzlib = __webpackgi_exports__.Bds,
    __webpackgi_exports__unzlibSync = __webpackgi_exports__.HTu,
    __webpackgi_exports__uploadFile = __webpackgi_exports__.cTq,
    __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__.X_Y,
    __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__.dA8,
    __webpackgi_exports__variationPlacements = __webpackgi_exports__.bwS,
    __webpackgi_exports__verifyPermission = __webpackgi_exports__.P4F,
    __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__.Pd0,
    __webpackgi_exports__viewport = __webpackgi_exports__.Pjo,
    __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__.Tum,
    __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__.dRH,
    __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__.RX0,
    __webpackgi_exports__write = __webpackgi_exports__.cWm,
    __webpackgi_exports__writeFile = __webpackgi_exports__.NC9,
    __webpackgi_exports__zip = __webpackgi_exports__.$Re,
    __webpackgi_exports__zipSync = __webpackgi_exports__.Xo9,
    __webpackgi_exports__zlib = __webpackgi_exports__.LNO,
    __webpackgi_exports__zlibSync = __webpackgi_exports__.iZP;
exports.zlibSync = __webpackgi_exports__zlibSync;
exports.zlib = __webpackgi_exports__zlib;
exports.zipSync = __webpackgi_exports__zipSync;
exports.zip = __webpackgi_exports__zip;
exports.writeFile = __webpackgi_exports__writeFile;
exports.write = __webpackgi_exports__write;
exports.webgiObject3DExtrasExtension = __webpackgi_exports__webgiObject3DExtrasExtension;
exports.webgiMaterialExtrasExtension = __webpackgi_exports__webgiMaterialExtrasExtension;
exports.webgiLightExtrasExtension = __webpackgi_exports__webgiLightExtrasExtension;
exports.viewport = __webpackgi_exports__viewport;
exports.viewerGLTFExtension = __webpackgi_exports__viewerGLTFExtension;
exports.verifyPermission = __webpackgi_exports__verifyPermission;
exports.variationPlacements = __webpackgi_exports__variationPlacements;
exports.vRGBMToLinear = __webpackgi_exports__vRGBMToLinear;
exports.vLinearToRGBM = __webpackgi_exports__vLinearToRGBM;
exports.uploadFile = __webpackgi_exports__uploadFile;
exports.unzlibSync = __webpackgi_exports__unzlibSync;
exports.unzlib = __webpackgi_exports__unzlib;
exports.unzipSync = __webpackgi_exports__unzipSync;
exports.unzip = __webpackgi_exports__unzip;
exports.uniform = __webpackgi_exports__uniform;
exports.uiVector = __webpackgi_exports__uiVector;
exports.uiToggle = __webpackgi_exports__uiToggle;
exports.uiSlider = __webpackgi_exports__uiSlider;
exports.uiMonitor = __webpackgi_exports__uiMonitor;
exports.uiInput = __webpackgi_exports__uiInput;
exports.uiImage = __webpackgi_exports__uiImage;
exports.uiFolder = __webpackgi_exports__uiFolder;
exports.uiDropdown = __webpackgi_exports__uiDropdown;
exports.uiConfig = __webpackgi_exports__uiConfig;
exports.uiColor = __webpackgi_exports__uiColor;
exports.uiButton = __webpackgi_exports__uiButton;
exports.top = __webpackgi_exports__top;
exports.toTitleCase = __webpackgi_exports__toTitleCase;
exports.toIndexedGeometry = __webpackgi_exports__toIndexedGeometry;
exports.timeout = __webpackgi_exports__timeout;
exports.syncAnimSetUi = __webpackgi_exports__syncAnimSetUi;
exports.svgUrl = __webpackgi_exports__svgUrl;
exports.svgToPng = __webpackgi_exports__svgToPng;
exports.svgToCanvas = __webpackgi_exports__svgToCanvas;
exports.strToU8 = __webpackgi_exports__strToU8;
exports.strFromU8 = __webpackgi_exports__strFromU8;
exports.start = __webpackgi_exports__start;
exports.standardMaterialPropList = __webpackgi_exports__standardMaterialPropList;
exports.sphericalFromObject = __webpackgi_exports__sphericalFromObject;
exports.snapObject = __webpackgi_exports__snapObject;
exports.slerp = __webpackgi_exports__slerp;
exports.shaderReplaceString = __webpackgi_exports__shaderReplaceString;
exports.setupSandboxWebGiEditor = __webpackgi_exports__setupSandboxWebGiEditor;
exports.setupObject3dModel = __webpackgi_exports__setupObject3dModel;
exports.setupIModel = __webpackgi_exports__setupIModel;
exports.setupCoreWebGiViewer = __webpackgi_exports__setupCoreWebGiViewer;
exports.setUrlQueryParam = __webpackgi_exports__setUrlQueryParam;
exports.setThreeRendererMode = __webpackgi_exports__setThreeRendererMode;
exports.setMeshMaterial = __webpackgi_exports__setMeshMaterial;
exports.setMeshGeometry = __webpackgi_exports__setMeshGeometry;
exports.serializers = __webpackgi_exports__serializers;
exports.serializeObject = __webpackgi_exports__serializeObject;
exports.serialize = __webpackgi_exports__serialize;
exports.serializable = __webpackgi_exports__serializable;
exports.safeSetProperty = __webpackgi_exports__safeSetProperty;
exports.sRGBEncoding = __webpackgi_exports__sRGBEncoding;
exports.rotateDuplicatedMesh = __webpackgi_exports__rotateDuplicatedMesh;
exports.right = __webpackgi_exports__right;
exports.replaceAll = __webpackgi_exports__replaceAll;
exports.removeDuplicateGeometries = __webpackgi_exports__removeDuplicateGeometries;
exports.reference = __webpackgi_exports__reference;
exports.read = __webpackgi_exports__read;
exports.processViewer = __webpackgi_exports__processViewer;
exports.preventOverflow = __webpackgi_exports__preventOverflow;
exports.popperOffsets = __webpackgi_exports__popperOffsets;
exports.popperGenerator = __webpackgi_exports__popperGenerator;
exports.popper = __webpackgi_exports__popper;
exports.placements = __webpackgi_exports__placements;
exports.physicalMaterialPropList = __webpackgi_exports__physicalMaterialPropList;
exports.pathJoin = __webpackgi_exports__pathJoin;
exports.patchShaderEncodingSupport = __webpackgi_exports__patchShaderEncodingSupport;
exports.parseFileExtension = __webpackgi_exports__parseFileExtension;
exports.onChange = __webpackgi_exports__onChange;
exports.offset = __webpackgi_exports__offset;
exports.now = __webpackgi_exports__now;
exports.modifierPhases = __webpackgi_exports__modifierPhases;
exports.mobileAndTabletCheck = __webpackgi_exports__mobileAndTabletCheck;
exports.matDefine = __webpackgi_exports__matDefine;
exports.makeTextSvg = __webpackgi_exports__makeTextSvg;
exports.makeSetterForAnimObject = __webpackgi_exports__makeSetterForAnimObject;
exports.makeSetterFor = __webpackgi_exports__makeSetterFor;
exports.makeObject3DUiConfig = __webpackgi_exports__makeObject3DUiConfig;
exports.makeGeometryUiConfig = __webpackgi_exports__makeGeometryUiConfig;
exports.makeFilter = __webpackgi_exports__makeFilter;
exports.makeColorSvgCircle = __webpackgi_exports__makeColorSvgCircle;
exports.makeColorSvg = __webpackgi_exports__makeColorSvg;
exports.main = __webpackgi_exports__main;
exports.lerpAngle2 = __webpackgi_exports__lerpAngle2;
exports.lerpAngle = __webpackgi_exports__lerpAngle;
exports.left = __webpackgi_exports__left;
exports.isPropertyWritable = __webpackgi_exports__isPropertyWritable;
exports.isAnimatableType = __webpackgi_exports__isAnimatableType;
exports.inflateSync = __webpackgi_exports__inflateSync;
exports.inflate = __webpackgi_exports__inflate;
exports.includesAll = __webpackgi_exports__includesAll;
exports.imageUrlToImageData = __webpackgi_exports__imageUrlToImageData;
exports.imageToCanvas = __webpackgi_exports__imageToCanvas;
exports.imageBitmapToBase64 = __webpackgi_exports__imageBitmapToBase64;
exports.iModelIgnoredUserData = __webpackgi_exports__iModelIgnoredUserData;
exports.iMaterialIgnoredUserData = __webpackgi_exports__iMaterialIgnoredUserData;
exports.iGeometryIgnoredUserData = __webpackgi_exports__iGeometryIgnoredUserData;
exports.htmlToSvg = __webpackgi_exports__htmlToSvg;
exports.htmlToPng = __webpackgi_exports__htmlToPng;
exports.htmlToCanvas = __webpackgi_exports__htmlToCanvas;
exports.html = __webpackgi_exports__html;
exports.hide = __webpackgi_exports__hide;
exports.gzipSync = __webpackgi_exports__gzipSync;
exports.gzip = __webpackgi_exports__gzip;
exports.gunzipSync = __webpackgi_exports__gunzipSync;
exports.gunzip = __webpackgi_exports__gunzip;
exports.glsl = __webpackgi_exports__glsl;
exports.getUrlQueryParam = __webpackgi_exports__getUrlQueryParam;
exports.getTextureEncodingFromMap = __webpackgi_exports__getTextureEncodingFromMap;
exports.getTextureDataType = __webpackgi_exports__getTextureDataType;
exports.getTexelEncodingFunction = __webpackgi_exports__getTexelEncodingFunction;
exports.getTexelEncoding = __webpackgi_exports__getTexelEncoding;
exports.getTexelDecodingFunction = __webpackgi_exports__getTexelDecodingFunction;
exports.getTexelDecoding2 = __webpackgi_exports__getTexelDecoding2;
exports.getTexelDecoding = __webpackgi_exports__getTexelDecoding;
exports.getPropertyDescriptor = __webpackgi_exports__getPropertyDescriptor;
exports.getOrCall = __webpackgi_exports__getOrCall;
exports.getKeyByValue = __webpackgi_exports__getKeyByValue;
exports.getFilenameFromPath = __webpackgi_exports__getFilenameFromPath;
exports.getEncodingComponents = __webpackgi_exports__getEncodingComponents;
exports.generateUiFolder = __webpackgi_exports__generateUiFolder;
exports.generateUiConfig = __webpackgi_exports__generateUiConfig;
exports.fontFormatExtensionMap = __webpackgi_exports__fontFormatExtensionMap;
exports.flip = __webpackgi_exports__flip;
exports.flattenUiConfig = __webpackgi_exports__flattenUiConfig;
exports.extractAnimationKey = __webpackgi_exports__extractAnimationKey;
exports.eventListeners = __webpackgi_exports__eventListeners;
exports.escapeRegExp = __webpackgi_exports__escapeRegExp;
exports.envMapBackground = __webpackgi_exports__envMapBackground;
exports.end = __webpackgi_exports__end;
exports.embedUrlRefs = __webpackgi_exports__embedUrlRefs;
exports.downloadFile = __webpackgi_exports__downloadFile;
exports.downloadBlob = __webpackgi_exports__downloadBlob;
exports.diamondMaterialPropList = __webpackgi_exports__diamondMaterialPropList;
exports.detectOverflow = __webpackgi_exports__detectOverflow;
exports.deserializers = __webpackgi_exports__deserializers;
exports.deserializeObject = __webpackgi_exports__deserializeObject;
exports.deflateSync = __webpackgi_exports__deflateSync;
exports.deflate = __webpackgi_exports__deflate;
exports.deepAccessObject = __webpackgi_exports__deepAccessObject;
exports.decompressSync = __webpackgi_exports__decompressSync;
exports.decompress = __webpackgi_exports__decompress;
exports.dataTextureFromVec4 = __webpackgi_exports__dataTextureFromVec4;
exports.dataTextureFromColor = __webpackgi_exports__dataTextureFromColor;
exports.css = __webpackgi_exports__css;
exports.createStyles = __webpackgi_exports__createStyles;
exports.createScriptFromURL = __webpackgi_exports__createScriptFromURL;
exports.createRenderTargetKey = __webpackgi_exports__createRenderTargetKey;
exports.createPopperLite = __webpackgi_exports__createPopperLite;
exports.createPopperBase = __webpackgi_exports__createPopperBase;
exports.createPopper = __webpackgi_exports__createPopper;
exports.createImage = __webpackgi_exports__createImage;
exports.createDiv = __webpackgi_exports__createDiv;
exports.createCanvasElement = __webpackgi_exports__createCanvasElement;
exports.copyProps = __webpackgi_exports__copyProps;
exports.copyObjectUserData = __webpackgi_exports__copyObjectUserData;
exports.copyMaterialUserData = __webpackgi_exports__copyMaterialUserData;
exports.computeStyles = __webpackgi_exports__computeStyles;
exports.computeScreenSpaceBoundingBox = __webpackgi_exports__computeScreenSpaceBoundingBox;
exports.computeOffsetMatrix = __webpackgi_exports__computeOffsetMatrix;
exports.compressSync = __webpackgi_exports__compressSync;
exports.compress = __webpackgi_exports__compress;
exports.combineDofShader = __webpackgi_exports__combineDofShader;
exports.clippingParents = __webpackgi_exports__clippingParents;
exports.cRGBMToLinear = __webpackgi_exports__cRGBMToLinear;
exports.cLinearToRGBM = __webpackgi_exports__cLinearToRGBM;
exports.bottom = __webpackgi_exports__bottom;
exports.blobToDataURL = __webpackgi_exports__blobToDataURL;
exports.beforeWrite = __webpackgi_exports__beforeWrite;
exports.beforeRead = __webpackgi_exports__beforeRead;
exports.beforeMain = __webpackgi_exports__beforeMain;
exports.basePlacements = __webpackgi_exports__basePlacements;
exports.autoScaleObject3D = __webpackgi_exports__autoScaleObject3D;
exports.auto = __webpackgi_exports__auto;
exports.arrow = __webpackgi_exports__arrow;
exports.applyStyles = __webpackgi_exports__applyStyles;
exports.animateTarget = __webpackgi_exports__animateTarget;
exports.animateSet = __webpackgi_exports__animateSet;
exports.animatePromise = __webpackgi_exports__animatePromise;
exports.animateObject = __webpackgi_exports__animateObject;
exports.animateAsync = __webpackgi_exports__animateAsync;
exports.animate = __webpackgi_exports__animate;
exports.afterWrite = __webpackgi_exports__afterWrite;
exports.afterRead = __webpackgi_exports__afterRead;
exports.afterMain = __webpackgi_exports__afterMain;
exports.addZipLoader = __webpackgi_exports__addZipLoader;
exports.addRGBELoader = __webpackgi_exports__addRGBELoader;
exports.addGLTFLoader = __webpackgi_exports__addGLTFLoader;
exports.addGLTFExporter = __webpackgi_exports__addGLTFExporter;
exports.addDracoLoader = __webpackgi_exports__addDracoLoader;
exports.addBasePlugins = __webpackgi_exports__addBasePlugins;
exports._SRGBAFormat = __webpackgi_exports___SRGBAFormat;
exports.Zlib = __webpackgi_exports__Zlib;
exports.ZipPassThrough = __webpackgi_exports__ZipPassThrough;
exports.ZipLoader = __webpackgi_exports__ZipLoader;
exports.ZipDeflate = __webpackgi_exports__ZipDeflate;
exports.Zip = __webpackgi_exports__Zip;
exports.ZeroStencilOp = __webpackgi_exports__ZeroStencilOp;
exports.ZeroSlopeEnding = __webpackgi_exports__ZeroSlopeEnding;
exports.ZeroFactor = __webpackgi_exports__ZeroFactor;
exports.ZeroCurvatureEnding = __webpackgi_exports__ZeroCurvatureEnding;
exports.WrapAroundEnding = __webpackgi_exports__WrapAroundEnding;
exports.WireframeGeometry = __webpackgi_exports__WireframeGeometry;
exports.WebGiViewerElement = __webpackgi_exports__WebGiViewerElement;
exports.WebGLUtils = __webpackgi_exports__WebGLUtils;
exports.WebGLRenderer = __webpackgi_exports__WebGLRenderer;
exports.WebGLRenderTarget = __webpackgi_exports__WebGLRenderTarget;
exports.WebGLMultisampleRenderTarget = __webpackgi_exports__WebGLMultisampleRenderTarget;
exports.WebGLMultipleRenderTargets = __webpackgi_exports__WebGLMultipleRenderTargets;
exports.WebGLCubeRenderTarget = __webpackgi_exports__WebGLCubeRenderTarget;
exports.WebGLArrayRenderTarget = __webpackgi_exports__WebGLArrayRenderTarget;
exports.WebGL3DRenderTarget = __webpackgi_exports__WebGL3DRenderTarget;
exports.WebGL1Renderer = __webpackgi_exports__WebGL1Renderer;
exports.ViewerState = __webpackgi_exports__ViewerState;
exports.ViewerApp = __webpackgi_exports__ViewerApp;
exports.VideoTexture = __webpackgi_exports__VideoTexture;
exports.VelocityBufferPlugin = __webpackgi_exports__VelocityBufferPlugin;
exports.VectorKeyframeTrack = __webpackgi_exports__VectorKeyframeTrack;
exports.Vector4 = __webpackgi_exports__Vector4;
exports.Vector3 = __webpackgi_exports__Vector3;
exports.Vector2 = __webpackgi_exports__Vector2;
exports.VSMShadowMap = __webpackgi_exports__VSMShadowMap;
exports.Unzlib = __webpackgi_exports__Unzlib;
exports.UnzipPassThrough = __webpackgi_exports__UnzipPassThrough;
exports.UnzipInflate = __webpackgi_exports__UnzipInflate;
exports.Unzip = __webpackgi_exports__Unzip;
exports.UnsignedShortType = __webpackgi_exports__UnsignedShortType;
exports.UnsignedShort5551Type = __webpackgi_exports__UnsignedShort5551Type;
exports.UnsignedShort4444Type = __webpackgi_exports__UnsignedShort4444Type;
exports.UnsignedIntType = __webpackgi_exports__UnsignedIntType;
exports.UnsignedInt248Type = __webpackgi_exports__UnsignedInt248Type;
exports.UnsignedByteType = __webpackgi_exports__UnsignedByteType;
exports.UniformsUtils = __webpackgi_exports__UniformsUtils;
exports.UniformsLib = __webpackgi_exports__UniformsLib;
exports.UniformsGroup = __webpackgi_exports__UniformsGroup;
exports.Uniform = __webpackgi_exports__Uniform;
exports.Uncharted2Tonemapping = __webpackgi_exports__Uncharted2Tonemapping;
exports.Uint8ClampedBufferAttribute = __webpackgi_exports__Uint8ClampedBufferAttribute;
exports.Uint8BufferAttribute = __webpackgi_exports__Uint8BufferAttribute;
exports.Uint32BufferAttribute = __webpackgi_exports__Uint32BufferAttribute;
exports.Uint16BufferAttribute = __webpackgi_exports__Uint16BufferAttribute;
exports.UVMapping = __webpackgi_exports__UVMapping;
exports.TweakpaneWrapper = __webpackgi_exports__TweakpaneWrapper;
exports.TweakpaneUiPlugin = __webpackgi_exports__TweakpaneUiPlugin;
exports.TubeShapeGeometry = __webpackgi_exports__TubeShapeGeometry;
exports.TubeGeometry = __webpackgi_exports__TubeGeometry;
exports.TubeBufferGeometry = __webpackgi_exports__TubeBufferGeometry;
exports.TrianglesDrawMode = __webpackgi_exports__TrianglesDrawMode;
exports.TriangleStripDrawMode = __webpackgi_exports__TriangleStripDrawMode;
exports.TriangleFanDrawMode = __webpackgi_exports__TriangleFanDrawMode;
exports.Triangle = __webpackgi_exports__Triangle;
exports.TransformControls2 = __webpackgi_exports__TransformControls2;
exports.TorusKnotGeometry = __webpackgi_exports__TorusKnotGeometry;
exports.TorusKnotBufferGeometry = __webpackgi_exports__TorusKnotBufferGeometry;
exports.TorusGeometry = __webpackgi_exports__TorusGeometry;
exports.TorusBufferGeometry = __webpackgi_exports__TorusBufferGeometry;
exports.TonemapPlugin = __webpackgi_exports__TonemapPlugin;
exports.TonemapPass = __webpackgi_exports__TonemapPass;
exports.ThreeMaterialLoader = __webpackgi_exports__ThreeMaterialLoader;
exports.ThinFilmLayerPlugin = __webpackgi_exports__ThinFilmLayerPlugin;
exports.TextureLoader = __webpackgi_exports__TextureLoader;
exports.Texture = __webpackgi_exports__Texture;
exports.TextSVGOptions = __webpackgi_exports__TextSVGOptions;
exports.TextGeometry = __webpackgi_exports__TextGeometry;
exports.TetrahedronGeometry = __webpackgi_exports__TetrahedronGeometry;
exports.TetrahedronBufferGeometry = __webpackgi_exports__TetrahedronBufferGeometry;
exports.TemporalAAPlugin = __webpackgi_exports__TemporalAAPlugin;
exports.TangentSpaceNormalMap = __webpackgi_exports__TangentSpaceNormalMap;
exports.TOUCH = __webpackgi_exports__TOUCH;
exports.SwitchNodePlugin = __webpackgi_exports__SwitchNodePlugin;
exports.SubtractiveBlending = __webpackgi_exports__SubtractiveBlending;
exports.SubtractEquation = __webpackgi_exports__SubtractEquation;
exports.StringKeyframeTrack = __webpackgi_exports__StringKeyframeTrack;
exports.StreamReadUsage = __webpackgi_exports__StreamReadUsage;
exports.StreamDrawUsage = __webpackgi_exports__StreamDrawUsage;
exports.StreamCopyUsage = __webpackgi_exports__StreamCopyUsage;
exports.StereoCamera = __webpackgi_exports__StereoCamera;
exports.StaticReadUsage = __webpackgi_exports__StaticReadUsage;
exports.StaticDrawUsage = __webpackgi_exports__StaticDrawUsage;
exports.StaticCopyUsage = __webpackgi_exports__StaticCopyUsage;
exports.SrcColorFactor = __webpackgi_exports__SrcColorFactor;
exports.SrcAlphaSaturateFactor = __webpackgi_exports__SrcAlphaSaturateFactor;
exports.SrcAlphaFactor = __webpackgi_exports__SrcAlphaFactor;
exports.SpriteMaterial = __webpackgi_exports__SpriteMaterial;
exports.Sprite = __webpackgi_exports__Sprite;
exports.SpotLightHelper = __webpackgi_exports__SpotLightHelper;
exports.SpotLight2 = __webpackgi_exports__SpotLight2;
exports.SpotLight = __webpackgi_exports__SpotLight;
exports.SplineCurve = __webpackgi_exports__SplineCurve;
exports.SphericalHarmonics3 = __webpackgi_exports__SphericalHarmonics3;
exports.Spherical = __webpackgi_exports__Spherical;
exports.SphereSelectionWidget = __webpackgi_exports__SphereSelectionWidget;
exports.SphereGeometry = __webpackgi_exports__SphereGeometry;
exports.SphereBufferGeometry = __webpackgi_exports__SphereBufferGeometry;
exports.Sphere = __webpackgi_exports__Sphere;
exports.Source = __webpackgi_exports__Source;
exports.SmoothShading = __webpackgi_exports__SmoothShading;
exports.SkinnedMesh = __webpackgi_exports__SkinnedMesh;
exports.SkeletonHelper = __webpackgi_exports__SkeletonHelper;
exports.Skeleton = __webpackgi_exports__Skeleton;
exports.SimpleViewerUi = __webpackgi_exports__SimpleViewerUi;
exports.SimpleTextPlugin = __webpackgi_exports__SimpleTextPlugin;
exports.SimpleTextExporter = __webpackgi_exports__SimpleTextExporter;
exports.SimpleJSONLoader = __webpackgi_exports__SimpleJSONLoader;
exports.SimpleJSONExporter = __webpackgi_exports__SimpleJSONExporter;
exports.SimpleEventDispatcher = __webpackgi_exports__SimpleEventDispatcher;
exports.SimpleDataSource = __webpackgi_exports__SimpleDataSource;
exports.SimpleBackgroundEnvUiPlugin = __webpackgi_exports__SimpleBackgroundEnvUiPlugin;
exports.SimpleAssetList = __webpackgi_exports__SimpleAssetList;
exports.ShortType = __webpackgi_exports__ShortType;
exports.ShapeUtils = __webpackgi_exports__ShapeUtils;
exports.ShapeTubeExtrudePlugin = __webpackgi_exports__ShapeTubeExtrudePlugin;
exports.ShapePath = __webpackgi_exports__ShapePath;
exports.ShapeGeometry = __webpackgi_exports__ShapeGeometry;
exports.ShapeBufferGeometry = __webpackgi_exports__ShapeBufferGeometry;
exports.Shape = __webpackgi_exports__Shape;
exports.ShadowMaterial = __webpackgi_exports__ShadowMaterial;
exports.ShadowMapBaker = __webpackgi_exports__ShadowMapBaker;
exports.ShaderPass2 = __webpackgi_exports__ShaderPass2;
exports.ShaderMaterialEncodingSupport = __webpackgi_exports__ShaderMaterialEncodingSupport;
exports.ShaderMaterial = __webpackgi_exports__ShaderMaterial;
exports.ShaderLib = __webpackgi_exports__ShaderLib;
exports.ShaderChunk = __webpackgi_exports__ShaderChunk;
exports.SerializableOrbitControls = __webpackgi_exports__SerializableOrbitControls;
exports.SelectionWidget = __webpackgi_exports__SelectionWidget;
exports.Scene = __webpackgi_exports__Scene;
exports.STLLoadPlugin = __webpackgi_exports__STLLoadPlugin;
exports.SSRPlugin = __webpackgi_exports__SSRPlugin;
exports.SSContactShadows = __webpackgi_exports__SSContactShadows;
exports.SSAOPlugin = __webpackgi_exports__SSAOPlugin;
exports.SRGBColorSpace = __webpackgi_exports__SRGBColorSpace;
exports.SETTLING_TIME = __webpackgi_exports__SETTLING_TIME;
exports.RootScene = __webpackgi_exports__RootScene;
exports.RingGeometry = __webpackgi_exports__RingGeometry;
exports.RingBufferGeometry = __webpackgi_exports__RingBufferGeometry;
exports.Rhino3dmLoader2 = __webpackgi_exports__Rhino3dmLoader2;
exports.Rhino3dmLoadPlugin = __webpackgi_exports__Rhino3dmLoadPlugin;
exports.ReverseSubtractEquation = __webpackgi_exports__ReverseSubtractEquation;
exports.ReplaceStencilOp = __webpackgi_exports__ReplaceStencilOp;
exports.RepeatWrapping = __webpackgi_exports__RepeatWrapping;
exports.ReinhardToneMapping = __webpackgi_exports__ReinhardToneMapping;
exports.Reflector2 = __webpackgi_exports__Reflector2;
exports.RedIntegerFormat = __webpackgi_exports__RedIntegerFormat;
exports.RedFormat = __webpackgi_exports__RedFormat;
exports.RectAreaLight = __webpackgi_exports__RectAreaLight;
exports.Raycaster = __webpackgi_exports__Raycaster;
exports.Ray = __webpackgi_exports__Ray;
exports.RawShaderMaterial = __webpackgi_exports__RawShaderMaterial;
exports.RandomizedDirectionalLightPlugin = __webpackgi_exports__RandomizedDirectionalLightPlugin;
exports.RandomizedDirectionalLight = __webpackgi_exports__RandomizedDirectionalLight;
exports.RGIntegerFormat = __webpackgi_exports__RGIntegerFormat;
exports.RGFormat = __webpackgi_exports__RGFormat;
exports.RGB_S3TC_DXT1_Format = __webpackgi_exports__RGB_S3TC_DXT1_Format;
exports.RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__RGB_PVRTC_4BPPV1_Format;
exports.RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__RGB_PVRTC_2BPPV1_Format;
exports.RGB_ETC2_Format = __webpackgi_exports__RGB_ETC2_Format;
exports.RGB_ETC1_Format = __webpackgi_exports__RGB_ETC1_Format;
exports.RGBM7Encoding = __webpackgi_exports__RGBM7Encoding;
exports.RGBM16Encoding = __webpackgi_exports__RGBM16Encoding;
exports.RGBFormat = __webpackgi_exports__RGBFormat;
exports.RGBA_S3TC_DXT5_Format = __webpackgi_exports__RGBA_S3TC_DXT5_Format;
exports.RGBA_S3TC_DXT3_Format = __webpackgi_exports__RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT1_Format = __webpackgi_exports__RGBA_S3TC_DXT1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format;
exports.RGBA_ETC2_EAC_Format = __webpackgi_exports__RGBA_ETC2_EAC_Format;
exports.RGBA_BPTC_Format = __webpackgi_exports__RGBA_BPTC_Format;
exports.RGBA_ASTC_8x8_Format = __webpackgi_exports__RGBA_ASTC_8x8_Format;
exports.RGBA_ASTC_8x6_Format = __webpackgi_exports__RGBA_ASTC_8x6_Format;
exports.RGBA_ASTC_8x5_Format = __webpackgi_exports__RGBA_ASTC_8x5_Format;
exports.RGBA_ASTC_6x6_Format = __webpackgi_exports__RGBA_ASTC_6x6_Format;
exports.RGBA_ASTC_6x5_Format = __webpackgi_exports__RGBA_ASTC_6x5_Format;
exports.RGBA_ASTC_5x5_Format = __webpackgi_exports__RGBA_ASTC_5x5_Format;
exports.RGBA_ASTC_5x4_Format = __webpackgi_exports__RGBA_ASTC_5x4_Format;
exports.RGBA_ASTC_4x4_Format = __webpackgi_exports__RGBA_ASTC_4x4_Format;
exports.RGBA_ASTC_12x12_Format = __webpackgi_exports__RGBA_ASTC_12x12_Format;
exports.RGBA_ASTC_12x10_Format = __webpackgi_exports__RGBA_ASTC_12x10_Format;
exports.RGBA_ASTC_10x8_Format = __webpackgi_exports__RGBA_ASTC_10x8_Format;
exports.RGBA_ASTC_10x6_Format = __webpackgi_exports__RGBA_ASTC_10x6_Format;
exports.RGBA_ASTC_10x5_Format = __webpackgi_exports__RGBA_ASTC_10x5_Format;
exports.RGBA_ASTC_10x10_Format = __webpackgi_exports__RGBA_ASTC_10x10_Format;
exports.RGBAIntegerFormat = __webpackgi_exports__RGBAIntegerFormat;
exports.RGBAFormat = __webpackgi_exports__RGBAFormat;
exports.RGBADepthPacking = __webpackgi_exports__RGBADepthPacking;
exports.REVISION = __webpackgi_exports__REVISION;
exports.QuaternionLinearInterpolant = __webpackgi_exports__QuaternionLinearInterpolant;
exports.QuaternionKeyframeTrack = __webpackgi_exports__QuaternionKeyframeTrack;
exports.Quaternion = __webpackgi_exports__Quaternion;
exports.QuadraticBezierCurve3 = __webpackgi_exports__QuadraticBezierCurve3;
exports.QuadraticBezierCurve = __webpackgi_exports__QuadraticBezierCurve;
exports.PropertyMixer = __webpackgi_exports__PropertyMixer;
exports.PropertyBinding = __webpackgi_exports__PropertyBinding;
exports.ProgressivePlugin = __webpackgi_exports__ProgressivePlugin;
exports.PositionalAudio = __webpackgi_exports__PositionalAudio;
exports.PopmotionPlugin = __webpackgi_exports__PopmotionPlugin;
exports.PolyhedronGeometry = __webpackgi_exports__PolyhedronGeometry;
exports.PolyhedronBufferGeometry = __webpackgi_exports__PolyhedronBufferGeometry;
exports.PolarGridHelper = __webpackgi_exports__PolarGridHelper;
exports.PointsMaterial = __webpackgi_exports__PointsMaterial;
exports.Points = __webpackgi_exports__Points;
exports.PointLightHelper = __webpackgi_exports__PointLightHelper;
exports.PointLight = __webpackgi_exports__PointLight;
exports.PlaneHelper = __webpackgi_exports__PlaneHelper;
exports.PlaneGeometry = __webpackgi_exports__PlaneGeometry;
exports.PlaneBufferGeometry = __webpackgi_exports__PlaneBufferGeometry;
exports.Plane = __webpackgi_exports__Plane;
exports.PickingPlugin = __webpackgi_exports__PickingPlugin;
exports.PerspectiveCamera = __webpackgi_exports__PerspectiveCamera;
exports.Path = __webpackgi_exports__Path;
exports.ParametricGeometry = __webpackgi_exports__ParametricGeometry;
exports.ParallaxMappingPlugin = __webpackgi_exports__ParallaxMappingPlugin;
exports.PMREMGeneratorPlugin = __webpackgi_exports__PMREMGeneratorPlugin;
exports.PMREMGenerator = __webpackgi_exports__PMREMGenerator;
exports.PCFSoftShadowMap = __webpackgi_exports__PCFSoftShadowMap;
exports.PCFShadowMap = __webpackgi_exports__PCFShadowMap;
exports.OrthographicCamera = __webpackgi_exports__OrthographicCamera;
exports.OrbitControls2 = __webpackgi_exports__OrbitControls2;
exports.OneMinusSrcColorFactor = __webpackgi_exports__OneMinusSrcColorFactor;
exports.OneMinusSrcAlphaFactor = __webpackgi_exports__OneMinusSrcAlphaFactor;
exports.OneMinusDstColorFactor = __webpackgi_exports__OneMinusDstColorFactor;
exports.OneMinusDstAlphaFactor = __webpackgi_exports__OneMinusDstAlphaFactor;
exports.OneFactor = __webpackgi_exports__OneFactor;
exports.OctahedronGeometry = __webpackgi_exports__OctahedronGeometry;
exports.OctahedronBufferGeometry = __webpackgi_exports__OctahedronBufferGeometry;
exports.ObjectSpaceNormalMap = __webpackgi_exports__ObjectSpaceNormalMap;
exports.ObjectRotationPlugin = __webpackgi_exports__ObjectRotationPlugin;
exports.ObjectProcessorMap = __webpackgi_exports__ObjectProcessorMap;
exports.ObjectPicker = __webpackgi_exports__ObjectPicker;
exports.ObjectLoader2 = __webpackgi_exports__ObjectLoader2;
exports.ObjectLoader = __webpackgi_exports__ObjectLoader;
exports.Object3DModel = __webpackgi_exports__Object3DModel;
exports.Object3D = __webpackgi_exports__Object3D;
exports.ObjMtlLoadPlugin = __webpackgi_exports__ObjMtlLoadPlugin;
exports.OBJLoader2 = __webpackgi_exports__OBJLoader2;
exports.NumberKeyframeTrack = __webpackgi_exports__NumberKeyframeTrack;
exports.NotEqualStencilFunc = __webpackgi_exports__NotEqualStencilFunc;
exports.NotEqualDepth = __webpackgi_exports__NotEqualDepth;
exports.NormalCaptureMaterial = __webpackgi_exports__NormalCaptureMaterial;
exports.NormalBlending = __webpackgi_exports__NormalBlending;
exports.NormalAnimationBlendMode = __webpackgi_exports__NormalAnimationBlendMode;
exports.NoiseBumpMaterialPlugin = __webpackgi_exports__NoiseBumpMaterialPlugin;
exports.NoToneMapping = __webpackgi_exports__NoToneMapping;
exports.NoColorSpace = __webpackgi_exports__NoColorSpace;
exports.NoBlending = __webpackgi_exports__NoBlending;
exports.NeverStencilFunc = __webpackgi_exports__NeverStencilFunc;
exports.NeverDepth = __webpackgi_exports__NeverDepth;
exports.NearestMipmapNearestFilter = __webpackgi_exports__NearestMipmapNearestFilter;
exports.NearestMipmapLinearFilter = __webpackgi_exports__NearestMipmapLinearFilter;
exports.NearestMipMapNearestFilter = __webpackgi_exports__NearestMipMapNearestFilter;
exports.NearestMipMapLinearFilter = __webpackgi_exports__NearestMipMapLinearFilter;
exports.NearestFilter = __webpackgi_exports__NearestFilter;
exports.MultiplyOperation = __webpackgi_exports__MultiplyOperation;
exports.MultiplyBlending = __webpackgi_exports__MultiplyBlending;
exports.MultiFilterPlugin = __webpackgi_exports__MultiFilterPlugin;
exports.MixOperation = __webpackgi_exports__MixOperation;
exports.MirroredRepeatWrapping = __webpackgi_exports__MirroredRepeatWrapping;
exports.MinEquation = __webpackgi_exports__MinEquation;
exports.MeshToonMaterial = __webpackgi_exports__MeshToonMaterial;
exports.MeshStandardMaterial2 = __webpackgi_exports__MeshStandardMaterial2;
exports.MeshStandardMaterial = __webpackgi_exports__MeshStandardMaterial;
exports.MeshPhysicalMaterial = __webpackgi_exports__MeshPhysicalMaterial;
exports.MeshPhongMaterial = __webpackgi_exports__MeshPhongMaterial;
exports.MeshNormalMaterial = __webpackgi_exports__MeshNormalMaterial;
exports.MeshMatcapMaterial = __webpackgi_exports__MeshMatcapMaterial;
exports.MeshLambertMaterial = __webpackgi_exports__MeshLambertMaterial;
exports.MeshDistanceMaterial = __webpackgi_exports__MeshDistanceMaterial;
exports.MeshDepthMaterial = __webpackgi_exports__MeshDepthMaterial;
exports.MeshBasicMaterial = __webpackgi_exports__MeshBasicMaterial;
exports.Mesh = __webpackgi_exports__Mesh;
exports.MaxEquation = __webpackgi_exports__MaxEquation;
exports.Matrix4 = __webpackgi_exports__Matrix4;
exports.Matrix3 = __webpackgi_exports__Matrix3;
exports.MathUtils = __webpackgi_exports__MathUtils;
exports.MaterialPreviewGenerator = __webpackgi_exports__MaterialPreviewGenerator;
exports.MaterialManager = __webpackgi_exports__MaterialManager;
exports.MaterialLoader = __webpackgi_exports__MaterialLoader;
exports.MaterialLibraryPlugin = __webpackgi_exports__MaterialLibraryPlugin;
exports.MaterialLibraryBasePlugin = __webpackgi_exports__MaterialLibraryBasePlugin;
exports.MaterialExtender = __webpackgi_exports__MaterialExtender;
exports.MaterialConfiguratorPlugin = __webpackgi_exports__MaterialConfiguratorPlugin;
exports.MaterialConfiguratorBasePlugin = __webpackgi_exports__MaterialConfiguratorBasePlugin;
exports.Material = __webpackgi_exports__Material;
exports.MTLLoader2 = __webpackgi_exports__MTLLoader2;
exports.MOUSE = __webpackgi_exports__MOUSE;
exports.LuminanceFormat = __webpackgi_exports__LuminanceFormat;
exports.LuminanceAlphaFormat = __webpackgi_exports__LuminanceAlphaFormat;
exports.LoopRepeat = __webpackgi_exports__LoopRepeat;
exports.LoopPingPong = __webpackgi_exports__LoopPingPong;
exports.LoopOnce = __webpackgi_exports__LoopOnce;
exports.LoadingManager = __webpackgi_exports__LoadingManager;
exports.LoaderUtils = __webpackgi_exports__LoaderUtils;
exports.Loader = __webpackgi_exports__Loader;
exports.LinearToneMapping = __webpackgi_exports__LinearToneMapping;
exports.LinearSRGBColorSpace = __webpackgi_exports__LinearSRGBColorSpace;
exports.LinearMipmapNearestFilter = __webpackgi_exports__LinearMipmapNearestFilter;
exports.LinearMipmapLinearFilter = __webpackgi_exports__LinearMipmapLinearFilter;
exports.LinearMipMapNearestFilter = __webpackgi_exports__LinearMipMapNearestFilter;
exports.LinearMipMapLinearFilter = __webpackgi_exports__LinearMipMapLinearFilter;
exports.LinearInterpolant = __webpackgi_exports__LinearInterpolant;
exports.LinearFilter = __webpackgi_exports__LinearFilter;
exports.LinearEncoding = __webpackgi_exports__LinearEncoding;
exports.LineSegments = __webpackgi_exports__LineSegments;
exports.LineLoop = __webpackgi_exports__LineLoop;
exports.LineDashedMaterial = __webpackgi_exports__LineDashedMaterial;
exports.LineCurve3 = __webpackgi_exports__LineCurve3;
exports.LineCurve = __webpackgi_exports__LineCurve;
exports.LineBasicMaterial = __webpackgi_exports__LineBasicMaterial;
exports.Line3 = __webpackgi_exports__Line3;
exports.Line = __webpackgi_exports__Line;
exports.LightProbe = __webpackgi_exports__LightProbe;
exports.Light = __webpackgi_exports__Light;
exports.LessStencilFunc = __webpackgi_exports__LessStencilFunc;
exports.LessEqualStencilFunc = __webpackgi_exports__LessEqualStencilFunc;
exports.LessEqualDepth = __webpackgi_exports__LessEqualDepth;
exports.LessDepth = __webpackgi_exports__LessDepth;
exports.Layers = __webpackgi_exports__Layers;
exports.LatheGeometry = __webpackgi_exports__LatheGeometry;
exports.LatheBufferGeometry = __webpackgi_exports__LatheBufferGeometry;
exports.LOD = __webpackgi_exports__LOD;
exports.KeyframeTrack = __webpackgi_exports__KeyframeTrack;
exports.KeepStencilOp = __webpackgi_exports__KeepStencilOp;
exports.KTXLoadPlugin = __webpackgi_exports__KTXLoadPlugin;
exports.KTX2LoadPlugin = __webpackgi_exports__KTX2LoadPlugin;
exports.KHR_TEXTURE_BASISU = __webpackgi_exports__KHR_TEXTURE_BASISU;
exports.InvertStencilOp = __webpackgi_exports__InvertStencilOp;
exports.InterpolateSmooth = __webpackgi_exports__InterpolateSmooth;
exports.InterpolateLinear = __webpackgi_exports__InterpolateLinear;
exports.InterpolateDiscrete = __webpackgi_exports__InterpolateDiscrete;
exports.Interpolant = __webpackgi_exports__Interpolant;
exports.InterleavedBufferAttribute = __webpackgi_exports__InterleavedBufferAttribute;
exports.InterleavedBuffer = __webpackgi_exports__InterleavedBuffer;
exports.IntType = __webpackgi_exports__IntType;
exports.Int8BufferAttribute = __webpackgi_exports__Int8BufferAttribute;
exports.Int32BufferAttribute = __webpackgi_exports__Int32BufferAttribute;
exports.Int16BufferAttribute = __webpackgi_exports__Int16BufferAttribute;
exports.InstancedMesh = __webpackgi_exports__InstancedMesh;
exports.InstancedInterleavedBuffer = __webpackgi_exports__InstancedInterleavedBuffer;
exports.InstancedBufferGeometry = __webpackgi_exports__InstancedBufferGeometry;
exports.InstancedBufferAttribute = __webpackgi_exports__InstancedBufferAttribute;
exports.Inflate = __webpackgi_exports__Inflate;
exports.IncrementWrapStencilOp = __webpackgi_exports__IncrementWrapStencilOp;
exports.IncrementStencilOp = __webpackgi_exports__IncrementStencilOp;
exports.Importer = __webpackgi_exports__Importer;
exports.ImmediateRenderObject = __webpackgi_exports__ImmediateRenderObject;
exports.ImageUtils = __webpackgi_exports__ImageUtils;
exports.ImageLoader = __webpackgi_exports__ImageLoader;
exports.ImageBitmapLoader = __webpackgi_exports__ImageBitmapLoader;
exports.IcosahedronGeometry = __webpackgi_exports__IcosahedronGeometry;
exports.IcosahedronBufferGeometry = __webpackgi_exports__IcosahedronBufferGeometry;
exports.HierarchyUiPlugin = __webpackgi_exports__HierarchyUiPlugin;
exports.HemisphereLightProbe = __webpackgi_exports__HemisphereLightProbe;
exports.HemisphereLightHelper = __webpackgi_exports__HemisphereLightHelper;
exports.HemisphereLight = __webpackgi_exports__HemisphereLight;
exports.HalfFloatType = __webpackgi_exports__HalfFloatType;
exports.HDRiGroundPlugin = __webpackgi_exports__HDRiGroundPlugin;
exports.Gzip = __webpackgi_exports__Gzip;
exports.Gunzip = __webpackgi_exports__Gunzip;
exports.Group = __webpackgi_exports__Group;
exports.GroundPlugin = __webpackgi_exports__GroundPlugin;
exports.GridHelper = __webpackgi_exports__GridHelper;
exports.GreaterStencilFunc = __webpackgi_exports__GreaterStencilFunc;
exports.GreaterEqualStencilFunc = __webpackgi_exports__GreaterEqualStencilFunc;
exports.GreaterEqualDepth = __webpackgi_exports__GreaterEqualDepth;
exports.GreaterDepth = __webpackgi_exports__GreaterDepth;
exports.GenericFilterPlugin = __webpackgi_exports__GenericFilterPlugin;
exports.GenericBlendTexturePass = __webpackgi_exports__GenericBlendTexturePass;
exports.GLTFWriter2 = __webpackgi_exports__GLTFWriter2;
exports.GLTFMeshOptPlugin = __webpackgi_exports__GLTFMeshOptPlugin;
exports.GLTFMaterialsLightMapExtensionName = __webpackgi_exports__GLTFMaterialsLightMapExtensionName;
exports.GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__GLTFMaterialsBumpMapExtensionName;
exports.GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName;
exports.GLTFLoader2 = __webpackgi_exports__GLTFLoader2;
exports.GLTFExporter2 = __webpackgi_exports__GLTFExporter2;
exports.GLTFDracoExporter = __webpackgi_exports__GLTFDracoExporter;
exports.GLTFDracoExportPlugin = __webpackgi_exports__GLTFDracoExportPlugin;
exports.GLTFAnimationPlugin = __webpackgi_exports__GLTFAnimationPlugin;
exports.GLSL3 = __webpackgi_exports__GLSL3;
exports.GLSL1 = __webpackgi_exports__GLSL1;
exports.GLBufferAttribute = __webpackgi_exports__GLBufferAttribute;
exports.GBufferPlugin = __webpackgi_exports__GBufferPlugin;
exports.FullScreenPlugin = __webpackgi_exports__FullScreenPlugin;
exports.Frustum = __webpackgi_exports__Frustum;
exports.FrontSide = __webpackgi_exports__FrontSide;
exports.FramebufferTexture = __webpackgi_exports__FramebufferTexture;
exports.FrameFadePlugin = __webpackgi_exports__FrameFadePlugin;
exports.FontLoader = __webpackgi_exports__FontLoader;
exports.Font = __webpackgi_exports__Font;
exports.FogExp2 = __webpackgi_exports__FogExp2;
exports.Fog = __webpackgi_exports__Fog;
exports.FloatType = __webpackgi_exports__FloatType;
exports.Float64BufferAttribute = __webpackgi_exports__Float64BufferAttribute;
exports.Float32BufferAttribute = __webpackgi_exports__Float32BufferAttribute;
exports.Float16BufferAttribute = __webpackgi_exports__Float16BufferAttribute;
exports.FlatShading = __webpackgi_exports__FlatShading;
exports.FileLoader = __webpackgi_exports__FileLoader;
exports.FSShadowMaterial = __webpackgi_exports__FSShadowMaterial;
exports.FBXLoadPlugin = __webpackgi_exports__FBXLoadPlugin;
exports.ExtrudeGeometry = __webpackgi_exports__ExtrudeGeometry;
exports.ExtrudeBufferGeometry = __webpackgi_exports__ExtrudeBufferGeometry;
exports.EventDispatcher = __webpackgi_exports__EventDispatcher;
exports.Euler = __webpackgi_exports__Euler;
exports.EquirectangularRefractionMapping = __webpackgi_exports__EquirectangularRefractionMapping;
exports.EquirectangularReflectionMapping = __webpackgi_exports__EquirectangularReflectionMapping;
exports.EqualStencilFunc = __webpackgi_exports__EqualStencilFunc;
exports.EqualDepth = __webpackgi_exports__EqualDepth;
exports.EncodeUTF8 = __webpackgi_exports__EncodeUTF8;
exports.EllipseCurve = __webpackgi_exports__EllipseCurve;
exports.EffectComposer2 = __webpackgi_exports__EffectComposer2;
exports.EdgesGeometry = __webpackgi_exports__EdgesGeometry;
exports.EasingFunctions = __webpackgi_exports__EasingFunctions;
exports.EXRLoadPlugin = __webpackgi_exports__EXRLoadPlugin;
exports.DynamicReadUsage = __webpackgi_exports__DynamicReadUsage;
exports.DynamicDrawUsage = __webpackgi_exports__DynamicDrawUsage;
exports.DynamicCopyUsage = __webpackgi_exports__DynamicCopyUsage;
exports.DstColorFactor = __webpackgi_exports__DstColorFactor;
exports.DstAlphaFactor = __webpackgi_exports__DstAlphaFactor;
exports.DropzonePlugin = __webpackgi_exports__DropzonePlugin;
exports.Dropzone = __webpackgi_exports__Dropzone;
exports.DoubleSide = __webpackgi_exports__DoubleSide;
exports.DodecahedronGeometry = __webpackgi_exports__DodecahedronGeometry;
exports.DodecahedronBufferGeometry = __webpackgi_exports__DodecahedronBufferGeometry;
exports.DiscreteInterpolant = __webpackgi_exports__DiscreteInterpolant;
exports.DirectionalLightHelper = __webpackgi_exports__DirectionalLightHelper;
exports.DirectionalLight2 = __webpackgi_exports__DirectionalLight2;
exports.DirectionalLight = __webpackgi_exports__DirectionalLight;
exports.DiamondPlugin = __webpackgi_exports__DiamondPlugin;
exports.DiamondMaterial = __webpackgi_exports__DiamondMaterial;
exports.DepthTexture = __webpackgi_exports__DepthTexture;
exports.DepthStencilFormat = __webpackgi_exports__DepthStencilFormat;
exports.DepthOfFieldPlugin = __webpackgi_exports__DepthOfFieldPlugin;
exports.DepthOfFieldPass = __webpackgi_exports__DepthOfFieldPass;
exports.DepthFormat = __webpackgi_exports__DepthFormat;
exports.Deflate = __webpackgi_exports__Deflate;
exports.DefaultLoadingManager = __webpackgi_exports__DefaultLoadingManager;
exports.DecrementWrapStencilOp = __webpackgi_exports__DecrementWrapStencilOp;
exports.DecrementStencilOp = __webpackgi_exports__DecrementStencilOp;
exports.Decompress = __webpackgi_exports__Decompress;
exports.DecodeUTF8 = __webpackgi_exports__DecodeUTF8;
exports.DebugPlugin = __webpackgi_exports__DebugPlugin;
exports.DataUtils = __webpackgi_exports__DataUtils;
exports.DataUrlLoader = __webpackgi_exports__DataUrlLoader;
exports.DataTextureLoader = __webpackgi_exports__DataTextureLoader;
exports.DataTexture3D = __webpackgi_exports__DataTexture3D;
exports.DataTexture2DArray = __webpackgi_exports__DataTexture2DArray;
exports.DataTexture = __webpackgi_exports__DataTexture;
exports.DataArrayTexture = __webpackgi_exports__DataArrayTexture;
exports.Data3DTexture = __webpackgi_exports__Data3DTexture;
exports.Damper = __webpackgi_exports__Damper;
exports.DRACOLoader2 = __webpackgi_exports__DRACOLoader2;
exports.DECAY_MILLISECONDS = __webpackgi_exports__DECAY_MILLISECONDS;
exports.Cylindrical = __webpackgi_exports__Cylindrical;
exports.CylinderGeometry = __webpackgi_exports__CylinderGeometry;
exports.CylinderBufferGeometry = __webpackgi_exports__CylinderBufferGeometry;
exports.CustomToneMapping = __webpackgi_exports__CustomToneMapping;
exports.CustomBumpMapPlugin = __webpackgi_exports__CustomBumpMapPlugin;
exports.CustomBlending = __webpackgi_exports__CustomBlending;
exports.CurvePath = __webpackgi_exports__CurvePath;
exports.Curve = __webpackgi_exports__Curve;
exports.CullFaceNone = __webpackgi_exports__CullFaceNone;
exports.CullFaceFrontBack = __webpackgi_exports__CullFaceFrontBack;
exports.CullFaceFront = __webpackgi_exports__CullFaceFront;
exports.CullFaceBack = __webpackgi_exports__CullFaceBack;
exports.CubicInterpolant = __webpackgi_exports__CubicInterpolant;
exports.CubicBezierCurve3 = __webpackgi_exports__CubicBezierCurve3;
exports.CubicBezierCurve = __webpackgi_exports__CubicBezierCurve;
exports.CubeUVReflectionMapping = __webpackgi_exports__CubeUVReflectionMapping;
exports.CubeTextureLoader = __webpackgi_exports__CubeTextureLoader;
exports.CubeTexture = __webpackgi_exports__CubeTexture;
exports.CubeRefractionMapping = __webpackgi_exports__CubeRefractionMapping;
exports.CubeReflectionMapping = __webpackgi_exports__CubeReflectionMapping;
exports.CubeNormalsCaptureHelper = __webpackgi_exports__CubeNormalsCaptureHelper;
exports.CubeCamera = __webpackgi_exports__CubeCamera;
exports.ContactShadowGroundPlugin = __webpackgi_exports__ContactShadowGroundPlugin;
exports.ConeGeometry = __webpackgi_exports__ConeGeometry;
exports.ConeBufferGeometry = __webpackgi_exports__ConeBufferGeometry;
exports.CompressedTextureLoader = __webpackgi_exports__CompressedTextureLoader;
exports.CompressedTexture = __webpackgi_exports__CompressedTexture;
exports.Compress = __webpackgi_exports__Compress;
exports.ColorManagement = __webpackgi_exports__ColorManagement;
exports.ColorKeyframeTrack = __webpackgi_exports__ColorKeyframeTrack;
exports.Color = __webpackgi_exports__Color;
exports.Clock = __webpackgi_exports__Clock;
exports.ClampToEdgeWrapping = __webpackgi_exports__ClampToEdgeWrapping;
exports.CircleGeometry = __webpackgi_exports__CircleGeometry;
exports.CircleBufferGeometry = __webpackgi_exports__CircleBufferGeometry;
exports.CineonToneMapping = __webpackgi_exports__CineonToneMapping;
exports.CatmullRomCurve3 = __webpackgi_exports__CatmullRomCurve3;
exports.CapsuleGeometry = __webpackgi_exports__CapsuleGeometry;
exports.CapsuleBufferGeometry = __webpackgi_exports__CapsuleBufferGeometry;
exports.CanvasTexture = __webpackgi_exports__CanvasTexture;
exports.CanvasSnipperPlugin = __webpackgi_exports__CanvasSnipperPlugin;
exports.CanvasSnipper = __webpackgi_exports__CanvasSnipper;
exports.CanvasRecorderPlugin = __webpackgi_exports__CanvasRecorderPlugin;
exports.CanvasRecorder = __webpackgi_exports__CanvasRecorder;
exports.CameraViewPlugin = __webpackgi_exports__CameraViewPlugin;
exports.CameraView = __webpackgi_exports__CameraView;
exports.CameraHelper = __webpackgi_exports__CameraHelper;
exports.CameraController = __webpackgi_exports__CameraController;
exports.Camera = __webpackgi_exports__Camera;
exports.Cache = __webpackgi_exports__Cache;
exports.ByteType = __webpackgi_exports__ByteType;
exports.BufferGeometryLoader = __webpackgi_exports__BufferGeometryLoader;
exports.BufferGeometry = __webpackgi_exports__BufferGeometry;
exports.BufferAttribute = __webpackgi_exports__BufferAttribute;
exports.BoxSelectionWidget = __webpackgi_exports__BoxSelectionWidget;
exports.BoxHelper = __webpackgi_exports__BoxHelper;
exports.BoxGeometry = __webpackgi_exports__BoxGeometry;
exports.BoxBufferGeometry = __webpackgi_exports__BoxBufferGeometry;
exports.Box3Helper = __webpackgi_exports__Box3Helper;
exports.Box3B = __webpackgi_exports__Box3B;
exports.Box3 = __webpackgi_exports__Box3;
exports.Box2 = __webpackgi_exports__Box2;
exports.BooleanKeyframeTrack = __webpackgi_exports__BooleanKeyframeTrack;
exports.Bone = __webpackgi_exports__Bone;
exports.BloomPlugin = __webpackgi_exports__BloomPlugin;
exports.BlobLoader = __webpackgi_exports__BlobLoader;
exports.BasicShadowMap = __webpackgi_exports__BasicShadowMap;
exports.BasicDepthPacking = __webpackgi_exports__BasicDepthPacking;
exports.BaseRenderer = __webpackgi_exports__BaseRenderer;
exports.BaseGroundPlugin = __webpackgi_exports__BaseGroundPlugin;
exports.BackSide = __webpackgi_exports__BackSide;
exports.AxesHelper = __webpackgi_exports__AxesHelper;
exports.AudioLoader = __webpackgi_exports__AudioLoader;
exports.AudioListener = __webpackgi_exports__AudioListener;
exports.AudioContext = __webpackgi_exports__AudioContext;
exports.AudioAnalyser = __webpackgi_exports__AudioAnalyser;
exports.Audio = __webpackgi_exports__Audio;
exports.AsyncZlib = __webpackgi_exports__AsyncZlib;
exports.AsyncZipDeflate = __webpackgi_exports__AsyncZipDeflate;
exports.AsyncUnzlib = __webpackgi_exports__AsyncUnzlib;
exports.AsyncUnzipInflate = __webpackgi_exports__AsyncUnzipInflate;
exports.AsyncInflate = __webpackgi_exports__AsyncInflate;
exports.AsyncGzip = __webpackgi_exports__AsyncGzip;
exports.AsyncGunzip = __webpackgi_exports__AsyncGunzip;
exports.AsyncDeflate = __webpackgi_exports__AsyncDeflate;
exports.AsyncDecompress = __webpackgi_exports__AsyncDecompress;
exports.AsyncCompress = __webpackgi_exports__AsyncCompress;
exports.AssetManagerPlugin = __webpackgi_exports__AssetManagerPlugin;
exports.AssetImporter = __webpackgi_exports__AssetImporter;
exports.AssetImportBasicPopupPlugin = __webpackgi_exports__AssetImportBasicPopupPlugin;
exports.AssetExporterPlugin = __webpackgi_exports__AssetExporterPlugin;
exports.AssetExporter = __webpackgi_exports__AssetExporter;
exports.ArrowHelper = __webpackgi_exports__ArrowHelper;
exports.ArrayCamera = __webpackgi_exports__ArrayCamera;
exports.ArcCurve = __webpackgi_exports__ArcCurve;
exports.AnisotropyPlugin = __webpackgi_exports__AnisotropyPlugin;
exports.AnimationUtils = __webpackgi_exports__AnimationUtils;
exports.AnimationObjectGroup = __webpackgi_exports__AnimationObjectGroup;
exports.AnimationMixer = __webpackgi_exports__AnimationMixer;
exports.AnimationLoader = __webpackgi_exports__AnimationLoader;
exports.AnimationClip = __webpackgi_exports__AnimationClip;
exports.AmbientLightProbe = __webpackgi_exports__AmbientLightProbe;
exports.AmbientLight2 = __webpackgi_exports__AmbientLight2;
exports.AmbientLight = __webpackgi_exports__AmbientLight;
exports.AlwaysStencilFunc = __webpackgi_exports__AlwaysStencilFunc;
exports.AlwaysDepth = __webpackgi_exports__AlwaysDepth;
exports.AlphaFormat = __webpackgi_exports__AlphaFormat;
exports.AdditiveBlending = __webpackgi_exports__AdditiveBlending;
exports.AdditiveAnimationBlendMode = __webpackgi_exports__AdditiveAnimationBlendMode;
exports.AddOperation = __webpackgi_exports__AddOperation;
exports.AddEquation = __webpackgi_exports__AddEquation;
exports.AddBlendPass = __webpackgi_exports__AddBlendPass;
exports.AViewerPlugin = __webpackgi_exports__AViewerPlugin;
exports.ARTouchInputHelper = __webpackgi_exports__ARTouchInputHelper;
exports.ARPlugin = __webpackgi_exports__ARPlugin;
exports.ARPlacementBox = __webpackgi_exports__ARPlacementBox;
exports.AMaterialManager = __webpackgi_exports__AMaterialManager;
exports.ACESFilmicToneMapping = __webpackgi_exports__ACESFilmicToneMapping;
},{"buffer":"aMB2"}],"P74P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapYoyo = exports.wrap = exports.unitize = exports.toArray = exports.splitColor = exports.snap = exports.shuffle = exports.selector = exports.random = exports.pipe = exports.normalize = exports.mapRange = exports.interpolate = exports.gsap = exports.getUnit = exports.distribute = exports.default = exports.clamp = exports._ticker = exports._sortPropTweensByPriority = exports._setDefaults = exports._roundModifier = exports._round = exports._replaceRandom = exports._renderComplexString = exports._removeLinkedListItem = exports._relExp = exports._plugins = exports._parseRelative = exports._numWithUnitExp = exports._numExp = exports._missingPlugin = exports._isUndefined = exports._isString = exports._getSetter = exports._getProperty = exports._getCache = exports._forEachName = exports._config = exports._colorStringFilter = exports._colorExp = exports._checkPlugin = exports.TweenMax = exports.TweenLite = exports.Tween = exports.TimelineMax = exports.TimelineLite = exports.Timeline = exports.Strong = exports.SteppedEase = exports.Sine = exports.Quint = exports.Quart = exports.Quad = exports.PropTween = exports.Power4 = exports.Power3 = exports.Power2 = exports.Power1 = exports.Power0 = exports.Linear = exports.GSCache = exports.Expo = exports.Elastic = exports.Cubic = exports.Circ = exports.Bounce = exports.Back = exports.Animation = void 0;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


exports._ticker = _ticker;
exports._colorStringFilter = _colorStringFilter;
exports._colorExp = _colorExp;
exports.splitColor = splitColor;
exports.interpolate = interpolate;
exports.mapRange = mapRange;
exports._replaceRandom = _replaceRandom;
exports.wrapYoyo = wrapYoyo;
exports.wrap = wrap;
exports.normalize = normalize;
exports.unitize = unitize;
exports.pipe = pipe;
exports.random = random;
exports.snap = snap;
exports._roundModifier = _roundModifier;
exports.distribute = distribute;
exports.shuffle = shuffle;
exports.selector = selector;
exports.toArray = toArray;
exports.clamp = clamp;
exports.getUnit = getUnit;
exports._removeLinkedListItem = _removeLinkedListItem;
exports._setDefaults = _setDefaults;
exports._parseRelative = _parseRelative;
exports._round = _round;
exports._forEachName = _forEachName;
exports._getProperty = _getProperty;
exports._getCache = _getCache;
exports._plugins = _plugins;
exports._missingPlugin = _missingPlugin;
exports._relExp = _relExp;
exports._numWithUnitExp = _numWithUnitExp;
exports._numExp = _numExp;
exports._isUndefined = _isUndefined;
exports._isString = _isString;
exports._config = _config;

_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */


exports.GSCache = GSCache;

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

exports.Animation = Animation;

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

exports.TimelineLite = exports.TimelineMax = exports.Timeline = Timeline;

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      _removeFromParent(prevStartAt.render(-1, true));

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property) {
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return 1;
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    pt = ptCache[i];
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    pt.e && (pt.e = _round(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)

    pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

exports._checkPlugin = _checkPlugin;

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

exports.TweenLite = exports.TweenMax = exports.Tween = Tween;

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


exports._sortPropTweensByPriority = _sortPropTweensByPriority;
exports._renderComplexString = _renderComplexString;
exports._getSetter = _getSetter;

var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks


exports.PropTween = PropTween;

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.


exports.default = exports.gsap = gsap;
Tween.version = Timeline.version = gsap.version = "3.10.4";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;
exports.Circ = Circ;
exports.Expo = Expo;
exports.Sine = Sine;
exports.Bounce = Bounce;
exports.SteppedEase = SteppedEase;
exports.Back = Back;
exports.Elastic = Elastic;
exports.Strong = Strong;
exports.Quint = Quint;
exports.Quart = Quart;
exports.Cubic = Cubic;
exports.Quad = Quad;
exports.Linear = Linear;
exports.Power4 = Power4;
exports.Power3 = Power3;
exports.Power2 = Power2;
exports.Power1 = Power1;
exports.Power0 = Power0;
},{}],"KE4Q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.checkPrefix = exports._getBBox = exports._createElement = exports.CSSPlugin = void 0;

var _gsapCore = require("./gsap-core.js");

/*!
 * CSSPlugin 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0, _gsapCore._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsapCore._ticker.time) {
    return (0, _gsapCore._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0, _gsapCore._getCache)(parent);
      cache.time = _gsapCore._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0, _gsapCore._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsapCore._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsapCore.PropTween(this._pt, target.style, prop, 0, 1, _gsapCore._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];
  (0, _gsapCore._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().

  start = a[0];
  end = a[1];
  startValues = start.match(_gsapCore._numWithUnitExp) || [];
  endValues = end.match(_gsapCore._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsapCore._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = (0, _gsapCore._parseRelative)(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsapCore._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsapCore._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsapCore._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsapCore.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsapCore._numExp).map(_gsapCore._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0, _gsapCore._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsapCore.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0, _gsapCore._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0, _gsapCore._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0, _gsapCore._round)(scaleX);
  cache.scaleY = (0, _gsapCore._round)(scaleY);
  cache.rotation = (0, _gsapCore._round)(rotation) + deg;
  cache.rotationX = (0, _gsapCore._round)(rotationX) + deg;
  cache.rotationY = (0, _gsapCore._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsapCore._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0, _gsapCore.getUnit)(start);
  return (0, _gsapCore._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0, _gsapCore._round)(a11);
    a21 = (0, _gsapCore._round)(a21);
    a12 = (0, _gsapCore._round)(a12);
    a22 = (0, _gsapCore._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0, _gsapCore._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0, _gsapCore._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0, _gsapCore._round)(tx + xPercent / 100 * temp.width);
    ty = (0, _gsapCore._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = (0, _gsapCore._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsapCore.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0, _gsapCore.getUnit)(startValue);
      endUnit = (0, _gsapCore.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsapCore.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


exports._getBBox = _getBBox;
exports.checkPrefix = _checkPropPrefix;
exports._createElement = _createElement;
(0, _gsapCore._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsapCore._plugins[p] && (0, _gsapCore._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0, _gsapCore._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsapCore._colorExp.lastIndex = 0;

        if (!_gsapCore._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0, _gsapCore.getUnit)(startValue);
          endUnit = (0, _gsapCore.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0, _gsapCore._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsapCore._replaceRandom)(startValue));
          (0, _gsapCore.getUnit)(startValue + "") || (startValue += _gsapCore._config.units[p] || (0, _gsapCore.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsapCore.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsapCore.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsapCore._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsapCore._parseRelative)(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0, _gsapCore.getUnit)(endValue) || (p in _gsapCore._config.units ? _gsapCore._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsapCore.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsapCore._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else {
            (0, _gsapCore._missingPlugin)(p, endValue);
            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0, _gsapCore._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsapCore._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsapCore._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
exports.default = exports.CSSPlugin = CSSPlugin;
_gsapCore.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0, _gsapCore._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });
  (0, _gsapCore._forEachName)(rotation, function (name) {
    _gsapCore._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });
  _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  (0, _gsapCore._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0, _gsapCore._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsapCore._config.units[name] = "px";
});

_gsapCore.gsap.registerPlugin(CSSPlugin);
},{"./gsap-core.js":"P74P"}],"f8Z0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Back", {
  enumerable: true,
  get: function () {
    return _gsapCore.Back;
  }
});
Object.defineProperty(exports, "Bounce", {
  enumerable: true,
  get: function () {
    return _gsapCore.Bounce;
  }
});
Object.defineProperty(exports, "CSSPlugin", {
  enumerable: true,
  get: function () {
    return _CSSPlugin.CSSPlugin;
  }
});
Object.defineProperty(exports, "Circ", {
  enumerable: true,
  get: function () {
    return _gsapCore.Circ;
  }
});
Object.defineProperty(exports, "Cubic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Cubic;
  }
});
Object.defineProperty(exports, "Elastic", {
  enumerable: true,
  get: function () {
    return _gsapCore.Elastic;
  }
});
Object.defineProperty(exports, "Expo", {
  enumerable: true,
  get: function () {
    return _gsapCore.Expo;
  }
});
Object.defineProperty(exports, "Linear", {
  enumerable: true,
  get: function () {
    return _gsapCore.Linear;
  }
});
Object.defineProperty(exports, "Power0", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power0;
  }
});
Object.defineProperty(exports, "Power1", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power1;
  }
});
Object.defineProperty(exports, "Power2", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power2;
  }
});
Object.defineProperty(exports, "Power3", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power3;
  }
});
Object.defineProperty(exports, "Power4", {
  enumerable: true,
  get: function () {
    return _gsapCore.Power4;
  }
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quad;
  }
});
Object.defineProperty(exports, "Quart", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quart;
  }
});
Object.defineProperty(exports, "Quint", {
  enumerable: true,
  get: function () {
    return _gsapCore.Quint;
  }
});
Object.defineProperty(exports, "Sine", {
  enumerable: true,
  get: function () {
    return _gsapCore.Sine;
  }
});
Object.defineProperty(exports, "SteppedEase", {
  enumerable: true,
  get: function () {
    return _gsapCore.SteppedEase;
  }
});
Object.defineProperty(exports, "Strong", {
  enumerable: true,
  get: function () {
    return _gsapCore.Strong;
  }
});
Object.defineProperty(exports, "TimelineLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineLite;
  }
});
Object.defineProperty(exports, "TimelineMax", {
  enumerable: true,
  get: function () {
    return _gsapCore.TimelineMax;
  }
});
Object.defineProperty(exports, "TweenLite", {
  enumerable: true,
  get: function () {
    return _gsapCore.TweenLite;
  }
});
exports.gsap = exports.default = exports.TweenMax = void 0;

var _gsapCore = require("./gsap-core.js");

var _CSSPlugin = require("./CSSPlugin.js");

var gsapWithCSS = _gsapCore.gsap.registerPlugin(_CSSPlugin.CSSPlugin) || _gsapCore.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;

exports.TweenMax = TweenMaxWithCSS;
exports.default = exports.gsap = gsapWithCSS;
},{"./gsap-core.js":"P74P","./CSSPlugin.js":"KE4Q"}],"sFbG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports._vertical = exports._scrollers = exports._proxies = exports._isViewport = exports._horizontal = exports._getVelocityProp = exports._getTarget = exports._getScrollFunc = exports._getProxyProp = exports.Observer = void 0;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/*!
 * Observer 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var gsap,
    _coreInitted,
    _clamp,
    _win,
    _doc,
    _docEl,
    _body,
    _isTouch,
    _pointerType,
    ScrollTrigger,
    _root,
    _normalizer,
    _eventTypes,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _startup = 1,
    _observers = [],
    _scrollers = [],
    _proxies = [],
    _getTime = Date.now,
    _bridge = function _bridge(name, value) {
  return value;
},
    _integrate = function _integrate() {
  var core = ScrollTrigger.core,
      data = core.bridge || {},
      scrollers = core._scrollers,
      proxies = core._proxies;
  scrollers.push.apply(scrollers, _scrollers);
  proxies.push.apply(proxies, _proxies);
  exports._scrollers = _scrollers = scrollers;
  exports._proxies = _proxies = proxies;

  _bridge = function _bridge(name, value) {
    return data[name](value);
  };
},
    _getProxyProp = function _getProxyProp(element, property) {
  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
},
    _isViewport = function _isViewport(el) {
  return !!~_root.indexOf(el);
},
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    _removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _onScroll = function _onScroll() {
  return _normalizer && _normalizer.isPressed || _scrollers.cache++;
},
    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
  var cachingFunc = function cachingFunc(value) {
    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
    if (value || value === 0) {
      _startup && (_win.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

      var isNormalizing = _normalizer && _normalizer.isPressed;
      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

      f(value);
      cachingFunc.cacheID = _scrollers.cache;
      isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
      cachingFunc.cacheID = _scrollers.cache;
      cachingFunc.v = f();
    }

    return cachingFunc.v + cachingFunc.offset;
  };

  cachingFunc.offset = 0;
  return f && cachingFunc;
},
    _horizontal = {
  s: _scrollLeft,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
  })
},
    _vertical = {
  s: _scrollTop,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: _horizontal,
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
  })
},
    _getTarget = function _getTarget(t) {
  return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
},
    _getScrollFunc = function _getScrollFunc(element, _ref) {
  var s = _ref.s,
      sc = _ref.sc; // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.

  var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;

  !~i && (i = _scrollers.push(element) - 1);
  return _scrollers[i + offset] || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
    return arguments.length ? element[s] = value : element[s];
  })));
},
    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
  var v1 = value,
      v2 = value,
      t1 = _getTime(),
      t2 = t1,
      min = minTimeRefresh || 50,
      dropToZeroTime = Math.max(500, min * 3),
      update = function update(value, force) {
    var t = _getTime();

    if (force || t - t1 > min) {
      v2 = v1;
      v1 = value;
      t2 = t1;
      t1 = t;
    } else if (useDelta) {
      v1 += value;
    } else {
      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
    }
  },
      reset = function reset() {
    v2 = v1 = useDelta ? 0 : v1;
    t2 = t1 = 0;
  },
      getVelocity = function getVelocity(latestValue) {
    var tOld = t2,
        vOld = v2,
        t = _getTime();

    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
  };

  return {
    update: update,
    reset: reset,
    getVelocity: getVelocity
  };
},
    _getEvent = function _getEvent(e, preventDefault) {
  preventDefault && !e._gsapAllow && e.preventDefault();
  return e.changedTouches ? e.changedTouches[0] : e;
},
    _getAbsoluteMax = function _getAbsoluteMax(a) {
  var max = Math.max.apply(Math, a),
      min = Math.min.apply(Math, a);
  return Math.abs(max) >= Math.abs(min) ? max : min;
},
    _setScrollTrigger = function _setScrollTrigger() {
  ScrollTrigger = gsap.core.globals().ScrollTrigger;
  ScrollTrigger && ScrollTrigger.core && _integrate();
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (gsap && typeof document !== "undefined" && document.body) {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;
    _root = [_win, _doc, _docEl, _body];
    _clamp = gsap.utils.clamp;
    _pointerType = "onpointerenter" in _body ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
    _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
    setTimeout(function () {
      return _startup = 0;
    }, 500);

    _setScrollTrigger();

    _coreInitted = 1;
  }

  return _coreInitted;
};

exports._getVelocityProp = _getVelocityProp;
exports._getScrollFunc = _getScrollFunc;
exports._getTarget = _getTarget;
exports._vertical = _vertical;
exports._horizontal = _horizontal;
exports._isViewport = _isViewport;
exports._getProxyProp = _getProxyProp;
exports._proxies = _proxies;
exports._scrollers = _scrollers;
_horizontal.op = _vertical;
_scrollers.cache = 0;

var Observer = /*#__PURE__*/function () {
  function Observer(vars) {
    this.init(vars);
  }

  var _proto = Observer.prototype;

  _proto.init = function init(vars) {
    _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
    ScrollTrigger || _setScrollTrigger();
    var tolerance = vars.tolerance,
        dragMinimum = vars.dragMinimum,
        type = vars.type,
        target = vars.target,
        lineHeight = vars.lineHeight,
        debounce = vars.debounce,
        preventDefault = vars.preventDefault,
        onStop = vars.onStop,
        onStopDelay = vars.onStopDelay,
        ignore = vars.ignore,
        wheelSpeed = vars.wheelSpeed,
        event = vars.event,
        onDragStart = vars.onDragStart,
        onDragEnd = vars.onDragEnd,
        onDrag = vars.onDrag,
        onPress = vars.onPress,
        onRelease = vars.onRelease,
        onRight = vars.onRight,
        onLeft = vars.onLeft,
        onUp = vars.onUp,
        onDown = vars.onDown,
        onChangeX = vars.onChangeX,
        onChangeY = vars.onChangeY,
        onChange = vars.onChange,
        onToggleX = vars.onToggleX,
        onToggleY = vars.onToggleY,
        onHover = vars.onHover,
        onHoverEnd = vars.onHoverEnd,
        onMove = vars.onMove,
        ignoreCheck = vars.ignoreCheck,
        isNormalizer = vars.isNormalizer,
        onGestureStart = vars.onGestureStart,
        onGestureEnd = vars.onGestureEnd,
        onWheel = vars.onWheel,
        onEnable = vars.onEnable,
        onDisable = vars.onDisable,
        onClick = vars.onClick,
        scrollSpeed = vars.scrollSpeed,
        capture = vars.capture,
        allowClicks = vars.allowClicks,
        lockAxis = vars.lockAxis,
        onLockAxis = vars.onLockAxis;
    this.target = target = _getTarget(target) || _docEl;
    this.vars = vars;
    ignore && (ignore = gsap.utils.toArray(ignore));
    tolerance = tolerance || 0;
    dragMinimum = dragMinimum || 0;
    wheelSpeed = wheelSpeed || 1;
    scrollSpeed = scrollSpeed || 1;
    type = type || "wheel,touch,pointer";
    debounce = debounce !== false;
    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report "normal", so default to 22.

    var id,
        onStopDelayedCall,
        dragged,
        moved,
        wheeled,
        locked,
        axis,
        self = this,
        prevDeltaX = 0,
        prevDeltaY = 0,
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollX = scrollFuncX(),
        scrollY = scrollFuncY(),
        limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
        // for devices that accommodate mouse events and touch events, we need to distinguish.
    isViewport = _isViewport(target),
        ownerDoc = target.ownerDocument || _doc,
        deltaX = [0, 0, 0],
        // wheel, scroll, pointer/touch
    deltaY = [0, 0, 0],
        onClickTime = 0,
        clickCapture = function clickCapture() {
      return onClickTime = _getTime();
    },
        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
    },
        onStopFunc = function onStopFunc() {
      self._vx.reset();

      self._vy.reset();

      onStopDelayedCall.pause();
      onStop && onStop(self);
    },
        update = function update() {
      var dx = self.deltaX = _getAbsoluteMax(deltaX),
          dy = self.deltaY = _getAbsoluteMax(deltaY),
          changedX = Math.abs(dx) >= tolerance,
          changedY = Math.abs(dy) >= tolerance;

      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

      if (changedX) {
        onRight && self.deltaX > 0 && onRight(self);
        onLeft && self.deltaX < 0 && onLeft(self);
        onChangeX && onChangeX(self);
        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
        prevDeltaX = self.deltaX;
        deltaX[0] = deltaX[1] = deltaX[2] = 0;
      }

      if (changedY) {
        onDown && self.deltaY > 0 && onDown(self);
        onUp && self.deltaY < 0 && onUp(self);
        onChangeY && onChangeY(self);
        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
        prevDeltaY = self.deltaY;
        deltaY[0] = deltaY[1] = deltaY[2] = 0;
      }

      if (moved || dragged) {
        onMove && onMove(self);
        onLockAxis && locked && onLockAxis(self);

        if (dragged) {
          onDrag(self);
          dragged = false;
        }

        moved = locked = false;
      }

      if (wheeled) {
        onWheel(self);
        wheeled = false;
      }

      id = 0;
    },
        onDelta = function onDelta(x, y, index) {
      deltaX[index] += x;
      deltaY[index] += y;

      self._vx.update(x);

      self._vy.update(y);

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
      if (axis !== "y") {
        deltaX[2] += x;

        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

      }

      if (axis !== "x") {
        deltaY[2] += y;

        self._vy.update(y, true);
      }

      if (lockAxis && !axis) {
        self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
        locked = true;
      }

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        _onDrag = function _onDrag(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y,
          isDragging = self.isDragging;
      self.x = x;
      self.y = y;

      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
        onDrag && (dragged = true);
        isDragging || (self.isDragging = true);
        onTouchOrPointerDelta(dx, dy);
        isDragging || onDragStart && onDragStart(self);
      }
    },
        _onPress = self.onPress = function (e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      self.axis = axis = null;
      onStopDelayedCall.pause();
      self.isPressed = true;
      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

      prevDeltaX = prevDeltaY = 0;
      self.startX = self.x = e.clientX;
      self.startY = self.y = e.clientY;

      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


      self._vy.reset();

      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);

      self.deltaX = self.deltaY = 0;
      onPress && onPress(self);
    },
        _onRelease = function _onRelease(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

      var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
      eventData = _getEvent(e);

      if (!wasDragging) {
        self._vx.reset();

        self._vy.reset();

        if (preventDefault && allowClicks) {
          gsap.delayedCall(0.08, function () {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
              if (e.target.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                e.target.click();
              } else if (ownerDoc.createEvent) {
                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                e.target.dispatchEvent(syntheticEvent);
              }
            }
          });
        }
      }

      self.isDragging = self.isGesturing = self.isPressed = false;
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
      onDragEnd && wasDragging && onDragEnd(self);
      onRelease && onRelease(self, wasDragging);
    },
        _onGestureStart = function _onGestureStart(e) {
      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
    },
        _onGestureEnd = function _onGestureEnd() {
      return (self.isGesturing = false) || onGestureEnd(self);
    },
        onScroll = function onScroll(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = scrollFuncX(),
          y = scrollFuncY();
      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
      scrollX = x;
      scrollY = y;
      onStop && onStopDelayedCall.restart(true);
    },
        _onWheel = function _onWheel(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      onWheel && (wheeled = true);
      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
    },
        _onMove = function _onMove(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y;
      self.x = x;
      self.y = y;
      moved = true;
      (dx || dy) && onTouchOrPointerDelta(dx, dy);
    },
        _onHover = function _onHover(e) {
      self.event = e;
      onHover(self);
    },
        _onHoverEnd = function _onHoverEnd(e) {
      self.event = e;
      onHoverEnd(self);
    },
        _onClick = function _onClick(e) {
      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
    };

    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
    self.deltaX = self.deltaY = 0;
    self._vx = _getVelocityProp(0, 50, true);
    self._vy = _getVelocityProp(0, 50, true);
    self.scrollX = scrollFuncX;
    self.scrollY = scrollFuncY;
    self.isDragging = self.isGesturing = self.isPressed = false;

    self.enable = function (e) {
      if (!self.isEnabled) {
        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);

        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);

          _addListener(ownerDoc, _eventTypes[2], _onRelease);

          _addListener(ownerDoc, _eventTypes[3], _onRelease);

          allowClicks && _addListener(target, "click", clickCapture, false, true);
          onClick && _addListener(target, "click", _onClick);
          onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
          onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
          onHover && _addListener(target, _pointerType + "enter", _onHover);
          onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
          onMove && _addListener(target, _pointerType + "move", _onMove);
        }

        self.isEnabled = true;
        e && e.type && _onPress(e);
        onEnable && onEnable(self);
      }

      return self;
    };

    self.disable = function () {
      if (self.isEnabled) {
        // only remove the _onScroll listener if there aren't any others that rely on the functionality.
        _observers.filter(function (o) {
          return o !== self && _isViewport(o.target);
        }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        if (self.isPressed) {
          self._vx.reset();

          self._vy.reset();

          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        }

        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

        _removeListener(target, "wheel", _onWheel, capture);

        _removeListener(target, _eventTypes[0], _onPress, capture);

        _removeListener(ownerDoc, _eventTypes[2], _onRelease);

        _removeListener(ownerDoc, _eventTypes[3], _onRelease);

        _removeListener(target, "click", clickCapture, true);

        _removeListener(target, "click", _onClick);

        _removeListener(ownerDoc, "gesturestart", _onGestureStart);

        _removeListener(ownerDoc, "gestureend", _onGestureEnd);

        _removeListener(target, _pointerType + "enter", _onHover);

        _removeListener(target, _pointerType + "leave", _onHoverEnd);

        _removeListener(target, _pointerType + "move", _onMove);

        self.isEnabled = self.isPressed = self.isDragging = false;
        onDisable && onDisable(self);
      }
    };

    self.kill = function () {
      self.disable();

      var i = _observers.indexOf(self);

      i >= 0 && _observers.splice(i, 1);
      _normalizer === self && (_normalizer = 0);
    };

    _observers.push(self);

    isNormalizer && _isViewport(target) && (_normalizer = self);
    self.enable(event);
  };

  _createClass(Observer, [{
    key: "velocityX",
    get: function get() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this._vy.getVelocity();
    }
  }]);

  return Observer;
}();

exports.default = exports.Observer = Observer;
Observer.version = "3.10.4";

Observer.create = function (vars) {
  return new Observer(vars);
};

Observer.register = _initCore;

Observer.getAll = function () {
  return _observers.slice();
};

Observer.getById = function (id) {
  return _observers.filter(function (o) {
    return o.vars.id === id;
  })[0];
};

_getGSAP() && gsap.registerPlugin(Observer);
},{}],"rpvU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScrollTrigger = void 0;

var _Observer = require("./Observer.js");

/*!
 * ScrollTrigger 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _win,
    _doc,
    _docEl,
    _body,
    _root,
    _resizeDelay,
    _toArray,
    _clamp,
    _time2,
    _syncInterval,
    _refreshing,
    _pointerIsDown,
    _transformProp,
    _i,
    _prevWidth,
    _prevHeight,
    _autoRefresh,
    _sort,
    _suppressOverwrites,
    _ignoreResize,
    _normalizer,
    _ignoreMobileResize,
    _baseScreenHeight,
    _baseScreenWidth,
    _fixIOSBug,
    _limitCallbacks,
    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
_startup = 1,
    _getTime = Date.now,
    _time1 = _getTime(),
    _lastScrollTime = 0,
    _enabled = 0,
    _pointerDownHandler = function _pointerDownHandler() {
  return _pointerIsDown = 1;
},
    _pointerUpHandler = function _pointerUpHandler() {
  return _pointerIsDown = 0;
},
    _passThrough = function _passThrough(v) {
  return v;
},
    _round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isViewport = function _isViewport(e) {
  return !!~_root.indexOf(e);
},
    _getBoundsFunc = function _getBoundsFunc(element) {
  return (0, _Observer._getProxyProp)(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
    _winOffsets.width = _win.innerWidth;
    _winOffsets.height = _win.innerHeight;
    return _winOffsets;
  } : function () {
    return _getBounds(element);
  });
},
    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
  var d = _ref.d,
      d2 = _ref.d2,
      a = _ref.a;
  return (a = (0, _Observer._getProxyProp)(scroller, "getBoundingClientRect")) ? function () {
    return a()[d];
  } : function () {
    return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
  };
},
    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
  return !isViewport || ~_Observer._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
    return _winOffsets;
  };
},
    _maxScroll = function _maxScroll(element, _ref2) {
  var s = _ref2.s,
      d2 = _ref2.d2,
      d = _ref2.d,
      a = _ref2.a;
  return (s = "scroll" + d2) && (a = (0, _Observer._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
},
    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
  for (var i = 0; i < _autoRefresh.length; i += 3) {
    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
  }
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _callIfFunc = function _callIfFunc(value) {
  return _isFunction(value) && value();
},
    _combineFunc = function _combineFunc(f1, f2) {
  return function () {
    var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);

    return function () {
      _callIfFunc(result1);

      _callIfFunc(result2);
    };
  };
},
    _endAnimation = function _endAnimation(animation, reversed, pause) {
  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
},
    _callback = function _callback(self, func) {
  if (self.enabled) {
    var result = func(self);
    result && result.totalTime && (self.callbackAnimation = result);
  }
},
    _abs = Math.abs,
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _left = "left",
    _top = "top",
    _right = "right",
    _bottom = "bottom",
    _width = "width",
    _height = "height",
    _Right = "Right",
    _Left = "Left",
    _Top = "Top",
    _Bottom = "Bottom",
    _padding = "padding",
    _margin = "margin",
    _Width = "Width",
    _Height = "Height",
    _px = "px",
    _getComputedStyle = function _getComputedStyle(element) {
  return _win.getComputedStyle(element);
},
    _makePositionable = function _makePositionable(element) {
  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
  var position = _getComputedStyle(element).position;

  element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _getBounds = function _getBounds(element, withoutTransforms) {
  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1),
      bounds = element.getBoundingClientRect();
  tween && tween.progress(0).kill();
  return bounds;
},
    _getSize = function _getSize(element, _ref3) {
  var d2 = _ref3.d2;
  return element["offset" + d2] || element["client" + d2] || 0;
},
    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
  var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;

  for (p in labels) {
    a.push(labels[p] / duration);
  }

  return a;
},
    _getClosestLabel = function _getClosestLabel(animation) {
  return function (value) {
    return gsap.utils.snap(_getLabelRatioArray(animation), value);
  };
},
    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
  var snap = gsap.utils.snap(snapIncrementOrArray),
      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
    return a - b;
  });
  return a ? function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var i;

    if (!direction) {
      return snap(value);
    }

    if (direction > 0) {
      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

      for (i = 0; i < a.length; i++) {
        if (a[i] >= value) {
          return a[i];
        }
      }

      return a[i - 1];
    } else {
      i = a.length;
      value += threshold;

      while (i--) {
        if (a[i] <= value) {
          return a[i];
        }
      }
    }

    return a[0];
  } : function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var snapped = snap(value);
    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
  };
},
    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
  return function (value, st) {
    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
  };
},
    _multiListener = function _multiListener(func, element, types, callback) {
  return types.split(",").forEach(function (type) {
    return func(element, type, callback);
  });
},
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    _removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _wheelListener = function _wheelListener(func, el, scrollFunc) {
  return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
},
    _markerDefaults = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
},
    _defaults = {
  toggleActions: "play",
  anticipatePin: 0
},
    _keywords = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
},
    _offsetToPx = function _offsetToPx(value, size) {
  if (_isString(value)) {
    var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

    if (~eqIndex) {
      value.indexOf("%") > eqIndex && (relative *= size / 100);
      value = value.substr(0, eqIndex - 1);
    }

    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
  }

  return value;
},
    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
  var startColor = _ref4.startColor,
      endColor = _ref4.endColor,
      fontSize = _ref4.fontSize,
      indent = _ref4.indent,
      fontWeight = _ref4.fontWeight;

  var e = _doc.createElement("div"),
      useFixedPosition = _isViewport(container) || (0, _Observer._getProxyProp)(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? _body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

  css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer._vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
  e._isStart = isStart;
  e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
  e.style.cssText = css;
  e.innerText = name || name === 0 ? type + "-" + name : type;
  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
  e._offset = e["offset" + direction.op.d2];

  _positionMarker(e, 0, direction, isStart);

  return e;
},
    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
  var vars = {
    display: "block"
  },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
  marker._isFlipped = flipped;
  vars[direction.a + "Percent"] = flipped ? -100 : 0;
  vars[direction.a] = flipped ? "1px" : 0;
  vars["border" + side + _Width] = 1;
  vars["border" + oppositeSide + _Width] = 0;
  vars[direction.p] = start + "px";
  gsap.set(marker, vars);
},
    _triggers = [],
    _ids = {},
    _rafID,
    _sync = function _sync() {
  return _getTime() - _lastScrollTime > 34 && _updateAll();
},
    _onScroll = function _onScroll() {
  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {
    // if the user is dragging the scrollbar, allow it.
    _Observer._scrollers.cache++;
    _rafID || (_rafID = requestAnimationFrame(_updateAll));
    _lastScrollTime || _dispatch("scrollStart");
    _lastScrollTime = _getTime();
  }
},
    _setBaseDimensions = function _setBaseDimensions() {
  _baseScreenWidth = _win.innerWidth;
  _baseScreenHeight = _win.innerHeight;
},
    _onResize = function _onResize() {
  _Observer._scrollers.cache++;
  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);
},
    // ignore resizes triggered by refresh()
_listeners = {},
    _emptyArray = [],
    _media = [],
    _creatingMedia,
    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
_lastMediaTick,
    _onMediaChange = function _onMediaChange(e) {
  var tick = gsap.ticker.frame,
      matches = [],
      i = 0,
      index;

  if (_lastMediaTick !== tick || _startup) {
    _revertAll();

    for (; i < _media.length; i += 4) {
      index = _win.matchMedia(_media[i]).matches;

      if (index !== _media[i + 3]) {
        // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
        _media[i + 3] = index;
        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
      }
    }

    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.


    for (i = 0; i < matches.length; i++) {
      index = matches[i];
      _creatingMedia = _media[index];
      _media[index + 2] = _media[index + 1](e);
    }

    _creatingMedia = 0;
    _coreInitted && _refreshAll(0, 1);
    _lastMediaTick = tick;

    _dispatch("matchMedia");
  }
},
    _softRefresh = function _softRefresh() {
  return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
},
    _dispatch = function _dispatch(type) {
  return _listeners[type] && _listeners[type].map(function (f) {
    return f();
  }) || _emptyArray;
},
    _savedStyles = [],
    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
_revertRecorded = function _revertRecorded(media) {
  for (var i = 0; i < _savedStyles.length; i += 5) {
    if (!media || _savedStyles[i + 4] === media) {
      _savedStyles[i].style.cssText = _savedStyles[i + 1];
      _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
      _savedStyles[i + 3].uncache = 1;
    }
  }
},
    _revertAll = function _revertAll(kill, media) {
  var trigger;

  for (_i = 0; _i < _triggers.length; _i++) {
    trigger = _triggers[_i];

    if (!media || trigger.media === media) {
      if (kill) {
        trigger.kill(1);
      } else {
        trigger.revert();
      }
    }
  }

  media && _revertRecorded(media);
  media || _dispatch("revert");
},
    _clearScrollMemory = function _clearScrollMemory() {
  return _Observer._scrollers.cache++ && _Observer._scrollers.forEach(function (obj) {
    return typeof obj === "function" && (obj.rec = 0);
  });
},
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
_refreshingAll,
    _refreshID = 0,
    _refreshAll = function _refreshAll(force, skipRevert) {
  if (_lastScrollTime && !force) {
    _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

    return;
  }

  _refreshingAll = true;

  var refreshInits = _dispatch("refreshInit");

  _sort && ScrollTrigger.sort();
  skipRevert || _revertAll();

  _triggers.slice(0).forEach(function (t) {
    return t.refresh();
  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


  _triggers.forEach(function (t) {
    return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".


  refreshInits.forEach(function (result) {
    return result && result.render && result.render(-1);
  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

  _clearScrollMemory();

  _resizeDelay.pause();

  _refreshID++;
  _refreshingAll = false;

  _dispatch("refresh");
},
    _lastScroll = 0,
    _direction = 1,
    _primary,
    _updateAll = function _updateAll() {
  if (!_refreshingAll) {
    ScrollTrigger.isUpdating = true;
    _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

    var l = _triggers.length,
        time = _getTime(),
        recordVelocity = time - _time1 >= 50,
        scroll = l && _triggers[0].scroll();

    _direction = _lastScroll > scroll ? -1 : 1;
    _lastScroll = scroll;

    if (recordVelocity) {
      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
        _lastScrollTime = 0;

        _dispatch("scrollEnd");
      }

      _time2 = _time1;
      _time1 = time;
    }

    if (_direction < 0) {
      _i = l;

      while (_i-- > 0) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }

      _direction = 1;
    } else {
      for (_i = 0; _i < l; _i++) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
    }

    ScrollTrigger.isUpdating = false;
  }

  _rafID = 0;
},
    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
    _swapPinOut = function _swapPinOut(pin, spacer, state) {
  _setState(state);

  var cache = pin._gsap;

  if (cache.spacerIsNative) {
    _setState(cache.spacerState);
  } else if (pin.parentNode === spacer) {
    var parent = spacer.parentNode;

    if (parent) {
      parent.insertBefore(pin, spacer);
      parent.removeChild(spacer);
    }
  }
},
    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
  if (pin.parentNode !== spacer) {
    var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;

    while (i--) {
      p = _propNamesToCopy[i];
      spacerStyle[p] = cs[p];
    }

    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
    cs.display === "inline" && (spacerStyle.display = "inline-block");
    pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
    spacerStyle.overflow = "visible";
    spacerStyle.boxSizing = "border-box";
    spacerStyle[_width] = _getSize(pin, _Observer._horizontal) + _px;
    spacerStyle[_height] = _getSize(pin, _Observer._vertical) + _px;
    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

    _setState(spacerState);

    pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
    pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
    pinStyle[_padding] = cs[_padding];
    pin.parentNode.insertBefore(spacer, pin);
    spacer.appendChild(pin);
  }
},
    _capsExp = /([A-Z])/g,
    _setState = function _setState(state) {
  if (state) {
    var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

    for (; i < l; i += 2) {
      value = state[i + 1];
      p = state[i];

      if (value) {
        style[p] = value;
      } else if (style[p]) {
        style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
      }
    }
  }
},
    _getState = function _getState(element) {
  // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
  var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;

  for (; i < l; i++) {
    state.push(_stateProps[i], style[_stateProps[i]]);
  }

  state.t = element;
  return state;
},
    _copyState = function _copyState(state, override, omitOffsets) {
  var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
  p;

  for (; i < l; i += 2) {
    p = state[i];
    result.push(p, p in override ? override[p] : state[i + 1]);
  }

  result.t = state.t;
  return result;
},
    _winOffsets = {
  left: 0,
  top: 0
},
    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
// 	scroller = _getTarget(scroller || _win);
// 	let direction = horizontal ? _horizontal : _vertical,
// 		isViewport = _isViewport(scroller);
// 	_getSizeFunc(scroller, isViewport, direction);
// 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
// },
_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
  _isFunction(value) && (value = value(self));

  if (_isString(value) && value.substr(0, 3) === "max") {
    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
  }

  var time = containerAnimation ? containerAnimation.time() : 0,
      p1,
      p2,
      element;
  containerAnimation && containerAnimation.seek(0);

  if (!_isNumber(value)) {
    _isFunction(trigger) && (trigger = trigger(self));
    var offsets = value.split(" "),
        bounds,
        localOffset,
        globalOffset,
        display;
    element = (0, _Observer._getTarget)(trigger) || _body;
    bounds = _getBounds(element) || {};

    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
      // if display is "none", it won't report getBoundingClientRect() properly
      display = element.style.display;
      element.style.display = "block";
      bounds = _getBounds(element);
      display ? element.style.display = display : element.style.removeProperty("display");
    }

    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
  } else if (markerScroller) {
    _positionMarker(markerScroller, scrollerSize, direction, true);
  }

  if (marker) {
    var position = value + scrollerSize,
        isStart = marker._isStart;
    p1 = "scroll" + direction.d2;

    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);

    if (useFixedPosition) {
      scrollerBounds = _getBounds(markerScroller);
      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
    }
  }

  if (containerAnimation && element) {
    p1 = _getBounds(element);
    containerAnimation.seek(scrollerMax);
    p2 = _getBounds(element);
    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
    value = value / containerAnimation._caScrollDist * scrollerMax;
  }

  containerAnimation && containerAnimation.seek(time);
  return containerAnimation ? value : Math.round(value);
},
    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
    _reparent = function _reparent(element, parent, top, left) {
  if (element.parentNode !== parent) {
    var style = element.style,
        p,
        cs;

    if (parent === _body) {
      element._stOrig = style.cssText; // record original inline styles so we can revert them later

      cs = _getComputedStyle(element);

      for (p in cs) {
        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
          style[p] = cs[p];
        }
      }

      style.top = top;
      style.left = left;
    } else {
      style.cssText = element._stOrig;
    }

    gsap.core.getCache(element).uncache = 1;
    parent.appendChild(element);
  }
},
    // _mergeAnimations = animations => {
// 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
// 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
// 	tl.smoothChildTiming = false;
// 	return tl;
// },
// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
_getTweenCreator = function _getTweenCreator(scroller, direction) {
  var getScroll = (0, _Observer._getScrollFunc)(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
  lastScroll1,
      lastScroll2,
      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
    var tween = getTween.tween,
        onComplete = vars.onComplete,
        modifiers = {};
    initialValue = initialValue || getScroll();
    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

    change1 = change1 || scrollTo - initialValue;
    tween && tween.kill();
    lastScroll1 = Math.round(initialValue);
    vars[prop] = scrollTo;
    vars.modifiers = modifiers;

    modifiers[prop] = function (value) {
      value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        tween.kill();
        getTween.tween = 0;
      } else {
        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
      }

      lastScroll2 = lastScroll1;
      return lastScroll1 = _round(value);
    };

    vars.onComplete = function () {
      getTween.tween = 0;
      onComplete && onComplete.call(tween);
    };

    tween = getTween.tween = gsap.to(scroller, vars);
    return tween;
  };

  scroller[prop] = getScroll;

  getScroll.wheelHandler = function () {
    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
  };

  _addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


  return getTween;
};

var ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }

  var _proto = ScrollTrigger.prototype;

  _proto.init = function init(vars, animation) {
    this.progress = this.start = 0;
    this.vars && this.kill(true, true); // in case it's being initted again

    if (!_enabled) {
      this.update = this.refresh = this.kill = _passThrough;
      return;
    }

    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
      trigger: vars
    } : vars, _defaults);

    var _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        pinSpacer = _vars.pinSpacer,
        containerAnimation = _vars.containerAnimation,
        fastScrollEnd = _vars.fastScrollEnd,
        preventOverlaps = _vars.preventOverlaps,
        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer._horizontal : _Observer._vertical,
        isToggle = !scrub && scrub !== 0,
        scroller = (0, _Observer._getTarget)(vars.scroller || _win),
        scrollerCache = gsap.core.getCache(scroller),
        isViewport = _isViewport(scroller),
        useFixedPosition = ("pinType" in vars ? vars.pinType : (0, _Observer._getProxyProp)(scroller, "pinType") || isViewport && "fixed") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
      return vars.onRefreshInit(self);
    },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        lastRefresh = 0,
        scrollFunc = (0, _Observer._getScrollFunc)(scroller, direction),
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress,
        caMarkerSetter,
        customRevertReturn;

    self.media = _creatingMedia;
    self._dir = direction;
    anticipatePin *= 45;
    self.scroller = scroller;
    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
    scroll1 = scrollFunc();
    self.vars = vars;
    animation = animation || vars.animation;

    if ("refreshPriority" in vars) {
      _sort = 1;
      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
    }

    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
      top: _getTweenCreator(scroller, _Observer._vertical),
      left: _getTweenCreator(scroller, _Observer._horizontal)
    };
    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

    self.scrubDuration = function (value) {
      scrubSmooth = _isNumber(value) && value;

      if (!scrubSmooth) {
        scrubTween && scrubTween.progress(1).kill();
        scrubTween = 0;
      } else {
        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
          ease: "expo",
          totalProgress: "+=0.001",
          duration: scrubSmooth,
          paused: true,
          onComplete: function onComplete() {
            return onScrubComplete && onScrubComplete(self);
          }
        });
      }
    };

    if (animation) {
      animation.vars.lazy = false;
      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
      self.animation = animation.pause();
      animation.scrollTrigger = self;
      self.scrubDuration(scrub);
      snap1 = 0;
      id || (id = animation.vars.id);
    }

    _triggers.push(self);

    if (snap) {
      if (!_isObject(snap) || snap.push) {
        snap = {
          snapTo: snap
        };
      }

      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
        scrollBehavior: "auto"
      }); // smooth scrolling doesn't work with snap.

      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);
      } : gsap.utils.snap(snap.snapTo);
      snapDurClamp = snap.duration || {
        min: 0.1,
        max: 2
      };
      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
        var scroll = scrollFunc(),
            refreshedRecently = _getTime() - lastRefresh < 500,
            tween = tweenTo.tween;

        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
          var progress = (scroll - start) / change,
              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = progress + (snap.inertia === false ? 0 : change1),
              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete;

          if (scroll <= end && scroll >= start && endScroll !== scroll) {
            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
              return;
            }

            if (snap.inertia === false) {
              change1 = endValue - progress;
            }

            tweenTo(endScroll, {
              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
              ease: snap.ease || "power3",
              data: _abs(endScroll - scroll),
              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
              onInterrupt: function onInterrupt() {
                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
              },
              onComplete: function onComplete() {
                self.update();
                lastSnap = scrollFunc();
                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                onSnapComplete && onSnapComplete(self);
                _onComplete && _onComplete(self);
              }
            }, scroll, change1 * change, endScroll - scroll - change1 * change);
            onStart && onStart(self, tweenTo.tween);
          }
        } else if (self.isActive && lastSnap !== scroll) {
          snapDelayedCall.restart(true);
        }
      }).pause();
    }

    id && (_ids[id] = self);
    trigger = self.trigger = (0, _Observer._getTarget)(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
    customRevertReturn && (customRevertReturn = customRevertReturn(self));
    pin = pin === true ? trigger : (0, _Observer._getTarget)(pin);
    _isString(toggleClass) && (toggleClass = {
      targets: trigger,
      className: toggleClass
    });

    if (pin) {
      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.

      self.pin = pin;
      vars.force3D !== false && gsap.set(pin, {
        force3D: true
      });
      pinCache = gsap.core.getCache(pin);

      if (!pinCache.spacer) {
        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
        if (pinSpacer) {
          pinSpacer = (0, _Observer._getTarget)(pinSpacer);
          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

          pinCache.spacerIsNative = !!pinSpacer;
          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
        }

        pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
        spacer.classList.add("pin-spacer");
        id && spacer.classList.add("pin-spacer-" + id);
        pinCache.pinState = pinOriginalState = _getState(pin);
      } else {
        pinOriginalState = pinCache.pinState;
      }

      self.spacer = spacer = pinCache.spacer;
      cs = _getComputedStyle(pin);
      spacingStart = cs[pinSpacing + direction.os2];
      pinGetter = gsap.getProperty(pin);
      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

      _swapPinIn(pin, spacer, cs);

      pinState = _getState(pin);
    }

    if (markers) {
      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
      offset = markerStartTrigger["offset" + direction.op.d2];
      var content = (0, _Observer._getTarget)((0, _Observer._getProxyProp)(scroller, "content") || scroller);
      markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
      markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

      if (!useFixedPosition && !(_Observer._proxies.length && (0, _Observer._getProxyProp)(scroller, "fixedMarkers") === true)) {
        _makePositionable(isViewport ? _body : scroller);

        gsap.set([markerStartTrigger, markerEndTrigger], {
          force3D: true
        });
        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
      }
    }

    if (containerAnimation) {
      var oldOnUpdate = containerAnimation.vars.onUpdate,
          oldParams = containerAnimation.vars.onUpdateParams;
      containerAnimation.eventCallback("onUpdate", function () {
        self.update(0, 0, 1);
        oldOnUpdate && oldOnUpdate.apply(oldParams || []);
      });
    }

    self.previous = function () {
      return _triggers[_triggers.indexOf(self) - 1];
    };

    self.next = function () {
      return _triggers[_triggers.indexOf(self) + 1];
    };

    self.revert = function (revert) {
      var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;

      if (r !== self.isReverted) {
        if (r) {
          self.scroll.rec || !_refreshing || !_refreshingAll || (self.scroll.rec = scrollFunc());
          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

          prevProgress = self.progress;
          prevAnimProgress = animation && animation.progress();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.style.display = r ? "none" : "block";
        });
        r && (_refreshing = 1);
        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.

        _refreshing = prevRefreshing;
        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
        self.isReverted = r;
      }
    };

    self.refresh = function (soft, force) {
      if ((_refreshing || !self.enabled) && !force) {
        return;
      }

      if (pin && soft && _lastScrollTime) {
        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

        return;
      }

      !_refreshingAll && onRefreshInit && onRefreshInit(self);
      _refreshing = 1;
      lastRefresh = _getTime();

      if (tweenTo.tween) {
        tweenTo.tween.kill();
        tweenTo.tween = 0;
      }

      scrubTween && scrubTween.pause();
      invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
      self.isReverted || self.revert();
      var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0, _Observer._getTarget)(vars.pinnedContainer),
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins;

      while (i--) {
        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
        curTrigger = _triggers[i];
        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

        curPin = curTrigger.pin;

        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
          revertedPins || (revertedPins = []);
          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

          curTrigger.revert();
        }

        if (curTrigger !== _triggers[i]) {
          // in case it got removed.
          triggerIndex--;
          i--;
        }
      }

      _isFunction(parsedStart) && (parsedStart = parsedStart(self));
      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
        if (~parsedEnd.indexOf(" ")) {
          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
        } else {
          offset = _offsetToPx(parsedEnd.substr(2), size);
          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

          parsedEndTrigger = trigger;
        }
      }

      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
      change = end - start || (start -= 0.01) && 0.001;
      offset = 0;
      i = triggerIndex;

      while (i--) {
        curTrigger = _triggers[i];
        curPin = curTrigger.pin;

        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {
          cs = curTrigger.end - curTrigger.start;

          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
            // numeric start values shouldn't be offset at all - treat them as absolute
            offset += cs * (1 - curTrigger.progress);
          }

          curPin === pin && (otherPinOffset += cs);
        }
      }

      start += offset;
      end += offset;
      self._pinPush = otherPinOffset;

      if (markerStart && offset) {
        // offset the markers if necessary
        cs = {};
        cs[direction.a] = "+=" + offset;
        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
        gsap.set([markerStart, markerEnd], cs);
      }

      if (pin) {
        cs = _getComputedStyle(pin);
        isVertical = direction === _Observer._vertical;
        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
        !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

        bounds = _getBounds(pin, true);
        oppositeScroll = useFixedPosition && (0, _Observer._getScrollFunc)(scroller, isVertical ? _Observer._horizontal : _Observer._vertical)();

        if (pinSpacing) {
          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
          spacerState.t = spacer;
          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

          _setState(spacerState);

          useFixedPosition && scrollFunc(prevScroll);
        }

        if (useFixedPosition) {
          override = {
            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
            boxSizing: "border-box",
            position: "fixed"
          };
          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
          override[_padding] = cs[_padding];
          override[_padding + _Top] = cs[_padding + _Top];
          override[_padding + _Right] = cs[_padding + _Right];
          override[_padding + _Bottom] = cs[_padding + _Bottom];
          override[_padding + _Left] = cs[_padding + _Left];
          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
        }

        if (animation) {
          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

          _suppressOverwrites(1);

          animation.render(animation.duration(), true, true);
          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
          change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

          animation.render(0, true, true);
          initted || animation.invalidate();

          _suppressOverwrites(0);
        } else {
          pinChange = change;
        }
      } else if (trigger && scrollFunc() && !containerAnimation) {
        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
        bounds = trigger.parentNode;

        while (bounds && bounds !== _body) {
          if (bounds._pinOffset) {
            start -= bounds._pinOffset;
            end -= bounds._pinOffset;
          }

          bounds = bounds.parentNode;
        }
      }

      revertedPins && revertedPins.forEach(function (t) {
        return t.revert(false);
      });
      self.start = start;
      self.end = end;
      scroll1 = scroll2 = scrollFunc(); // reset velocity

      if (!containerAnimation) {
        scroll1 < prevScroll && scrollFunc(prevScroll);
        self.scroll.rec = 0;
      }

      self.revert(false);

      if (snapDelayedCall) {
        lastSnap = -1;
        self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value

        snapDelayedCall.restart(true);
      }

      _refreshing = 0;
      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

      if (prevProgress !== self.progress || containerAnimation) {
        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

        self.progress = prevProgress;
        self.update(0, 0, 1);
      }

      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //			scrubTween && scrubTween.invalidate();

      onRefresh && onRefresh(self);
    };

    self.getVelocity = function () {
      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
    };

    self.endAnimation = function () {
      _endAnimation(self.callbackAnimation);

      if (animation) {
        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
      }
    };

    self.labelToScroll = function (label) {
      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
    };

    self.getTrailing = function (name) {
      var i = _triggers.indexOf(self),
          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

      return (_isString(name) ? a.filter(function (t) {
        return t.vars.preventOverlaps === name;
      }) : a).filter(function (t) {
        return self.direction > 0 ? t.end <= start : t.start >= end;
      });
    };

    self.update = function (reset, recordVelocity, forceFake) {
      if (containerAnimation && !forceFake && !reset) {
        return;
      }

      var scroll = self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled,
          isAtMax,
          isTakingAction;

      if (recordVelocity) {
        scroll2 = scroll1;
        scroll1 = containerAnimation ? scrollFunc() : scroll;

        if (snap) {
          snap2 = snap1;
          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
        }
      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

      if (clipped !== prevProgress && self.enabled) {
        isActive = self.isActive = !!clipped && clipped < 1;
        wasActive = !!prevProgress && prevProgress < 1;
        toggled = isActive !== wasActive;
        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

        self.direction = clipped > prevProgress ? 1 : -1;
        self.progress = clipped;

        if (stateChanged && !_refreshing) {
          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

          if (isToggle) {
            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

            isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
          }
        }

        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
          return t.endAnimation();
        }));

        if (!isToggle) {
          if (scrubTween && !_refreshing && !_startup) {
            (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

            if (scrubTween.resetTo) {
              scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
            } else {
              // legacy support (courtesy), before 3.10.0
              scrubTween.vars.totalProgress = clipped;
              scrubTween.invalidate().restart();
            }
          } else if (animation) {
            animation.totalProgress(clipped, !!_refreshing);
          }
        }

        if (pin) {
          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

          if (!useFixedPosition) {
            pinSetter(_round(pinStart + pinChange * clipped));
          } else if (stateChanged) {
            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

            if (pinReparent) {
              if (!reset && (isActive || isAtMax)) {
                var bounds = _getBounds(pin, true),
                    _offset = scroll - start;

                _reparent(pin, _body, bounds.top + (direction === _Observer._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer._vertical ? 0 : _offset) + _px);
              } else {
                _reparent(pin, spacer);
              }
            }

            _setState(isActive || isAtMax ? pinActiveState : pinState);

            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
          }
        }

        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
        }); // classes could affect positioning, so do it even if reset or refreshing is true.

        onUpdate && !isToggle && !reset && onUpdate(self);

        if (stateChanged && !_refreshing) {
          if (isToggle) {
            if (isTakingAction) {
              if (action === "complete") {
                animation.pause().totalProgress(1);
              } else if (action === "reset") {
                animation.restart(true).pause();
              } else if (action === "restart") {
                animation.restart(true);
              } else {
                animation[action]();
              }
            }

            onUpdate && onUpdate(self);
          }

          if (toggled || !_limitCallbacks) {
            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
            onToggle && toggled && _callback(self, onToggle);
            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

            if (!toggled) {
              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
              toggleState = clipped === 1 ? 1 : 3;
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            }
          }

          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
            _endAnimation(self.callbackAnimation);

            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
          }
        } else if (isToggle && onUpdate && !_refreshing) {
          onUpdate(self);
        }
      } // update absolutely-positioned markers (only if the scroller isn't the viewport)


      if (markerEndSetter) {
        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
        markerEndSetter(n);
      }

      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
    };

    self.enable = function (reset, refresh) {
      if (!self.enabled) {
        self.enabled = true;

        _addListener(scroller, "resize", _onResize);

        _addListener(isViewport ? _doc : scroller, "scroll", _onScroll);

        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (reset !== false) {
          self.progress = prevProgress = 0;
          scroll1 = scroll2 = lastSnap = scrollFunc();
        }

        refresh !== false && self.refresh();
      }
    };

    self.getTween = function (snap) {
      return snap && tweenTo ? tweenTo.tween : scrubTween;
    };

    self.setPositions = function (newStart, newEnd) {
      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
      if (pin) {
        pinStart += newStart - start;
        pinChange += newEnd - newStart - change;
      }

      self.start = start = newStart;
      self.end = end = newEnd;
      change = newEnd - newStart;
      self.update();
    };

    self.disable = function (reset, allowAnimation) {
      if (self.enabled) {
        reset !== false && self.revert();
        self.enabled = self.isActive = false;
        allowAnimation || scrubTween && scrubTween.pause();
        prevScroll = 0;
        pinCache && (pinCache.uncache = 1);
        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (snapDelayedCall) {
          snapDelayedCall.pause();
          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
        }

        if (!isViewport) {
          var i = _triggers.length;

          while (i--) {
            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
              return; //don't remove the listeners if there are still other triggers referencing it.
            }
          }

          _removeListener(scroller, "resize", _onResize);

          _removeListener(scroller, "scroll", _onScroll);
        }
      }
    };

    self.kill = function (revert, allowAnimation) {
      self.disable(revert, allowAnimation);
      scrubTween && !allowAnimation && scrubTween.kill();
      id && delete _ids[id];

      var i = _triggers.indexOf(self);

      i >= 0 && _triggers.splice(i, 1);
      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

      i = 0;

      _triggers.forEach(function (t) {
        return t.scroller === self.scroller && (i = 1);
      });

      i || (self.scroll.rec = 0);

      if (animation) {
        animation.scrollTrigger = null;
        revert && animation.render(-1);
        allowAnimation || animation.kill();
      }

      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
        return m.parentNode && m.parentNode.removeChild(m);
      });
      _primary === self && (_primary = 0);

      if (pin) {
        pinCache && (pinCache.uncache = 1);
        i = 0;

        _triggers.forEach(function (t) {
          return t.pin === pin && i++;
        });

        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
      }

      vars.onKill && vars.onKill(self);
    };

    self.enable(false, false);
    customRevertReturn && customRevertReturn(self);
    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
      return start || end || self.refresh();
    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
  };

  ScrollTrigger.register = function register(core) {
    if (!_coreInitted) {
      gsap = core || _getGSAP();
      _windowExists() && window.document && ScrollTrigger.enable();
      _coreInitted = _enabled;
    }

    return _coreInitted;
  };

  ScrollTrigger.defaults = function defaults(config) {
    if (config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }

    return _defaults;
  };

  ScrollTrigger.disable = function disable(reset, kill) {
    _enabled = 0;

    _triggers.forEach(function (trigger) {
      return trigger[kill ? "kill" : "disable"](reset);
    });

    _removeListener(_win, "wheel", _onScroll);

    _removeListener(_doc, "scroll", _onScroll);

    clearInterval(_syncInterval);

    _removeListener(_doc, "touchcancel", _passThrough);

    _removeListener(_body, "touchstart", _passThrough);

    _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

    _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

    _resizeDelay.kill();

    _iterateAutoRefresh(_removeListener);

    for (var i = 0; i < _Observer._scrollers.length; i += 3) {
      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);

      _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
    }
  };

  ScrollTrigger.enable = function enable() {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;

    if (gsap) {
      _toArray = gsap.utils.toArray;
      _clamp = gsap.utils.clamp;
      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
      gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

      if (_body) {
        _enabled = 1;

        _Observer.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.


        ScrollTrigger.isTouch = _Observer.Observer.isTouch;
        _fixIOSBug = _Observer.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

        _addListener(_win, "wheel", _onScroll); // mostly for 3rd party smooth scrolling libraries.


        _root = [_win, _doc, _docEl, _body];
        ScrollTrigger.matchMedia({
          // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
          "(orientation: portrait)": function orientationPortrait() {
            _setBaseDimensions();

            return _setBaseDimensions;
          }
        });

        _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


        var bodyStyle = _body.style,
            border = bodyStyle.borderTopStyle,
            bounds,
            i;
        bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

        bounds = _getBounds(_body);
        _Observer._vertical.m = Math.round(bounds.top + _Observer._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

        _Observer._horizontal.m = Math.round(bounds.left + _Observer._horizontal.sc()) || 0;
        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

        _syncInterval = setInterval(_sync, 250);
        gsap.delayedCall(0.5, function () {
          return _startup = 0;
        });

        _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


        _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


        _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

        _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);

        _transformProp = gsap.utils.checkPrefix("transform");

        _stateProps.push(_transformProp);

        _coreInitted = _getTime();
        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
        _autoRefresh = [_doc, "visibilitychange", function () {
          var w = _win.innerWidth,
              h = _win.innerHeight;

          if (_doc.hidden) {
            _prevWidth = w;
            _prevHeight = h;
          } else if (_prevWidth !== w || _prevHeight !== h) {
            _onResize();
          }
        }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];

        _iterateAutoRefresh(_addListener);

        _triggers.forEach(function (trigger) {
          return trigger.enable(0, 1);
        });

        for (i = 0; i < _Observer._scrollers.length; i += 3) {
          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 1]);

          _wheelListener(_removeListener, _Observer._scrollers[i], _Observer._scrollers[i + 2]);
        }
      }
    }
  };

  ScrollTrigger.config = function config(vars) {
    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
    var ms = vars.syncInterval;
    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
    "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

    if ("autoRefreshEvents" in vars) {
      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
    }
  };

  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
    var t = (0, _Observer._getTarget)(target),
        i = _Observer._scrollers.indexOf(t),
        isViewport = _isViewport(t);

    if (~i) {
      _Observer._scrollers.splice(i, isViewport ? 6 : 2);
    }

    if (vars) {
      isViewport ? _Observer._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer._proxies.unshift(t, vars);
    }
  };

  ScrollTrigger.matchMedia = function matchMedia(vars) {
    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
    var mq, p, i, func, result;

    for (p in vars) {
      i = _media.indexOf(p);
      func = vars[p];
      _creatingMedia = p;

      if (p === "all") {
        func();
      } else {
        mq = _win.matchMedia(p);

        if (mq) {
          mq.matches && (result = func());

          if (~i) {
            _media[i + 1] = _combineFunc(_media[i + 1], func);
            _media[i + 2] = _combineFunc(_media[i + 2], result);
          } else {
            i = _media.length;

            _media.push(p, func, result);

            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }

          _media[i + 3] = mq.matches;
        }
      }

      _creatingMedia = 0;
    }

    return _media;
  };

  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
    query || (_media.length = 0);
    query = _media.indexOf(query);
    query >= 0 && _media.splice(query, 4);
  };

  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
    var bounds = (_isString(element) ? (0, _Observer._getTarget)(element) : element).getBoundingClientRect(),
        offset = bounds[horizontal ? _width : _height] * ratio || 0;
    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
  };

  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
    _isString(element) && (element = (0, _Observer._getTarget)(element));
    var bounds = element.getBoundingClientRect(),
        size = bounds[horizontal ? _width : _height],
        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
  };

  return ScrollTrigger;
}();

exports.default = exports.ScrollTrigger = ScrollTrigger;
ScrollTrigger.version = "3.10.4";

ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);

      i >= 0 && _savedStyles.splice(i, 5);

      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
    }
  }) : _savedStyles;
};

ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};

ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger(vars, animation);
};

ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
};

ScrollTrigger.update = _updateAll;
ScrollTrigger.clearScrollMemory = _clearScrollMemory;

ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _Observer._horizontal : _Observer._vertical);
};

ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return (0, _Observer._getScrollFunc)((0, _Observer._getTarget)(element), horizontal ? _Observer._horizontal : _Observer._vertical);
};

ScrollTrigger.getById = function (id) {
  return _ids[id];
};

ScrollTrigger.getAll = function () {
  return _triggers.filter(function (t) {
    return t.vars.id !== "ScrollSmoother";
  });
}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};

ScrollTrigger.snapDirectional = _snapDirectional;

ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};

ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
      i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};

ScrollTrigger.batch = function (targets, vars) {
  var result = [],
      varsCopy = {},
      interval = vars.interval || 0.016,
      batchMax = vars.batchMax || 1e9,
      proxyCallback = function proxyCallback(type, callback) {
    var elements = [],
        triggers = [],
        delay = gsap.delayedCall(interval, function () {
      callback(elements, triggers);
      elements = [];
      triggers = [];
    }).pause();
    return function (self) {
      elements.length || delay.restart(true);
      elements.push(self.trigger);
      triggers.push(self);
      batchMax <= elements.length && delay.progress(1);
    };
  },
      p;

  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }

  if (_isFunction(batchMax)) {
    batchMax = batchMax();

    _addListener(ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }

  _toArray(targets).forEach(function (target) {
    var config = {};

    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }

    config.trigger = target;
    result.push(ScrollTrigger.create(config));
  });

  return result;
}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
},
    _allowNativePanning = function _allowNativePanning(target, direction) {
  if (direction === true) {
    target.style.removeProperty("touch-action");
  } else {
    target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (_Observer.Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
  }

  target === _docEl && _allowNativePanning(_body, direction);
},
    _overflow = {
  auto: 1,
  scroll: 1
},
    _nestedScroll = function _nestedScroll(_ref5) {
  var event = _ref5.event,
      target = _ref5.target,
      axis = _ref5.axis;

  var node = (event.changedTouches ? event.changedTouches[0] : event).target,
      cache = node._gsap || gsap.core.getCache(node),
      time = _getTime(),
      cs;

  if (!cache._isScrollT || time - cache._isScrollT > 2000) {
    // cache for 2 seconds to improve performance.
    while (node && node.scrollHeight <= node.clientHeight) {
      node = node.parentNode;
    }

    cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
    cache._isScrollT = time;
  }

  (cache._isScroll || axis === "x") && (event._gsapAllow = true);
},
    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
_inputObserver = function _inputObserver(target, type, inputs, nested) {
  return _Observer.Observer.create({
    target: target,
    capture: true,
    debounce: false,
    lockAxis: true,
    type: type,
    onWheel: nested = nested && _nestedScroll,
    onPress: nested,
    onDrag: nested,
    onScroll: nested,
    onEnable: function onEnable() {
      return inputs && _addListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, false, true);
    },
    onDisable: function onDisable() {
      return _removeListener(_doc, _Observer.Observer.eventTypes[0], _captureInputs, true);
    }
  });
},
    _inputExp = /(input|label|select|textarea)/i,
    _inputIsFocused,
    _captureInputs = function _captureInputs(e) {
  var isInput = _inputExp.test(e.target.tagName);

  if (isInput || _inputIsFocused) {
    e._gsapAllow = true;
    _inputIsFocused = isInput;
  }
},
    _getScrollNormalizer = function _getScrollNormalizer(vars) {
  _isObject(vars) || (vars = {});
  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
  vars.type || (vars.type = "wheel,touch");
  vars.debounce = !!vars.debounce;
  vars.id = vars.id || "normalizer";

  var _vars2 = vars,
      normalizeScrollX = _vars2.normalizeScrollX,
      momentum = _vars2.momentum,
      allowNestedScroll = _vars2.allowNestedScroll,
      self,
      maxY,
      target = (0, _Observer._getTarget)(vars.target) || _docEl,
      smoother = gsap.core.globals().ScrollSmoother,
      content = _fixIOSBug && (vars.content && (0, _Observer._getTarget)(vars.content) || smoother && smoother.get() && smoother.get().content()),
      scrollFuncY = (0, _Observer._getScrollFunc)(target, _Observer._vertical),
      scrollFuncX = (0, _Observer._getScrollFunc)(target, _Observer._horizontal),
      scale = 1,
      initialScale = (_Observer.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
      wheelRefresh = 0,
      resolveMomentumDuration = _isFunction(momentum) ? function () {
    return momentum(self);
  } : function () {
    return momentum || 2.8;
  },
      skipTouchMove,
      lastRefreshID,
      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
      resumeTouchMove = function resumeTouchMove() {
    return skipTouchMove = false;
  },
      scrollClampX = _passThrough,
      scrollClampY = _passThrough,
      updateClamps = function updateClamps() {
    maxY = _maxScroll(target, _Observer._vertical);
    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer._horizontal)));
    lastRefreshID = _refreshID;
  },
      ignoreDrag = function ignoreDrag() {
    if (skipTouchMove) {
      requestAnimationFrame(resumeTouchMove); // we MUST wait for a requestAnimationFrame, otherwise iOS will misreport the value.

      var offset = _round(self.deltaY / 2),
          scroll = scrollClampY(scrollFuncY.v - offset);

      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
        scrollFuncY.offset = scroll - scrollFuncY.v;
        content.style.transform = "translateY(" + -scrollFuncY.offset + "px)";
        content._gsap && (content._gsap.y = -scrollFuncY.offset + "px");
        scrollFuncY.cacheID = _Observer._scrollers.cache;

        _updateAll();
      }

      return true;
    }

    if (content) {
      content.style.transform = "translateY(0px)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
      content._gsap && (content._gsap.y = "0px");
    }

    skipTouchMove = true;
  },
      tween,
      startScrollX,
      startScrollY,
      onStopDelayedCall,
      onResize = function onResize() {
    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
    updateClamps();

    if (tween.isActive() && tween.vars.scrollY > maxY) {
      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
    }
  };

  vars.ignoreCheck = function (e) {
    return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
  };

  vars.onPress = function () {
    var prevScale = scale;
    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
    tween.pause();
    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
    skipTouchMove = false;
    startScrollX = scrollFuncX();
    startScrollY = scrollFuncY();
    updateClamps();
    lastRefreshID = _refreshID;
  };

  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
    if (content) {
      content.style.transform = "translateY(0px)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
      content._gsap && (content._gsap.y = "0px");
    }

    if (!wasDragging) {
      onStopDelayedCall.restart(true);
    } else {
      _Observer._scrollers.cache++; // make sure we're pulling the non-cached value
      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

      var dur = resolveMomentumDuration(),
          currentScroll,
          endScroll;

      if (normalizeScrollX) {
        currentScroll = scrollFuncX();
        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer._horizontal));
        tween.vars.scrollX = scrollClampX(endScroll);
      }

      currentScroll = scrollFuncY();
      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer._vertical));
      tween.vars.scrollY = scrollClampY(endScroll);
      tween.invalidate().duration(dur).play(0.01);

      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
        // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
        gsap.to({}, {
          onUpdate: onResize,
          duration: dur
        });
      }
    }
  };

  vars.onWheel = function () {
    tween._ts && tween.pause();

    if (_getTime() - wheelRefresh > 1000) {
      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
      lastRefreshID = 0;
      wheelRefresh = _getTime();
    }
  };

  vars.onChange = function (self, dx, dy, xArray, yArray) {
    _refreshID !== lastRefreshID && updateClamps();
    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

    dy && scrollFuncY(scrollClampY(yArray[2] === dy ? startScrollY + (self.startY - self.y) : scrollFuncY() + dy - yArray[1]));

    _updateAll();
  };

  vars.onEnable = function () {
    _allowNativePanning(target, normalizeScrollX ? false : "x");

    _addListener(_win, "resize", onResize);

    inputObserver.enable();
  };

  vars.onDisable = function () {
    _allowNativePanning(target, true);

    _removeListener(_win, "resize", onResize);

    inputObserver.kill();
  };

  self = new _Observer.Observer(vars);
  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

  onStopDelayedCall = self._dc;
  tween = gsap.to(self, {
    ease: "power4",
    paused: true,
    scrollX: normalizeScrollX ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    onComplete: onStopDelayedCall.vars.onComplete
  });
  return self;
};

ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};

ScrollTrigger.observe = function (vars) {
  return new _Observer.Observer(vars);
};

ScrollTrigger.normalizeScroll = function (vars) {
  if (typeof vars === "undefined") {
    return _normalizer;
  }

  if (vars === true && _normalizer) {
    return _normalizer.enable();
  }

  if (vars === false) {
    return _normalizer && _normalizer.kill();
  }

  var normalizer = vars instanceof _Observer.Observer ? vars : _getScrollNormalizer(vars);
  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
  _isViewport(normalizer.target) && (_normalizer = normalizer);
  return normalizer;
};

ScrollTrigger.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: _Observer._getVelocityProp,
  _inputObserver: _inputObserver,
  _scrollers: _Observer._scrollers,
  _proxies: _Observer._proxies,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function ss() {
      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = _getTime();
    },
    // a way to get the _refreshing value in Observer
    ref: function ref() {
      return _refreshing;
    }
  }
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);
},{"./Observer.js":"sFbG"}],"D9Nj":[function(require,module,exports) {

},{}],"B6dB":[function(require,module,exports) {
"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var webgi_1 = require("webgi");

var gsap_1 = __importDefault(require("gsap"));

var ScrollTrigger_1 = require("gsap/ScrollTrigger");

require("./styles.css");

gsap_1.default.registerPlugin(ScrollTrigger_1.ScrollTrigger);
var lensObjectNames = ['Circle002', '+Sphere001001', 'new', '+Plane008001', '+SideButtons001', 'Rings2001', '+Rings1001', '+Circle003001', '+Sphere003001', '+Circle001001', 'Text001', 'Plane006001', '+Plane005001', '+Sphere001', '+Cylinder001', '+BODY044001'];
var lensComponentsPosition = {
  x: 0
};

function setupViewer() {
  var _a, _b, _c;

  return __awaiter(this, void 0, void 0, function () {
    function introAnimation() {
      var introTL = gsap_1.default.timeline();
      introTL.to('.loader', {
        x: '150%',
        duration: 0.8,
        ease: "power4.inOut",
        delay: 1
      }).fromTo(position, {
        x: 3.6,
        y: -0.04,
        z: -3.93
      }, {
        x: -3.6,
        y: -0.04,
        z: -3.93,
        duration: 4,
        onUpdate: onUpdate
      }, '-=0.8').fromTo(target, {
        x: 3.16,
        y: -0.13,
        z: 0.51
      }, {
        x: isMobile ? -0.1 : 0.86,
        y: -0.13,
        z: 0.51,
        duration: 4,
        onUpdate: onUpdate
      }, '-=4').fromTo('.header--container', {
        opacity: 0,
        y: '-100%'
      }, {
        opacity: 1,
        y: '0%',
        ease: "power1.inOut",
        duration: 0.8
      }, '-=1').fromTo('.hero--scroller', {
        opacity: 0,
        y: '150%'
      }, {
        opacity: 1,
        y: '0%',
        ease: "power4.inOut",
        duration: 1
      }, '-=1').fromTo('.hero--content', {
        opacity: 0,
        x: '-50%'
      }, {
        opacity: 1,
        x: '0%',
        ease: "power4.inOut",
        duration: 1.8,
        onComplete: setupScrollAnimation
      }, '-=1');
    }

    function setupScrollAnimation() {
      document.body.style.overflowY = "scroll";
      document.body.removeChild(loaderElement);
      var tl = gsap_1.default.timeline({
        default: {
          ease: 'none'
        }
      }); // PERFORMANCE SECTION

      tl.to(position, {
        x: -2.5,
        y: 0.2,
        z: -3.5,
        scrollTrigger: {
          trigger: ".cam-view-2",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: isMobile ? 0.1 : -0.6,
        y: -0.1,
        z: 0.9,
        scrollTrigger: {
          trigger: ".cam-view-2",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to('.hero--scroller', {
        opacity: 0,
        y: '150%',
        scrollTrigger: {
          trigger: ".cam-view-2",
          start: "top bottom",
          end: "top center",
          scrub: 1,
          immediateRender: false,
          pin: '.hero--scroller--container'
        }
      }).to('.hero--content', {
        opacity: 0,
        xPercent: '-100',
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-2",
          start: "top bottom",
          end: "top top",
          scrub: 1,
          immediateRender: false,
          pin: '.hero--content'
        }
      }).addLabel("start").fromTo('.performance--content', {
        opacity: 0,
        x: '110%'
      }, {
        opacity: 1,
        x: '0%',
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-2",
          start: "top bottom",
          end: 'top top',
          scrub: 1,
          immediateRender: false,
          pin: '.performance--container'
        }
      }).addLabel("Performance") // // POWER SECTION
      .to(position, {
        x: -0.07,
        y: isMobile ? 3 : 5.45,
        z: isMobile ? -1.1 : -3.7,
        scrollTrigger: {
          trigger: ".cam-view-3",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: isMobile ? -0.4 : -0.04,
        y: isMobile ? -3.8 : -0.52,
        z: 0.61,
        scrollTrigger: {
          trigger: ".cam-view-3",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to('.performance--content', {
        autoAlpha: 0,
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-3",
          start: "top bottom",
          end: 'top center',
          scrub: 1,
          immediateRender: false
        }
      }).fromTo('.power--content', {
        opacity: 0,
        x: '-110%'
      }, {
        opacity: 1,
        x: '0%',
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-3",
          start: "top 20%",
          end: 'top top',
          scrub: 1,
          immediateRender: false
        }
      }).fromTo('.power--features--img', {
        opacity: 0,
        x: '110%'
      }, {
        opacity: 1,
        x: '0%',
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-3",
          start: "top 20%",
          end: 'top top',
          scrub: 1,
          immediateRender: false
        }
      }).addLabel("Power") // // AUTOFOCUS SECTION
      .to(position, {
        x: -5.5,
        y: 1.7,
        z: 5,
        scrollTrigger: {
          trigger: ".cam-view-4",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: 0.04,
        y: 0.2,
        z: 0.6,
        scrollTrigger: {
          trigger: ".cam-view-4",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(lensComponentsPosition, {
        x: 1,
        scrollTrigger: {
          trigger: ".cam-view-4",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: expandUpdate
      }).fromTo('.autofocus--content', {
        opacity: 0,
        y: '130%'
      }, {
        opacity: 1,
        y: '0%',
        duration: 0.5,
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-4",
          start: "top 20%",
          end: "top top",
          scrub: 1,
          immediateRender: false
        }
      }).addLabel("Autofocus") // EXPLORE SECTION
      .to(position, {
        x: -0.3,
        y: -0.3,
        z: -4.85,
        scrollTrigger: {
          trigger: ".cam-view-5",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(target, {
        x: isMobile ? -0.1 : -0.9,
        y: -0.17,
        z: 0.1,
        scrollTrigger: {
          trigger: ".cam-view-5",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: onUpdate
      }).to(lensComponentsPosition, {
        x: 0,
        scrollTrigger: {
          trigger: ".cam-view-5",
          start: "top bottom",
          end: "top top",
          scrub: true,
          immediateRender: false
        },
        onUpdate: expandUpdate
      }).fromTo('.explore--content', {
        opacity: 0,
        x: '130%'
      }, {
        opacity: 1,
        x: '0%',
        duration: 0.5,
        ease: "power4.out",
        scrollTrigger: {
          trigger: ".cam-view-5",
          start: "top bottom",
          end: "top top",
          scrub: 1,
          immediateRender: false
        }
      }).addLabel("Explore");
    }

    function onUpdate() {
      needsUpdate = true;
    }

    function exploreAnimation() {
      var tlExplore = gsap_1.default.timeline();
      tlExplore.to(position, {
        x: 5,
        y: 0.3,
        z: -4.5,
        duration: 2.5,
        onUpdate: onUpdate
      }).to(target, {
        x: -0.26,
        y: -0.2,
        z: 0.9,
        duration: 2.5,
        onUpdate: onUpdate
      }, '-=2.5').fromTo('.header', {
        opacity: 0
      }, {
        opacity: 1,
        duration: 1.5,
        ease: "power4.out"
      }, '-=2.5').to('.explore--content', {
        opacity: 0,
        x: '130%',
        duration: 1.5,
        ease: "power4.out",
        onComplete: onCompleteExplore
      }, '-=2.5');
    }

    function onCompleteExplore() {
      exitContainer.style.display = "flex";
      if (camera.controls) camera.controls.enabled = true;
    } // EXIT EVENT


    function exitAnimation() {
      if (camera.controls) camera.controls.enabled = false;
      var tlExit = gsap_1.default.timeline();
      tlExit.to(position, {
        x: -0.3,
        y: -0.3,
        z: -4.85,
        duration: 1.2,
        ease: "power4.out",
        onUpdate: onUpdate
      }).to(target, {
        x: -0.9,
        y: -0.17,
        z: 0.1,
        duration: 1.2,
        ease: "power4.out",
        onUpdate: onUpdate
      }, '-=1.2').to('.explore--content', {
        opacity: 1,
        x: '0%',
        duration: 0.5,
        ease: "power4.out"
      }, '-=1.2');
      setLensAppearance(true);
      lensOnly = false;
    }

    function setLensAppearance(_value) {
      for (var _i = 0, lensObjects_1 = lensObjects; _i < lensObjects_1.length; _i++) {
        var o = lensObjects_1[_i];
        o.visible = _value;
      }

      viewer.scene.setDirty({
        sceneUpdate: true
      });
    }

    var viewer, isMobile, manager, camera, position, target, exploreView, canvasView, canvasContainer, exitContainer, loaderElement, header, bodyButton, ssr, ssao, bloom, importer, lensObjects, _i, lensObjectNames_1, obj, o, expandUpdate, needsUpdate, sections, sectionTops_1, lensOnly;

    return __generator(this, function (_d) {
      switch (_d.label) {
        case 0:
          viewer = new webgi_1.ViewerApp({
            canvas: document.getElementById('webgi-canvas'),
            useRgbm: true,
            useGBufferDepth: true,
            isAntialiased: false
          });
          isMobile = (0, webgi_1.mobileAndTabletCheck)();
          viewer.renderer.displayCanvasScaling = Math.min(window.devicePixelRatio, 1);
          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.AssetManagerPlugin)];

        case 1:
          manager = _d.sent();
          camera = viewer.scene.activeCamera;
          position = camera.position;
          target = camera.target;
          exploreView = document.querySelector('.cam-view-5');
          canvasView = document.getElementById('webgi-canvas');
          canvasContainer = document.getElementById('webgi-canvas-container');
          exitContainer = document.querySelector('.exit--container');
          loaderElement = document.querySelector('.loader');
          header = document.querySelector('.header');
          bodyButton = document.querySelector('.button--body'); // Add WEBGi plugins

          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.GBufferPlugin)];

        case 2:
          // Add WEBGi plugins
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(new webgi_1.ProgressivePlugin(32))];

        case 3:
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(new webgi_1.TonemapPlugin(true, true))];

        case 4:
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.SSRPlugin)];

        case 5:
          ssr = _d.sent();
          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.SSAOPlugin)];

        case 6:
          ssao = _d.sent();
          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.FrameFadePlugin)];

        case 7:
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.GroundPlugin)];

        case 8:
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.BloomPlugin)];

        case 9:
          bloom = _d.sent();
          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.TemporalAAPlugin)];

        case 10:
          _d.sent();

          return [4
          /*yield*/
          , viewer.addPlugin(webgi_1.RandomizedDirectionalLightPlugin, false)];

        case 11:
          _d.sent();

          ssr.passes.ssr.passObject.lowQualityFrames = 0;
          bloom.pass.passObject.bloomIterations = 2;
          ssao.passes.ssao.passObject.material.defines.NUM_SAMPLES = 4;
          importer = manager.importer;
          importer.addEventListener("onStart", function (ev) {
            target.set(8.16, -0.13, 0.51);
            position.set(3.6, -0.04, -3.93);
            onUpdate();
          });
          importer.addEventListener("onProgress", function (ev) {
            var _a;

            var progressRatio = ev.loaded / ev.total;
            (_a = document.querySelector('.progress')) === null || _a === void 0 ? void 0 : _a.setAttribute('style', "transform: scaleX(" + progressRatio + ")");
          });
          importer.addEventListener("onLoad", function (ev) {
            introAnimation();
          });
          viewer.renderer.refreshPipeline(); // WEBGi load model

          return [4
          /*yield*/
          , manager.addFromPath("./assets/camera.glb")];

        case 12:
          // WEBGi load model
          _d.sent();

          lensObjects = [];

          for (_i = 0, lensObjectNames_1 = lensObjectNames; _i < lensObjectNames_1.length; _i++) {
            obj = lensObjectNames_1[_i];
            o = viewer.scene.findObjectsByName(obj)[0];
            o.userData.__startPos = o.position.z;
            o.userData.__deltaPos = -Math.pow(Math.abs(o.position.z) * 1.5, 1.25);
            lensObjects.push(o);
          }

          if (camera.controls) camera.controls.enabled = false; // WEBGi mobile adjustments

          if (isMobile) {
            ssr.passes.ssr.passObject.stepCount /= 2;
            bloom.enabled = false;
            camera.setCameraOptions({
              fov: 65
            });
          }

          window.scrollTo(0, 0);
          return [4
          /*yield*/
          , (0, webgi_1.timeout)(50)];

        case 13:
          _d.sent();

          expandUpdate = function expandUpdate() {
            for (var _i = 0, lensObjects_2 = lensObjects; _i < lensObjects_2.length; _i++) {
              var o = lensObjects_2[_i];
              o.position.z = o.userData.__startPos + lensComponentsPosition.x * o.userData.__deltaPos;
            }

            viewer.setDirty();
            viewer.renderer.resetShadows();
          };

          needsUpdate = true;

          if (!isMobile) {
            sections = document.querySelectorAll('.section');
            sectionTops_1 = [];
            sections.forEach(function (section) {
              sectionTops_1.push(section.getBoundingClientRect().top);
            });
            setupCustomWheelSmoothScrolling(viewer, document.documentElement, sectionTops_1);
          } else {
            (0, webgi_1.createStyles)("\nhtml, body {\n  scroll-snap-type: y mandatory;\n}\n\n        ");
          }

          viewer.addEventListener('preFrame', function () {
            if (needsUpdate) {
              camera.positionUpdated(false);
              camera.targetUpdated(true);
              needsUpdate = false;
            }
          }); // KNOW MORE EVENT

          (_a = document.querySelector('.button-know-more')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', function () {
            var element = document.querySelector('.cam-view-2');
            window.scrollTo({
              top: element === null || element === void 0 ? void 0 : element.getBoundingClientRect().top,
              left: 0,
              behavior: 'smooth'
            });
          }); // EXPLORE ALL FEATURES EVENT

          (_b = document.querySelector('.button-explore')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', function () {
            exploreView.style.pointerEvents = "none";
            canvasView.style.pointerEvents = "all";
            canvasContainer.style.zIndex = "1";
            header.style.position = "fixed";
            document.body.style.overflowY = "hidden";
            document.body.style.cursor = "grab";
            exploreAnimation();
          });
          (_c = document.querySelector('.button--exit')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', function () {
            exploreView.style.pointerEvents = "all";
            canvasView.style.pointerEvents = "none";
            canvasContainer.style.zIndex = "unset";
            document.body.style.overflowY = "auto";
            exitContainer.style.display = "none";
            header.style.position = "absolute";
            document.body.style.cursor = "default";
            exitAnimation();
          });
          lensOnly = false;
          bodyButton.addEventListener('click', function () {
            if (lensOnly) {
              setLensAppearance(true);
              lensOnly = false;
              bodyButton.innerHTML = "view body only";
            } else {
              setLensAppearance(false);
              lensOnly = true;
              bodyButton.innerHTML = "view with lens";
            }
          });
          return [2
          /*return*/
          ];
      }
    });
  });
}

function setupCustomWheelSmoothScrolling(viewer, element, snapPositions, speed) {
  if (speed === void 0) {
    speed = 1.5;
  }

  var customScrollY = element.scrollTop;
  var frameDelta = 0;
  var scrollVelocity = 0;
  window.addEventListener('wheel', function (e) {
    e.preventDefault();
    e.stopPropagation(); // todo: check delta mode?

    frameDelta = Math.min(Math.max(e.deltaY * speed, -window.innerHeight / 3), window.innerHeight / 3);
    return false;
  }, {
    passive: false
  });
  var idleSpeedFactor = 0.05;
  var snapSpeedFactor = 0.4;
  var snapProximity = window.innerHeight / 4;
  var wheelDamping = 0.25;
  var velocityDamping = 0.2;
  viewer.addEventListener('preFrame', function () {
    if (Math.abs(frameDelta) < 1) {
      var nearestSection = snapPositions.reduce(function (prev, curr) {
        return Math.abs(curr - customScrollY) < Math.abs(prev - customScrollY) ? curr : prev;
      });
      var d = nearestSection - customScrollY;
      scrollVelocity = d * (Math.abs(d) < snapProximity ? snapSpeedFactor : idleSpeedFactor);
    }

    scrollVelocity += frameDelta * wheelDamping;
    frameDelta *= 1. - wheelDamping;
    if (Math.abs(frameDelta) < 0.01) frameDelta = 0;

    if (Math.abs(scrollVelocity) > 0.01) {
      customScrollY = Math.max(customScrollY + scrollVelocity * velocityDamping, 0);
      element.scrollTop = customScrollY;
      scrollVelocity *= 1. - velocityDamping;
    } else {
      scrollVelocity = 0;
    }
  });
}

setupViewer();
},{"webgi":"rbXN","gsap":"f8Z0","gsap/ScrollTrigger":"rpvU","./styles.css":"D9Nj"}]},{},["B6dB"], null)
//# sourceMappingURL=src.18f50172.js.map